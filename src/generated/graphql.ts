import { gql } from 'apollo-angular';
import { Injectable } from '@angular/core';
import * as Apollo from 'apollo-angular';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: { input: any; output: any; }
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: { input: any; output: any; }
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: { input: any; output: any; }
  /** The day, does not include a time. */
  Date: { input: any; output: any; }
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: { input: any; output: any; }
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: any; output: any; }
  /**
   * A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
   * which securely represents claims between two parties.
   */
  JwtToken: { input: any; output: any; }
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: { input: any; output: any; }
};

export type Aco = Node & {
  __typename?: 'Aco';
  alias?: Maybe<Scalars['String']['output']>;
  foreignKey?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  lft?: Maybe<Scalars['Int']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentId?: Maybe<Scalars['Int']['output']>;
  rght?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `Aco` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AcoCondition = {
  /** Checks for equality with the object’s `alias` field. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `foreignKey` field. */
  foreignKey?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lft` field. */
  lft?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `model` field. */
  model?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `rght` field. */
  rght?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Aco` object types. All fields are combined with a logical ‘and.’ */
export type AcoFilter = {
  /** Filter by the object’s `alias` field. */
  alias?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AcoFilter>>;
  /** Filter by the object’s `foreignKey` field. */
  foreignKey?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lft` field. */
  lft?: InputMaybe<IntFilter>;
  /** Filter by the object’s `model` field. */
  model?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AcoFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AcoFilter>>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `rght` field. */
  rght?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Aco` */
export type AcoInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  foreignKey?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lft?: InputMaybe<Scalars['Int']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['Int']['input']>;
  rght?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Aco`. Fields that are set will be updated. */
export type AcoPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  foreignKey?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lft?: InputMaybe<Scalars['Int']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['Int']['input']>;
  rght?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Aco` values. */
export type AcosConnection = {
  __typename?: 'AcosConnection';
  /** A list of edges which contains the `Aco` and cursor to aid in pagination. */
  edges: Array<AcosEdge>;
  /** A list of `Aco` objects. */
  nodes: Array<Aco>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Aco` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Aco` edge in the connection. */
export type AcosEdge = {
  __typename?: 'AcosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Aco` at the end of the edge. */
  node: Aco;
};

/** Methods to use when ordering `Aco`. */
export enum AcosOrderBy {
  AliasAsc = 'ALIAS_ASC',
  AliasDesc = 'ALIAS_DESC',
  ForeignKeyAsc = 'FOREIGN_KEY_ASC',
  ForeignKeyDesc = 'FOREIGN_KEY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LftAsc = 'LFT_ASC',
  LftDesc = 'LFT_DESC',
  ModelAsc = 'MODEL_ASC',
  ModelDesc = 'MODEL_DESC',
  Natural = 'NATURAL',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RghtAsc = 'RGHT_ASC',
  RghtDesc = 'RGHT_DESC'
}

export type Action = Node & {
  __typename?: 'Action';
  action: Scalars['String']['output'];
  closed: Scalars['Boolean']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  date?: Maybe<Scalars['Date']['output']>;
  endUserId: Scalars['Int']['output'];
  followUp?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `Action`. */
  groupByGroupId?: Maybe<Group>;
  groupId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `Report` that is related to this `Action`. */
  reportByReportId?: Maybe<Report>;
  reportId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `Action`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Action`. */
  userByUserId?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `Action` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ActionCondition = {
  /** Checks for equality with the object’s `action` field. */
  action?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `closed` field. */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `followUp` field. */
  followUp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reportId` field. */
  reportId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Action` object types. All fields are combined with a logical ‘and.’ */
export type ActionFilter = {
  /** Filter by the object’s `action` field. */
  action?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ActionFilter>>;
  /** Filter by the object’s `closed` field. */
  closed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `followUp` field. */
  followUp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `groupByGroupId` relation. */
  groupByGroupId?: InputMaybe<GroupFilter>;
  /** A related `groupByGroupId` exists. */
  groupByGroupIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ActionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ActionFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reportByReportId` relation. */
  reportByReportId?: InputMaybe<ReportFilter>;
  /** A related `reportByReportId` exists. */
  reportByReportIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reportId` field. */
  reportId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** A related `userByUserId` exists. */
  userByUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Action` */
export type ActionInput = {
  action: Scalars['String']['input'];
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  endUserId: Scalars['Int']['input'];
  followUp?: InputMaybe<Scalars['String']['input']>;
  groupId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  reportId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Action`. Fields that are set will be updated. */
export type ActionPatch = {
  action?: InputMaybe<Scalars['String']['input']>;
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  followUp?: InputMaybe<Scalars['String']['input']>;
  groupId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  reportId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Action` values. */
export type ActionsConnection = {
  __typename?: 'ActionsConnection';
  /** A list of edges which contains the `Action` and cursor to aid in pagination. */
  edges: Array<ActionsEdge>;
  /** A list of `Action` objects. */
  nodes: Array<Action>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Action` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Action` edge in the connection. */
export type ActionsEdge = {
  __typename?: 'ActionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Action` at the end of the edge. */
  node: Action;
};

/** Methods to use when ordering `Action`. */
export enum ActionsOrderBy {
  ActionAsc = 'ACTION_ASC',
  ActionDesc = 'ACTION_DESC',
  ClosedAsc = 'CLOSED_ASC',
  ClosedDesc = 'CLOSED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  FollowUpAsc = 'FOLLOW_UP_ASC',
  FollowUpDesc = 'FOLLOW_UP_DESC',
  GroupByGroupIdCreatedAsc = 'GROUP_BY_GROUP_ID__CREATED_ASC',
  GroupByGroupIdCreatedDesc = 'GROUP_BY_GROUP_ID__CREATED_DESC',
  GroupByGroupIdIdAsc = 'GROUP_BY_GROUP_ID__ID_ASC',
  GroupByGroupIdIdDesc = 'GROUP_BY_GROUP_ID__ID_DESC',
  GroupByGroupIdModifiedAsc = 'GROUP_BY_GROUP_ID__MODIFIED_ASC',
  GroupByGroupIdModifiedDesc = 'GROUP_BY_GROUP_ID__MODIFIED_DESC',
  GroupByGroupIdNameAsc = 'GROUP_BY_GROUP_ID__NAME_ASC',
  GroupByGroupIdNameDesc = 'GROUP_BY_GROUP_ID__NAME_DESC',
  GroupByGroupIdOwnerIdAsc = 'GROUP_BY_GROUP_ID__OWNER_ID_ASC',
  GroupByGroupIdOwnerIdDesc = 'GROUP_BY_GROUP_ID__OWNER_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReportByReportIdCheckedTechcentreAsc = 'REPORT_BY_REPORT_ID__CHECKED_TECHCENTRE_ASC',
  ReportByReportIdCheckedTechcentreDesc = 'REPORT_BY_REPORT_ID__CHECKED_TECHCENTRE_DESC',
  ReportByReportIdClosedAsc = 'REPORT_BY_REPORT_ID__CLOSED_ASC',
  ReportByReportIdClosedDesc = 'REPORT_BY_REPORT_ID__CLOSED_DESC',
  ReportByReportIdClosedOldAsc = 'REPORT_BY_REPORT_ID__CLOSED_OLD_ASC',
  ReportByReportIdClosedOldDesc = 'REPORT_BY_REPORT_ID__CLOSED_OLD_DESC',
  ReportByReportIdCreatedAsc = 'REPORT_BY_REPORT_ID__CREATED_ASC',
  ReportByReportIdCreatedDesc = 'REPORT_BY_REPORT_ID__CREATED_DESC',
  ReportByReportIdDateAsc = 'REPORT_BY_REPORT_ID__DATE_ASC',
  ReportByReportIdDateDesc = 'REPORT_BY_REPORT_ID__DATE_DESC',
  ReportByReportIdDestroyedAsc = 'REPORT_BY_REPORT_ID__DESTROYED_ASC',
  ReportByReportIdDestroyedDesc = 'REPORT_BY_REPORT_ID__DESTROYED_DESC',
  ReportByReportIdEndUserIdAsc = 'REPORT_BY_REPORT_ID__END_USER_ID_ASC',
  ReportByReportIdEndUserIdDesc = 'REPORT_BY_REPORT_ID__END_USER_ID_DESC',
  ReportByReportIdExtraWorkAsc = 'REPORT_BY_REPORT_ID__EXTRA_WORK_ASC',
  ReportByReportIdExtraWorkDesc = 'REPORT_BY_REPORT_ID__EXTRA_WORK_DESC',
  ReportByReportIdFactuuropdrachtAsc = 'REPORT_BY_REPORT_ID__FACTUUROPDRACHT_ASC',
  ReportByReportIdFactuuropdrachtDesc = 'REPORT_BY_REPORT_ID__FACTUUROPDRACHT_DESC',
  ReportByReportIdFilenameAsc = 'REPORT_BY_REPORT_ID__FILENAME_ASC',
  ReportByReportIdFilenameDesc = 'REPORT_BY_REPORT_ID__FILENAME_DESC',
  ReportByReportIdIdAsc = 'REPORT_BY_REPORT_ID__ID_ASC',
  ReportByReportIdIdDesc = 'REPORT_BY_REPORT_ID__ID_DESC',
  ReportByReportIdMaintenanceAsc = 'REPORT_BY_REPORT_ID__MAINTENANCE_ASC',
  ReportByReportIdMaintenanceDesc = 'REPORT_BY_REPORT_ID__MAINTENANCE_DESC',
  ReportByReportIdModifiedAsc = 'REPORT_BY_REPORT_ID__MODIFIED_ASC',
  ReportByReportIdModifiedDesc = 'REPORT_BY_REPORT_ID__MODIFIED_DESC',
  ReportByReportIdOtherAsc = 'REPORT_BY_REPORT_ID__OTHER_ASC',
  ReportByReportIdOtherDesc = 'REPORT_BY_REPORT_ID__OTHER_DESC',
  ReportByReportIdOwnerIdAsc = 'REPORT_BY_REPORT_ID__OWNER_ID_ASC',
  ReportByReportIdOwnerIdDesc = 'REPORT_BY_REPORT_ID__OWNER_ID_DESC',
  ReportByReportIdRemarksAsc = 'REPORT_BY_REPORT_ID__REMARKS_ASC',
  ReportByReportIdRemarksDesc = 'REPORT_BY_REPORT_ID__REMARKS_DESC',
  ReportByReportIdRepairAsc = 'REPORT_BY_REPORT_ID__REPAIR_ASC',
  ReportByReportIdRepairDesc = 'REPORT_BY_REPORT_ID__REPAIR_DESC',
  ReportByReportIdStartupAsc = 'REPORT_BY_REPORT_ID__STARTUP_ASC',
  ReportByReportIdStartupDesc = 'REPORT_BY_REPORT_ID__STARTUP_DESC',
  ReportByReportIdTsrNumberAsc = 'REPORT_BY_REPORT_ID__TSR_NUMBER_ASC',
  ReportByReportIdTsrNumberDesc = 'REPORT_BY_REPORT_ID__TSR_NUMBER_DESC',
  ReportByReportIdTypeAsc = 'REPORT_BY_REPORT_ID__TYPE_ASC',
  ReportByReportIdTypeDesc = 'REPORT_BY_REPORT_ID__TYPE_DESC',
  ReportByReportIdUserIdAsc = 'REPORT_BY_REPORT_ID__USER_ID_ASC',
  ReportByReportIdUserIdDesc = 'REPORT_BY_REPORT_ID__USER_ID_DESC',
  ReportByReportIdVersionAsc = 'REPORT_BY_REPORT_ID__VERSION_ASC',
  ReportByReportIdVersionDesc = 'REPORT_BY_REPORT_ID__VERSION_DESC',
  ReportIdAsc = 'REPORT_ID_ASC',
  ReportIdDesc = 'REPORT_ID_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Adre = {
  __typename?: 'Adre';
  adresGuid?: Maybe<Scalars['String']['output']>;
  adrestype?: Maybe<Scalars['String']['output']>;
  cdadres?: Maybe<Scalars['Int']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Adre` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AdreCondition = {
  /** Checks for equality with the object’s `adresGuid` field. */
  adresGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `adrestype` field. */
  adrestype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdadres` field. */
  cdadres?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `straat` field. */
  straat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Adre` object types. All fields are combined with a logical ‘and.’ */
export type AdreFilter = {
  /** Filter by the object’s `adresGuid` field. */
  adresGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `adrestype` field. */
  adrestype?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AdreFilter>>;
  /** Filter by the object’s `cdadres` field. */
  cdadres?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AdreFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AdreFilter>>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postcode` field. */
  postcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `straat` field. */
  straat?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Adre` values. */
export type AdresConnection = {
  __typename?: 'AdresConnection';
  /** A list of edges which contains the `Adre` and cursor to aid in pagination. */
  edges: Array<AdresEdge>;
  /** A list of `Adre` objects. */
  nodes: Array<Adre>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Adre` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Adre` edge in the connection. */
export type AdresEdge = {
  __typename?: 'AdresEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Adre` at the end of the edge. */
  node: Adre;
};

export type AdresMv = {
  __typename?: 'AdresMv';
  adresGuid?: Maybe<Scalars['String']['output']>;
  adrestype?: Maybe<Scalars['String']['output']>;
  cdadres?: Maybe<Scalars['Int']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `AdresMv` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AdresMvCondition = {
  /** Checks for equality with the object’s `adresGuid` field. */
  adresGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `adrestype` field. */
  adrestype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdadres` field. */
  cdadres?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `straat` field. */
  straat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AdresMv` object types. All fields are combined with a logical ‘and.’ */
export type AdresMvFilter = {
  /** Filter by the object’s `adresGuid` field. */
  adresGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `adrestype` field. */
  adrestype?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AdresMvFilter>>;
  /** Filter by the object’s `cdadres` field. */
  cdadres?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AdresMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AdresMvFilter>>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postcode` field. */
  postcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `straat` field. */
  straat?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<StringFilter>;
};

/** A connection to a list of `AdresMv` values. */
export type AdresMvsConnection = {
  __typename?: 'AdresMvsConnection';
  /** A list of edges which contains the `AdresMv` and cursor to aid in pagination. */
  edges: Array<AdresMvsEdge>;
  /** A list of `AdresMv` objects. */
  nodes: Array<AdresMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AdresMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AdresMv` edge in the connection. */
export type AdresMvsEdge = {
  __typename?: 'AdresMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AdresMv` at the end of the edge. */
  node: AdresMv;
};

/** Methods to use when ordering `AdresMv`. */
export enum AdresMvsOrderBy {
  AdrestypeAsc = 'ADRESTYPE_ASC',
  AdrestypeDesc = 'ADRESTYPE_DESC',
  AdresGuidAsc = 'ADRES_GUID_ASC',
  AdresGuidDesc = 'ADRES_GUID_DESC',
  CdadresAsc = 'CDADRES_ASC',
  CdadresDesc = 'CDADRES_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC'
}

/** Methods to use when ordering `Adre`. */
export enum AdresOrderBy {
  AdrestypeAsc = 'ADRESTYPE_ASC',
  AdrestypeDesc = 'ADRESTYPE_DESC',
  AdresGuidAsc = 'ADRES_GUID_ASC',
  AdresGuidDesc = 'ADRES_GUID_DESC',
  CdadresAsc = 'CDADRES_ASC',
  CdadresDesc = 'CDADRES_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC'
}

export type AnotherRefreshToken = {
  __typename?: 'AnotherRefreshToken';
  columnName?: Maybe<Scalars['Int']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  hashedValue: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
  isBlackListed: Scalars['Boolean']['output'];
  lastUsed?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `AnotherRefreshToken` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type AnotherRefreshTokenCondition = {
  /** Checks for equality with the object’s `columnName` field. */
  columnName?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `hashedValue` field. */
  hashedValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isBlackListed` field. */
  isBlackListed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `lastUsed` field. */
  lastUsed?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `AnotherRefreshToken` object types. All fields are combined with a logical ‘and.’ */
export type AnotherRefreshTokenFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AnotherRefreshTokenFilter>>;
  /** Filter by the object’s `columnName` field. */
  columnName?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `hashedValue` field. */
  hashedValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isBlackListed` field. */
  isBlackListed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lastUsed` field. */
  lastUsed?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AnotherRefreshTokenFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AnotherRefreshTokenFilter>>;
};

/** An input for mutations affecting `AnotherRefreshToken` */
export type AnotherRefreshTokenInput = {
  columnName?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  hashedValue: Scalars['String']['input'];
  id: Scalars['UUID']['input'];
  isBlackListed?: InputMaybe<Scalars['Boolean']['input']>;
  lastUsed?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `AnotherRefreshToken` values. */
export type AnotherRefreshTokensConnection = {
  __typename?: 'AnotherRefreshTokensConnection';
  /** A list of edges which contains the `AnotherRefreshToken` and cursor to aid in pagination. */
  edges: Array<AnotherRefreshTokensEdge>;
  /** A list of `AnotherRefreshToken` objects. */
  nodes: Array<AnotherRefreshToken>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AnotherRefreshToken` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AnotherRefreshToken` edge in the connection. */
export type AnotherRefreshTokensEdge = {
  __typename?: 'AnotherRefreshTokensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AnotherRefreshToken` at the end of the edge. */
  node: AnotherRefreshToken;
};

/** Methods to use when ordering `AnotherRefreshToken`. */
export enum AnotherRefreshTokensOrderBy {
  ColumnNameAsc = 'COLUMN_NAME_ASC',
  ColumnNameDesc = 'COLUMN_NAME_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  HashedValueAsc = 'HASHED_VALUE_ASC',
  HashedValueDesc = 'HASHED_VALUE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsBlackListedAsc = 'IS_BLACK_LISTED_ASC',
  IsBlackListedDesc = 'IS_BLACK_LISTED_DESC',
  LastUsedAsc = 'LAST_USED_ASC',
  LastUsedDesc = 'LAST_USED_DESC',
  Natural = 'NATURAL'
}

export type Application = Node & {
  __typename?: 'Application';
  _toolId?: Maybe<Scalars['Int']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DetectorSensorLocation`. */
  detectorSensorLocationsByApplicationId: DetectorSensorLocationsConnection;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `Application`. */
  userByOwnerId?: Maybe<User>;
};


export type ApplicationDetectorSensorLocationsByApplicationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationCondition>;
  filter?: InputMaybe<DetectorSensorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};

/**
 * A condition to be used against `Application` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ApplicationCondition = {
  /** Checks for equality with the object’s `_toolId` field. */
  _toolId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Application` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationFilter = {
  /** Filter by the object’s `_toolId` field. */
  _toolId?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorSensorLocationsByApplicationId` relation. */
  detectorSensorLocationsByApplicationId?: InputMaybe<ApplicationToManyDetectorSensorLocationFilter>;
  /** Some related `detectorSensorLocationsByApplicationId` exist. */
  detectorSensorLocationsByApplicationIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `Application` */
export type ApplicationInput = {
  _toolId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
};

/** Represents an update to a `Application`. Fields that are set will be updated. */
export type ApplicationPatch = {
  _toolId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `DetectorSensorLocation` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDetectorSensorLocationFilter = {
  /** Every related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorLocationFilter>;
  /** No related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorLocationFilter>;
  /** Some related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorLocationFilter>;
};

/** A connection to a list of `Application` values. */
export type ApplicationsConnection = {
  __typename?: 'ApplicationsConnection';
  /** A list of edges which contains the `Application` and cursor to aid in pagination. */
  edges: Array<ApplicationsEdge>;
  /** A list of `Application` objects. */
  nodes: Array<Application>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Application` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Application` edge in the connection. */
export type ApplicationsEdge = {
  __typename?: 'ApplicationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Application` at the end of the edge. */
  node: Application;
};

/** Methods to use when ordering `Application`. */
export enum ApplicationsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorSensorLocationsByApplicationIdCountAsc = 'DETECTOR_SENSOR_LOCATIONS_BY_APPLICATION_ID__COUNT_ASC',
  DetectorSensorLocationsByApplicationIdCountDesc = 'DETECTOR_SENSOR_LOCATIONS_BY_APPLICATION_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  ToolIdAsc = '_TOOL_ID_ASC',
  ToolIdDesc = '_TOOL_ID_DESC'
}

export type Area = Node & {
  __typename?: 'Area';
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DetectorLocation`. */
  detectorLocationsByAreaId: DetectorLocationsConnection;
  /** Reads a single `Floor` that is related to this `Area`. */
  floorByFloorId?: Maybe<Floor>;
  floorId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SamplePoint`. */
  samplePointsByAreaId: SamplePointsConnection;
  /** Reads a single `User` that is related to this `Area`. */
  userByOwnerId?: Maybe<User>;
};


export type AreaDetectorLocationsByAreaIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorLocationCondition>;
  filter?: InputMaybe<DetectorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorLocationsOrderBy>>;
};


export type AreaSamplePointsByAreaIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SamplePointCondition>;
  filter?: InputMaybe<SamplePointFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SamplePointsOrderBy>>;
};

/** A condition to be used against `Area` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AreaCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `floorId` field. */
  floorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AreaEntity` values. */
export type AreaEntitiesConnection = {
  __typename?: 'AreaEntitiesConnection';
  /** A list of edges which contains the `AreaEntity` and cursor to aid in pagination. */
  edges: Array<AreaEntitiesEdge>;
  /** A list of `AreaEntity` objects. */
  nodes: Array<AreaEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AreaEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AreaEntity` edge in the connection. */
export type AreaEntitiesEdge = {
  __typename?: 'AreaEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AreaEntity` at the end of the edge. */
  node: AreaEntity;
};

/** Methods to use when ordering `AreaEntity`. */
export enum AreaEntitiesOrderBy {
  BuildingIdAsc = 'BUILDING_ID_ASC',
  BuildingIdDesc = 'BUILDING_ID_DESC',
  BuildingNameAsc = 'BUILDING_NAME_ASC',
  BuildingNameDesc = 'BUILDING_NAME_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  EndUserNameAsc = 'END_USER_NAME_ASC',
  EndUserNameDesc = 'END_USER_NAME_DESC',
  FloorIdAsc = 'FLOOR_ID_ASC',
  FloorIdDesc = 'FLOOR_ID_DESC',
  FloorNameAsc = 'FLOOR_NAME_ASC',
  FloorNameDesc = 'FLOOR_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC'
}

export type AreaEntity = {
  __typename?: 'AreaEntity';
  buildingId?: Maybe<Scalars['Int']['output']>;
  buildingName?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  endUserName?: Maybe<Scalars['String']['output']>;
  floorId?: Maybe<Scalars['Int']['output']>;
  floorName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `AreaEntity` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AreaEntityCondition = {
  /** Checks for equality with the object’s `buildingId` field. */
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `buildingName` field. */
  buildingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserName` field. */
  endUserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `floorId` field. */
  floorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `floorName` field. */
  floorName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AreaEntity` object types. All fields are combined with a logical ‘and.’ */
export type AreaEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AreaEntityFilter>>;
  /** Filter by the object’s `buildingId` field. */
  buildingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `buildingName` field. */
  buildingName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserName` field. */
  endUserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `floorId` field. */
  floorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `floorName` field. */
  floorName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AreaEntityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AreaEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
};

/** A filter to be used against `Area` object types. All fields are combined with a logical ‘and.’ */
export type AreaFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AreaFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorLocationsByAreaId` relation. */
  detectorLocationsByAreaId?: InputMaybe<AreaToManyDetectorLocationFilter>;
  /** Some related `detectorLocationsByAreaId` exist. */
  detectorLocationsByAreaIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `floorByFloorId` relation. */
  floorByFloorId?: InputMaybe<FloorFilter>;
  /** Filter by the object’s `floorId` field. */
  floorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AreaFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AreaFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samplePointsByAreaId` relation. */
  samplePointsByAreaId?: InputMaybe<AreaToManySamplePointFilter>;
  /** Some related `samplePointsByAreaId` exist. */
  samplePointsByAreaIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `Area` */
export type AreaInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  floorId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Area`. Fields that are set will be updated. */
export type AreaPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  floorId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `DetectorLocation` object types. All fields are combined with a logical ‘and.’ */
export type AreaToManyDetectorLocationFilter = {
  /** Every related `DetectorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorLocationFilter>;
  /** No related `DetectorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorLocationFilter>;
  /** Some related `DetectorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorLocationFilter>;
};

/** A filter to be used against many `SamplePoint` object types. All fields are combined with a logical ‘and.’ */
export type AreaToManySamplePointFilter = {
  /** Every related `SamplePoint` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SamplePointFilter>;
  /** No related `SamplePoint` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SamplePointFilter>;
  /** Some related `SamplePoint` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SamplePointFilter>;
};

/** A connection to a list of `Area` values. */
export type AreasConnection = {
  __typename?: 'AreasConnection';
  /** A list of edges which contains the `Area` and cursor to aid in pagination. */
  edges: Array<AreasEdge>;
  /** A list of `Area` objects. */
  nodes: Array<Area>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Area` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Area` edge in the connection. */
export type AreasEdge = {
  __typename?: 'AreasEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Area` at the end of the edge. */
  node: Area;
};

/** Methods to use when ordering `Area`. */
export enum AreasOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorLocationsByAreaIdCountAsc = 'DETECTOR_LOCATIONS_BY_AREA_ID__COUNT_ASC',
  DetectorLocationsByAreaIdCountDesc = 'DETECTOR_LOCATIONS_BY_AREA_ID__COUNT_DESC',
  FloorByFloorIdBuildingIdAsc = 'FLOOR_BY_FLOOR_ID__BUILDING_ID_ASC',
  FloorByFloorIdBuildingIdDesc = 'FLOOR_BY_FLOOR_ID__BUILDING_ID_DESC',
  FloorByFloorIdCreatedAsc = 'FLOOR_BY_FLOOR_ID__CREATED_ASC',
  FloorByFloorIdCreatedDesc = 'FLOOR_BY_FLOOR_ID__CREATED_DESC',
  FloorByFloorIdIdAsc = 'FLOOR_BY_FLOOR_ID__ID_ASC',
  FloorByFloorIdIdDesc = 'FLOOR_BY_FLOOR_ID__ID_DESC',
  FloorByFloorIdModifiedAsc = 'FLOOR_BY_FLOOR_ID__MODIFIED_ASC',
  FloorByFloorIdModifiedDesc = 'FLOOR_BY_FLOOR_ID__MODIFIED_DESC',
  FloorByFloorIdNameAsc = 'FLOOR_BY_FLOOR_ID__NAME_ASC',
  FloorByFloorIdNameDesc = 'FLOOR_BY_FLOOR_ID__NAME_DESC',
  FloorByFloorIdOwnerIdAsc = 'FLOOR_BY_FLOOR_ID__OWNER_ID_ASC',
  FloorByFloorIdOwnerIdDesc = 'FLOOR_BY_FLOOR_ID__OWNER_ID_DESC',
  FloorIdAsc = 'FLOOR_ID_ASC',
  FloorIdDesc = 'FLOOR_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  SamplePointsByAreaIdCountAsc = 'SAMPLE_POINTS_BY_AREA_ID__COUNT_ASC',
  SamplePointsByAreaIdCountDesc = 'SAMPLE_POINTS_BY_AREA_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Aro = Node & {
  __typename?: 'Aro';
  alias?: Maybe<Scalars['String']['output']>;
  foreignKey?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  lft?: Maybe<Scalars['Int']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentId?: Maybe<Scalars['Int']['output']>;
  rght?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `Aro` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AroCondition = {
  /** Checks for equality with the object’s `alias` field. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `foreignKey` field. */
  foreignKey?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lft` field. */
  lft?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `model` field. */
  model?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `rght` field. */
  rght?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Aro` object types. All fields are combined with a logical ‘and.’ */
export type AroFilter = {
  /** Filter by the object’s `alias` field. */
  alias?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AroFilter>>;
  /** Filter by the object’s `foreignKey` field. */
  foreignKey?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lft` field. */
  lft?: InputMaybe<IntFilter>;
  /** Filter by the object’s `model` field. */
  model?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AroFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AroFilter>>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `rght` field. */
  rght?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Aro` */
export type AroInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  foreignKey?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lft?: InputMaybe<Scalars['Int']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['Int']['input']>;
  rght?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Aro`. Fields that are set will be updated. */
export type AroPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  foreignKey?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lft?: InputMaybe<Scalars['Int']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['Int']['input']>;
  rght?: InputMaybe<Scalars['Int']['input']>;
};

export type ArosAco = Node & {
  __typename?: 'ArosAco';
  _create: Scalars['String']['output'];
  _delete: Scalars['String']['output'];
  _read: Scalars['String']['output'];
  _update: Scalars['String']['output'];
  acoId: Scalars['Int']['output'];
  aroId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A condition to be used against `ArosAco` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ArosAcoCondition = {
  /** Checks for equality with the object’s `_create` field. */
  _create?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `_delete` field. */
  _delete?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `_read` field. */
  _read?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `_update` field. */
  _update?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `acoId` field. */
  acoId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aroId` field. */
  aroId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ArosAco` object types. All fields are combined with a logical ‘and.’ */
export type ArosAcoFilter = {
  /** Filter by the object’s `_create` field. */
  _create?: InputMaybe<StringFilter>;
  /** Filter by the object’s `_delete` field. */
  _delete?: InputMaybe<StringFilter>;
  /** Filter by the object’s `_read` field. */
  _read?: InputMaybe<StringFilter>;
  /** Filter by the object’s `_update` field. */
  _update?: InputMaybe<StringFilter>;
  /** Filter by the object’s `acoId` field. */
  acoId?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArosAcoFilter>>;
  /** Filter by the object’s `aroId` field. */
  aroId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArosAcoFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArosAcoFilter>>;
};

/** An input for mutations affecting `ArosAco` */
export type ArosAcoInput = {
  _create?: InputMaybe<Scalars['String']['input']>;
  _delete?: InputMaybe<Scalars['String']['input']>;
  _read?: InputMaybe<Scalars['String']['input']>;
  _update?: InputMaybe<Scalars['String']['input']>;
  acoId: Scalars['Int']['input'];
  aroId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `ArosAco`. Fields that are set will be updated. */
export type ArosAcoPatch = {
  _create?: InputMaybe<Scalars['String']['input']>;
  _delete?: InputMaybe<Scalars['String']['input']>;
  _read?: InputMaybe<Scalars['String']['input']>;
  _update?: InputMaybe<Scalars['String']['input']>;
  acoId?: InputMaybe<Scalars['Int']['input']>;
  aroId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ArosAco` values. */
export type ArosAcosConnection = {
  __typename?: 'ArosAcosConnection';
  /** A list of edges which contains the `ArosAco` and cursor to aid in pagination. */
  edges: Array<ArosAcosEdge>;
  /** A list of `ArosAco` objects. */
  nodes: Array<ArosAco>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArosAco` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArosAco` edge in the connection. */
export type ArosAcosEdge = {
  __typename?: 'ArosAcosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArosAco` at the end of the edge. */
  node: ArosAco;
};

/** Methods to use when ordering `ArosAco`. */
export enum ArosAcosOrderBy {
  AcoIdAsc = 'ACO_ID_ASC',
  AcoIdDesc = 'ACO_ID_DESC',
  AroIdAsc = 'ARO_ID_ASC',
  AroIdDesc = 'ARO_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  CreateAsc = '_CREATE_ASC',
  CreateDesc = '_CREATE_DESC',
  DeleteAsc = '_DELETE_ASC',
  DeleteDesc = '_DELETE_DESC',
  ReadAsc = '_READ_ASC',
  ReadDesc = '_READ_DESC',
  UpdateAsc = '_UPDATE_ASC',
  UpdateDesc = '_UPDATE_DESC'
}

/** A connection to a list of `Aro` values. */
export type ArosConnection = {
  __typename?: 'ArosConnection';
  /** A list of edges which contains the `Aro` and cursor to aid in pagination. */
  edges: Array<ArosEdge>;
  /** A list of `Aro` objects. */
  nodes: Array<Aro>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Aro` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Aro` edge in the connection. */
export type ArosEdge = {
  __typename?: 'ArosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Aro` at the end of the edge. */
  node: Aro;
};

/** Methods to use when ordering `Aro`. */
export enum ArosOrderBy {
  AliasAsc = 'ALIAS_ASC',
  AliasDesc = 'ALIAS_DESC',
  ForeignKeyAsc = 'FOREIGN_KEY_ASC',
  ForeignKeyDesc = 'FOREIGN_KEY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LftAsc = 'LFT_ASC',
  LftDesc = 'LFT_DESC',
  ModelAsc = 'MODEL_ASC',
  ModelDesc = 'MODEL_DESC',
  Natural = 'NATURAL',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RghtAsc = 'RGHT_ASC',
  RghtDesc = 'RGHT_DESC'
}

export type Artikel = Node & {
  __typename?: 'Artikel';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  aantaldec?: Maybe<Scalars['Int']['output']>;
  aanveenh?: Maybe<Scalars['BigFloat']['output']>;
  afdrukSamOpOfferte?: Maybe<Scalars['String']['output']>;
  assemblageArtikel?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `AssemblyType`. */
  assemblyTypesByCdartikel: AssemblyTypesConnection;
  btwcode?: Maybe<Scalars['Int']['output']>;
  cdartgroep?: Maybe<Scalars['String']['output']>;
  cdartikel: Scalars['String']['output'];
  cdartkortgrp?: Maybe<Scalars['String']['output']>;
  cdgoedcode?: Maybe<Scalars['Int']['output']>;
  cdgrbrekdekking?: Maybe<Scalars['String']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdgrbrekkort?: Maybe<Scalars['String']['output']>;
  cdlandOorspr?: Maybe<Scalars['String']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  eannummer?: Maybe<Scalars['String']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  factuur?: Maybe<Scalars['String']['output']>;
  gewicht?: Maybe<Scalars['BigFloat']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  inkvolgnr?: Maybe<Scalars['Int']['output']>;
  magbon?: Maybe<Scalars['String']['output']>;
  margePerc?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  omschr?: Maybe<Scalars['String']['output']>;
  opweb?: Maybe<Scalars['String']['output']>;
  pakbon?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  prijsincl?: Maybe<Scalars['BigFloat']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  projMutsoort?: Maybe<Scalars['String']['output']>;
  projOpslag?: Maybe<Scalars['BigFloat']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  uitloop?: Maybe<Scalars['String']['output']>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vvbestand?: Maybe<Scalars['String']['output']>;
  vvgroep?: Maybe<Scalars['String']['output']>;
  vvvrijvelda?: Maybe<Scalars['String']['output']>;
  vvvrijveldb?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};


export type ArtikelAssemblyTypesByCdartikelArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyTypeCondition>;
  filter?: InputMaybe<AssemblyTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyTypesOrderBy>>;
};

export type Artikel2 = {
  __typename?: 'Artikel2';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  aantaldec?: Maybe<Scalars['Int']['output']>;
  aanveenh?: Maybe<Scalars['BigFloat']['output']>;
  afdrukSamOpOfferte?: Maybe<Scalars['String']['output']>;
  assemblageArtikel?: Maybe<Scalars['String']['output']>;
  btwcode?: Maybe<Scalars['Int']['output']>;
  cdartgroep?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdartkortgrp?: Maybe<Scalars['String']['output']>;
  cdgoedcode?: Maybe<Scalars['Int']['output']>;
  cdgrbrekdekking?: Maybe<Scalars['String']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdgrbrekkort?: Maybe<Scalars['String']['output']>;
  cdlandOorspr?: Maybe<Scalars['String']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  eannummer?: Maybe<Scalars['String']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  factuur?: Maybe<Scalars['String']['output']>;
  gewicht?: Maybe<Scalars['BigFloat']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  inkvolgnr?: Maybe<Scalars['Int']['output']>;
  magbon?: Maybe<Scalars['String']['output']>;
  margePerc?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  opweb?: Maybe<Scalars['String']['output']>;
  pakbon?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  prijsincl?: Maybe<Scalars['BigFloat']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  projMutsoort?: Maybe<Scalars['String']['output']>;
  projOpslag?: Maybe<Scalars['BigFloat']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  uitloop?: Maybe<Scalars['String']['output']>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vvbestand?: Maybe<Scalars['String']['output']>;
  vvgroep?: Maybe<Scalars['String']['output']>;
  vvvrijvelda?: Maybe<Scalars['String']['output']>;
  vvvrijveldb?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Artikel2` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type Artikel2Condition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aanveenh` field. */
  aanveenh?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `afdrukSamOpOfferte` field. */
  afdrukSamOpOfferte?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwcode` field. */
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdartgroep` field. */
  cdartgroep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartkortgrp` field. */
  cdartkortgrp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdgrbrekdekking` field. */
  cdgrbrekdekking?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlandOorspr` field. */
  cdlandOorspr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `eannummer` field. */
  eannummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuur` field. */
  factuur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gewicht` field. */
  gewicht?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `magbon` field. */
  magbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margePerc` field. */
  margePerc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `opweb` field. */
  opweb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pakbon` field. */
  pakbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projOpslag` field. */
  projOpslag?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uitloop` field. */
  uitloop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvgroep` field. */
  vvgroep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvvrijveldb` field. */
  vvvrijveldb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Artikel2` object types. All fields are combined with a logical ‘and.’ */
export type Artikel2Filter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<IntFilter>;
  /** Filter by the object’s `aanveenh` field. */
  aanveenh?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `afdrukSamOpOfferte` field. */
  afdrukSamOpOfferte?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<Artikel2Filter>>;
  /** Filter by the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwcode` field. */
  btwcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdartgroep` field. */
  cdartgroep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartkortgrp` field. */
  cdartkortgrp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdgrbrekdekking` field. */
  cdgrbrekdekking?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlandOorspr` field. */
  cdlandOorspr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `eannummer` field. */
  eannummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuur` field. */
  factuur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gewicht` field. */
  gewicht?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `magbon` field. */
  magbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margePerc` field. */
  margePerc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<Artikel2Filter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `opweb` field. */
  opweb?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<Artikel2Filter>>;
  /** Filter by the object’s `pakbon` field. */
  pakbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projOpslag` field. */
  projOpslag?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uitloop` field. */
  uitloop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvgroep` field. */
  vvgroep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvvrijveldb` field. */
  vvvrijveldb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Artikel2` values. */
export type Artikel2SConnection = {
  __typename?: 'Artikel2SConnection';
  /** A list of edges which contains the `Artikel2` and cursor to aid in pagination. */
  edges: Array<Artikel2SEdge>;
  /** A list of `Artikel2` objects. */
  nodes: Array<Artikel2>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Artikel2` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Artikel2` edge in the connection. */
export type Artikel2SEdge = {
  __typename?: 'Artikel2SEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Artikel2` at the end of the edge. */
  node: Artikel2;
};

/** Methods to use when ordering `Artikel2`. */
export enum Artikel2SOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  AantaldecAsc = 'AANTALDEC_ASC',
  AantaldecDesc = 'AANTALDEC_DESC',
  AanveenhAsc = 'AANVEENH_ASC',
  AanveenhDesc = 'AANVEENH_DESC',
  AfdrukSamOpOfferteAsc = 'AFDRUK_SAM_OP_OFFERTE_ASC',
  AfdrukSamOpOfferteDesc = 'AFDRUK_SAM_OP_OFFERTE_DESC',
  AssemblageArtikelAsc = 'ASSEMBLAGE_ARTIKEL_ASC',
  AssemblageArtikelDesc = 'ASSEMBLAGE_ARTIKEL_DESC',
  BtwcodeAsc = 'BTWCODE_ASC',
  BtwcodeDesc = 'BTWCODE_DESC',
  CdartgroepAsc = 'CDARTGROEP_ASC',
  CdartgroepDesc = 'CDARTGROEP_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdartkortgrpAsc = 'CDARTKORTGRP_ASC',
  CdartkortgrpDesc = 'CDARTKORTGRP_DESC',
  CdgoedcodeAsc = 'CDGOEDCODE_ASC',
  CdgoedcodeDesc = 'CDGOEDCODE_DESC',
  CdgrbrekdekkingAsc = 'CDGRBREKDEKKING_ASC',
  CdgrbrekdekkingDesc = 'CDGRBREKDEKKING_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdgrbrekkortAsc = 'CDGRBREKKORT_ASC',
  CdgrbrekkortDesc = 'CDGRBREKKORT_DESC',
  CdlandOorsprAsc = 'CDLAND_OORSPR_ASC',
  CdlandOorsprDesc = 'CDLAND_OORSPR_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  EannummerAsc = 'EANNUMMER_ASC',
  EannummerDesc = 'EANNUMMER_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  FactuurAsc = 'FACTUUR_ASC',
  FactuurDesc = 'FACTUUR_DESC',
  GewichtAsc = 'GEWICHT_ASC',
  GewichtDesc = 'GEWICHT_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  InkvolgnrAsc = 'INKVOLGNR_ASC',
  InkvolgnrDesc = 'INKVOLGNR_DESC',
  MagbonAsc = 'MAGBON_ASC',
  MagbonDesc = 'MAGBON_DESC',
  MargePercAsc = 'MARGE_PERC_ASC',
  MargePercDesc = 'MARGE_PERC_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OpwebAsc = 'OPWEB_ASC',
  OpwebDesc = 'OPWEB_DESC',
  PakbonAsc = 'PAKBON_ASC',
  PakbonDesc = 'PAKBON_DESC',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  PrijsinclAsc = 'PRIJSINCL_ASC',
  PrijsinclDesc = 'PRIJSINCL_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  ProjMutsoortAsc = 'PROJ_MUTSOORT_ASC',
  ProjMutsoortDesc = 'PROJ_MUTSOORT_DESC',
  ProjOpslagAsc = 'PROJ_OPSLAG_ASC',
  ProjOpslagDesc = 'PROJ_OPSLAG_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  UitloopAsc = 'UITLOOP_ASC',
  UitloopDesc = 'UITLOOP_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VvbestandAsc = 'VVBESTAND_ASC',
  VvbestandDesc = 'VVBESTAND_DESC',
  VvgroepAsc = 'VVGROEP_ASC',
  VvgroepDesc = 'VVGROEP_DESC',
  VvvrijveldaAsc = 'VVVRIJVELDA_ASC',
  VvvrijveldaDesc = 'VVVRIJVELDA_DESC',
  VvvrijveldbAsc = 'VVVRIJVELDB_ASC',
  VvvrijveldbDesc = 'VVVRIJVELDB_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type ArtikelAssemblyIndex = {
  __typename?: 'ArtikelAssemblyIndex';
  advice?: Maybe<Scalars['BigFloat']['output']>;
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  assemblageArtikel?: Maybe<Scalars['String']['output']>;
  assemblbij?: Maybe<Scalars['BigFloat']['output']>;
  besthoeveelheid?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vrij?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `ArtikelAssemblyIndex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ArtikelAssemblyIndexCondition = {
  /** Checks for equality with the object’s `advice` field. */
  advice?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vrij` field. */
  vrij?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `ArtikelAssemblyIndex` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelAssemblyIndexFilter = {
  /** Filter by the object’s `advice` field. */
  advice?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelAssemblyIndexFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelAssemblyIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelAssemblyIndexFilter>>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vrij` field. */
  vrij?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `ArtikelAssemblyIndex` values. */
export type ArtikelAssemblyIndicesConnection = {
  __typename?: 'ArtikelAssemblyIndicesConnection';
  /** A list of edges which contains the `ArtikelAssemblyIndex` and cursor to aid in pagination. */
  edges: Array<ArtikelAssemblyIndicesEdge>;
  /** A list of `ArtikelAssemblyIndex` objects. */
  nodes: Array<ArtikelAssemblyIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelAssemblyIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelAssemblyIndex` edge in the connection. */
export type ArtikelAssemblyIndicesEdge = {
  __typename?: 'ArtikelAssemblyIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelAssemblyIndex` at the end of the edge. */
  node: ArtikelAssemblyIndex;
};

/** Methods to use when ordering `ArtikelAssemblyIndex`. */
export enum ArtikelAssemblyIndicesOrderBy {
  AdviceAsc = 'ADVICE_ASC',
  AdviceDesc = 'ADVICE_DESC',
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  AssemblageArtikelAsc = 'ASSEMBLAGE_ARTIKEL_ASC',
  AssemblageArtikelDesc = 'ASSEMBLAGE_ARTIKEL_DESC',
  AssemblbijAsc = 'ASSEMBLBIJ_ASC',
  AssemblbijDesc = 'ASSEMBLBIJ_DESC',
  BesthoeveelheidAsc = 'BESTHOEVEELHEID_ASC',
  BesthoeveelheidDesc = 'BESTHOEVEELHEID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VrijAsc = 'VRIJ_ASC',
  VrijDesc = 'VRIJ_DESC'
}

export type ArtikelComponenten = {
  __typename?: 'ArtikelComponenten';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdartsamenstel?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  virtualStock?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vrij?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ArtikelComponenten` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtikelComponentenCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartsamenstel` field. */
  cdartsamenstel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `virtualStock` field. */
  virtualStock?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vrij` field. */
  vrij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtikelComponenten` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelComponentenFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelComponentenFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartsamenstel` field. */
  cdartsamenstel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelComponentenFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelComponentenFilter>>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `virtualStock` field. */
  virtualStock?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vrij` field. */
  vrij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ArtikelComponenten` values. */
export type ArtikelComponentensConnection = {
  __typename?: 'ArtikelComponentensConnection';
  /** A list of edges which contains the `ArtikelComponenten` and cursor to aid in pagination. */
  edges: Array<ArtikelComponentensEdge>;
  /** A list of `ArtikelComponenten` objects. */
  nodes: Array<ArtikelComponenten>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelComponenten` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelComponenten` edge in the connection. */
export type ArtikelComponentensEdge = {
  __typename?: 'ArtikelComponentensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelComponenten` at the end of the edge. */
  node: ArtikelComponenten;
};

/** Methods to use when ordering `ArtikelComponenten`. */
export enum ArtikelComponentensOrderBy {
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdartsamenstelAsc = 'CDARTSAMENSTEL_ASC',
  CdartsamenstelDesc = 'CDARTSAMENSTEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  VirtualStockAsc = 'VIRTUAL_STOCK_ASC',
  VirtualStockDesc = 'VIRTUAL_STOCK_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VrijAsc = 'VRIJ_ASC',
  VrijDesc = 'VRIJ_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A condition to be used against `Artikel` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ArtikelCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aanveenh` field. */
  aanveenh?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `afdrukSamOpOfferte` field. */
  afdrukSamOpOfferte?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwcode` field. */
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdartgroep` field. */
  cdartgroep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartkortgrp` field. */
  cdartkortgrp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdgrbrekdekking` field. */
  cdgrbrekdekking?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlandOorspr` field. */
  cdlandOorspr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `eannummer` field. */
  eannummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuur` field. */
  factuur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gewicht` field. */
  gewicht?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `magbon` field. */
  magbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margePerc` field. */
  margePerc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `opweb` field. */
  opweb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pakbon` field. */
  pakbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projOpslag` field. */
  projOpslag?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uitloop` field. */
  uitloop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvgroep` field. */
  vvgroep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvvrijveldb` field. */
  vvvrijveldb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Artikel` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<IntFilter>;
  /** Filter by the object’s `aanveenh` field. */
  aanveenh?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `afdrukSamOpOfferte` field. */
  afdrukSamOpOfferte?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelFilter>>;
  /** Filter by the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `assemblyTypesByCdartikel` relation. */
  assemblyTypesByCdartikel?: InputMaybe<ArtikelToManyAssemblyTypeFilter>;
  /** Some related `assemblyTypesByCdartikel` exist. */
  assemblyTypesByCdartikelExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `btwcode` field. */
  btwcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdartgroep` field. */
  cdartgroep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartkortgrp` field. */
  cdartkortgrp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdgrbrekdekking` field. */
  cdgrbrekdekking?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlandOorspr` field. */
  cdlandOorspr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `eannummer` field. */
  eannummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuur` field. */
  factuur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gewicht` field. */
  gewicht?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `magbon` field. */
  magbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margePerc` field. */
  margePerc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `opweb` field. */
  opweb?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelFilter>>;
  /** Filter by the object’s `pakbon` field. */
  pakbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projOpslag` field. */
  projOpslag?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uitloop` field. */
  uitloop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvgroep` field. */
  vvgroep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvvrijveldb` field. */
  vvvrijveldb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

export type ArtikelIndex = {
  __typename?: 'ArtikelIndex';
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  assemblbij?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  margin?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  samenstelling?: Maybe<Scalars['String']['output']>;
  uitloop?: Maybe<Scalars['String']['output']>;
  virtualStock?: Maybe<Scalars['BigFloat']['output']>;
  virtualStock2?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  voorraadGereserveerd2?: Maybe<Scalars['BigFloat']['output']>;
  voorraadVrij?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

export type ArtikelIndex2 = {
  __typename?: 'ArtikelIndex2';
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  assemblbij?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdartsamenstel?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  margin?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  samenstelling?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['BigFloat']['output']>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  virtualStock?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  voorraadGereserveerd2?: Maybe<Scalars['BigFloat']['output']>;
  voorraadVrij?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ArtikelIndex2` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtikelIndex2Condition = {
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartsamenstel` field. */
  cdartsamenstel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samenstelling` field. */
  samenstelling?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `virtualStock` field. */
  virtualStock?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraadGereserveerd2` field. */
  voorraadGereserveerd2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraadVrij` field. */
  voorraadVrij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtikelIndex2` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelIndex2Filter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelIndex2Filter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartsamenstel` field. */
  cdartsamenstel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelIndex2Filter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelIndex2Filter>>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samenstelling` field. */
  samenstelling?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `virtualStock` field. */
  virtualStock?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraadGereserveerd2` field. */
  voorraadGereserveerd2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraadVrij` field. */
  voorraadVrij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ArtikelIndex2` values. */
export type ArtikelIndex2SConnection = {
  __typename?: 'ArtikelIndex2SConnection';
  /** A list of edges which contains the `ArtikelIndex2` and cursor to aid in pagination. */
  edges: Array<ArtikelIndex2SEdge>;
  /** A list of `ArtikelIndex2` objects. */
  nodes: Array<ArtikelIndex2>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelIndex2` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelIndex2` edge in the connection. */
export type ArtikelIndex2SEdge = {
  __typename?: 'ArtikelIndex2SEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelIndex2` at the end of the edge. */
  node: ArtikelIndex2;
};

/** Methods to use when ordering `ArtikelIndex2`. */
export enum ArtikelIndex2SOrderBy {
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  AssemblbijAsc = 'ASSEMBLBIJ_ASC',
  AssemblbijDesc = 'ASSEMBLBIJ_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdartsamenstelAsc = 'CDARTSAMENSTEL_ASC',
  CdartsamenstelDesc = 'CDARTSAMENSTEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginDesc = 'MARGIN_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  SamenstellingAsc = 'SAMENSTELLING_ASC',
  SamenstellingDesc = 'SAMENSTELLING_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  VirtualStockAsc = 'VIRTUAL_STOCK_ASC',
  VirtualStockDesc = 'VIRTUAL_STOCK_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VoorraadGereserveerd2Asc = 'VOORRAAD_GERESERVEERD2_ASC',
  VoorraadGereserveerd2Desc = 'VOORRAAD_GERESERVEERD2_DESC',
  VoorraadVrijAsc = 'VOORRAAD_VRIJ_ASC',
  VoorraadVrijDesc = 'VOORRAAD_VRIJ_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/**
 * A condition to be used against `ArtikelIndex` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtikelIndexCondition = {
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `samenstelling` field. */
  samenstelling?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uitloop` field. */
  uitloop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `virtualStock` field. */
  virtualStock?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `virtualStock2` field. */
  virtualStock2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraadGereserveerd2` field. */
  voorraadGereserveerd2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraadVrij` field. */
  voorraadVrij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtikelIndex` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelIndexFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelIndexFilter>>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `samenstelling` field. */
  samenstelling?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uitloop` field. */
  uitloop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `virtualStock` field. */
  virtualStock?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `virtualStock2` field. */
  virtualStock2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraadGereserveerd2` field. */
  voorraadGereserveerd2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraadVrij` field. */
  voorraadVrij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ArtikelIndex` values. */
export type ArtikelIndicesConnection = {
  __typename?: 'ArtikelIndicesConnection';
  /** A list of edges which contains the `ArtikelIndex` and cursor to aid in pagination. */
  edges: Array<ArtikelIndicesEdge>;
  /** A list of `ArtikelIndex` objects. */
  nodes: Array<ArtikelIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelIndex` edge in the connection. */
export type ArtikelIndicesEdge = {
  __typename?: 'ArtikelIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelIndex` at the end of the edge. */
  node: ArtikelIndex;
};

/** Methods to use when ordering `ArtikelIndex`. */
export enum ArtikelIndicesOrderBy {
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  AssemblbijAsc = 'ASSEMBLBIJ_ASC',
  AssemblbijDesc = 'ASSEMBLBIJ_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginDesc = 'MARGIN_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  SamenstellingAsc = 'SAMENSTELLING_ASC',
  SamenstellingDesc = 'SAMENSTELLING_DESC',
  UitloopAsc = 'UITLOOP_ASC',
  UitloopDesc = 'UITLOOP_DESC',
  VirtualStock2Asc = 'VIRTUAL_STOCK2_ASC',
  VirtualStock2Desc = 'VIRTUAL_STOCK2_DESC',
  VirtualStockAsc = 'VIRTUAL_STOCK_ASC',
  VirtualStockDesc = 'VIRTUAL_STOCK_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VoorraadGereserveerd2Asc = 'VOORRAAD_GERESERVEERD2_ASC',
  VoorraadGereserveerd2Desc = 'VOORRAAD_GERESERVEERD2_DESC',
  VoorraadVrijAsc = 'VOORRAAD_VRIJ_ASC',
  VoorraadVrijDesc = 'VOORRAAD_VRIJ_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** An input for mutations affecting `Artikel` */
export type ArtikelInput = {
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  aanveenh?: InputMaybe<Scalars['BigFloat']['input']>;
  afdrukSamOpOfferte?: InputMaybe<Scalars['String']['input']>;
  assemblageArtikel?: InputMaybe<Scalars['String']['input']>;
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  cdartgroep?: InputMaybe<Scalars['String']['input']>;
  cdartikel: Scalars['String']['input'];
  cdartkortgrp?: InputMaybe<Scalars['String']['input']>;
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  cdgrbrekdekking?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  cdlandOorspr?: InputMaybe<Scalars['String']['input']>;
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  eannummer?: InputMaybe<Scalars['String']['input']>;
  eenheid?: InputMaybe<Scalars['String']['input']>;
  factuur?: InputMaybe<Scalars['String']['input']>;
  gewicht?: InputMaybe<Scalars['BigFloat']['input']>;
  guidItem?: InputMaybe<Scalars['String']['input']>;
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  magbon?: InputMaybe<Scalars['String']['input']>;
  margePerc?: InputMaybe<Scalars['BigFloat']['input']>;
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  opweb?: InputMaybe<Scalars['String']['input']>;
  pakbon?: InputMaybe<Scalars['String']['input']>;
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  prijsincl?: InputMaybe<Scalars['BigFloat']['input']>;
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  projOpslag?: InputMaybe<Scalars['BigFloat']['input']>;
  samVersie?: InputMaybe<Scalars['String']['input']>;
  soort?: InputMaybe<Scalars['String']['input']>;
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  uitloop?: InputMaybe<Scalars['String']['input']>;
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  vvgroep?: InputMaybe<Scalars['String']['input']>;
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
  vvvrijveldb?: InputMaybe<Scalars['String']['input']>;
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

export type ArtikelLog = Node & {
  __typename?: 'ArtikelLog';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  new?: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  old?: Maybe<Scalars['JSON']['output']>;
  operation?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ArtikelLog` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ArtikelLogCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `new` field. */
  new?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `old` field. */
  old?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `operation` field. */
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtikelLog` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelLogFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `new` field. */
  new?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelLogFilter>;
  /** Filter by the object’s `old` field. */
  old?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `operation` field. */
  operation?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelLogFilter>>;
};

/** An input for mutations affecting `ArtikelLog` */
export type ArtikelLogInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  new?: InputMaybe<Scalars['JSON']['input']>;
  old?: InputMaybe<Scalars['JSON']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `ArtikelLog`. Fields that are set will be updated. */
export type ArtikelLogPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  new?: InputMaybe<Scalars['JSON']['input']>;
  old?: InputMaybe<Scalars['JSON']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `ArtikelLog` values. */
export type ArtikelLogsConnection = {
  __typename?: 'ArtikelLogsConnection';
  /** A list of edges which contains the `ArtikelLog` and cursor to aid in pagination. */
  edges: Array<ArtikelLogsEdge>;
  /** A list of `ArtikelLog` objects. */
  nodes: Array<ArtikelLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelLog` edge in the connection. */
export type ArtikelLogsEdge = {
  __typename?: 'ArtikelLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelLog` at the end of the edge. */
  node: ArtikelLog;
};

export type ArtikelLogsIndex = {
  __typename?: 'ArtikelLogsIndex';
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Date']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  new?: Maybe<Scalars['String']['output']>;
  old?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ArtikelLogsIndex` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtikelLogsIndexCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `new` field. */
  new?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `old` field. */
  old?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtikelLogsIndex` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelLogsIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelLogsIndexFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DateFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `new` field. */
  new?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelLogsIndexFilter>;
  /** Filter by the object’s `old` field. */
  old?: InputMaybe<StringFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelLogsIndexFilter>>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ArtikelLogsIndex` values. */
export type ArtikelLogsIndicesConnection = {
  __typename?: 'ArtikelLogsIndicesConnection';
  /** A list of edges which contains the `ArtikelLogsIndex` and cursor to aid in pagination. */
  edges: Array<ArtikelLogsIndicesEdge>;
  /** A list of `ArtikelLogsIndex` objects. */
  nodes: Array<ArtikelLogsIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelLogsIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelLogsIndex` edge in the connection. */
export type ArtikelLogsIndicesEdge = {
  __typename?: 'ArtikelLogsIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelLogsIndex` at the end of the edge. */
  node: ArtikelLogsIndex;
};

/** Methods to use when ordering `ArtikelLogsIndex`. */
export enum ArtikelLogsIndicesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  Natural = 'NATURAL',
  NewAsc = 'NEW_ASC',
  NewDesc = 'NEW_DESC',
  OldAsc = 'OLD_ASC',
  OldDesc = 'OLD_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** Methods to use when ordering `ArtikelLog`. */
export enum ArtikelLogsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NewAsc = 'NEW_ASC',
  NewDesc = 'NEW_DESC',
  OldAsc = 'OLD_ASC',
  OldDesc = 'OLD_DESC',
  OperationAsc = 'OPERATION_ASC',
  OperationDesc = 'OPERATION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ArtikelMv = {
  __typename?: 'ArtikelMv';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  aantaldec?: Maybe<Scalars['Int']['output']>;
  aanveenh?: Maybe<Scalars['BigFloat']['output']>;
  afdrukSamOpOfferte?: Maybe<Scalars['String']['output']>;
  assemblageArtikel?: Maybe<Scalars['String']['output']>;
  btwcode?: Maybe<Scalars['Int']['output']>;
  cdartgroep?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdartkortgrp?: Maybe<Scalars['String']['output']>;
  cdgoedcode?: Maybe<Scalars['Int']['output']>;
  cdgrbrekdekking?: Maybe<Scalars['String']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdgrbrekkort?: Maybe<Scalars['String']['output']>;
  cdlandOorspr?: Maybe<Scalars['String']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  eannummer?: Maybe<Scalars['String']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  factuur?: Maybe<Scalars['String']['output']>;
  gewicht?: Maybe<Scalars['BigFloat']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  inkvolgnr?: Maybe<Scalars['Int']['output']>;
  magbon?: Maybe<Scalars['String']['output']>;
  margePerc?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  opweb?: Maybe<Scalars['String']['output']>;
  pakbon?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  prijsincl?: Maybe<Scalars['BigFloat']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  projMutsoort?: Maybe<Scalars['String']['output']>;
  projOpslag?: Maybe<Scalars['BigFloat']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  uitloop?: Maybe<Scalars['String']['output']>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vvbestand?: Maybe<Scalars['String']['output']>;
  vvgroep?: Maybe<Scalars['String']['output']>;
  vvvrijvelda?: Maybe<Scalars['String']['output']>;
  vvvrijveldb?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ArtikelMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ArtikelMvCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aanveenh` field. */
  aanveenh?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `afdrukSamOpOfferte` field. */
  afdrukSamOpOfferte?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwcode` field. */
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdartgroep` field. */
  cdartgroep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartkortgrp` field. */
  cdartkortgrp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdgrbrekdekking` field. */
  cdgrbrekdekking?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlandOorspr` field. */
  cdlandOorspr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `eannummer` field. */
  eannummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuur` field. */
  factuur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gewicht` field. */
  gewicht?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `magbon` field. */
  magbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margePerc` field. */
  margePerc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `opweb` field. */
  opweb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pakbon` field. */
  pakbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projOpslag` field. */
  projOpslag?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uitloop` field. */
  uitloop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvgroep` field. */
  vvgroep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvvrijveldb` field. */
  vvvrijveldb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtikelMv` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelMvFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<IntFilter>;
  /** Filter by the object’s `aanveenh` field. */
  aanveenh?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `afdrukSamOpOfferte` field. */
  afdrukSamOpOfferte?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelMvFilter>>;
  /** Filter by the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwcode` field. */
  btwcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdartgroep` field. */
  cdartgroep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartkortgrp` field. */
  cdartkortgrp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdgrbrekdekking` field. */
  cdgrbrekdekking?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlandOorspr` field. */
  cdlandOorspr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `eannummer` field. */
  eannummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuur` field. */
  factuur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gewicht` field. */
  gewicht?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `magbon` field. */
  magbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margePerc` field. */
  margePerc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelMvFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `opweb` field. */
  opweb?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelMvFilter>>;
  /** Filter by the object’s `pakbon` field. */
  pakbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projOpslag` field. */
  projOpslag?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uitloop` field. */
  uitloop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvgroep` field. */
  vvgroep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvvrijveldb` field. */
  vvvrijveldb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ArtikelMv` values. */
export type ArtikelMvsConnection = {
  __typename?: 'ArtikelMvsConnection';
  /** A list of edges which contains the `ArtikelMv` and cursor to aid in pagination. */
  edges: Array<ArtikelMvsEdge>;
  /** A list of `ArtikelMv` objects. */
  nodes: Array<ArtikelMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelMv` edge in the connection. */
export type ArtikelMvsEdge = {
  __typename?: 'ArtikelMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelMv` at the end of the edge. */
  node: ArtikelMv;
};

/** Methods to use when ordering `ArtikelMv`. */
export enum ArtikelMvsOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  AantaldecAsc = 'AANTALDEC_ASC',
  AantaldecDesc = 'AANTALDEC_DESC',
  AanveenhAsc = 'AANVEENH_ASC',
  AanveenhDesc = 'AANVEENH_DESC',
  AfdrukSamOpOfferteAsc = 'AFDRUK_SAM_OP_OFFERTE_ASC',
  AfdrukSamOpOfferteDesc = 'AFDRUK_SAM_OP_OFFERTE_DESC',
  AssemblageArtikelAsc = 'ASSEMBLAGE_ARTIKEL_ASC',
  AssemblageArtikelDesc = 'ASSEMBLAGE_ARTIKEL_DESC',
  BtwcodeAsc = 'BTWCODE_ASC',
  BtwcodeDesc = 'BTWCODE_DESC',
  CdartgroepAsc = 'CDARTGROEP_ASC',
  CdartgroepDesc = 'CDARTGROEP_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdartkortgrpAsc = 'CDARTKORTGRP_ASC',
  CdartkortgrpDesc = 'CDARTKORTGRP_DESC',
  CdgoedcodeAsc = 'CDGOEDCODE_ASC',
  CdgoedcodeDesc = 'CDGOEDCODE_DESC',
  CdgrbrekdekkingAsc = 'CDGRBREKDEKKING_ASC',
  CdgrbrekdekkingDesc = 'CDGRBREKDEKKING_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdgrbrekkortAsc = 'CDGRBREKKORT_ASC',
  CdgrbrekkortDesc = 'CDGRBREKKORT_DESC',
  CdlandOorsprAsc = 'CDLAND_OORSPR_ASC',
  CdlandOorsprDesc = 'CDLAND_OORSPR_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  EannummerAsc = 'EANNUMMER_ASC',
  EannummerDesc = 'EANNUMMER_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  FactuurAsc = 'FACTUUR_ASC',
  FactuurDesc = 'FACTUUR_DESC',
  GewichtAsc = 'GEWICHT_ASC',
  GewichtDesc = 'GEWICHT_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  InkvolgnrAsc = 'INKVOLGNR_ASC',
  InkvolgnrDesc = 'INKVOLGNR_DESC',
  MagbonAsc = 'MAGBON_ASC',
  MagbonDesc = 'MAGBON_DESC',
  MargePercAsc = 'MARGE_PERC_ASC',
  MargePercDesc = 'MARGE_PERC_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OpwebAsc = 'OPWEB_ASC',
  OpwebDesc = 'OPWEB_DESC',
  PakbonAsc = 'PAKBON_ASC',
  PakbonDesc = 'PAKBON_DESC',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  PrijsinclAsc = 'PRIJSINCL_ASC',
  PrijsinclDesc = 'PRIJSINCL_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  ProjMutsoortAsc = 'PROJ_MUTSOORT_ASC',
  ProjMutsoortDesc = 'PROJ_MUTSOORT_DESC',
  ProjOpslagAsc = 'PROJ_OPSLAG_ASC',
  ProjOpslagDesc = 'PROJ_OPSLAG_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  UitloopAsc = 'UITLOOP_ASC',
  UitloopDesc = 'UITLOOP_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VvbestandAsc = 'VVBESTAND_ASC',
  VvbestandDesc = 'VVBESTAND_DESC',
  VvgroepAsc = 'VVGROEP_ASC',
  VvgroepDesc = 'VVGROEP_DESC',
  VvvrijveldaAsc = 'VVVRIJVELDA_ASC',
  VvvrijveldaDesc = 'VVVRIJVELDA_DESC',
  VvvrijveldbAsc = 'VVVRIJVELDB_ASC',
  VvvrijveldbDesc = 'VVVRIJVELDB_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** Represents an update to a `Artikel`. Fields that are set will be updated. */
export type ArtikelPatch = {
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  aanveenh?: InputMaybe<Scalars['BigFloat']['input']>;
  afdrukSamOpOfferte?: InputMaybe<Scalars['String']['input']>;
  assemblageArtikel?: InputMaybe<Scalars['String']['input']>;
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  cdartgroep?: InputMaybe<Scalars['String']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  cdartkortgrp?: InputMaybe<Scalars['String']['input']>;
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  cdgrbrekdekking?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  cdlandOorspr?: InputMaybe<Scalars['String']['input']>;
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  eannummer?: InputMaybe<Scalars['String']['input']>;
  eenheid?: InputMaybe<Scalars['String']['input']>;
  factuur?: InputMaybe<Scalars['String']['input']>;
  gewicht?: InputMaybe<Scalars['BigFloat']['input']>;
  guidItem?: InputMaybe<Scalars['String']['input']>;
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  magbon?: InputMaybe<Scalars['String']['input']>;
  margePerc?: InputMaybe<Scalars['BigFloat']['input']>;
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  opweb?: InputMaybe<Scalars['String']['input']>;
  pakbon?: InputMaybe<Scalars['String']['input']>;
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  prijsincl?: InputMaybe<Scalars['BigFloat']['input']>;
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  projOpslag?: InputMaybe<Scalars['BigFloat']['input']>;
  samVersie?: InputMaybe<Scalars['String']['input']>;
  soort?: InputMaybe<Scalars['String']['input']>;
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  uitloop?: InputMaybe<Scalars['String']['input']>;
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  vvgroep?: InputMaybe<Scalars['String']['input']>;
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
  vvvrijveldb?: InputMaybe<Scalars['String']['input']>;
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

export type ArtikelSamenstellingen = {
  __typename?: 'ArtikelSamenstellingen';
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  cdartcomponent?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  margin?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  virtualStock?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vrij?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `ArtikelSamenstellingen` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ArtikelSamenstellingenCondition = {
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `virtualStock` field. */
  virtualStock?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vrij` field. */
  vrij?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `ArtikelSamenstellingen` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelSamenstellingenFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelSamenstellingenFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelSamenstellingenFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelSamenstellingenFilter>>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `virtualStock` field. */
  virtualStock?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vrij` field. */
  vrij?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `ArtikelSamenstellingen` values. */
export type ArtikelSamenstellingensConnection = {
  __typename?: 'ArtikelSamenstellingensConnection';
  /** A list of edges which contains the `ArtikelSamenstellingen` and cursor to aid in pagination. */
  edges: Array<ArtikelSamenstellingensEdge>;
  /** A list of `ArtikelSamenstellingen` objects. */
  nodes: Array<ArtikelSamenstellingen>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelSamenstellingen` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelSamenstellingen` edge in the connection. */
export type ArtikelSamenstellingensEdge = {
  __typename?: 'ArtikelSamenstellingensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelSamenstellingen` at the end of the edge. */
  node: ArtikelSamenstellingen;
};

/** Methods to use when ordering `ArtikelSamenstellingen`. */
export enum ArtikelSamenstellingensOrderBy {
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  CdartcomponentAsc = 'CDARTCOMPONENT_ASC',
  CdartcomponentDesc = 'CDARTCOMPONENT_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginDesc = 'MARGIN_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  VirtualStockAsc = 'VIRTUAL_STOCK_ASC',
  VirtualStockDesc = 'VIRTUAL_STOCK_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VrijAsc = 'VRIJ_ASC',
  VrijDesc = 'VRIJ_DESC'
}

/** A filter to be used against many `AssemblyType` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelToManyAssemblyTypeFilter = {
  /** Every related `AssemblyType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AssemblyTypeFilter>;
  /** No related `AssemblyType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AssemblyTypeFilter>;
  /** Some related `AssemblyType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AssemblyTypeFilter>;
};

export type Artikelomschr = Node & {
  __typename?: 'Artikelomschr';
  cdartikel: Scalars['String']['output'];
  cdtaal: Scalars['String']['output'];
  eenheid?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  omschr?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Artikelomschr` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtikelomschrCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Artikelomschr` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelomschrFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelomschrFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelomschrFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelomschrFilter>>;
};

/** An input for mutations affecting `Artikelomschr` */
export type ArtikelomschrInput = {
  cdartikel: Scalars['String']['input'];
  cdtaal: Scalars['String']['input'];
  eenheid?: InputMaybe<Scalars['String']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
};

export type ArtikelomschrMv = {
  __typename?: 'ArtikelomschrMv';
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ArtikelomschrMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtikelomschrMvCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtikelomschrMv` object types. All fields are combined with a logical ‘and.’ */
export type ArtikelomschrMvFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtikelomschrMvFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtikelomschrMvFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtikelomschrMvFilter>>;
};

/** A connection to a list of `ArtikelomschrMv` values. */
export type ArtikelomschrMvsConnection = {
  __typename?: 'ArtikelomschrMvsConnection';
  /** A list of edges which contains the `ArtikelomschrMv` and cursor to aid in pagination. */
  edges: Array<ArtikelomschrMvsEdge>;
  /** A list of `ArtikelomschrMv` objects. */
  nodes: Array<ArtikelomschrMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtikelomschrMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtikelomschrMv` edge in the connection. */
export type ArtikelomschrMvsEdge = {
  __typename?: 'ArtikelomschrMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtikelomschrMv` at the end of the edge. */
  node: ArtikelomschrMv;
};

/** Methods to use when ordering `ArtikelomschrMv`. */
export enum ArtikelomschrMvsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC'
}

/** Represents an update to a `Artikelomschr`. Fields that are set will be updated. */
export type ArtikelomschrPatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  eenheid?: InputMaybe<Scalars['String']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Artikelomschr` values. */
export type ArtikelomschrsConnection = {
  __typename?: 'ArtikelomschrsConnection';
  /** A list of edges which contains the `Artikelomschr` and cursor to aid in pagination. */
  edges: Array<ArtikelomschrsEdge>;
  /** A list of `Artikelomschr` objects. */
  nodes: Array<Artikelomschr>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Artikelomschr` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Artikelomschr` edge in the connection. */
export type ArtikelomschrsEdge = {
  __typename?: 'ArtikelomschrsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Artikelomschr` at the end of the edge. */
  node: Artikelomschr;
};

/** Methods to use when ordering `Artikelomschr`. */
export enum ArtikelomschrsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `Artikel` values. */
export type ArtikelsConnection = {
  __typename?: 'ArtikelsConnection';
  /** A list of edges which contains the `Artikel` and cursor to aid in pagination. */
  edges: Array<ArtikelsEdge>;
  /** A list of `Artikel` objects. */
  nodes: Array<Artikel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Artikel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Artikel` edge in the connection. */
export type ArtikelsEdge = {
  __typename?: 'ArtikelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Artikel` at the end of the edge. */
  node: Artikel;
};

/** Methods to use when ordering `Artikel`. */
export enum ArtikelsOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  AantaldecAsc = 'AANTALDEC_ASC',
  AantaldecDesc = 'AANTALDEC_DESC',
  AanveenhAsc = 'AANVEENH_ASC',
  AanveenhDesc = 'AANVEENH_DESC',
  AfdrukSamOpOfferteAsc = 'AFDRUK_SAM_OP_OFFERTE_ASC',
  AfdrukSamOpOfferteDesc = 'AFDRUK_SAM_OP_OFFERTE_DESC',
  AssemblageArtikelAsc = 'ASSEMBLAGE_ARTIKEL_ASC',
  AssemblageArtikelDesc = 'ASSEMBLAGE_ARTIKEL_DESC',
  AssemblyTypesByCdartikelCountAsc = 'ASSEMBLY_TYPES_BY_CDARTIKEL__COUNT_ASC',
  AssemblyTypesByCdartikelCountDesc = 'ASSEMBLY_TYPES_BY_CDARTIKEL__COUNT_DESC',
  BtwcodeAsc = 'BTWCODE_ASC',
  BtwcodeDesc = 'BTWCODE_DESC',
  CdartgroepAsc = 'CDARTGROEP_ASC',
  CdartgroepDesc = 'CDARTGROEP_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdartkortgrpAsc = 'CDARTKORTGRP_ASC',
  CdartkortgrpDesc = 'CDARTKORTGRP_DESC',
  CdgoedcodeAsc = 'CDGOEDCODE_ASC',
  CdgoedcodeDesc = 'CDGOEDCODE_DESC',
  CdgrbrekdekkingAsc = 'CDGRBREKDEKKING_ASC',
  CdgrbrekdekkingDesc = 'CDGRBREKDEKKING_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdgrbrekkortAsc = 'CDGRBREKKORT_ASC',
  CdgrbrekkortDesc = 'CDGRBREKKORT_DESC',
  CdlandOorsprAsc = 'CDLAND_OORSPR_ASC',
  CdlandOorsprDesc = 'CDLAND_OORSPR_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  EannummerAsc = 'EANNUMMER_ASC',
  EannummerDesc = 'EANNUMMER_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  FactuurAsc = 'FACTUUR_ASC',
  FactuurDesc = 'FACTUUR_DESC',
  GewichtAsc = 'GEWICHT_ASC',
  GewichtDesc = 'GEWICHT_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  InkvolgnrAsc = 'INKVOLGNR_ASC',
  InkvolgnrDesc = 'INKVOLGNR_DESC',
  MagbonAsc = 'MAGBON_ASC',
  MagbonDesc = 'MAGBON_DESC',
  MargePercAsc = 'MARGE_PERC_ASC',
  MargePercDesc = 'MARGE_PERC_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OpwebAsc = 'OPWEB_ASC',
  OpwebDesc = 'OPWEB_DESC',
  PakbonAsc = 'PAKBON_ASC',
  PakbonDesc = 'PAKBON_DESC',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  PrijsinclAsc = 'PRIJSINCL_ASC',
  PrijsinclDesc = 'PRIJSINCL_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProjMutsoortAsc = 'PROJ_MUTSOORT_ASC',
  ProjMutsoortDesc = 'PROJ_MUTSOORT_DESC',
  ProjOpslagAsc = 'PROJ_OPSLAG_ASC',
  ProjOpslagDesc = 'PROJ_OPSLAG_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  UitloopAsc = 'UITLOOP_ASC',
  UitloopDesc = 'UITLOOP_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VvbestandAsc = 'VVBESTAND_ASC',
  VvbestandDesc = 'VVBESTAND_DESC',
  VvgroepAsc = 'VVGROEP_ASC',
  VvgroepDesc = 'VVGROEP_DESC',
  VvvrijveldaAsc = 'VVVRIJVELDA_ASC',
  VvvrijveldaDesc = 'VVVRIJVELDA_DESC',
  VvvrijveldbAsc = 'VVVRIJVELDB_ASC',
  VvvrijveldbDesc = 'VVVRIJVELDB_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type Artsamcomponenten = {
  __typename?: 'Artsamcomponenten';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  cdartcomponent?: Maybe<Scalars['String']['output']>;
  cdartsamenstel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Artsamcomponenten` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtsamcomponentenCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartsamenstel` field. */
  cdartsamenstel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Artsamcomponenten` object types. All fields are combined with a logical ‘and.’ */
export type ArtsamcomponentenFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtsamcomponentenFilter>>;
  /** Filter by the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartsamenstel` field. */
  cdartsamenstel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtsamcomponentenFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtsamcomponentenFilter>>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
};

export type ArtsamcomponentenMv = {
  __typename?: 'ArtsamcomponentenMv';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  cdartcomponent?: Maybe<Scalars['String']['output']>;
  cdartsamenstel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ArtsamcomponentenMv` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ArtsamcomponentenMvCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartsamenstel` field. */
  cdartsamenstel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtsamcomponentenMv` object types. All fields are combined with a logical ‘and.’ */
export type ArtsamcomponentenMvFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtsamcomponentenMvFilter>>;
  /** Filter by the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartsamenstel` field. */
  cdartsamenstel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtsamcomponentenMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtsamcomponentenMvFilter>>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ArtsamcomponentenMv` values. */
export type ArtsamcomponentenMvsConnection = {
  __typename?: 'ArtsamcomponentenMvsConnection';
  /** A list of edges which contains the `ArtsamcomponentenMv` and cursor to aid in pagination. */
  edges: Array<ArtsamcomponentenMvsEdge>;
  /** A list of `ArtsamcomponentenMv` objects. */
  nodes: Array<ArtsamcomponentenMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtsamcomponentenMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtsamcomponentenMv` edge in the connection. */
export type ArtsamcomponentenMvsEdge = {
  __typename?: 'ArtsamcomponentenMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtsamcomponentenMv` at the end of the edge. */
  node: ArtsamcomponentenMv;
};

/** Methods to use when ordering `ArtsamcomponentenMv`. */
export enum ArtsamcomponentenMvsOrderBy {
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  CdartcomponentAsc = 'CDARTCOMPONENT_ASC',
  CdartcomponentDesc = 'CDARTCOMPONENT_DESC',
  CdartsamenstelAsc = 'CDARTSAMENSTEL_ASC',
  CdartsamenstelDesc = 'CDARTSAMENSTEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  Natural = 'NATURAL',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC'
}

/** A connection to a list of `Artsamcomponenten` values. */
export type ArtsamcomponentensConnection = {
  __typename?: 'ArtsamcomponentensConnection';
  /** A list of edges which contains the `Artsamcomponenten` and cursor to aid in pagination. */
  edges: Array<ArtsamcomponentensEdge>;
  /** A list of `Artsamcomponenten` objects. */
  nodes: Array<Artsamcomponenten>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Artsamcomponenten` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Artsamcomponenten` edge in the connection. */
export type ArtsamcomponentensEdge = {
  __typename?: 'ArtsamcomponentensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Artsamcomponenten` at the end of the edge. */
  node: Artsamcomponenten;
};

/** Methods to use when ordering `Artsamcomponenten`. */
export enum ArtsamcomponentensOrderBy {
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  CdartcomponentAsc = 'CDARTCOMPONENT_ASC',
  CdartcomponentDesc = 'CDARTCOMPONENT_DESC',
  CdartsamenstelAsc = 'CDARTSAMENSTEL_ASC',
  CdartsamenstelDesc = 'CDARTSAMENSTEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  Natural = 'NATURAL',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC'
}

export type Artsamenstelling = {
  __typename?: 'Artsamenstelling';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  commentaar?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  prijsincl?: Maybe<Scalars['BigFloat']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Artsamenstelling` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtsamenstellingCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `commentaar` field. */
  commentaar?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Artsamenstelling` object types. All fields are combined with a logical ‘and.’ */
export type ArtsamenstellingFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtsamenstellingFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `commentaar` field. */
  commentaar?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtsamenstellingFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtsamenstellingFilter>>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
};

export type ArtsamenstellingMv = {
  __typename?: 'ArtsamenstellingMv';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  commentaar?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  prijsincl?: Maybe<Scalars['BigFloat']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ArtsamenstellingMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ArtsamenstellingMvCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `commentaar` field. */
  commentaar?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ArtsamenstellingMv` object types. All fields are combined with a logical ‘and.’ */
export type ArtsamenstellingMvFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ArtsamenstellingMvFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `commentaar` field. */
  commentaar?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ArtsamenstellingMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ArtsamenstellingMvFilter>>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsincl` field. */
  prijsincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ArtsamenstellingMv` values. */
export type ArtsamenstellingMvsConnection = {
  __typename?: 'ArtsamenstellingMvsConnection';
  /** A list of edges which contains the `ArtsamenstellingMv` and cursor to aid in pagination. */
  edges: Array<ArtsamenstellingMvsEdge>;
  /** A list of `ArtsamenstellingMv` objects. */
  nodes: Array<ArtsamenstellingMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ArtsamenstellingMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ArtsamenstellingMv` edge in the connection. */
export type ArtsamenstellingMvsEdge = {
  __typename?: 'ArtsamenstellingMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ArtsamenstellingMv` at the end of the edge. */
  node: ArtsamenstellingMv;
};

/** Methods to use when ordering `ArtsamenstellingMv`. */
export enum ArtsamenstellingMvsOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CommentaarAsc = 'COMMENTAAR_ASC',
  CommentaarDesc = 'COMMENTAAR_DESC',
  Natural = 'NATURAL',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  PrijsinclAsc = 'PRIJSINCL_ASC',
  PrijsinclDesc = 'PRIJSINCL_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC'
}

/** A connection to a list of `Artsamenstelling` values. */
export type ArtsamenstellingsConnection = {
  __typename?: 'ArtsamenstellingsConnection';
  /** A list of edges which contains the `Artsamenstelling` and cursor to aid in pagination. */
  edges: Array<ArtsamenstellingsEdge>;
  /** A list of `Artsamenstelling` objects. */
  nodes: Array<Artsamenstelling>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Artsamenstelling` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Artsamenstelling` edge in the connection. */
export type ArtsamenstellingsEdge = {
  __typename?: 'ArtsamenstellingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Artsamenstelling` at the end of the edge. */
  node: Artsamenstelling;
};

/** Methods to use when ordering `Artsamenstelling`. */
export enum ArtsamenstellingsOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CommentaarAsc = 'COMMENTAAR_ASC',
  CommentaarDesc = 'COMMENTAAR_DESC',
  Natural = 'NATURAL',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  PrijsinclAsc = 'PRIJSINCL_ASC',
  PrijsinclDesc = 'PRIJSINCL_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC'
}

export type AspNetRole = Node & {
  __typename?: 'AspNetRole';
  /** Reads and enables pagination through a set of `AspNetRoleClaim`. */
  aspNetRoleClaimsByRoleId: AspNetRoleClaimsConnection;
  /** Reads and enables pagination through a set of `AspNetUserRole`. */
  aspNetUserRolesByRoleId: AspNetUserRolesConnection;
  concurrencyStamp?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  normalizedName?: Maybe<Scalars['String']['output']>;
};


export type AspNetRoleAspNetRoleClaimsByRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetRoleClaimCondition>;
  filter?: InputMaybe<AspNetRoleClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetRoleClaimsOrderBy>>;
};


export type AspNetRoleAspNetUserRolesByRoleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserRoleCondition>;
  filter?: InputMaybe<AspNetUserRoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserRolesOrderBy>>;
};

export type AspNetRoleClaim = Node & {
  __typename?: 'AspNetRoleClaim';
  /** Reads a single `AspNetRole` that is related to this `AspNetRoleClaim`. */
  aspNetRoleByRoleId?: Maybe<AspNetRole>;
  claimType?: Maybe<Scalars['String']['output']>;
  claimValue?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  roleId: Scalars['String']['output'];
};

/**
 * A condition to be used against `AspNetRoleClaim` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AspNetRoleClaimCondition = {
  /** Checks for equality with the object’s `claimType` field. */
  claimType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `claimValue` field. */
  claimValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AspNetRoleClaim` object types. All fields are combined with a logical ‘and.’ */
export type AspNetRoleClaimFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AspNetRoleClaimFilter>>;
  /** Filter by the object’s `aspNetRoleByRoleId` relation. */
  aspNetRoleByRoleId?: InputMaybe<AspNetRoleFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimValue` field. */
  claimValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AspNetRoleClaimFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AspNetRoleClaimFilter>>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `AspNetRoleClaim` */
export type AspNetRoleClaimInput = {
  claimType?: InputMaybe<Scalars['String']['input']>;
  claimValue?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  roleId: Scalars['String']['input'];
};

/** Represents an update to a `AspNetRoleClaim`. Fields that are set will be updated. */
export type AspNetRoleClaimPatch = {
  claimType?: InputMaybe<Scalars['String']['input']>;
  claimValue?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  roleId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AspNetRoleClaim` values. */
export type AspNetRoleClaimsConnection = {
  __typename?: 'AspNetRoleClaimsConnection';
  /** A list of edges which contains the `AspNetRoleClaim` and cursor to aid in pagination. */
  edges: Array<AspNetRoleClaimsEdge>;
  /** A list of `AspNetRoleClaim` objects. */
  nodes: Array<AspNetRoleClaim>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AspNetRoleClaim` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AspNetRoleClaim` edge in the connection. */
export type AspNetRoleClaimsEdge = {
  __typename?: 'AspNetRoleClaimsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AspNetRoleClaim` at the end of the edge. */
  node: AspNetRoleClaim;
};

/** Methods to use when ordering `AspNetRoleClaim`. */
export enum AspNetRoleClaimsOrderBy {
  AspNetRoleByRoleIdConcurrencyStampAsc = 'ASP_NET_ROLE_BY_ROLE_ID__CONCURRENCY_STAMP_ASC',
  AspNetRoleByRoleIdConcurrencyStampDesc = 'ASP_NET_ROLE_BY_ROLE_ID__CONCURRENCY_STAMP_DESC',
  AspNetRoleByRoleIdIdAsc = 'ASP_NET_ROLE_BY_ROLE_ID__ID_ASC',
  AspNetRoleByRoleIdIdDesc = 'ASP_NET_ROLE_BY_ROLE_ID__ID_DESC',
  AspNetRoleByRoleIdNameAsc = 'ASP_NET_ROLE_BY_ROLE_ID__NAME_ASC',
  AspNetRoleByRoleIdNameDesc = 'ASP_NET_ROLE_BY_ROLE_ID__NAME_DESC',
  AspNetRoleByRoleIdNormalizedNameAsc = 'ASP_NET_ROLE_BY_ROLE_ID__NORMALIZED_NAME_ASC',
  AspNetRoleByRoleIdNormalizedNameDesc = 'ASP_NET_ROLE_BY_ROLE_ID__NORMALIZED_NAME_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  ClaimValueAsc = 'CLAIM_VALUE_ASC',
  ClaimValueDesc = 'CLAIM_VALUE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC'
}

/**
 * A condition to be used against `AspNetRole` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AspNetRoleCondition = {
  /** Checks for equality with the object’s `concurrencyStamp` field. */
  concurrencyStamp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `normalizedName` field. */
  normalizedName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AspNetRole` object types. All fields are combined with a logical ‘and.’ */
export type AspNetRoleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AspNetRoleFilter>>;
  /** Filter by the object’s `aspNetRoleClaimsByRoleId` relation. */
  aspNetRoleClaimsByRoleId?: InputMaybe<AspNetRoleToManyAspNetRoleClaimFilter>;
  /** Some related `aspNetRoleClaimsByRoleId` exist. */
  aspNetRoleClaimsByRoleIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `aspNetUserRolesByRoleId` relation. */
  aspNetUserRolesByRoleId?: InputMaybe<AspNetRoleToManyAspNetUserRoleFilter>;
  /** Some related `aspNetUserRolesByRoleId` exist. */
  aspNetUserRolesByRoleIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `concurrencyStamp` field. */
  concurrencyStamp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Filter by the object’s `normalizedName` field. */
  normalizedName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AspNetRoleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AspNetRoleFilter>>;
};

/** An input for mutations affecting `AspNetRole` */
export type AspNetRoleInput = {
  concurrencyStamp?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  normalizedName?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `AspNetRole`. Fields that are set will be updated. */
export type AspNetRolePatch = {
  concurrencyStamp?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  normalizedName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `AspNetRoleClaim` object types. All fields are combined with a logical ‘and.’ */
export type AspNetRoleToManyAspNetRoleClaimFilter = {
  /** Every related `AspNetRoleClaim` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AspNetRoleClaimFilter>;
  /** No related `AspNetRoleClaim` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AspNetRoleClaimFilter>;
  /** Some related `AspNetRoleClaim` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AspNetRoleClaimFilter>;
};

/** A filter to be used against many `AspNetUserRole` object types. All fields are combined with a logical ‘and.’ */
export type AspNetRoleToManyAspNetUserRoleFilter = {
  /** Every related `AspNetUserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AspNetUserRoleFilter>;
  /** No related `AspNetUserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AspNetUserRoleFilter>;
  /** Some related `AspNetUserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AspNetUserRoleFilter>;
};

/** A connection to a list of `AspNetRole` values. */
export type AspNetRolesConnection = {
  __typename?: 'AspNetRolesConnection';
  /** A list of edges which contains the `AspNetRole` and cursor to aid in pagination. */
  edges: Array<AspNetRolesEdge>;
  /** A list of `AspNetRole` objects. */
  nodes: Array<AspNetRole>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AspNetRole` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AspNetRole` edge in the connection. */
export type AspNetRolesEdge = {
  __typename?: 'AspNetRolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AspNetRole` at the end of the edge. */
  node: AspNetRole;
};

/** Methods to use when ordering `AspNetRole`. */
export enum AspNetRolesOrderBy {
  AspNetRoleClaimsByRoleIdCountAsc = 'ASP_NET_ROLE_CLAIMS_BY_ROLE_ID__COUNT_ASC',
  AspNetRoleClaimsByRoleIdCountDesc = 'ASP_NET_ROLE_CLAIMS_BY_ROLE_ID__COUNT_DESC',
  AspNetUserRolesByRoleIdCountAsc = 'ASP_NET_USER_ROLES_BY_ROLE_ID__COUNT_ASC',
  AspNetUserRolesByRoleIdCountDesc = 'ASP_NET_USER_ROLES_BY_ROLE_ID__COUNT_DESC',
  ConcurrencyStampAsc = 'CONCURRENCY_STAMP_ASC',
  ConcurrencyStampDesc = 'CONCURRENCY_STAMP_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  NormalizedNameAsc = 'NORMALIZED_NAME_ASC',
  NormalizedNameDesc = 'NORMALIZED_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type AspNetUser = Node & {
  __typename?: 'AspNetUser';
  accessFailedCount: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `AspNetUserClaim`. */
  aspNetUserClaimsByUserId: AspNetUserClaimsConnection;
  /** Reads and enables pagination through a set of `AspNetUserLogin`. */
  aspNetUserLoginsByUserId: AspNetUserLoginsConnection;
  /** Reads and enables pagination through a set of `AspNetUserRole`. */
  aspNetUserRolesByAppUserId: AspNetUserRolesConnection;
  /** Reads and enables pagination through a set of `AspNetUserRole`. */
  aspNetUserRolesByUserId: AspNetUserRolesConnection;
  /** Reads and enables pagination through a set of `AspNetUserToken`. */
  aspNetUserTokensByUserId: AspNetUserTokensConnection;
  concurrencyStamp?: Maybe<Scalars['String']['output']>;
  displayName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  emailConfirmed: Scalars['Boolean']['output'];
  id: Scalars['String']['output'];
  lockoutEnabled: Scalars['Boolean']['output'];
  lockoutEnd?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  normalizedEmail?: Maybe<Scalars['String']['output']>;
  normalizedUserName?: Maybe<Scalars['String']['output']>;
  passwordHash?: Maybe<Scalars['String']['output']>;
  phoneNumber?: Maybe<Scalars['String']['output']>;
  phoneNumberConfirmed: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `RefreshToken`. */
  refreshTokensByAppUserId: RefreshTokensConnection;
  securityStamp?: Maybe<Scalars['String']['output']>;
  twoFactorEnabled: Scalars['Boolean']['output'];
  userName?: Maybe<Scalars['String']['output']>;
};


export type AspNetUserAspNetUserClaimsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserClaimCondition>;
  filter?: InputMaybe<AspNetUserClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserClaimsOrderBy>>;
};


export type AspNetUserAspNetUserLoginsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserLoginCondition>;
  filter?: InputMaybe<AspNetUserLoginFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserLoginsOrderBy>>;
};


export type AspNetUserAspNetUserRolesByAppUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserRoleCondition>;
  filter?: InputMaybe<AspNetUserRoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserRolesOrderBy>>;
};


export type AspNetUserAspNetUserRolesByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserRoleCondition>;
  filter?: InputMaybe<AspNetUserRoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserRolesOrderBy>>;
};


export type AspNetUserAspNetUserTokensByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserTokenCondition>;
  filter?: InputMaybe<AspNetUserTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserTokensOrderBy>>;
};


export type AspNetUserRefreshTokensByAppUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RefreshTokenCondition>;
  filter?: InputMaybe<RefreshTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RefreshTokensOrderBy>>;
};

export type AspNetUserClaim = Node & {
  __typename?: 'AspNetUserClaim';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserClaim`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  claimType?: Maybe<Scalars['String']['output']>;
  claimValue?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  userId: Scalars['String']['output'];
};

/**
 * A condition to be used against `AspNetUserClaim` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AspNetUserClaimCondition = {
  /** Checks for equality with the object’s `claimType` field. */
  claimType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `claimValue` field. */
  claimValue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AspNetUserClaim` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserClaimFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AspNetUserClaimFilter>>;
  /** Filter by the object’s `aspNetUserByUserId` relation. */
  aspNetUserByUserId?: InputMaybe<AspNetUserFilter>;
  /** Filter by the object’s `claimType` field. */
  claimType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `claimValue` field. */
  claimValue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AspNetUserClaimFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AspNetUserClaimFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `AspNetUserClaim` */
export type AspNetUserClaimInput = {
  claimType?: InputMaybe<Scalars['String']['input']>;
  claimValue?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId: Scalars['String']['input'];
};

/** Represents an update to a `AspNetUserClaim`. Fields that are set will be updated. */
export type AspNetUserClaimPatch = {
  claimType?: InputMaybe<Scalars['String']['input']>;
  claimValue?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AspNetUserClaim` values. */
export type AspNetUserClaimsConnection = {
  __typename?: 'AspNetUserClaimsConnection';
  /** A list of edges which contains the `AspNetUserClaim` and cursor to aid in pagination. */
  edges: Array<AspNetUserClaimsEdge>;
  /** A list of `AspNetUserClaim` objects. */
  nodes: Array<AspNetUserClaim>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AspNetUserClaim` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AspNetUserClaim` edge in the connection. */
export type AspNetUserClaimsEdge = {
  __typename?: 'AspNetUserClaimsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AspNetUserClaim` at the end of the edge. */
  node: AspNetUserClaim;
};

/** Methods to use when ordering `AspNetUserClaim`. */
export enum AspNetUserClaimsOrderBy {
  AspNetUserByUserIdAccessFailedCountAsc = 'ASP_NET_USER_BY_USER_ID__ACCESS_FAILED_COUNT_ASC',
  AspNetUserByUserIdAccessFailedCountDesc = 'ASP_NET_USER_BY_USER_ID__ACCESS_FAILED_COUNT_DESC',
  AspNetUserByUserIdConcurrencyStampAsc = 'ASP_NET_USER_BY_USER_ID__CONCURRENCY_STAMP_ASC',
  AspNetUserByUserIdConcurrencyStampDesc = 'ASP_NET_USER_BY_USER_ID__CONCURRENCY_STAMP_DESC',
  AspNetUserByUserIdDisplayNameAsc = 'ASP_NET_USER_BY_USER_ID__DISPLAY_NAME_ASC',
  AspNetUserByUserIdDisplayNameDesc = 'ASP_NET_USER_BY_USER_ID__DISPLAY_NAME_DESC',
  AspNetUserByUserIdEmailAsc = 'ASP_NET_USER_BY_USER_ID__EMAIL_ASC',
  AspNetUserByUserIdEmailConfirmedAsc = 'ASP_NET_USER_BY_USER_ID__EMAIL_CONFIRMED_ASC',
  AspNetUserByUserIdEmailConfirmedDesc = 'ASP_NET_USER_BY_USER_ID__EMAIL_CONFIRMED_DESC',
  AspNetUserByUserIdEmailDesc = 'ASP_NET_USER_BY_USER_ID__EMAIL_DESC',
  AspNetUserByUserIdIdAsc = 'ASP_NET_USER_BY_USER_ID__ID_ASC',
  AspNetUserByUserIdIdDesc = 'ASP_NET_USER_BY_USER_ID__ID_DESC',
  AspNetUserByUserIdLockoutEnabledAsc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_ENABLED_ASC',
  AspNetUserByUserIdLockoutEnabledDesc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_ENABLED_DESC',
  AspNetUserByUserIdLockoutEndAsc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_END_ASC',
  AspNetUserByUserIdLockoutEndDesc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_END_DESC',
  AspNetUserByUserIdNormalizedEmailAsc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_EMAIL_ASC',
  AspNetUserByUserIdNormalizedEmailDesc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_EMAIL_DESC',
  AspNetUserByUserIdNormalizedUserNameAsc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_USER_NAME_ASC',
  AspNetUserByUserIdNormalizedUserNameDesc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_USER_NAME_DESC',
  AspNetUserByUserIdPasswordHashAsc = 'ASP_NET_USER_BY_USER_ID__PASSWORD_HASH_ASC',
  AspNetUserByUserIdPasswordHashDesc = 'ASP_NET_USER_BY_USER_ID__PASSWORD_HASH_DESC',
  AspNetUserByUserIdPhoneNumberAsc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_ASC',
  AspNetUserByUserIdPhoneNumberConfirmedAsc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_CONFIRMED_ASC',
  AspNetUserByUserIdPhoneNumberConfirmedDesc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_CONFIRMED_DESC',
  AspNetUserByUserIdPhoneNumberDesc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_DESC',
  AspNetUserByUserIdSecurityStampAsc = 'ASP_NET_USER_BY_USER_ID__SECURITY_STAMP_ASC',
  AspNetUserByUserIdSecurityStampDesc = 'ASP_NET_USER_BY_USER_ID__SECURITY_STAMP_DESC',
  AspNetUserByUserIdTwoFactorEnabledAsc = 'ASP_NET_USER_BY_USER_ID__TWO_FACTOR_ENABLED_ASC',
  AspNetUserByUserIdTwoFactorEnabledDesc = 'ASP_NET_USER_BY_USER_ID__TWO_FACTOR_ENABLED_DESC',
  AspNetUserByUserIdUserNameAsc = 'ASP_NET_USER_BY_USER_ID__USER_NAME_ASC',
  AspNetUserByUserIdUserNameDesc = 'ASP_NET_USER_BY_USER_ID__USER_NAME_DESC',
  ClaimTypeAsc = 'CLAIM_TYPE_ASC',
  ClaimTypeDesc = 'CLAIM_TYPE_DESC',
  ClaimValueAsc = 'CLAIM_VALUE_ASC',
  ClaimValueDesc = 'CLAIM_VALUE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/**
 * A condition to be used against `AspNetUser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AspNetUserCondition = {
  /** Checks for equality with the object’s `accessFailedCount` field. */
  accessFailedCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `concurrencyStamp` field. */
  concurrencyStamp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `displayName` field. */
  displayName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `emailConfirmed` field. */
  emailConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lockoutEnabled` field. */
  lockoutEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `lockoutEnd` field. */
  lockoutEnd?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `normalizedEmail` field. */
  normalizedEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `normalizedUserName` field. */
  normalizedUserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phoneNumber` field. */
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phoneNumberConfirmed` field. */
  phoneNumberConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `securityStamp` field. */
  securityStamp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `twoFactorEnabled` field. */
  twoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `userName` field. */
  userName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AspNetUser` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserFilter = {
  /** Filter by the object’s `accessFailedCount` field. */
  accessFailedCount?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AspNetUserFilter>>;
  /** Filter by the object’s `aspNetUserClaimsByUserId` relation. */
  aspNetUserClaimsByUserId?: InputMaybe<AspNetUserToManyAspNetUserClaimFilter>;
  /** Some related `aspNetUserClaimsByUserId` exist. */
  aspNetUserClaimsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `aspNetUserLoginsByUserId` relation. */
  aspNetUserLoginsByUserId?: InputMaybe<AspNetUserToManyAspNetUserLoginFilter>;
  /** Some related `aspNetUserLoginsByUserId` exist. */
  aspNetUserLoginsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `aspNetUserRolesByAppUserId` relation. */
  aspNetUserRolesByAppUserId?: InputMaybe<AspNetUserToManyAspNetUserRoleFilter>;
  /** Some related `aspNetUserRolesByAppUserId` exist. */
  aspNetUserRolesByAppUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `aspNetUserRolesByUserId` relation. */
  aspNetUserRolesByUserId?: InputMaybe<AspNetUserToManyAspNetUserRoleFilter>;
  /** Some related `aspNetUserRolesByUserId` exist. */
  aspNetUserRolesByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `aspNetUserTokensByUserId` relation. */
  aspNetUserTokensByUserId?: InputMaybe<AspNetUserToManyAspNetUserTokenFilter>;
  /** Some related `aspNetUserTokensByUserId` exist. */
  aspNetUserTokensByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `concurrencyStamp` field. */
  concurrencyStamp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `displayName` field. */
  displayName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emailConfirmed` field. */
  emailConfirmed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lockoutEnabled` field. */
  lockoutEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lockoutEnd` field. */
  lockoutEnd?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `normalizedEmail` field. */
  normalizedEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `normalizedUserName` field. */
  normalizedUserName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AspNetUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AspNetUserFilter>>;
  /** Filter by the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `phoneNumber` field. */
  phoneNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `phoneNumberConfirmed` field. */
  phoneNumberConfirmed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `refreshTokensByAppUserId` relation. */
  refreshTokensByAppUserId?: InputMaybe<AspNetUserToManyRefreshTokenFilter>;
  /** Some related `refreshTokensByAppUserId` exist. */
  refreshTokensByAppUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `securityStamp` field. */
  securityStamp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `twoFactorEnabled` field. */
  twoFactorEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `userName` field. */
  userName?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `AspNetUser` */
export type AspNetUserInput = {
  accessFailedCount: Scalars['Int']['input'];
  concurrencyStamp?: InputMaybe<Scalars['String']['input']>;
  displayName: Scalars['String']['input'];
  email?: InputMaybe<Scalars['String']['input']>;
  emailConfirmed: Scalars['Boolean']['input'];
  id: Scalars['String']['input'];
  lockoutEnabled: Scalars['Boolean']['input'];
  lockoutEnd?: InputMaybe<Scalars['Datetime']['input']>;
  normalizedEmail?: InputMaybe<Scalars['String']['input']>;
  normalizedUserName?: InputMaybe<Scalars['String']['input']>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  phoneNumberConfirmed: Scalars['Boolean']['input'];
  securityStamp?: InputMaybe<Scalars['String']['input']>;
  twoFactorEnabled: Scalars['Boolean']['input'];
  userName?: InputMaybe<Scalars['String']['input']>;
};

export type AspNetUserLogin = Node & {
  __typename?: 'AspNetUserLogin';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserLogin`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  loginProvider: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  providerDisplayName?: Maybe<Scalars['String']['output']>;
  providerKey: Scalars['String']['output'];
  userId: Scalars['String']['output'];
};

/**
 * A condition to be used against `AspNetUserLogin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AspNetUserLoginCondition = {
  /** Checks for equality with the object’s `loginProvider` field. */
  loginProvider?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `providerDisplayName` field. */
  providerDisplayName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `providerKey` field. */
  providerKey?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AspNetUserLogin` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserLoginFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AspNetUserLoginFilter>>;
  /** Filter by the object’s `aspNetUserByUserId` relation. */
  aspNetUserByUserId?: InputMaybe<AspNetUserFilter>;
  /** Filter by the object’s `loginProvider` field. */
  loginProvider?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AspNetUserLoginFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AspNetUserLoginFilter>>;
  /** Filter by the object’s `providerDisplayName` field. */
  providerDisplayName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `providerKey` field. */
  providerKey?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `AspNetUserLogin` */
export type AspNetUserLoginInput = {
  loginProvider: Scalars['String']['input'];
  providerDisplayName?: InputMaybe<Scalars['String']['input']>;
  providerKey: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};

/** Represents an update to a `AspNetUserLogin`. Fields that are set will be updated. */
export type AspNetUserLoginPatch = {
  loginProvider?: InputMaybe<Scalars['String']['input']>;
  providerDisplayName?: InputMaybe<Scalars['String']['input']>;
  providerKey?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AspNetUserLogin` values. */
export type AspNetUserLoginsConnection = {
  __typename?: 'AspNetUserLoginsConnection';
  /** A list of edges which contains the `AspNetUserLogin` and cursor to aid in pagination. */
  edges: Array<AspNetUserLoginsEdge>;
  /** A list of `AspNetUserLogin` objects. */
  nodes: Array<AspNetUserLogin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AspNetUserLogin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AspNetUserLogin` edge in the connection. */
export type AspNetUserLoginsEdge = {
  __typename?: 'AspNetUserLoginsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AspNetUserLogin` at the end of the edge. */
  node: AspNetUserLogin;
};

/** Methods to use when ordering `AspNetUserLogin`. */
export enum AspNetUserLoginsOrderBy {
  AspNetUserByUserIdAccessFailedCountAsc = 'ASP_NET_USER_BY_USER_ID__ACCESS_FAILED_COUNT_ASC',
  AspNetUserByUserIdAccessFailedCountDesc = 'ASP_NET_USER_BY_USER_ID__ACCESS_FAILED_COUNT_DESC',
  AspNetUserByUserIdConcurrencyStampAsc = 'ASP_NET_USER_BY_USER_ID__CONCURRENCY_STAMP_ASC',
  AspNetUserByUserIdConcurrencyStampDesc = 'ASP_NET_USER_BY_USER_ID__CONCURRENCY_STAMP_DESC',
  AspNetUserByUserIdDisplayNameAsc = 'ASP_NET_USER_BY_USER_ID__DISPLAY_NAME_ASC',
  AspNetUserByUserIdDisplayNameDesc = 'ASP_NET_USER_BY_USER_ID__DISPLAY_NAME_DESC',
  AspNetUserByUserIdEmailAsc = 'ASP_NET_USER_BY_USER_ID__EMAIL_ASC',
  AspNetUserByUserIdEmailConfirmedAsc = 'ASP_NET_USER_BY_USER_ID__EMAIL_CONFIRMED_ASC',
  AspNetUserByUserIdEmailConfirmedDesc = 'ASP_NET_USER_BY_USER_ID__EMAIL_CONFIRMED_DESC',
  AspNetUserByUserIdEmailDesc = 'ASP_NET_USER_BY_USER_ID__EMAIL_DESC',
  AspNetUserByUserIdIdAsc = 'ASP_NET_USER_BY_USER_ID__ID_ASC',
  AspNetUserByUserIdIdDesc = 'ASP_NET_USER_BY_USER_ID__ID_DESC',
  AspNetUserByUserIdLockoutEnabledAsc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_ENABLED_ASC',
  AspNetUserByUserIdLockoutEnabledDesc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_ENABLED_DESC',
  AspNetUserByUserIdLockoutEndAsc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_END_ASC',
  AspNetUserByUserIdLockoutEndDesc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_END_DESC',
  AspNetUserByUserIdNormalizedEmailAsc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_EMAIL_ASC',
  AspNetUserByUserIdNormalizedEmailDesc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_EMAIL_DESC',
  AspNetUserByUserIdNormalizedUserNameAsc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_USER_NAME_ASC',
  AspNetUserByUserIdNormalizedUserNameDesc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_USER_NAME_DESC',
  AspNetUserByUserIdPasswordHashAsc = 'ASP_NET_USER_BY_USER_ID__PASSWORD_HASH_ASC',
  AspNetUserByUserIdPasswordHashDesc = 'ASP_NET_USER_BY_USER_ID__PASSWORD_HASH_DESC',
  AspNetUserByUserIdPhoneNumberAsc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_ASC',
  AspNetUserByUserIdPhoneNumberConfirmedAsc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_CONFIRMED_ASC',
  AspNetUserByUserIdPhoneNumberConfirmedDesc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_CONFIRMED_DESC',
  AspNetUserByUserIdPhoneNumberDesc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_DESC',
  AspNetUserByUserIdSecurityStampAsc = 'ASP_NET_USER_BY_USER_ID__SECURITY_STAMP_ASC',
  AspNetUserByUserIdSecurityStampDesc = 'ASP_NET_USER_BY_USER_ID__SECURITY_STAMP_DESC',
  AspNetUserByUserIdTwoFactorEnabledAsc = 'ASP_NET_USER_BY_USER_ID__TWO_FACTOR_ENABLED_ASC',
  AspNetUserByUserIdTwoFactorEnabledDesc = 'ASP_NET_USER_BY_USER_ID__TWO_FACTOR_ENABLED_DESC',
  AspNetUserByUserIdUserNameAsc = 'ASP_NET_USER_BY_USER_ID__USER_NAME_ASC',
  AspNetUserByUserIdUserNameDesc = 'ASP_NET_USER_BY_USER_ID__USER_NAME_DESC',
  LoginProviderAsc = 'LOGIN_PROVIDER_ASC',
  LoginProviderDesc = 'LOGIN_PROVIDER_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProviderDisplayNameAsc = 'PROVIDER_DISPLAY_NAME_ASC',
  ProviderDisplayNameDesc = 'PROVIDER_DISPLAY_NAME_DESC',
  ProviderKeyAsc = 'PROVIDER_KEY_ASC',
  ProviderKeyDesc = 'PROVIDER_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Represents an update to a `AspNetUser`. Fields that are set will be updated. */
export type AspNetUserPatch = {
  accessFailedCount?: InputMaybe<Scalars['Int']['input']>;
  concurrencyStamp?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  lockoutEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  lockoutEnd?: InputMaybe<Scalars['Datetime']['input']>;
  normalizedEmail?: InputMaybe<Scalars['String']['input']>;
  normalizedUserName?: InputMaybe<Scalars['String']['input']>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  phoneNumberConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  securityStamp?: InputMaybe<Scalars['String']['input']>;
  twoFactorEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  userName?: InputMaybe<Scalars['String']['input']>;
};

export type AspNetUserRole = Node & {
  __typename?: 'AspNetUserRole';
  appUserId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `AspNetRole` that is related to this `AspNetUserRole`. */
  aspNetRoleByRoleId?: Maybe<AspNetRole>;
  /** Reads a single `AspNetUser` that is related to this `AspNetUserRole`. */
  aspNetUserByAppUserId?: Maybe<AspNetUser>;
  /** Reads a single `AspNetUser` that is related to this `AspNetUserRole`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  roleId: Scalars['String']['output'];
  userId: Scalars['String']['output'];
};

/**
 * A condition to be used against `AspNetUserRole` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AspNetUserRoleCondition = {
  /** Checks for equality with the object’s `appUserId` field. */
  appUserId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `roleId` field. */
  roleId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AspNetUserRole` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserRoleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AspNetUserRoleFilter>>;
  /** Filter by the object’s `appUserId` field. */
  appUserId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `aspNetRoleByRoleId` relation. */
  aspNetRoleByRoleId?: InputMaybe<AspNetRoleFilter>;
  /** Filter by the object’s `aspNetUserByAppUserId` relation. */
  aspNetUserByAppUserId?: InputMaybe<AspNetUserFilter>;
  /** A related `aspNetUserByAppUserId` exists. */
  aspNetUserByAppUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `aspNetUserByUserId` relation. */
  aspNetUserByUserId?: InputMaybe<AspNetUserFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AspNetUserRoleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AspNetUserRoleFilter>>;
  /** Filter by the object’s `roleId` field. */
  roleId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `AspNetUserRole` */
export type AspNetUserRoleInput = {
  appUserId?: InputMaybe<Scalars['String']['input']>;
  roleId: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};

/** Represents an update to a `AspNetUserRole`. Fields that are set will be updated. */
export type AspNetUserRolePatch = {
  appUserId?: InputMaybe<Scalars['String']['input']>;
  roleId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AspNetUserRole` values. */
export type AspNetUserRolesConnection = {
  __typename?: 'AspNetUserRolesConnection';
  /** A list of edges which contains the `AspNetUserRole` and cursor to aid in pagination. */
  edges: Array<AspNetUserRolesEdge>;
  /** A list of `AspNetUserRole` objects. */
  nodes: Array<AspNetUserRole>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AspNetUserRole` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AspNetUserRole` edge in the connection. */
export type AspNetUserRolesEdge = {
  __typename?: 'AspNetUserRolesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AspNetUserRole` at the end of the edge. */
  node: AspNetUserRole;
};

/** Methods to use when ordering `AspNetUserRole`. */
export enum AspNetUserRolesOrderBy {
  AppUserIdAsc = 'APP_USER_ID_ASC',
  AppUserIdDesc = 'APP_USER_ID_DESC',
  AspNetRoleByRoleIdConcurrencyStampAsc = 'ASP_NET_ROLE_BY_ROLE_ID__CONCURRENCY_STAMP_ASC',
  AspNetRoleByRoleIdConcurrencyStampDesc = 'ASP_NET_ROLE_BY_ROLE_ID__CONCURRENCY_STAMP_DESC',
  AspNetRoleByRoleIdIdAsc = 'ASP_NET_ROLE_BY_ROLE_ID__ID_ASC',
  AspNetRoleByRoleIdIdDesc = 'ASP_NET_ROLE_BY_ROLE_ID__ID_DESC',
  AspNetRoleByRoleIdNameAsc = 'ASP_NET_ROLE_BY_ROLE_ID__NAME_ASC',
  AspNetRoleByRoleIdNameDesc = 'ASP_NET_ROLE_BY_ROLE_ID__NAME_DESC',
  AspNetRoleByRoleIdNormalizedNameAsc = 'ASP_NET_ROLE_BY_ROLE_ID__NORMALIZED_NAME_ASC',
  AspNetRoleByRoleIdNormalizedNameDesc = 'ASP_NET_ROLE_BY_ROLE_ID__NORMALIZED_NAME_DESC',
  AspNetUserByAppUserIdAccessFailedCountAsc = 'ASP_NET_USER_BY_APP_USER_ID__ACCESS_FAILED_COUNT_ASC',
  AspNetUserByAppUserIdAccessFailedCountDesc = 'ASP_NET_USER_BY_APP_USER_ID__ACCESS_FAILED_COUNT_DESC',
  AspNetUserByAppUserIdConcurrencyStampAsc = 'ASP_NET_USER_BY_APP_USER_ID__CONCURRENCY_STAMP_ASC',
  AspNetUserByAppUserIdConcurrencyStampDesc = 'ASP_NET_USER_BY_APP_USER_ID__CONCURRENCY_STAMP_DESC',
  AspNetUserByAppUserIdDisplayNameAsc = 'ASP_NET_USER_BY_APP_USER_ID__DISPLAY_NAME_ASC',
  AspNetUserByAppUserIdDisplayNameDesc = 'ASP_NET_USER_BY_APP_USER_ID__DISPLAY_NAME_DESC',
  AspNetUserByAppUserIdEmailAsc = 'ASP_NET_USER_BY_APP_USER_ID__EMAIL_ASC',
  AspNetUserByAppUserIdEmailConfirmedAsc = 'ASP_NET_USER_BY_APP_USER_ID__EMAIL_CONFIRMED_ASC',
  AspNetUserByAppUserIdEmailConfirmedDesc = 'ASP_NET_USER_BY_APP_USER_ID__EMAIL_CONFIRMED_DESC',
  AspNetUserByAppUserIdEmailDesc = 'ASP_NET_USER_BY_APP_USER_ID__EMAIL_DESC',
  AspNetUserByAppUserIdIdAsc = 'ASP_NET_USER_BY_APP_USER_ID__ID_ASC',
  AspNetUserByAppUserIdIdDesc = 'ASP_NET_USER_BY_APP_USER_ID__ID_DESC',
  AspNetUserByAppUserIdLockoutEnabledAsc = 'ASP_NET_USER_BY_APP_USER_ID__LOCKOUT_ENABLED_ASC',
  AspNetUserByAppUserIdLockoutEnabledDesc = 'ASP_NET_USER_BY_APP_USER_ID__LOCKOUT_ENABLED_DESC',
  AspNetUserByAppUserIdLockoutEndAsc = 'ASP_NET_USER_BY_APP_USER_ID__LOCKOUT_END_ASC',
  AspNetUserByAppUserIdLockoutEndDesc = 'ASP_NET_USER_BY_APP_USER_ID__LOCKOUT_END_DESC',
  AspNetUserByAppUserIdNormalizedEmailAsc = 'ASP_NET_USER_BY_APP_USER_ID__NORMALIZED_EMAIL_ASC',
  AspNetUserByAppUserIdNormalizedEmailDesc = 'ASP_NET_USER_BY_APP_USER_ID__NORMALIZED_EMAIL_DESC',
  AspNetUserByAppUserIdNormalizedUserNameAsc = 'ASP_NET_USER_BY_APP_USER_ID__NORMALIZED_USER_NAME_ASC',
  AspNetUserByAppUserIdNormalizedUserNameDesc = 'ASP_NET_USER_BY_APP_USER_ID__NORMALIZED_USER_NAME_DESC',
  AspNetUserByAppUserIdPasswordHashAsc = 'ASP_NET_USER_BY_APP_USER_ID__PASSWORD_HASH_ASC',
  AspNetUserByAppUserIdPasswordHashDesc = 'ASP_NET_USER_BY_APP_USER_ID__PASSWORD_HASH_DESC',
  AspNetUserByAppUserIdPhoneNumberAsc = 'ASP_NET_USER_BY_APP_USER_ID__PHONE_NUMBER_ASC',
  AspNetUserByAppUserIdPhoneNumberConfirmedAsc = 'ASP_NET_USER_BY_APP_USER_ID__PHONE_NUMBER_CONFIRMED_ASC',
  AspNetUserByAppUserIdPhoneNumberConfirmedDesc = 'ASP_NET_USER_BY_APP_USER_ID__PHONE_NUMBER_CONFIRMED_DESC',
  AspNetUserByAppUserIdPhoneNumberDesc = 'ASP_NET_USER_BY_APP_USER_ID__PHONE_NUMBER_DESC',
  AspNetUserByAppUserIdSecurityStampAsc = 'ASP_NET_USER_BY_APP_USER_ID__SECURITY_STAMP_ASC',
  AspNetUserByAppUserIdSecurityStampDesc = 'ASP_NET_USER_BY_APP_USER_ID__SECURITY_STAMP_DESC',
  AspNetUserByAppUserIdTwoFactorEnabledAsc = 'ASP_NET_USER_BY_APP_USER_ID__TWO_FACTOR_ENABLED_ASC',
  AspNetUserByAppUserIdTwoFactorEnabledDesc = 'ASP_NET_USER_BY_APP_USER_ID__TWO_FACTOR_ENABLED_DESC',
  AspNetUserByAppUserIdUserNameAsc = 'ASP_NET_USER_BY_APP_USER_ID__USER_NAME_ASC',
  AspNetUserByAppUserIdUserNameDesc = 'ASP_NET_USER_BY_APP_USER_ID__USER_NAME_DESC',
  AspNetUserByUserIdAccessFailedCountAsc = 'ASP_NET_USER_BY_USER_ID__ACCESS_FAILED_COUNT_ASC',
  AspNetUserByUserIdAccessFailedCountDesc = 'ASP_NET_USER_BY_USER_ID__ACCESS_FAILED_COUNT_DESC',
  AspNetUserByUserIdConcurrencyStampAsc = 'ASP_NET_USER_BY_USER_ID__CONCURRENCY_STAMP_ASC',
  AspNetUserByUserIdConcurrencyStampDesc = 'ASP_NET_USER_BY_USER_ID__CONCURRENCY_STAMP_DESC',
  AspNetUserByUserIdDisplayNameAsc = 'ASP_NET_USER_BY_USER_ID__DISPLAY_NAME_ASC',
  AspNetUserByUserIdDisplayNameDesc = 'ASP_NET_USER_BY_USER_ID__DISPLAY_NAME_DESC',
  AspNetUserByUserIdEmailAsc = 'ASP_NET_USER_BY_USER_ID__EMAIL_ASC',
  AspNetUserByUserIdEmailConfirmedAsc = 'ASP_NET_USER_BY_USER_ID__EMAIL_CONFIRMED_ASC',
  AspNetUserByUserIdEmailConfirmedDesc = 'ASP_NET_USER_BY_USER_ID__EMAIL_CONFIRMED_DESC',
  AspNetUserByUserIdEmailDesc = 'ASP_NET_USER_BY_USER_ID__EMAIL_DESC',
  AspNetUserByUserIdIdAsc = 'ASP_NET_USER_BY_USER_ID__ID_ASC',
  AspNetUserByUserIdIdDesc = 'ASP_NET_USER_BY_USER_ID__ID_DESC',
  AspNetUserByUserIdLockoutEnabledAsc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_ENABLED_ASC',
  AspNetUserByUserIdLockoutEnabledDesc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_ENABLED_DESC',
  AspNetUserByUserIdLockoutEndAsc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_END_ASC',
  AspNetUserByUserIdLockoutEndDesc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_END_DESC',
  AspNetUserByUserIdNormalizedEmailAsc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_EMAIL_ASC',
  AspNetUserByUserIdNormalizedEmailDesc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_EMAIL_DESC',
  AspNetUserByUserIdNormalizedUserNameAsc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_USER_NAME_ASC',
  AspNetUserByUserIdNormalizedUserNameDesc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_USER_NAME_DESC',
  AspNetUserByUserIdPasswordHashAsc = 'ASP_NET_USER_BY_USER_ID__PASSWORD_HASH_ASC',
  AspNetUserByUserIdPasswordHashDesc = 'ASP_NET_USER_BY_USER_ID__PASSWORD_HASH_DESC',
  AspNetUserByUserIdPhoneNumberAsc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_ASC',
  AspNetUserByUserIdPhoneNumberConfirmedAsc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_CONFIRMED_ASC',
  AspNetUserByUserIdPhoneNumberConfirmedDesc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_CONFIRMED_DESC',
  AspNetUserByUserIdPhoneNumberDesc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_DESC',
  AspNetUserByUserIdSecurityStampAsc = 'ASP_NET_USER_BY_USER_ID__SECURITY_STAMP_ASC',
  AspNetUserByUserIdSecurityStampDesc = 'ASP_NET_USER_BY_USER_ID__SECURITY_STAMP_DESC',
  AspNetUserByUserIdTwoFactorEnabledAsc = 'ASP_NET_USER_BY_USER_ID__TWO_FACTOR_ENABLED_ASC',
  AspNetUserByUserIdTwoFactorEnabledDesc = 'ASP_NET_USER_BY_USER_ID__TWO_FACTOR_ENABLED_DESC',
  AspNetUserByUserIdUserNameAsc = 'ASP_NET_USER_BY_USER_ID__USER_NAME_ASC',
  AspNetUserByUserIdUserNameDesc = 'ASP_NET_USER_BY_USER_ID__USER_NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RoleIdAsc = 'ROLE_ID_ASC',
  RoleIdDesc = 'ROLE_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A filter to be used against many `AspNetUserClaim` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserToManyAspNetUserClaimFilter = {
  /** Every related `AspNetUserClaim` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AspNetUserClaimFilter>;
  /** No related `AspNetUserClaim` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AspNetUserClaimFilter>;
  /** Some related `AspNetUserClaim` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AspNetUserClaimFilter>;
};

/** A filter to be used against many `AspNetUserLogin` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserToManyAspNetUserLoginFilter = {
  /** Every related `AspNetUserLogin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AspNetUserLoginFilter>;
  /** No related `AspNetUserLogin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AspNetUserLoginFilter>;
  /** Some related `AspNetUserLogin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AspNetUserLoginFilter>;
};

/** A filter to be used against many `AspNetUserRole` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserToManyAspNetUserRoleFilter = {
  /** Every related `AspNetUserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AspNetUserRoleFilter>;
  /** No related `AspNetUserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AspNetUserRoleFilter>;
  /** Some related `AspNetUserRole` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AspNetUserRoleFilter>;
};

/** A filter to be used against many `AspNetUserToken` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserToManyAspNetUserTokenFilter = {
  /** Every related `AspNetUserToken` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AspNetUserTokenFilter>;
  /** No related `AspNetUserToken` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AspNetUserTokenFilter>;
  /** Some related `AspNetUserToken` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AspNetUserTokenFilter>;
};

/** A filter to be used against many `RefreshToken` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserToManyRefreshTokenFilter = {
  /** Every related `RefreshToken` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RefreshTokenFilter>;
  /** No related `RefreshToken` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RefreshTokenFilter>;
  /** Some related `RefreshToken` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RefreshTokenFilter>;
};

export type AspNetUserToken = Node & {
  __typename?: 'AspNetUserToken';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserToken`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  loginProvider: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  userId: Scalars['String']['output'];
  value?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `AspNetUserToken` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AspNetUserTokenCondition = {
  /** Checks for equality with the object’s `loginProvider` field. */
  loginProvider?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AspNetUserToken` object types. All fields are combined with a logical ‘and.’ */
export type AspNetUserTokenFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AspNetUserTokenFilter>>;
  /** Filter by the object’s `aspNetUserByUserId` relation. */
  aspNetUserByUserId?: InputMaybe<AspNetUserFilter>;
  /** Filter by the object’s `loginProvider` field. */
  loginProvider?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AspNetUserTokenFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AspNetUserTokenFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `AspNetUserToken` */
export type AspNetUserTokenInput = {
  loginProvider: Scalars['String']['input'];
  name: Scalars['String']['input'];
  userId: Scalars['String']['input'];
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `AspNetUserToken`. Fields that are set will be updated. */
export type AspNetUserTokenPatch = {
  loginProvider?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AspNetUserToken` values. */
export type AspNetUserTokensConnection = {
  __typename?: 'AspNetUserTokensConnection';
  /** A list of edges which contains the `AspNetUserToken` and cursor to aid in pagination. */
  edges: Array<AspNetUserTokensEdge>;
  /** A list of `AspNetUserToken` objects. */
  nodes: Array<AspNetUserToken>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AspNetUserToken` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AspNetUserToken` edge in the connection. */
export type AspNetUserTokensEdge = {
  __typename?: 'AspNetUserTokensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AspNetUserToken` at the end of the edge. */
  node: AspNetUserToken;
};

/** Methods to use when ordering `AspNetUserToken`. */
export enum AspNetUserTokensOrderBy {
  AspNetUserByUserIdAccessFailedCountAsc = 'ASP_NET_USER_BY_USER_ID__ACCESS_FAILED_COUNT_ASC',
  AspNetUserByUserIdAccessFailedCountDesc = 'ASP_NET_USER_BY_USER_ID__ACCESS_FAILED_COUNT_DESC',
  AspNetUserByUserIdConcurrencyStampAsc = 'ASP_NET_USER_BY_USER_ID__CONCURRENCY_STAMP_ASC',
  AspNetUserByUserIdConcurrencyStampDesc = 'ASP_NET_USER_BY_USER_ID__CONCURRENCY_STAMP_DESC',
  AspNetUserByUserIdDisplayNameAsc = 'ASP_NET_USER_BY_USER_ID__DISPLAY_NAME_ASC',
  AspNetUserByUserIdDisplayNameDesc = 'ASP_NET_USER_BY_USER_ID__DISPLAY_NAME_DESC',
  AspNetUserByUserIdEmailAsc = 'ASP_NET_USER_BY_USER_ID__EMAIL_ASC',
  AspNetUserByUserIdEmailConfirmedAsc = 'ASP_NET_USER_BY_USER_ID__EMAIL_CONFIRMED_ASC',
  AspNetUserByUserIdEmailConfirmedDesc = 'ASP_NET_USER_BY_USER_ID__EMAIL_CONFIRMED_DESC',
  AspNetUserByUserIdEmailDesc = 'ASP_NET_USER_BY_USER_ID__EMAIL_DESC',
  AspNetUserByUserIdIdAsc = 'ASP_NET_USER_BY_USER_ID__ID_ASC',
  AspNetUserByUserIdIdDesc = 'ASP_NET_USER_BY_USER_ID__ID_DESC',
  AspNetUserByUserIdLockoutEnabledAsc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_ENABLED_ASC',
  AspNetUserByUserIdLockoutEnabledDesc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_ENABLED_DESC',
  AspNetUserByUserIdLockoutEndAsc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_END_ASC',
  AspNetUserByUserIdLockoutEndDesc = 'ASP_NET_USER_BY_USER_ID__LOCKOUT_END_DESC',
  AspNetUserByUserIdNormalizedEmailAsc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_EMAIL_ASC',
  AspNetUserByUserIdNormalizedEmailDesc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_EMAIL_DESC',
  AspNetUserByUserIdNormalizedUserNameAsc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_USER_NAME_ASC',
  AspNetUserByUserIdNormalizedUserNameDesc = 'ASP_NET_USER_BY_USER_ID__NORMALIZED_USER_NAME_DESC',
  AspNetUserByUserIdPasswordHashAsc = 'ASP_NET_USER_BY_USER_ID__PASSWORD_HASH_ASC',
  AspNetUserByUserIdPasswordHashDesc = 'ASP_NET_USER_BY_USER_ID__PASSWORD_HASH_DESC',
  AspNetUserByUserIdPhoneNumberAsc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_ASC',
  AspNetUserByUserIdPhoneNumberConfirmedAsc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_CONFIRMED_ASC',
  AspNetUserByUserIdPhoneNumberConfirmedDesc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_CONFIRMED_DESC',
  AspNetUserByUserIdPhoneNumberDesc = 'ASP_NET_USER_BY_USER_ID__PHONE_NUMBER_DESC',
  AspNetUserByUserIdSecurityStampAsc = 'ASP_NET_USER_BY_USER_ID__SECURITY_STAMP_ASC',
  AspNetUserByUserIdSecurityStampDesc = 'ASP_NET_USER_BY_USER_ID__SECURITY_STAMP_DESC',
  AspNetUserByUserIdTwoFactorEnabledAsc = 'ASP_NET_USER_BY_USER_ID__TWO_FACTOR_ENABLED_ASC',
  AspNetUserByUserIdTwoFactorEnabledDesc = 'ASP_NET_USER_BY_USER_ID__TWO_FACTOR_ENABLED_DESC',
  AspNetUserByUserIdUserNameAsc = 'ASP_NET_USER_BY_USER_ID__USER_NAME_ASC',
  AspNetUserByUserIdUserNameDesc = 'ASP_NET_USER_BY_USER_ID__USER_NAME_DESC',
  LoginProviderAsc = 'LOGIN_PROVIDER_ASC',
  LoginProviderDesc = 'LOGIN_PROVIDER_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

/** A connection to a list of `AspNetUser` values. */
export type AspNetUsersConnection = {
  __typename?: 'AspNetUsersConnection';
  /** A list of edges which contains the `AspNetUser` and cursor to aid in pagination. */
  edges: Array<AspNetUsersEdge>;
  /** A list of `AspNetUser` objects. */
  nodes: Array<AspNetUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AspNetUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AspNetUser` edge in the connection. */
export type AspNetUsersEdge = {
  __typename?: 'AspNetUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AspNetUser` at the end of the edge. */
  node: AspNetUser;
};

/** Methods to use when ordering `AspNetUser`. */
export enum AspNetUsersOrderBy {
  AccessFailedCountAsc = 'ACCESS_FAILED_COUNT_ASC',
  AccessFailedCountDesc = 'ACCESS_FAILED_COUNT_DESC',
  AspNetUserClaimsByUserIdCountAsc = 'ASP_NET_USER_CLAIMS_BY_USER_ID__COUNT_ASC',
  AspNetUserClaimsByUserIdCountDesc = 'ASP_NET_USER_CLAIMS_BY_USER_ID__COUNT_DESC',
  AspNetUserLoginsByUserIdCountAsc = 'ASP_NET_USER_LOGINS_BY_USER_ID__COUNT_ASC',
  AspNetUserLoginsByUserIdCountDesc = 'ASP_NET_USER_LOGINS_BY_USER_ID__COUNT_DESC',
  AspNetUserRolesByAppUserIdCountAsc = 'ASP_NET_USER_ROLES_BY_APP_USER_ID__COUNT_ASC',
  AspNetUserRolesByAppUserIdCountDesc = 'ASP_NET_USER_ROLES_BY_APP_USER_ID__COUNT_DESC',
  AspNetUserRolesByUserIdCountAsc = 'ASP_NET_USER_ROLES_BY_USER_ID__COUNT_ASC',
  AspNetUserRolesByUserIdCountDesc = 'ASP_NET_USER_ROLES_BY_USER_ID__COUNT_DESC',
  AspNetUserTokensByUserIdCountAsc = 'ASP_NET_USER_TOKENS_BY_USER_ID__COUNT_ASC',
  AspNetUserTokensByUserIdCountDesc = 'ASP_NET_USER_TOKENS_BY_USER_ID__COUNT_DESC',
  ConcurrencyStampAsc = 'CONCURRENCY_STAMP_ASC',
  ConcurrencyStampDesc = 'CONCURRENCY_STAMP_DESC',
  DisplayNameAsc = 'DISPLAY_NAME_ASC',
  DisplayNameDesc = 'DISPLAY_NAME_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailConfirmedAsc = 'EMAIL_CONFIRMED_ASC',
  EmailConfirmedDesc = 'EMAIL_CONFIRMED_DESC',
  EmailDesc = 'EMAIL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LockoutEnabledAsc = 'LOCKOUT_ENABLED_ASC',
  LockoutEnabledDesc = 'LOCKOUT_ENABLED_DESC',
  LockoutEndAsc = 'LOCKOUT_END_ASC',
  LockoutEndDesc = 'LOCKOUT_END_DESC',
  Natural = 'NATURAL',
  NormalizedEmailAsc = 'NORMALIZED_EMAIL_ASC',
  NormalizedEmailDesc = 'NORMALIZED_EMAIL_DESC',
  NormalizedUserNameAsc = 'NORMALIZED_USER_NAME_ASC',
  NormalizedUserNameDesc = 'NORMALIZED_USER_NAME_DESC',
  PasswordHashAsc = 'PASSWORD_HASH_ASC',
  PasswordHashDesc = 'PASSWORD_HASH_DESC',
  PhoneNumberAsc = 'PHONE_NUMBER_ASC',
  PhoneNumberConfirmedAsc = 'PHONE_NUMBER_CONFIRMED_ASC',
  PhoneNumberConfirmedDesc = 'PHONE_NUMBER_CONFIRMED_DESC',
  PhoneNumberDesc = 'PHONE_NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RefreshTokensByAppUserIdCountAsc = 'REFRESH_TOKENS_BY_APP_USER_ID__COUNT_ASC',
  RefreshTokensByAppUserIdCountDesc = 'REFRESH_TOKENS_BY_APP_USER_ID__COUNT_DESC',
  SecurityStampAsc = 'SECURITY_STAMP_ASC',
  SecurityStampDesc = 'SECURITY_STAMP_DESC',
  TwoFactorEnabledAsc = 'TWO_FACTOR_ENABLED_ASC',
  TwoFactorEnabledDesc = 'TWO_FACTOR_ENABLED_DESC',
  UserNameAsc = 'USER_NAME_ASC',
  UserNameDesc = 'USER_NAME_DESC'
}

export type Assemblage = {
  __typename?: 'Assemblage';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  aantalGeassembleerd?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereservbij?: Maybe<Scalars['BigFloat']['output']>;
  afdrukAssemblageBon?: Maybe<Scalars['String']['output']>;
  assemblageDatum?: Maybe<Scalars['Date']['output']>;
  assemblageOrder?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  commentaar?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  orderDatum?: Maybe<Scalars['Date']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  waardeGeassembleerd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Assemblage` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AssemblageCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalGeassembleerd` field. */
  aantalGeassembleerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereservbij` field. */
  aantalgereservbij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `afdrukAssemblageBon` field. */
  afdrukAssemblageBon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `commentaar` field. */
  commentaar?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderDatum` field. */
  orderDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `waardeGeassembleerd` field. */
  waardeGeassembleerd?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `Assemblage` object types. All fields are combined with a logical ‘and.’ */
export type AssemblageFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalGeassembleerd` field. */
  aantalGeassembleerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereservbij` field. */
  aantalgereservbij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `afdrukAssemblageBon` field. */
  afdrukAssemblageBon?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblageFilter>>;
  /** Filter by the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `commentaar` field. */
  commentaar?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblageFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblageFilter>>;
  /** Filter by the object’s `orderDatum` field. */
  orderDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `waardeGeassembleerd` field. */
  waardeGeassembleerd?: InputMaybe<BigFloatFilter>;
};

export type AssemblageMv = {
  __typename?: 'AssemblageMv';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  aantalGeassembleerd?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereservbij?: Maybe<Scalars['BigFloat']['output']>;
  afdrukAssemblageBon?: Maybe<Scalars['String']['output']>;
  assemblageDatum?: Maybe<Scalars['Date']['output']>;
  assemblageOrder?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  commentaar?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  orderDatum?: Maybe<Scalars['Date']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  waardeGeassembleerd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `AssemblageMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AssemblageMvCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalGeassembleerd` field. */
  aantalGeassembleerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereservbij` field. */
  aantalgereservbij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `afdrukAssemblageBon` field. */
  afdrukAssemblageBon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `commentaar` field. */
  commentaar?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderDatum` field. */
  orderDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `waardeGeassembleerd` field. */
  waardeGeassembleerd?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `AssemblageMv` object types. All fields are combined with a logical ‘and.’ */
export type AssemblageMvFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalGeassembleerd` field. */
  aantalGeassembleerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereservbij` field. */
  aantalgereservbij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `afdrukAssemblageBon` field. */
  afdrukAssemblageBon?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblageMvFilter>>;
  /** Filter by the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `commentaar` field. */
  commentaar?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblageMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblageMvFilter>>;
  /** Filter by the object’s `orderDatum` field. */
  orderDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `waardeGeassembleerd` field. */
  waardeGeassembleerd?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `AssemblageMv` values. */
export type AssemblageMvsConnection = {
  __typename?: 'AssemblageMvsConnection';
  /** A list of edges which contains the `AssemblageMv` and cursor to aid in pagination. */
  edges: Array<AssemblageMvsEdge>;
  /** A list of `AssemblageMv` objects. */
  nodes: Array<AssemblageMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblageMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblageMv` edge in the connection. */
export type AssemblageMvsEdge = {
  __typename?: 'AssemblageMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblageMv` at the end of the edge. */
  node: AssemblageMv;
};

/** Methods to use when ordering `AssemblageMv`. */
export enum AssemblageMvsOrderBy {
  AantalgereservbijAsc = 'AANTALGERESERVBIJ_ASC',
  AantalgereservbijDesc = 'AANTALGERESERVBIJ_DESC',
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  AantalGeassembleerdAsc = 'AANTAL_GEASSEMBLEERD_ASC',
  AantalGeassembleerdDesc = 'AANTAL_GEASSEMBLEERD_DESC',
  AfdrukAssemblageBonAsc = 'AFDRUK_ASSEMBLAGE_BON_ASC',
  AfdrukAssemblageBonDesc = 'AFDRUK_ASSEMBLAGE_BON_DESC',
  AssemblageDatumAsc = 'ASSEMBLAGE_DATUM_ASC',
  AssemblageDatumDesc = 'ASSEMBLAGE_DATUM_DESC',
  AssemblageOrderAsc = 'ASSEMBLAGE_ORDER_ASC',
  AssemblageOrderDesc = 'ASSEMBLAGE_ORDER_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  CommentaarAsc = 'COMMENTAAR_ASC',
  CommentaarDesc = 'COMMENTAAR_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  Natural = 'NATURAL',
  OrderDatumAsc = 'ORDER_DATUM_ASC',
  OrderDatumDesc = 'ORDER_DATUM_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  WaardeGeassembleerdAsc = 'WAARDE_GEASSEMBLEERD_ASC',
  WaardeGeassembleerdDesc = 'WAARDE_GEASSEMBLEERD_DESC'
}

export type Assemblageregel = {
  __typename?: 'Assemblageregel';
  aantalGebruikt?: Maybe<Scalars['BigFloat']['output']>;
  aantalNorm?: Maybe<Scalars['BigFloat']['output']>;
  aantalSamenstelling?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereservaf?: Maybe<Scalars['BigFloat']['output']>;
  assemblageDatum?: Maybe<Scalars['Date']['output']>;
  assemblageOrder?: Maybe<Scalars['String']['output']>;
  cdartcomponent?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  waardeGebruikt?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Assemblageregel` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AssemblageregelCondition = {
  /** Checks for equality with the object’s `aantalGebruikt` field. */
  aantalGebruikt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalNorm` field. */
  aantalNorm?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalSamenstelling` field. */
  aantalSamenstelling?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereservaf` field. */
  aantalgereservaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `waardeGebruikt` field. */
  waardeGebruikt?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `Assemblageregel` object types. All fields are combined with a logical ‘and.’ */
export type AssemblageregelFilter = {
  /** Filter by the object’s `aantalGebruikt` field. */
  aantalGebruikt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalNorm` field. */
  aantalNorm?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalSamenstelling` field. */
  aantalSamenstelling?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereservaf` field. */
  aantalgereservaf?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblageregelFilter>>;
  /** Filter by the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblageregelFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblageregelFilter>>;
  /** Filter by the object’s `waardeGebruikt` field. */
  waardeGebruikt?: InputMaybe<BigFloatFilter>;
};

export type AssemblageregelMv = {
  __typename?: 'AssemblageregelMv';
  aantalGebruikt?: Maybe<Scalars['BigFloat']['output']>;
  aantalNorm?: Maybe<Scalars['BigFloat']['output']>;
  aantalSamenstelling?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereservaf?: Maybe<Scalars['BigFloat']['output']>;
  assemblageDatum?: Maybe<Scalars['Date']['output']>;
  assemblageOrder?: Maybe<Scalars['String']['output']>;
  cdartcomponent?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  waardeGebruikt?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `AssemblageregelMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AssemblageregelMvCondition = {
  /** Checks for equality with the object’s `aantalGebruikt` field. */
  aantalGebruikt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalNorm` field. */
  aantalNorm?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalSamenstelling` field. */
  aantalSamenstelling?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereservaf` field. */
  aantalgereservaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `waardeGebruikt` field. */
  waardeGebruikt?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `AssemblageregelMv` object types. All fields are combined with a logical ‘and.’ */
export type AssemblageregelMvFilter = {
  /** Filter by the object’s `aantalGebruikt` field. */
  aantalGebruikt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalNorm` field. */
  aantalNorm?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalSamenstelling` field. */
  aantalSamenstelling?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereservaf` field. */
  aantalgereservaf?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblageregelMvFilter>>;
  /** Filter by the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartcomponent` field. */
  cdartcomponent?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblageregelMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblageregelMvFilter>>;
  /** Filter by the object’s `waardeGebruikt` field. */
  waardeGebruikt?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `AssemblageregelMv` values. */
export type AssemblageregelMvsConnection = {
  __typename?: 'AssemblageregelMvsConnection';
  /** A list of edges which contains the `AssemblageregelMv` and cursor to aid in pagination. */
  edges: Array<AssemblageregelMvsEdge>;
  /** A list of `AssemblageregelMv` objects. */
  nodes: Array<AssemblageregelMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblageregelMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblageregelMv` edge in the connection. */
export type AssemblageregelMvsEdge = {
  __typename?: 'AssemblageregelMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblageregelMv` at the end of the edge. */
  node: AssemblageregelMv;
};

/** Methods to use when ordering `AssemblageregelMv`. */
export enum AssemblageregelMvsOrderBy {
  AantalgereservafAsc = 'AANTALGERESERVAF_ASC',
  AantalgereservafDesc = 'AANTALGERESERVAF_DESC',
  AantalGebruiktAsc = 'AANTAL_GEBRUIKT_ASC',
  AantalGebruiktDesc = 'AANTAL_GEBRUIKT_DESC',
  AantalNormAsc = 'AANTAL_NORM_ASC',
  AantalNormDesc = 'AANTAL_NORM_DESC',
  AantalSamenstellingAsc = 'AANTAL_SAMENSTELLING_ASC',
  AantalSamenstellingDesc = 'AANTAL_SAMENSTELLING_DESC',
  AssemblageDatumAsc = 'ASSEMBLAGE_DATUM_ASC',
  AssemblageDatumDesc = 'ASSEMBLAGE_DATUM_DESC',
  AssemblageOrderAsc = 'ASSEMBLAGE_ORDER_ASC',
  AssemblageOrderDesc = 'ASSEMBLAGE_ORDER_DESC',
  CdartcomponentAsc = 'CDARTCOMPONENT_ASC',
  CdartcomponentDesc = 'CDARTCOMPONENT_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  Natural = 'NATURAL',
  WaardeGebruiktAsc = 'WAARDE_GEBRUIKT_ASC',
  WaardeGebruiktDesc = 'WAARDE_GEBRUIKT_DESC'
}

/** A connection to a list of `Assemblageregel` values. */
export type AssemblageregelsConnection = {
  __typename?: 'AssemblageregelsConnection';
  /** A list of edges which contains the `Assemblageregel` and cursor to aid in pagination. */
  edges: Array<AssemblageregelsEdge>;
  /** A list of `Assemblageregel` objects. */
  nodes: Array<Assemblageregel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Assemblageregel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Assemblageregel` edge in the connection. */
export type AssemblageregelsEdge = {
  __typename?: 'AssemblageregelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Assemblageregel` at the end of the edge. */
  node: Assemblageregel;
};

/** Methods to use when ordering `Assemblageregel`. */
export enum AssemblageregelsOrderBy {
  AantalgereservafAsc = 'AANTALGERESERVAF_ASC',
  AantalgereservafDesc = 'AANTALGERESERVAF_DESC',
  AantalGebruiktAsc = 'AANTAL_GEBRUIKT_ASC',
  AantalGebruiktDesc = 'AANTAL_GEBRUIKT_DESC',
  AantalNormAsc = 'AANTAL_NORM_ASC',
  AantalNormDesc = 'AANTAL_NORM_DESC',
  AantalSamenstellingAsc = 'AANTAL_SAMENSTELLING_ASC',
  AantalSamenstellingDesc = 'AANTAL_SAMENSTELLING_DESC',
  AssemblageDatumAsc = 'ASSEMBLAGE_DATUM_ASC',
  AssemblageDatumDesc = 'ASSEMBLAGE_DATUM_DESC',
  AssemblageOrderAsc = 'ASSEMBLAGE_ORDER_ASC',
  AssemblageOrderDesc = 'ASSEMBLAGE_ORDER_DESC',
  CdartcomponentAsc = 'CDARTCOMPONENT_ASC',
  CdartcomponentDesc = 'CDARTCOMPONENT_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  Natural = 'NATURAL',
  WaardeGebruiktAsc = 'WAARDE_GEBRUIKT_ASC',
  WaardeGebruiktDesc = 'WAARDE_GEBRUIKT_DESC'
}

/** A connection to a list of `Assemblage` values. */
export type AssemblagesConnection = {
  __typename?: 'AssemblagesConnection';
  /** A list of edges which contains the `Assemblage` and cursor to aid in pagination. */
  edges: Array<AssemblagesEdge>;
  /** A list of `Assemblage` objects. */
  nodes: Array<Assemblage>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Assemblage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Assemblage` edge in the connection. */
export type AssemblagesEdge = {
  __typename?: 'AssemblagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Assemblage` at the end of the edge. */
  node: Assemblage;
};

/** Methods to use when ordering `Assemblage`. */
export enum AssemblagesOrderBy {
  AantalgereservbijAsc = 'AANTALGERESERVBIJ_ASC',
  AantalgereservbijDesc = 'AANTALGERESERVBIJ_DESC',
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  AantalGeassembleerdAsc = 'AANTAL_GEASSEMBLEERD_ASC',
  AantalGeassembleerdDesc = 'AANTAL_GEASSEMBLEERD_DESC',
  AfdrukAssemblageBonAsc = 'AFDRUK_ASSEMBLAGE_BON_ASC',
  AfdrukAssemblageBonDesc = 'AFDRUK_ASSEMBLAGE_BON_DESC',
  AssemblageDatumAsc = 'ASSEMBLAGE_DATUM_ASC',
  AssemblageDatumDesc = 'ASSEMBLAGE_DATUM_DESC',
  AssemblageOrderAsc = 'ASSEMBLAGE_ORDER_ASC',
  AssemblageOrderDesc = 'ASSEMBLAGE_ORDER_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  CommentaarAsc = 'COMMENTAAR_ASC',
  CommentaarDesc = 'COMMENTAAR_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  Natural = 'NATURAL',
  OrderDatumAsc = 'ORDER_DATUM_ASC',
  OrderDatumDesc = 'ORDER_DATUM_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  WaardeGeassembleerdAsc = 'WAARDE_GEASSEMBLEERD_ASC',
  WaardeGeassembleerdDesc = 'WAARDE_GEASSEMBLEERD_DESC'
}

/** A connection to a list of `Assembly` values. */
export type AssembliesConnection = {
  __typename?: 'AssembliesConnection';
  /** A list of edges which contains the `Assembly` and cursor to aid in pagination. */
  edges: Array<AssembliesEdge>;
  /** A list of `Assembly` objects. */
  nodes: Array<Assembly>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Assembly` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Assembly` edge in the connection. */
export type AssembliesEdge = {
  __typename?: 'AssembliesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Assembly` at the end of the edge. */
  node: Assembly;
};

/** Methods to use when ordering `Assembly`. */
export enum AssembliesOrderBy {
  AssemblyTypeByAssemblyTypeIdCdartikelAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__CDARTIKEL_ASC',
  AssemblyTypeByAssemblyTypeIdCdartikelDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__CDARTIKEL_DESC',
  AssemblyTypeByAssemblyTypeIdCreatedAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__CREATED_ASC',
  AssemblyTypeByAssemblyTypeIdCreatedDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__CREATED_DESC',
  AssemblyTypeByAssemblyTypeIdIdAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__ID_ASC',
  AssemblyTypeByAssemblyTypeIdIdDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__ID_DESC',
  AssemblyTypeByAssemblyTypeIdModifiedAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__MODIFIED_ASC',
  AssemblyTypeByAssemblyTypeIdModifiedDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__MODIFIED_DESC',
  AssemblyTypeByAssemblyTypeIdNameAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__NAME_ASC',
  AssemblyTypeByAssemblyTypeIdNameDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__NAME_DESC',
  AssemblyTypeByAssemblyTypeIdOwnerIdAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__OWNER_ID_ASC',
  AssemblyTypeByAssemblyTypeIdOwnerIdDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__OWNER_ID_DESC',
  AssemblyTypeIdAsc = 'ASSEMBLY_TYPE_ID_ASC',
  AssemblyTypeIdDesc = 'ASSEMBLY_TYPE_ID_DESC',
  CheckedAsc = 'CHECKED_ASC',
  CheckedDesc = 'CHECKED_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CompletedAsc = 'COMPLETED_ASC',
  CompletedDesc = 'COMPLETED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  MvDocAsc = 'MV_DOC_ASC',
  MvDocDesc = 'MV_DOC_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PoAsc = 'PO_ASC',
  PoDesc = 'PO_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  StartSerialNumberAsc = 'START_SERIAL_NUMBER_ASC',
  StartSerialNumberDesc = 'START_SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Assembly = Node & {
  __typename?: 'Assembly';
  /** Reads a single `AssemblyType` that is related to this `Assembly`. */
  assemblyTypeByAssemblyTypeId?: Maybe<AssemblyType>;
  assemblyTypeId?: Maybe<Scalars['Int']['output']>;
  checked: Scalars['Boolean']['output'];
  code?: Maybe<Scalars['String']['output']>;
  completed: Scalars['Boolean']['output'];
  created: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  mvDoc?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  po: Scalars['Boolean']['output'];
  quantity?: Maybe<Scalars['Int']['output']>;
  startSerialNumber?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Assembly`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `Assembly` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AssemblyCondition = {
  /** Checks for equality with the object’s `assemblyTypeId` field. */
  assemblyTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `checked` field. */
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `completed` field. */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `mvDoc` field. */
  mvDoc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `po` field. */
  po?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `startSerialNumber` field. */
  startSerialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AssemblyEntity` values. */
export type AssemblyEntitiesConnection = {
  __typename?: 'AssemblyEntitiesConnection';
  /** A list of edges which contains the `AssemblyEntity` and cursor to aid in pagination. */
  edges: Array<AssemblyEntitiesEdge>;
  /** A list of `AssemblyEntity` objects. */
  nodes: Array<AssemblyEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblyEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblyEntity` edge in the connection. */
export type AssemblyEntitiesEdge = {
  __typename?: 'AssemblyEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblyEntity` at the end of the edge. */
  node: AssemblyEntity;
};

/** Methods to use when ordering `AssemblyEntity`. */
export enum AssemblyEntitiesOrderBy {
  AdviceAsc = 'ADVICE_ASC',
  AdviceDesc = 'ADVICE_DESC',
  AssemblyTypeIdAsc = 'ASSEMBLY_TYPE_ID_ASC',
  AssemblyTypeIdDesc = 'ASSEMBLY_TYPE_ID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CheckedAsc = 'CHECKED_ASC',
  CheckedDesc = 'CHECKED_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CompletedAsc = 'COMPLETED_ASC',
  CompletedDesc = 'COMPLETED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PoAsc = 'PO_ASC',
  PoDesc = 'PO_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC'
}

export type AssemblyEntity = {
  __typename?: 'AssemblyEntity';
  advice?: Maybe<Scalars['Int']['output']>;
  assemblyTypeId?: Maybe<Scalars['Int']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  checked?: Maybe<Scalars['Boolean']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  completed?: Maybe<Scalars['Boolean']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  po?: Maybe<Scalars['Boolean']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `AssemblyEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AssemblyEntityCondition = {
  /** Checks for equality with the object’s `advice` field. */
  advice?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `assemblyTypeId` field. */
  assemblyTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `checked` field. */
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `completed` field. */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `po` field. */
  po?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `AssemblyEntity` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyEntityFilter = {
  /** Filter by the object’s `advice` field. */
  advice?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblyEntityFilter>>;
  /** Filter by the object’s `assemblyTypeId` field. */
  assemblyTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `checked` field. */
  checked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `completed` field. */
  completed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblyEntityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblyEntityFilter>>;
  /** Filter by the object’s `po` field. */
  po?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
};

/** A filter to be used against `Assembly` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblyFilter>>;
  /** Filter by the object’s `assemblyTypeByAssemblyTypeId` relation. */
  assemblyTypeByAssemblyTypeId?: InputMaybe<AssemblyTypeFilter>;
  /** A related `assemblyTypeByAssemblyTypeId` exists. */
  assemblyTypeByAssemblyTypeIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assemblyTypeId` field. */
  assemblyTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `checked` field. */
  checked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `completed` field. */
  completed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `mvDoc` field. */
  mvDoc?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblyFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `po` field. */
  po?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>;
  /** Filter by the object’s `startSerialNumber` field. */
  startSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `Assembly` */
export type AssemblyInput = {
  assemblyTypeId?: InputMaybe<Scalars['Int']['input']>;
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  created: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  mvDoc?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
  po?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  startSerialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AssemblyLineEntity` values. */
export type AssemblyLineEntitiesConnection = {
  __typename?: 'AssemblyLineEntitiesConnection';
  /** A list of edges which contains the `AssemblyLineEntity` and cursor to aid in pagination. */
  edges: Array<AssemblyLineEntitiesEdge>;
  /** A list of `AssemblyLineEntity` objects. */
  nodes: Array<AssemblyLineEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblyLineEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblyLineEntity` edge in the connection. */
export type AssemblyLineEntitiesEdge = {
  __typename?: 'AssemblyLineEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblyLineEntity` at the end of the edge. */
  node: AssemblyLineEntity;
};

/** Methods to use when ordering `AssemblyLineEntity`. */
export enum AssemblyLineEntitiesOrderBy {
  AantalGebruiktAsc = 'AANTAL_GEBRUIKT_ASC',
  AantalGebruiktDesc = 'AANTAL_GEBRUIKT_DESC',
  AantalNormAsc = 'AANTAL_NORM_ASC',
  AantalNormDesc = 'AANTAL_NORM_DESC',
  AantalSamenstellingAsc = 'AANTAL_SAMENSTELLING_ASC',
  AantalSamenstellingDesc = 'AANTAL_SAMENSTELLING_DESC',
  AdviceAsc = 'ADVICE_ASC',
  AdviceDesc = 'ADVICE_DESC',
  AssemblageDatumAsc = 'ASSEMBLAGE_DATUM_ASC',
  AssemblageDatumDesc = 'ASSEMBLAGE_DATUM_DESC',
  AssemblageOrderAsc = 'ASSEMBLAGE_ORDER_ASC',
  AssemblageOrderDesc = 'ASSEMBLAGE_ORDER_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  InkvolgnrAsc = 'INKVOLGNR_ASC',
  InkvolgnrDesc = 'INKVOLGNR_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  WaardeGebruiktAsc = 'WAARDE_GEBRUIKT_ASC',
  WaardeGebruiktDesc = 'WAARDE_GEBRUIKT_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type AssemblyLineEntity = {
  __typename?: 'AssemblyLineEntity';
  aantalGebruikt?: Maybe<Scalars['BigFloat']['output']>;
  aantalNorm?: Maybe<Scalars['BigFloat']['output']>;
  aantalSamenstelling?: Maybe<Scalars['BigFloat']['output']>;
  advice?: Maybe<Scalars['Int']['output']>;
  assemblageDatum?: Maybe<Scalars['Date']['output']>;
  assemblageOrder?: Maybe<Scalars['String']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  inkvolgnr?: Maybe<Scalars['Int']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  waardeGebruikt?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `AssemblyLineEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AssemblyLineEntityCondition = {
  /** Checks for equality with the object’s `aantalGebruikt` field. */
  aantalGebruikt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalNorm` field. */
  aantalNorm?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalSamenstelling` field. */
  aantalSamenstelling?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `advice` field. */
  advice?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `waardeGebruikt` field. */
  waardeGebruikt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AssemblyLineEntity` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyLineEntityFilter = {
  /** Filter by the object’s `aantalGebruikt` field. */
  aantalGebruikt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalNorm` field. */
  aantalNorm?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalSamenstelling` field. */
  aantalSamenstelling?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `advice` field. */
  advice?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblyLineEntityFilter>>;
  /** Filter by the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<StringFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblyLineEntityFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblyLineEntityFilter>>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `waardeGebruikt` field. */
  waardeGebruikt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `AssemblyMultiversEntity` values. */
export type AssemblyMultiversEntitiesConnection = {
  __typename?: 'AssemblyMultiversEntitiesConnection';
  /** A list of edges which contains the `AssemblyMultiversEntity` and cursor to aid in pagination. */
  edges: Array<AssemblyMultiversEntitiesEdge>;
  /** A list of `AssemblyMultiversEntity` objects. */
  nodes: Array<AssemblyMultiversEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblyMultiversEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblyMultiversEntity` edge in the connection. */
export type AssemblyMultiversEntitiesEdge = {
  __typename?: 'AssemblyMultiversEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblyMultiversEntity` at the end of the edge. */
  node: AssemblyMultiversEntity;
};

/** Methods to use when ordering `AssemblyMultiversEntity`. */
export enum AssemblyMultiversEntitiesOrderBy {
  AantalgereservbijAsc = 'AANTALGERESERVBIJ_ASC',
  AantalgereservbijDesc = 'AANTALGERESERVBIJ_DESC',
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  AantalGeassembleerdAsc = 'AANTAL_GEASSEMBLEERD_ASC',
  AantalGeassembleerdDesc = 'AANTAL_GEASSEMBLEERD_DESC',
  AdviceAsc = 'ADVICE_ASC',
  AdviceDesc = 'ADVICE_DESC',
  AfdrukAssemblageBonAsc = 'AFDRUK_ASSEMBLAGE_BON_ASC',
  AfdrukAssemblageBonDesc = 'AFDRUK_ASSEMBLAGE_BON_DESC',
  AssemblageDatumAsc = 'ASSEMBLAGE_DATUM_ASC',
  AssemblageDatumDesc = 'ASSEMBLAGE_DATUM_DESC',
  AssemblageOrderAsc = 'ASSEMBLAGE_ORDER_ASC',
  AssemblageOrderDesc = 'ASSEMBLAGE_ORDER_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  CommentaarAsc = 'COMMENTAAR_ASC',
  CommentaarDesc = 'COMMENTAAR_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OrderDatumAsc = 'ORDER_DATUM_ASC',
  OrderDatumDesc = 'ORDER_DATUM_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  WaardeGeassembleerdAsc = 'WAARDE_GEASSEMBLEERD_ASC',
  WaardeGeassembleerdDesc = 'WAARDE_GEASSEMBLEERD_DESC'
}

export type AssemblyMultiversEntity = {
  __typename?: 'AssemblyMultiversEntity';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  aantalGeassembleerd?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereservbij?: Maybe<Scalars['BigFloat']['output']>;
  advice?: Maybe<Scalars['Int']['output']>;
  afdrukAssemblageBon?: Maybe<Scalars['String']['output']>;
  assemblageDatum?: Maybe<Scalars['Date']['output']>;
  assemblageOrder?: Maybe<Scalars['String']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  commentaar?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  orderDatum?: Maybe<Scalars['Date']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  waardeGeassembleerd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `AssemblyMultiversEntity` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type AssemblyMultiversEntityCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalGeassembleerd` field. */
  aantalGeassembleerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereservbij` field. */
  aantalgereservbij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `advice` field. */
  advice?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `afdrukAssemblageBon` field. */
  afdrukAssemblageBon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `commentaar` field. */
  commentaar?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderDatum` field. */
  orderDatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `waardeGeassembleerd` field. */
  waardeGeassembleerd?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `AssemblyMultiversEntity` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyMultiversEntityFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalGeassembleerd` field. */
  aantalGeassembleerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereservbij` field. */
  aantalgereservbij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `advice` field. */
  advice?: InputMaybe<IntFilter>;
  /** Filter by the object’s `afdrukAssemblageBon` field. */
  afdrukAssemblageBon?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblyMultiversEntityFilter>>;
  /** Filter by the object’s `assemblageDatum` field. */
  assemblageDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `assemblageOrder` field. */
  assemblageOrder?: InputMaybe<StringFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `commentaar` field. */
  commentaar?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblyMultiversEntityFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblyMultiversEntityFilter>>;
  /** Filter by the object’s `orderDatum` field. */
  orderDatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `waardeGeassembleerd` field. */
  waardeGeassembleerd?: InputMaybe<BigFloatFilter>;
};

export type AssemblyPart = Node & {
  __typename?: 'AssemblyPart';
  assemblyId: Scalars['Int']['output'];
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  deliveryEstimate?: Maybe<Scalars['String']['output']>;
  ext?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  locatie?: Maybe<Scalars['String']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  omschr?: Maybe<Scalars['String']['output']>;
  ownerId: Scalars['Int']['output'];
  po?: Maybe<Scalars['String']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  short?: Maybe<Scalars['String']['output']>;
  used1?: Maybe<Scalars['String']['output']>;
  used2?: Maybe<Scalars['String']['output']>;
  usedQuantity?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `AssemblyPart`. */
  userByOwnerId?: Maybe<User>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  xxx?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `AssemblyPart` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AssemblyPartCondition = {
  /** Checks for equality with the object’s `assemblyId` field. */
  assemblyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deliveryEstimate` field. */
  deliveryEstimate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ext` field. */
  ext?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `po` field. */
  po?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `short` field. */
  short?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `used1` field. */
  used1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `used2` field. */
  used2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `usedQuantity` field. */
  usedQuantity?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `xxx` field. */
  xxx?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AssemblyPart` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyPartFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblyPartFilter>>;
  /** Filter by the object’s `assemblyId` field. */
  assemblyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deliveryEstimate` field. */
  deliveryEstimate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ext` field. */
  ext?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblyPartFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblyPartFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `po` field. */
  po?: InputMaybe<StringFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `short` field. */
  short?: InputMaybe<StringFilter>;
  /** Filter by the object’s `used1` field. */
  used1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `used2` field. */
  used2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `usedQuantity` field. */
  usedQuantity?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `xxx` field. */
  xxx?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `AssemblyPart` */
export type AssemblyPartInput = {
  assemblyId: Scalars['Int']['input'];
  bestcode?: InputMaybe<Scalars['String']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deliveryEstimate?: InputMaybe<Scalars['String']['input']>;
  ext?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  locatie?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
  po?: InputMaybe<Scalars['String']['input']>;
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  quantity?: InputMaybe<Scalars['Float']['input']>;
  short?: InputMaybe<Scalars['String']['input']>;
  used1?: InputMaybe<Scalars['String']['input']>;
  used2?: InputMaybe<Scalars['String']['input']>;
  usedQuantity?: InputMaybe<Scalars['String']['input']>;
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  xxx?: InputMaybe<Scalars['String']['input']>;
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `AssemblyPart`. Fields that are set will be updated. */
export type AssemblyPartPatch = {
  assemblyId?: InputMaybe<Scalars['Int']['input']>;
  bestcode?: InputMaybe<Scalars['String']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deliveryEstimate?: InputMaybe<Scalars['String']['input']>;
  ext?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  locatie?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  po?: InputMaybe<Scalars['String']['input']>;
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  quantity?: InputMaybe<Scalars['Float']['input']>;
  short?: InputMaybe<Scalars['String']['input']>;
  used1?: InputMaybe<Scalars['String']['input']>;
  used2?: InputMaybe<Scalars['String']['input']>;
  usedQuantity?: InputMaybe<Scalars['String']['input']>;
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  xxx?: InputMaybe<Scalars['String']['input']>;
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AssemblyPart` values. */
export type AssemblyPartsConnection = {
  __typename?: 'AssemblyPartsConnection';
  /** A list of edges which contains the `AssemblyPart` and cursor to aid in pagination. */
  edges: Array<AssemblyPartsEdge>;
  /** A list of `AssemblyPart` objects. */
  nodes: Array<AssemblyPart>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblyPart` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblyPart` edge in the connection. */
export type AssemblyPartsEdge = {
  __typename?: 'AssemblyPartsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblyPart` at the end of the edge. */
  node: AssemblyPart;
};

/** Methods to use when ordering `AssemblyPart`. */
export enum AssemblyPartsOrderBy {
  AssemblyIdAsc = 'ASSEMBLY_ID_ASC',
  AssemblyIdDesc = 'ASSEMBLY_ID_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DeliveryEstimateAsc = 'DELIVERY_ESTIMATE_ASC',
  DeliveryEstimateDesc = 'DELIVERY_ESTIMATE_DESC',
  ExtAsc = 'EXT_ASC',
  ExtDesc = 'EXT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PoAsc = 'PO_ASC',
  PoDesc = 'PO_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  ShortAsc = 'SHORT_ASC',
  ShortDesc = 'SHORT_DESC',
  Used1Asc = 'USED1_ASC',
  Used1Desc = 'USED1_DESC',
  Used2Asc = 'USED2_ASC',
  Used2Desc = 'USED2_DESC',
  UsedQuantityAsc = 'USED_QUANTITY_ASC',
  UsedQuantityDesc = 'USED_QUANTITY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  XxxAsc = 'XXX_ASC',
  XxxDesc = 'XXX_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** Represents an update to a `Assembly`. Fields that are set will be updated. */
export type AssemblyPatch = {
  assemblyTypeId?: InputMaybe<Scalars['Int']['input']>;
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  mvDoc?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  po?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  startSerialNumber?: InputMaybe<Scalars['String']['input']>;
};

export type AssemblyType = Node & {
  __typename?: 'AssemblyType';
  /** Reads a single `Artikel` that is related to this `AssemblyType`. */
  artikelByCdartikel?: Maybe<Artikel>;
  /** Reads and enables pagination through a set of `Assembly`. */
  assembliesByAssemblyTypeId: AssembliesConnection;
  /** Reads and enables pagination through a set of `AssemblyTypePart`. */
  assemblyTypePartsByAssemblyTypeId: AssemblyTypePartsConnection;
  cdartikel?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `AssemblyType`. */
  userByOwnerId?: Maybe<User>;
};


export type AssemblyTypeAssembliesByAssemblyTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyCondition>;
  filter?: InputMaybe<AssemblyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssembliesOrderBy>>;
};


export type AssemblyTypeAssemblyTypePartsByAssemblyTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyTypePartCondition>;
  filter?: InputMaybe<AssemblyTypePartFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyTypePartsOrderBy>>;
};

/**
 * A condition to be used against `AssemblyType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AssemblyTypeCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `AssemblyType` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblyTypeFilter>>;
  /** Filter by the object’s `artikelByCdartikel` relation. */
  artikelByCdartikel?: InputMaybe<ArtikelFilter>;
  /** A related `artikelByCdartikel` exists. */
  artikelByCdartikelExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assembliesByAssemblyTypeId` relation. */
  assembliesByAssemblyTypeId?: InputMaybe<AssemblyTypeToManyAssemblyFilter>;
  /** Some related `assembliesByAssemblyTypeId` exist. */
  assembliesByAssemblyTypeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assemblyTypePartsByAssemblyTypeId` relation. */
  assemblyTypePartsByAssemblyTypeId?: InputMaybe<AssemblyTypeToManyAssemblyTypePartFilter>;
  /** Some related `assemblyTypePartsByAssemblyTypeId` exist. */
  assemblyTypePartsByAssemblyTypeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblyTypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblyTypeFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `AssemblyType` */
export type AssemblyTypeInput = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
};

export type AssemblyTypePart = Node & {
  __typename?: 'AssemblyTypePart';
  /** Reads a single `AssemblyType` that is related to this `AssemblyTypePart`. */
  assemblyTypeByAssemblyTypeId?: Maybe<AssemblyType>;
  assemblyTypeId: Scalars['Int']['output'];
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  locatie?: Maybe<Scalars['String']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  omschr?: Maybe<Scalars['String']['output']>;
  ownerId: Scalars['Int']['output'];
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  /** Reads a single `User` that is related to this `AssemblyTypePart`. */
  userByOwnerId?: Maybe<User>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `AssemblyTypePart` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AssemblyTypePartCondition = {
  /** Checks for equality with the object’s `assemblyTypeId` field. */
  assemblyTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AssemblyTypePart` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyTypePartFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblyTypePartFilter>>;
  /** Filter by the object’s `assemblyTypeByAssemblyTypeId` relation. */
  assemblyTypeByAssemblyTypeId?: InputMaybe<AssemblyTypeFilter>;
  /** Filter by the object’s `assemblyTypeId` field. */
  assemblyTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblyTypePartFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblyTypePartFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `AssemblyTypePart` */
export type AssemblyTypePartInput = {
  assemblyTypeId: Scalars['Int']['input'];
  bestcode?: InputMaybe<Scalars['String']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  locatie?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  quantity?: InputMaybe<Scalars['Float']['input']>;
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `AssemblyTypePart`. Fields that are set will be updated. */
export type AssemblyTypePartPatch = {
  assemblyTypeId?: InputMaybe<Scalars['Int']['input']>;
  bestcode?: InputMaybe<Scalars['String']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  locatie?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  quantity?: InputMaybe<Scalars['Float']['input']>;
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `AssemblyTypePart` values. */
export type AssemblyTypePartsConnection = {
  __typename?: 'AssemblyTypePartsConnection';
  /** A list of edges which contains the `AssemblyTypePart` and cursor to aid in pagination. */
  edges: Array<AssemblyTypePartsEdge>;
  /** A list of `AssemblyTypePart` objects. */
  nodes: Array<AssemblyTypePart>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblyTypePart` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblyTypePart` edge in the connection. */
export type AssemblyTypePartsEdge = {
  __typename?: 'AssemblyTypePartsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblyTypePart` at the end of the edge. */
  node: AssemblyTypePart;
};

/** Methods to use when ordering `AssemblyTypePart`. */
export enum AssemblyTypePartsOrderBy {
  AssemblyTypeByAssemblyTypeIdCdartikelAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__CDARTIKEL_ASC',
  AssemblyTypeByAssemblyTypeIdCdartikelDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__CDARTIKEL_DESC',
  AssemblyTypeByAssemblyTypeIdCreatedAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__CREATED_ASC',
  AssemblyTypeByAssemblyTypeIdCreatedDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__CREATED_DESC',
  AssemblyTypeByAssemblyTypeIdIdAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__ID_ASC',
  AssemblyTypeByAssemblyTypeIdIdDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__ID_DESC',
  AssemblyTypeByAssemblyTypeIdModifiedAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__MODIFIED_ASC',
  AssemblyTypeByAssemblyTypeIdModifiedDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__MODIFIED_DESC',
  AssemblyTypeByAssemblyTypeIdNameAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__NAME_ASC',
  AssemblyTypeByAssemblyTypeIdNameDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__NAME_DESC',
  AssemblyTypeByAssemblyTypeIdOwnerIdAsc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__OWNER_ID_ASC',
  AssemblyTypeByAssemblyTypeIdOwnerIdDesc = 'ASSEMBLY_TYPE_BY_ASSEMBLY_TYPE_ID__OWNER_ID_DESC',
  AssemblyTypeIdAsc = 'ASSEMBLY_TYPE_ID_ASC',
  AssemblyTypeIdDesc = 'ASSEMBLY_TYPE_ID_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** Represents an update to a `AssemblyType`. Fields that are set will be updated. */
export type AssemblyTypePatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `Assembly` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyTypeToManyAssemblyFilter = {
  /** Every related `Assembly` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AssemblyFilter>;
  /** No related `Assembly` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AssemblyFilter>;
  /** Some related `Assembly` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AssemblyFilter>;
};

/** A filter to be used against many `AssemblyTypePart` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyTypeToManyAssemblyTypePartFilter = {
  /** Every related `AssemblyTypePart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AssemblyTypePartFilter>;
  /** No related `AssemblyTypePart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AssemblyTypePartFilter>;
  /** Some related `AssemblyTypePart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AssemblyTypePartFilter>;
};

/** A connection to a list of `AssemblyType` values. */
export type AssemblyTypesConnection = {
  __typename?: 'AssemblyTypesConnection';
  /** A list of edges which contains the `AssemblyType` and cursor to aid in pagination. */
  edges: Array<AssemblyTypesEdge>;
  /** A list of `AssemblyType` objects. */
  nodes: Array<AssemblyType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblyType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblyType` edge in the connection. */
export type AssemblyTypesEdge = {
  __typename?: 'AssemblyTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblyType` at the end of the edge. */
  node: AssemblyType;
};

/** A connection to a list of `AssemblyTypesEntity` values. */
export type AssemblyTypesEntitiesConnection = {
  __typename?: 'AssemblyTypesEntitiesConnection';
  /** A list of edges which contains the `AssemblyTypesEntity` and cursor to aid in pagination. */
  edges: Array<AssemblyTypesEntitiesEdge>;
  /** A list of `AssemblyTypesEntity` objects. */
  nodes: Array<AssemblyTypesEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssemblyTypesEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssemblyTypesEntity` edge in the connection. */
export type AssemblyTypesEntitiesEdge = {
  __typename?: 'AssemblyTypesEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssemblyTypesEntity` at the end of the edge. */
  node: AssemblyTypesEntity;
};

/** Methods to use when ordering `AssemblyTypesEntity`. */
export enum AssemblyTypesEntitiesOrderBy {
  AdviceAsc = 'ADVICE_ASC',
  AdviceDesc = 'ADVICE_DESC',
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC'
}

export type AssemblyTypesEntity = {
  __typename?: 'AssemblyTypesEntity';
  advice?: Maybe<Scalars['Int']['output']>;
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `AssemblyTypesEntity` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type AssemblyTypesEntityCondition = {
  /** Checks for equality with the object’s `advice` field. */
  advice?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `AssemblyTypesEntity` object types. All fields are combined with a logical ‘and.’ */
export type AssemblyTypesEntityFilter = {
  /** Filter by the object’s `advice` field. */
  advice?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssemblyTypesEntityFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssemblyTypesEntityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssemblyTypesEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
};

/** Methods to use when ordering `AssemblyType`. */
export enum AssemblyTypesOrderBy {
  ArtikelByCdartikelAanmaakdatumAsc = 'ARTIKEL_BY_CDARTIKEL__AANMAAKDATUM_ASC',
  ArtikelByCdartikelAanmaakdatumDesc = 'ARTIKEL_BY_CDARTIKEL__AANMAAKDATUM_DESC',
  ArtikelByCdartikelAantaldecAsc = 'ARTIKEL_BY_CDARTIKEL__AANTALDEC_ASC',
  ArtikelByCdartikelAantaldecDesc = 'ARTIKEL_BY_CDARTIKEL__AANTALDEC_DESC',
  ArtikelByCdartikelAanveenhAsc = 'ARTIKEL_BY_CDARTIKEL__AANVEENH_ASC',
  ArtikelByCdartikelAanveenhDesc = 'ARTIKEL_BY_CDARTIKEL__AANVEENH_DESC',
  ArtikelByCdartikelAfdrukSamOpOfferteAsc = 'ARTIKEL_BY_CDARTIKEL__AFDRUK_SAM_OP_OFFERTE_ASC',
  ArtikelByCdartikelAfdrukSamOpOfferteDesc = 'ARTIKEL_BY_CDARTIKEL__AFDRUK_SAM_OP_OFFERTE_DESC',
  ArtikelByCdartikelAssemblageArtikelAsc = 'ARTIKEL_BY_CDARTIKEL__ASSEMBLAGE_ARTIKEL_ASC',
  ArtikelByCdartikelAssemblageArtikelDesc = 'ARTIKEL_BY_CDARTIKEL__ASSEMBLAGE_ARTIKEL_DESC',
  ArtikelByCdartikelBtwcodeAsc = 'ARTIKEL_BY_CDARTIKEL__BTWCODE_ASC',
  ArtikelByCdartikelBtwcodeDesc = 'ARTIKEL_BY_CDARTIKEL__BTWCODE_DESC',
  ArtikelByCdartikelCdartgroepAsc = 'ARTIKEL_BY_CDARTIKEL__CDARTGROEP_ASC',
  ArtikelByCdartikelCdartgroepDesc = 'ARTIKEL_BY_CDARTIKEL__CDARTGROEP_DESC',
  ArtikelByCdartikelCdartikelAsc = 'ARTIKEL_BY_CDARTIKEL__CDARTIKEL_ASC',
  ArtikelByCdartikelCdartikelDesc = 'ARTIKEL_BY_CDARTIKEL__CDARTIKEL_DESC',
  ArtikelByCdartikelCdartkortgrpAsc = 'ARTIKEL_BY_CDARTIKEL__CDARTKORTGRP_ASC',
  ArtikelByCdartikelCdartkortgrpDesc = 'ARTIKEL_BY_CDARTIKEL__CDARTKORTGRP_DESC',
  ArtikelByCdartikelCdgoedcodeAsc = 'ARTIKEL_BY_CDARTIKEL__CDGOEDCODE_ASC',
  ArtikelByCdartikelCdgoedcodeDesc = 'ARTIKEL_BY_CDARTIKEL__CDGOEDCODE_DESC',
  ArtikelByCdartikelCdgrbrekdekkingAsc = 'ARTIKEL_BY_CDARTIKEL__CDGRBREKDEKKING_ASC',
  ArtikelByCdartikelCdgrbrekdekkingDesc = 'ARTIKEL_BY_CDARTIKEL__CDGRBREKDEKKING_DESC',
  ArtikelByCdartikelCdgrbrekeningAsc = 'ARTIKEL_BY_CDARTIKEL__CDGRBREKENING_ASC',
  ArtikelByCdartikelCdgrbrekeningDesc = 'ARTIKEL_BY_CDARTIKEL__CDGRBREKENING_DESC',
  ArtikelByCdartikelCdgrbrekkortAsc = 'ARTIKEL_BY_CDARTIKEL__CDGRBREKKORT_ASC',
  ArtikelByCdartikelCdgrbrekkortDesc = 'ARTIKEL_BY_CDARTIKEL__CDGRBREKKORT_DESC',
  ArtikelByCdartikelCdlandOorsprAsc = 'ARTIKEL_BY_CDARTIKEL__CDLAND_OORSPR_ASC',
  ArtikelByCdartikelCdlandOorsprDesc = 'ARTIKEL_BY_CDARTIKEL__CDLAND_OORSPR_DESC',
  ArtikelByCdartikelDatumltstewijzAsc = 'ARTIKEL_BY_CDARTIKEL__DATUMLTSTEWIJZ_ASC',
  ArtikelByCdartikelDatumltstewijzDesc = 'ARTIKEL_BY_CDARTIKEL__DATUMLTSTEWIJZ_DESC',
  ArtikelByCdartikelEannummerAsc = 'ARTIKEL_BY_CDARTIKEL__EANNUMMER_ASC',
  ArtikelByCdartikelEannummerDesc = 'ARTIKEL_BY_CDARTIKEL__EANNUMMER_DESC',
  ArtikelByCdartikelEenheidAsc = 'ARTIKEL_BY_CDARTIKEL__EENHEID_ASC',
  ArtikelByCdartikelEenheidDesc = 'ARTIKEL_BY_CDARTIKEL__EENHEID_DESC',
  ArtikelByCdartikelFactuurAsc = 'ARTIKEL_BY_CDARTIKEL__FACTUUR_ASC',
  ArtikelByCdartikelFactuurDesc = 'ARTIKEL_BY_CDARTIKEL__FACTUUR_DESC',
  ArtikelByCdartikelGewichtAsc = 'ARTIKEL_BY_CDARTIKEL__GEWICHT_ASC',
  ArtikelByCdartikelGewichtDesc = 'ARTIKEL_BY_CDARTIKEL__GEWICHT_DESC',
  ArtikelByCdartikelGuidItemAsc = 'ARTIKEL_BY_CDARTIKEL__GUID_ITEM_ASC',
  ArtikelByCdartikelGuidItemDesc = 'ARTIKEL_BY_CDARTIKEL__GUID_ITEM_DESC',
  ArtikelByCdartikelInkvolgnrAsc = 'ARTIKEL_BY_CDARTIKEL__INKVOLGNR_ASC',
  ArtikelByCdartikelInkvolgnrDesc = 'ARTIKEL_BY_CDARTIKEL__INKVOLGNR_DESC',
  ArtikelByCdartikelMagbonAsc = 'ARTIKEL_BY_CDARTIKEL__MAGBON_ASC',
  ArtikelByCdartikelMagbonDesc = 'ARTIKEL_BY_CDARTIKEL__MAGBON_DESC',
  ArtikelByCdartikelMargePercAsc = 'ARTIKEL_BY_CDARTIKEL__MARGE_PERC_ASC',
  ArtikelByCdartikelMargePercDesc = 'ARTIKEL_BY_CDARTIKEL__MARGE_PERC_DESC',
  ArtikelByCdartikelMaxvoorraadAsc = 'ARTIKEL_BY_CDARTIKEL__MAXVOORRAAD_ASC',
  ArtikelByCdartikelMaxvoorraadDesc = 'ARTIKEL_BY_CDARTIKEL__MAXVOORRAAD_DESC',
  ArtikelByCdartikelMinvoorraadAsc = 'ARTIKEL_BY_CDARTIKEL__MINVOORRAAD_ASC',
  ArtikelByCdartikelMinvoorraadDesc = 'ARTIKEL_BY_CDARTIKEL__MINVOORRAAD_DESC',
  ArtikelByCdartikelOmschrAsc = 'ARTIKEL_BY_CDARTIKEL__OMSCHR_ASC',
  ArtikelByCdartikelOmschrDesc = 'ARTIKEL_BY_CDARTIKEL__OMSCHR_DESC',
  ArtikelByCdartikelOpwebAsc = 'ARTIKEL_BY_CDARTIKEL__OPWEB_ASC',
  ArtikelByCdartikelOpwebDesc = 'ARTIKEL_BY_CDARTIKEL__OPWEB_DESC',
  ArtikelByCdartikelPakbonAsc = 'ARTIKEL_BY_CDARTIKEL__PAKBON_ASC',
  ArtikelByCdartikelPakbonDesc = 'ARTIKEL_BY_CDARTIKEL__PAKBON_DESC',
  ArtikelByCdartikelPrijsexclAsc = 'ARTIKEL_BY_CDARTIKEL__PRIJSEXCL_ASC',
  ArtikelByCdartikelPrijsexclDesc = 'ARTIKEL_BY_CDARTIKEL__PRIJSEXCL_DESC',
  ArtikelByCdartikelPrijsinclAsc = 'ARTIKEL_BY_CDARTIKEL__PRIJSINCL_ASC',
  ArtikelByCdartikelPrijsinclDesc = 'ARTIKEL_BY_CDARTIKEL__PRIJSINCL_DESC',
  ArtikelByCdartikelPrijsperAsc = 'ARTIKEL_BY_CDARTIKEL__PRIJSPER_ASC',
  ArtikelByCdartikelPrijsperDesc = 'ARTIKEL_BY_CDARTIKEL__PRIJSPER_DESC',
  ArtikelByCdartikelProjMutsoortAsc = 'ARTIKEL_BY_CDARTIKEL__PROJ_MUTSOORT_ASC',
  ArtikelByCdartikelProjMutsoortDesc = 'ARTIKEL_BY_CDARTIKEL__PROJ_MUTSOORT_DESC',
  ArtikelByCdartikelProjOpslagAsc = 'ARTIKEL_BY_CDARTIKEL__PROJ_OPSLAG_ASC',
  ArtikelByCdartikelProjOpslagDesc = 'ARTIKEL_BY_CDARTIKEL__PROJ_OPSLAG_DESC',
  ArtikelByCdartikelSamVersieAsc = 'ARTIKEL_BY_CDARTIKEL__SAM_VERSIE_ASC',
  ArtikelByCdartikelSamVersieDesc = 'ARTIKEL_BY_CDARTIKEL__SAM_VERSIE_DESC',
  ArtikelByCdartikelSoortAsc = 'ARTIKEL_BY_CDARTIKEL__SOORT_ASC',
  ArtikelByCdartikelSoortDesc = 'ARTIKEL_BY_CDARTIKEL__SOORT_DESC',
  ArtikelByCdartikelSysCreateAsc = 'ARTIKEL_BY_CDARTIKEL__SYS_CREATE_ASC',
  ArtikelByCdartikelSysCreateDesc = 'ARTIKEL_BY_CDARTIKEL__SYS_CREATE_DESC',
  ArtikelByCdartikelSysUpdateAsc = 'ARTIKEL_BY_CDARTIKEL__SYS_UPDATE_ASC',
  ArtikelByCdartikelSysUpdateDesc = 'ARTIKEL_BY_CDARTIKEL__SYS_UPDATE_DESC',
  ArtikelByCdartikelUitloopAsc = 'ARTIKEL_BY_CDARTIKEL__UITLOOP_ASC',
  ArtikelByCdartikelUitloopDesc = 'ARTIKEL_BY_CDARTIKEL__UITLOOP_DESC',
  ArtikelByCdartikelVerrekenprijsAsc = 'ARTIKEL_BY_CDARTIKEL__VERREKENPRIJS_ASC',
  ArtikelByCdartikelVerrekenprijsDesc = 'ARTIKEL_BY_CDARTIKEL__VERREKENPRIJS_DESC',
  ArtikelByCdartikelVoorraadAsc = 'ARTIKEL_BY_CDARTIKEL__VOORRAAD_ASC',
  ArtikelByCdartikelVoorraadDesc = 'ARTIKEL_BY_CDARTIKEL__VOORRAAD_DESC',
  ArtikelByCdartikelVvbestandAsc = 'ARTIKEL_BY_CDARTIKEL__VVBESTAND_ASC',
  ArtikelByCdartikelVvbestandDesc = 'ARTIKEL_BY_CDARTIKEL__VVBESTAND_DESC',
  ArtikelByCdartikelVvgroepAsc = 'ARTIKEL_BY_CDARTIKEL__VVGROEP_ASC',
  ArtikelByCdartikelVvgroepDesc = 'ARTIKEL_BY_CDARTIKEL__VVGROEP_DESC',
  ArtikelByCdartikelVvvrijveldaAsc = 'ARTIKEL_BY_CDARTIKEL__VVVRIJVELDA_ASC',
  ArtikelByCdartikelVvvrijveldaDesc = 'ARTIKEL_BY_CDARTIKEL__VVVRIJVELDA_DESC',
  ArtikelByCdartikelVvvrijveldbAsc = 'ARTIKEL_BY_CDARTIKEL__VVVRIJVELDB_ASC',
  ArtikelByCdartikelVvvrijveldbDesc = 'ARTIKEL_BY_CDARTIKEL__VVVRIJVELDB_DESC',
  ArtikelByCdartikelZoeknaamAsc = 'ARTIKEL_BY_CDARTIKEL__ZOEKNAAM_ASC',
  ArtikelByCdartikelZoeknaamDesc = 'ARTIKEL_BY_CDARTIKEL__ZOEKNAAM_DESC',
  AssembliesByAssemblyTypeIdCountAsc = 'ASSEMBLIES_BY_ASSEMBLY_TYPE_ID__COUNT_ASC',
  AssembliesByAssemblyTypeIdCountDesc = 'ASSEMBLIES_BY_ASSEMBLY_TYPE_ID__COUNT_DESC',
  AssemblyTypePartsByAssemblyTypeIdCountAsc = 'ASSEMBLY_TYPE_PARTS_BY_ASSEMBLY_TYPE_ID__COUNT_ASC',
  AssemblyTypePartsByAssemblyTypeIdCountDesc = 'ASSEMBLY_TYPE_PARTS_BY_ASSEMBLY_TYPE_ID__COUNT_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** All input for the `authenticate` mutation. */
export type AuthenticateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

/** The output of our `authenticate` mutation. */
export type AuthenticatePayload = {
  __typename?: 'AuthenticatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  jwtToken?: Maybe<Scalars['JwtToken']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** A connection to a list of `Besteladvy` values. */
export type BesteladviesConnection = {
  __typename?: 'BesteladviesConnection';
  /** A list of edges which contains the `Besteladvy` and cursor to aid in pagination. */
  edges: Array<BesteladviesEdge>;
  /** A list of `Besteladvy` objects. */
  nodes: Array<Besteladvy>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Besteladvy` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Besteladvy` edge in the connection. */
export type BesteladviesEdge = {
  __typename?: 'BesteladviesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Besteladvy` at the end of the edge. */
  node: Besteladvy;
};

/** Methods to use when ordering `Besteladvy`. */
export enum BesteladviesOrderBy {
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  BesthoeveelheidAsc = 'BESTHOEVEELHEID_ASC',
  BesthoeveelheidDesc = 'BESTHOEVEELHEID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdartsamenstellingenAsc = 'CDARTSAMENSTELLINGEN_ASC',
  CdartsamenstellingenDesc = 'CDARTSAMENSTELLINGEN_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkoopprijsAsc = 'INKOOPPRIJS_ASC',
  InkoopprijsDesc = 'INKOOPPRIJS_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  IsovalutaAsc = 'ISOVALUTA_ASC',
  IsovalutaDesc = 'ISOVALUTA_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  StockSupplierIdAsc = 'STOCK_SUPPLIER_ID_ASC',
  StockSupplierIdDesc = 'STOCK_SUPPLIER_ID_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VrijAsc = 'VRIJ_ASC',
  VrijDesc = 'VRIJ_DESC'
}

export type Besteladvy = {
  __typename?: 'Besteladvy';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  besthoeveelheid?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdartsamenstellingen?: Maybe<Scalars['JSON']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkoopprijs?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  isovaluta?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  stockSupplierId?: Maybe<Scalars['Int']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vrij?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Besteladvy` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type BesteladvyCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartsamenstellingen` field. */
  cdartsamenstellingen?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stockSupplierId` field. */
  stockSupplierId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vrij` field. */
  vrij?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `Besteladvy` object types. All fields are combined with a logical ‘and.’ */
export type BesteladvyFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BesteladvyFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BesteladvyFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BesteladvyFilter>>;
  /** Filter by the object’s `stockSupplierId` field. */
  stockSupplierId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vrij` field. */
  vrij?: InputMaybe<BigFloatFilter>;
};

export type BieStatus = {
  __typename?: 'BieStatus';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  deliveryDate?: Maybe<Scalars['Date']['output']>;
  endUser?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  orderdatum?: Maybe<Scalars['Date']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  orderregel?: Maybe<Scalars['Int']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `BieStatus` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type BieStatusCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `endUser` field. */
  endUser?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderregel` field. */
  orderregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `BieStatus` object types. All fields are combined with a logical ‘and.’ */
export type BieStatusFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BieStatusFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `endUser` field. */
  endUser?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BieStatusFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BieStatusFilter>>;
  /** Filter by the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `orderregel` field. */
  orderregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `BieStatus` values. */
export type BieStatusesConnection = {
  __typename?: 'BieStatusesConnection';
  /** A list of edges which contains the `BieStatus` and cursor to aid in pagination. */
  edges: Array<BieStatusesEdge>;
  /** A list of `BieStatus` objects. */
  nodes: Array<BieStatus>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BieStatus` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `BieStatus` edge in the connection. */
export type BieStatusesEdge = {
  __typename?: 'BieStatusesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `BieStatus` at the end of the edge. */
  node: BieStatus;
};

/** Methods to use when ordering `BieStatus`. */
export enum BieStatusesOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  DeliveryDateAsc = 'DELIVERY_DATE_ASC',
  DeliveryDateDesc = 'DELIVERY_DATE_DESC',
  EndUserAsc = 'END_USER_ASC',
  EndUserDesc = 'END_USER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OrderdatumAsc = 'ORDERDATUM_ASC',
  OrderdatumDesc = 'ORDERDATUM_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  OrderregelAsc = 'ORDERREGEL_ASC',
  OrderregelDesc = 'ORDERREGEL_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC'
}

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
};

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type Building = Node & {
  __typename?: 'Building';
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `EndUser` that is related to this `Building`. */
  endUserByEndUserId?: Maybe<EndUser>;
  endUserId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Floor`. */
  floorsByBuildingId: FloorsConnection;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `Building`. */
  userByOwnerId?: Maybe<User>;
};


export type BuildingFloorsByBuildingIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FloorCondition>;
  filter?: InputMaybe<FloorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FloorsOrderBy>>;
};

/**
 * A condition to be used against `Building` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type BuildingCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Building` object types. All fields are combined with a logical ‘and.’ */
export type BuildingFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BuildingFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `endUserByEndUserId` relation. */
  endUserByEndUserId?: InputMaybe<EndUserFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `floorsByBuildingId` relation. */
  floorsByBuildingId?: InputMaybe<BuildingToManyFloorFilter>;
  /** Some related `floorsByBuildingId` exist. */
  floorsByBuildingIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BuildingFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BuildingFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `Building` */
export type BuildingInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  endUserId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Building`. Fields that are set will be updated. */
export type BuildingPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `Floor` object types. All fields are combined with a logical ‘and.’ */
export type BuildingToManyFloorFilter = {
  /** Every related `Floor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FloorFilter>;
  /** No related `Floor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FloorFilter>;
  /** Some related `Floor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FloorFilter>;
};

/** A connection to a list of `Building` values. */
export type BuildingsConnection = {
  __typename?: 'BuildingsConnection';
  /** A list of edges which contains the `Building` and cursor to aid in pagination. */
  edges: Array<BuildingsEdge>;
  /** A list of `Building` objects. */
  nodes: Array<Building>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Building` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Building` edge in the connection. */
export type BuildingsEdge = {
  __typename?: 'BuildingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Building` at the end of the edge. */
  node: Building;
};

/** Methods to use when ordering `Building`. */
export enum BuildingsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EndUserByEndUserIdAddress1Asc = 'END_USER_BY_END_USER_ID__ADDRESS1_ASC',
  EndUserByEndUserIdAddress1Desc = 'END_USER_BY_END_USER_ID__ADDRESS1_DESC',
  EndUserByEndUserIdAddress2Asc = 'END_USER_BY_END_USER_ID__ADDRESS2_ASC',
  EndUserByEndUserIdAddress2Desc = 'END_USER_BY_END_USER_ID__ADDRESS2_DESC',
  EndUserByEndUserIdCityAsc = 'END_USER_BY_END_USER_ID__CITY_ASC',
  EndUserByEndUserIdCityDesc = 'END_USER_BY_END_USER_ID__CITY_DESC',
  EndUserByEndUserIdContactEmailAsc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_ASC',
  EndUserByEndUserIdContactEmailDesc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_DESC',
  EndUserByEndUserIdContactNameAsc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_ASC',
  EndUserByEndUserIdContactNameDesc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_DESC',
  EndUserByEndUserIdContactPhoneAsc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_ASC',
  EndUserByEndUserIdContactPhoneDesc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_DESC',
  EndUserByEndUserIdCountryAsc = 'END_USER_BY_END_USER_ID__COUNTRY_ASC',
  EndUserByEndUserIdCountryDesc = 'END_USER_BY_END_USER_ID__COUNTRY_DESC',
  EndUserByEndUserIdCreatedAsc = 'END_USER_BY_END_USER_ID__CREATED_ASC',
  EndUserByEndUserIdCreatedDesc = 'END_USER_BY_END_USER_ID__CREATED_DESC',
  EndUserByEndUserIdFormerName1Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_ASC',
  EndUserByEndUserIdFormerName1Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_DESC',
  EndUserByEndUserIdFormerName2Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_ASC',
  EndUserByEndUserIdFormerName2Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_DESC',
  EndUserByEndUserIdIdAsc = 'END_USER_BY_END_USER_ID__ID_ASC',
  EndUserByEndUserIdIdDesc = 'END_USER_BY_END_USER_ID__ID_DESC',
  EndUserByEndUserIdLocationAsc = 'END_USER_BY_END_USER_ID__LOCATION_ASC',
  EndUserByEndUserIdLocationDesc = 'END_USER_BY_END_USER_ID__LOCATION_DESC',
  EndUserByEndUserIdModifiedAsc = 'END_USER_BY_END_USER_ID__MODIFIED_ASC',
  EndUserByEndUserIdModifiedDesc = 'END_USER_BY_END_USER_ID__MODIFIED_DESC',
  EndUserByEndUserIdNameAsc = 'END_USER_BY_END_USER_ID__NAME_ASC',
  EndUserByEndUserIdNameDesc = 'END_USER_BY_END_USER_ID__NAME_DESC',
  EndUserByEndUserIdOwnerIdAsc = 'END_USER_BY_END_USER_ID__OWNER_ID_ASC',
  EndUserByEndUserIdOwnerIdDesc = 'END_USER_BY_END_USER_ID__OWNER_ID_DESC',
  EndUserByEndUserIdRegionAsc = 'END_USER_BY_END_USER_ID__REGION_ASC',
  EndUserByEndUserIdRegionDesc = 'END_USER_BY_END_USER_ID__REGION_DESC',
  EndUserByEndUserIdSubLocationAsc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_ASC',
  EndUserByEndUserIdSubLocationDesc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_DESC',
  EndUserByEndUserIdZipCodeAsc = 'END_USER_BY_END_USER_ID__ZIP_CODE_ASC',
  EndUserByEndUserIdZipCodeDesc = 'END_USER_BY_END_USER_ID__ZIP_CODE_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  FloorsByBuildingIdCountAsc = 'FLOORS_BY_BUILDING_ID__COUNT_ASC',
  FloorsByBuildingIdCountDesc = 'FLOORS_BY_BUILDING_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type CalGas = Node & {
  __typename?: 'CalGas';
  cdartikel?: Maybe<Scalars['String']['output']>;
  concentration?: Maybe<Scalars['Float']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  engineeringUnits?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Gas` that is related to this `CalGas`. */
  gasByGasId?: Maybe<Gas>;
  gasId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  maintenanceVisitLinesByCalGasId: MaintenanceVisitLinesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorTestResult`. */
  sensorTestResultsByFsCalGasId: SensorTestResultsConnection;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByCalGasId: SensorTypesConnection;
  type?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `CalGas`. */
  userByOwnerId?: Maybe<User>;
};


export type CalGasMaintenanceVisitLinesByCalGasIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};


export type CalGasSensorTestResultsByFsCalGasIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTestResultCondition>;
  filter?: InputMaybe<SensorTestResultFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};


export type CalGasSensorTypesByCalGasIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/** A condition to be used against `CalGas` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CalGasCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `concentration` field. */
  concentration?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gasId` field. */
  gasId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `CalGas` object types. All fields are combined with a logical ‘and.’ */
export type CalGasFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CalGasFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `concentration` field. */
  concentration?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gasByGasId` relation. */
  gasByGasId?: InputMaybe<GasFilter>;
  /** Filter by the object’s `gasId` field. */
  gasId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitLinesByCalGasId` relation. */
  maintenanceVisitLinesByCalGasId?: InputMaybe<CalGasToManyMaintenanceVisitLineFilter>;
  /** Some related `maintenanceVisitLinesByCalGasId` exist. */
  maintenanceVisitLinesByCalGasIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CalGasFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CalGasFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTestResultsByFsCalGasId` relation. */
  sensorTestResultsByFsCalGasId?: InputMaybe<CalGasToManySensorTestResultFilter>;
  /** Some related `sensorTestResultsByFsCalGasId` exist. */
  sensorTestResultsByFsCalGasIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorTypesByCalGasId` relation. */
  sensorTypesByCalGasId?: InputMaybe<CalGasToManySensorTypeFilter>;
  /** Some related `sensorTypesByCalGasId` exist. */
  sensorTypesByCalGasIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `CalGas` */
export type CalGasInput = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  concentration?: InputMaybe<Scalars['Float']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  gasId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `CalGas`. Fields that are set will be updated. */
export type CalGasPatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  concentration?: InputMaybe<Scalars['Float']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  gasId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `MaintenanceVisitLine` object types. All fields are combined with a logical ‘and.’ */
export type CalGasToManyMaintenanceVisitLineFilter = {
  /** Every related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitLineFilter>;
  /** No related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitLineFilter>;
  /** Some related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitLineFilter>;
};

/** A filter to be used against many `SensorTestResult` object types. All fields are combined with a logical ‘and.’ */
export type CalGasToManySensorTestResultFilter = {
  /** Every related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTestResultFilter>;
  /** No related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTestResultFilter>;
  /** Some related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTestResultFilter>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type CalGasToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `CalGas` values. */
export type CalGasesConnection = {
  __typename?: 'CalGasesConnection';
  /** A list of edges which contains the `CalGas` and cursor to aid in pagination. */
  edges: Array<CalGasesEdge>;
  /** A list of `CalGas` objects. */
  nodes: Array<CalGas>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CalGas` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CalGas` edge in the connection. */
export type CalGasesEdge = {
  __typename?: 'CalGasesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CalGas` at the end of the edge. */
  node: CalGas;
};

/** Methods to use when ordering `CalGas`. */
export enum CalGasesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  ConcentrationAsc = 'CONCENTRATION_ASC',
  ConcentrationDesc = 'CONCENTRATION_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EngineeringUnitsAsc = 'ENGINEERING_UNITS_ASC',
  EngineeringUnitsDesc = 'ENGINEERING_UNITS_DESC',
  GasByGasIdChemicalCompoundIdAsc = 'GAS_BY_GAS_ID__CHEMICAL_COMPOUND_ID_ASC',
  GasByGasIdChemicalCompoundIdDesc = 'GAS_BY_GAS_ID__CHEMICAL_COMPOUND_ID_DESC',
  GasByGasIdCreatedAsc = 'GAS_BY_GAS_ID__CREATED_ASC',
  GasByGasIdCreatedDesc = 'GAS_BY_GAS_ID__CREATED_DESC',
  GasByGasIdFormulaAsc = 'GAS_BY_GAS_ID__FORMULA_ASC',
  GasByGasIdFormulaDesc = 'GAS_BY_GAS_ID__FORMULA_DESC',
  GasByGasIdIdAsc = 'GAS_BY_GAS_ID__ID_ASC',
  GasByGasIdIdDesc = 'GAS_BY_GAS_ID__ID_DESC',
  GasByGasIdModifiedAsc = 'GAS_BY_GAS_ID__MODIFIED_ASC',
  GasByGasIdModifiedDesc = 'GAS_BY_GAS_ID__MODIFIED_DESC',
  GasByGasIdNameAsc = 'GAS_BY_GAS_ID__NAME_ASC',
  GasByGasIdNameDesc = 'GAS_BY_GAS_ID__NAME_DESC',
  GasByGasIdOwnerIdAsc = 'GAS_BY_GAS_ID__OWNER_ID_ASC',
  GasByGasIdOwnerIdDesc = 'GAS_BY_GAS_ID__OWNER_ID_DESC',
  GasIdAsc = 'GAS_ID_ASC',
  GasIdDesc = 'GAS_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceVisitLinesByCalGasIdCountAsc = 'MAINTENANCE_VISIT_LINES_BY_CAL_GAS_ID__COUNT_ASC',
  MaintenanceVisitLinesByCalGasIdCountDesc = 'MAINTENANCE_VISIT_LINES_BY_CAL_GAS_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorTestResultsByFsCalGasIdCountAsc = 'SENSOR_TEST_RESULTS_BY_FS_CAL_GAS_ID__COUNT_ASC',
  SensorTestResultsByFsCalGasIdCountDesc = 'SENSOR_TEST_RESULTS_BY_FS_CAL_GAS_ID__COUNT_DESC',
  SensorTypesByCalGasIdCountAsc = 'SENSOR_TYPES_BY_CAL_GAS_ID__COUNT_ASC',
  SensorTypesByCalGasIdCountDesc = 'SENSOR_TYPES_BY_CAL_GAS_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A connection to a list of `CalgasEntity` values. */
export type CalgasEntitiesConnection = {
  __typename?: 'CalgasEntitiesConnection';
  /** A list of edges which contains the `CalgasEntity` and cursor to aid in pagination. */
  edges: Array<CalgasEntitiesEdge>;
  /** A list of `CalgasEntity` objects. */
  nodes: Array<CalgasEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CalgasEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CalgasEntity` edge in the connection. */
export type CalgasEntitiesEdge = {
  __typename?: 'CalgasEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CalgasEntity` at the end of the edge. */
  node: CalgasEntity;
};

/** Methods to use when ordering `CalgasEntity`. */
export enum CalgasEntitiesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  ConcentrationAsc = 'CONCENTRATION_ASC',
  ConcentrationDesc = 'CONCENTRATION_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EngineeringUnitsAsc = 'ENGINEERING_UNITS_ASC',
  EngineeringUnitsDesc = 'ENGINEERING_UNITS_DESC',
  GasCreatedAsc = 'GAS_CREATED_ASC',
  GasCreatedDesc = 'GAS_CREATED_DESC',
  GasIdAsc = 'GAS_ID_ASC',
  GasIdDesc = 'GAS_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC'
}

export type CalgasEntity = {
  __typename?: 'CalgasEntity';
  cdartikel?: Maybe<Scalars['String']['output']>;
  concentration?: Maybe<Scalars['Float']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  engineeringUnits?: Maybe<Scalars['String']['output']>;
  gasCreated?: Maybe<Scalars['Datetime']['output']>;
  gasId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  username?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `CalgasEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CalgasEntityCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `concentration` field. */
  concentration?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gasCreated` field. */
  gasCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `gasId` field. */
  gasId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `CalgasEntity` object types. All fields are combined with a logical ‘and.’ */
export type CalgasEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CalgasEntityFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `concentration` field. */
  concentration?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gasCreated` field. */
  gasCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `gasId` field. */
  gasId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CalgasEntityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CalgasEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

export type CatalogGroup = Node & {
  __typename?: 'CatalogGroup';
  /** Reads and enables pagination through a set of `CatalogSubGroup`. */
  catalogSubGroupsByCatalogGroupId: CatalogSubGroupsConnection;
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  sortCode?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `CatalogGroup`. */
  userByOwnerId?: Maybe<User>;
};


export type CatalogGroupCatalogSubGroupsByCatalogGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogSubGroupCondition>;
  filter?: InputMaybe<CatalogSubGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogSubGroupsOrderBy>>;
};

/**
 * A condition to be used against `CatalogGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CatalogGroupCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sortCode` field. */
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `CatalogGroup` object types. All fields are combined with a logical ‘and.’ */
export type CatalogGroupFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CatalogGroupFilter>>;
  /** Filter by the object’s `catalogSubGroupsByCatalogGroupId` relation. */
  catalogSubGroupsByCatalogGroupId?: InputMaybe<CatalogGroupToManyCatalogSubGroupFilter>;
  /** Some related `catalogSubGroupsByCatalogGroupId` exist. */
  catalogSubGroupsByCatalogGroupIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CatalogGroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CatalogGroupFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sortCode` field. */
  sortCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `CatalogGroup` */
export type CatalogGroupInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `CatalogGroup`. Fields that are set will be updated. */
export type CatalogGroupPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `CatalogSubGroup` object types. All fields are combined with a logical ‘and.’ */
export type CatalogGroupToManyCatalogSubGroupFilter = {
  /** Every related `CatalogSubGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CatalogSubGroupFilter>;
  /** No related `CatalogSubGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CatalogSubGroupFilter>;
  /** Some related `CatalogSubGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CatalogSubGroupFilter>;
};

/** A connection to a list of `CatalogGroup` values. */
export type CatalogGroupsConnection = {
  __typename?: 'CatalogGroupsConnection';
  /** A list of edges which contains the `CatalogGroup` and cursor to aid in pagination. */
  edges: Array<CatalogGroupsEdge>;
  /** A list of `CatalogGroup` objects. */
  nodes: Array<CatalogGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CatalogGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CatalogGroup` edge in the connection. */
export type CatalogGroupsEdge = {
  __typename?: 'CatalogGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CatalogGroup` at the end of the edge. */
  node: CatalogGroup;
};

/** Methods to use when ordering `CatalogGroup`. */
export enum CatalogGroupsOrderBy {
  CatalogSubGroupsByCatalogGroupIdCountAsc = 'CATALOG_SUB_GROUPS_BY_CATALOG_GROUP_ID__COUNT_ASC',
  CatalogSubGroupsByCatalogGroupIdCountDesc = 'CATALOG_SUB_GROUPS_BY_CATALOG_GROUP_ID__COUNT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SortCodeAsc = 'SORT_CODE_ASC',
  SortCodeDesc = 'SORT_CODE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type CatalogItem = Node & {
  __typename?: 'CatalogItem';
  /** Reads and enables pagination through a set of `CatalogItemFile`. */
  catalogItemFilesByCatalogItemId: CatalogItemFilesConnection;
  /** Reads and enables pagination through a set of `CatalogItemRelation`. */
  catalogItemRelationsByChildCatalogItemId: CatalogItemRelationsConnection;
  /** Reads and enables pagination through a set of `CatalogItemRelation`. */
  catalogItemRelationsByParentCatalogItemId: CatalogItemRelationsConnection;
  /** Reads a single `CatalogSubGroup` that is related to this `CatalogItem`. */
  catalogSubGroupByCatalogSubGroupId?: Maybe<CatalogSubGroup>;
  catalogSubGroupId: Scalars['Int']['output'];
  cdartikel: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  defaultItem?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  remarks?: Maybe<Scalars['String']['output']>;
  sortCode?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `CatalogItem`. */
  userByOwnerId?: Maybe<User>;
};


export type CatalogItemCatalogItemFilesByCatalogItemIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemFileCondition>;
  filter?: InputMaybe<CatalogItemFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemFilesOrderBy>>;
};


export type CatalogItemCatalogItemRelationsByChildCatalogItemIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemRelationCondition>;
  filter?: InputMaybe<CatalogItemRelationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemRelationsOrderBy>>;
};


export type CatalogItemCatalogItemRelationsByParentCatalogItemIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemRelationCondition>;
  filter?: InputMaybe<CatalogItemRelationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemRelationsOrderBy>>;
};

/**
 * A condition to be used against `CatalogItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CatalogItemCondition = {
  /** Checks for equality with the object’s `catalogSubGroupId` field. */
  catalogSubGroupId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `defaultItem` field. */
  defaultItem?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sortCode` field. */
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

export type CatalogItemFile = Node & {
  __typename?: 'CatalogItemFile';
  /** Reads a single `CatalogItem` that is related to this `CatalogItemFile`. */
  catalogItemByCatalogItemId?: Maybe<CatalogItem>;
  catalogItemId: Scalars['Int']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  filename: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  type: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `CatalogItemFile`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `CatalogItemFile` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CatalogItemFileCondition = {
  /** Checks for equality with the object’s `catalogItemId` field. */
  catalogItemId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `filename` field. */
  filename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `CatalogItemFile` object types. All fields are combined with a logical ‘and.’ */
export type CatalogItemFileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CatalogItemFileFilter>>;
  /** Filter by the object’s `catalogItemByCatalogItemId` relation. */
  catalogItemByCatalogItemId?: InputMaybe<CatalogItemFilter>;
  /** Filter by the object’s `catalogItemId` field. */
  catalogItemId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `filename` field. */
  filename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CatalogItemFileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CatalogItemFileFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `CatalogItemFile` */
export type CatalogItemFileInput = {
  catalogItemId: Scalars['Int']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  filename: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  type: Scalars['Int']['input'];
};

/** Represents an update to a `CatalogItemFile`. Fields that are set will be updated. */
export type CatalogItemFilePatch = {
  catalogItemId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `CatalogItemFile` values. */
export type CatalogItemFilesConnection = {
  __typename?: 'CatalogItemFilesConnection';
  /** A list of edges which contains the `CatalogItemFile` and cursor to aid in pagination. */
  edges: Array<CatalogItemFilesEdge>;
  /** A list of `CatalogItemFile` objects. */
  nodes: Array<CatalogItemFile>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CatalogItemFile` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CatalogItemFile` edge in the connection. */
export type CatalogItemFilesEdge = {
  __typename?: 'CatalogItemFilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CatalogItemFile` at the end of the edge. */
  node: CatalogItemFile;
};

/** Methods to use when ordering `CatalogItemFile`. */
export enum CatalogItemFilesOrderBy {
  CatalogItemByCatalogItemIdCatalogSubGroupIdAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__CATALOG_SUB_GROUP_ID_ASC',
  CatalogItemByCatalogItemIdCatalogSubGroupIdDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__CATALOG_SUB_GROUP_ID_DESC',
  CatalogItemByCatalogItemIdCdartikelAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__CDARTIKEL_ASC',
  CatalogItemByCatalogItemIdCdartikelDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__CDARTIKEL_DESC',
  CatalogItemByCatalogItemIdCreatedAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__CREATED_ASC',
  CatalogItemByCatalogItemIdCreatedDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__CREATED_DESC',
  CatalogItemByCatalogItemIdDefaultItemAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__DEFAULT_ITEM_ASC',
  CatalogItemByCatalogItemIdDefaultItemDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__DEFAULT_ITEM_DESC',
  CatalogItemByCatalogItemIdIdAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__ID_ASC',
  CatalogItemByCatalogItemIdIdDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__ID_DESC',
  CatalogItemByCatalogItemIdModifiedAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__MODIFIED_ASC',
  CatalogItemByCatalogItemIdModifiedDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__MODIFIED_DESC',
  CatalogItemByCatalogItemIdOwnerIdAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__OWNER_ID_ASC',
  CatalogItemByCatalogItemIdOwnerIdDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__OWNER_ID_DESC',
  CatalogItemByCatalogItemIdRemarksAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__REMARKS_ASC',
  CatalogItemByCatalogItemIdRemarksDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__REMARKS_DESC',
  CatalogItemByCatalogItemIdSortCodeAsc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__SORT_CODE_ASC',
  CatalogItemByCatalogItemIdSortCodeDesc = 'CATALOG_ITEM_BY_CATALOG_ITEM_ID__SORT_CODE_DESC',
  CatalogItemIdAsc = 'CATALOG_ITEM_ID_ASC',
  CatalogItemIdDesc = 'CATALOG_ITEM_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  FilenameAsc = 'FILENAME_ASC',
  FilenameDesc = 'FILENAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A filter to be used against `CatalogItem` object types. All fields are combined with a logical ‘and.’ */
export type CatalogItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CatalogItemFilter>>;
  /** Filter by the object’s `catalogItemFilesByCatalogItemId` relation. */
  catalogItemFilesByCatalogItemId?: InputMaybe<CatalogItemToManyCatalogItemFileFilter>;
  /** Some related `catalogItemFilesByCatalogItemId` exist. */
  catalogItemFilesByCatalogItemIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `catalogItemRelationsByChildCatalogItemId` relation. */
  catalogItemRelationsByChildCatalogItemId?: InputMaybe<CatalogItemToManyCatalogItemRelationFilter>;
  /** Some related `catalogItemRelationsByChildCatalogItemId` exist. */
  catalogItemRelationsByChildCatalogItemIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `catalogItemRelationsByParentCatalogItemId` relation. */
  catalogItemRelationsByParentCatalogItemId?: InputMaybe<CatalogItemToManyCatalogItemRelationFilter>;
  /** Some related `catalogItemRelationsByParentCatalogItemId` exist. */
  catalogItemRelationsByParentCatalogItemIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `catalogSubGroupByCatalogSubGroupId` relation. */
  catalogSubGroupByCatalogSubGroupId?: InputMaybe<CatalogSubGroupFilter>;
  /** Filter by the object’s `catalogSubGroupId` field. */
  catalogSubGroupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `defaultItem` field. */
  defaultItem?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CatalogItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CatalogItemFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sortCode` field. */
  sortCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `CatalogItem` */
export type CatalogItemInput = {
  catalogSubGroupId: Scalars['Int']['input'];
  cdartikel: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  defaultItem?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  remarks?: InputMaybe<Scalars['String']['input']>;
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `CatalogItem`. Fields that are set will be updated. */
export type CatalogItemPatch = {
  catalogSubGroupId?: InputMaybe<Scalars['Int']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  defaultItem?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

export type CatalogItemRelation = Node & {
  __typename?: 'CatalogItemRelation';
  /** Reads a single `CatalogItem` that is related to this `CatalogItemRelation`. */
  catalogItemByChildCatalogItemId?: Maybe<CatalogItem>;
  /** Reads a single `CatalogItem` that is related to this `CatalogItemRelation`. */
  catalogItemByParentCatalogItemId?: Maybe<CatalogItem>;
  childCatalogItemId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentCatalogItemId: Scalars['Int']['output'];
};

/**
 * A condition to be used against `CatalogItemRelation` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type CatalogItemRelationCondition = {
  /** Checks for equality with the object’s `childCatalogItemId` field. */
  childCatalogItemId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `parentCatalogItemId` field. */
  parentCatalogItemId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `CatalogItemRelation` object types. All fields are combined with a logical ‘and.’ */
export type CatalogItemRelationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CatalogItemRelationFilter>>;
  /** Filter by the object’s `catalogItemByChildCatalogItemId` relation. */
  catalogItemByChildCatalogItemId?: InputMaybe<CatalogItemFilter>;
  /** Filter by the object’s `catalogItemByParentCatalogItemId` relation. */
  catalogItemByParentCatalogItemId?: InputMaybe<CatalogItemFilter>;
  /** Filter by the object’s `childCatalogItemId` field. */
  childCatalogItemId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CatalogItemRelationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CatalogItemRelationFilter>>;
  /** Filter by the object’s `parentCatalogItemId` field. */
  parentCatalogItemId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `CatalogItemRelation` */
export type CatalogItemRelationInput = {
  childCatalogItemId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  parentCatalogItemId: Scalars['Int']['input'];
};

/** Represents an update to a `CatalogItemRelation`. Fields that are set will be updated. */
export type CatalogItemRelationPatch = {
  childCatalogItemId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parentCatalogItemId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `CatalogItemRelation` values. */
export type CatalogItemRelationsConnection = {
  __typename?: 'CatalogItemRelationsConnection';
  /** A list of edges which contains the `CatalogItemRelation` and cursor to aid in pagination. */
  edges: Array<CatalogItemRelationsEdge>;
  /** A list of `CatalogItemRelation` objects. */
  nodes: Array<CatalogItemRelation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CatalogItemRelation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CatalogItemRelation` edge in the connection. */
export type CatalogItemRelationsEdge = {
  __typename?: 'CatalogItemRelationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CatalogItemRelation` at the end of the edge. */
  node: CatalogItemRelation;
};

/** Methods to use when ordering `CatalogItemRelation`. */
export enum CatalogItemRelationsOrderBy {
  CatalogItemByChildCatalogItemIdCatalogSubGroupIdAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__CATALOG_SUB_GROUP_ID_ASC',
  CatalogItemByChildCatalogItemIdCatalogSubGroupIdDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__CATALOG_SUB_GROUP_ID_DESC',
  CatalogItemByChildCatalogItemIdCdartikelAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__CDARTIKEL_ASC',
  CatalogItemByChildCatalogItemIdCdartikelDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__CDARTIKEL_DESC',
  CatalogItemByChildCatalogItemIdCreatedAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__CREATED_ASC',
  CatalogItemByChildCatalogItemIdCreatedDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__CREATED_DESC',
  CatalogItemByChildCatalogItemIdDefaultItemAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__DEFAULT_ITEM_ASC',
  CatalogItemByChildCatalogItemIdDefaultItemDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__DEFAULT_ITEM_DESC',
  CatalogItemByChildCatalogItemIdIdAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__ID_ASC',
  CatalogItemByChildCatalogItemIdIdDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__ID_DESC',
  CatalogItemByChildCatalogItemIdModifiedAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__MODIFIED_ASC',
  CatalogItemByChildCatalogItemIdModifiedDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__MODIFIED_DESC',
  CatalogItemByChildCatalogItemIdOwnerIdAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__OWNER_ID_ASC',
  CatalogItemByChildCatalogItemIdOwnerIdDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__OWNER_ID_DESC',
  CatalogItemByChildCatalogItemIdRemarksAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__REMARKS_ASC',
  CatalogItemByChildCatalogItemIdRemarksDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__REMARKS_DESC',
  CatalogItemByChildCatalogItemIdSortCodeAsc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__SORT_CODE_ASC',
  CatalogItemByChildCatalogItemIdSortCodeDesc = 'CATALOG_ITEM_BY_CHILD_CATALOG_ITEM_ID__SORT_CODE_DESC',
  CatalogItemByParentCatalogItemIdCatalogSubGroupIdAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__CATALOG_SUB_GROUP_ID_ASC',
  CatalogItemByParentCatalogItemIdCatalogSubGroupIdDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__CATALOG_SUB_GROUP_ID_DESC',
  CatalogItemByParentCatalogItemIdCdartikelAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__CDARTIKEL_ASC',
  CatalogItemByParentCatalogItemIdCdartikelDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__CDARTIKEL_DESC',
  CatalogItemByParentCatalogItemIdCreatedAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__CREATED_ASC',
  CatalogItemByParentCatalogItemIdCreatedDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__CREATED_DESC',
  CatalogItemByParentCatalogItemIdDefaultItemAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__DEFAULT_ITEM_ASC',
  CatalogItemByParentCatalogItemIdDefaultItemDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__DEFAULT_ITEM_DESC',
  CatalogItemByParentCatalogItemIdIdAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__ID_ASC',
  CatalogItemByParentCatalogItemIdIdDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__ID_DESC',
  CatalogItemByParentCatalogItemIdModifiedAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__MODIFIED_ASC',
  CatalogItemByParentCatalogItemIdModifiedDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__MODIFIED_DESC',
  CatalogItemByParentCatalogItemIdOwnerIdAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__OWNER_ID_ASC',
  CatalogItemByParentCatalogItemIdOwnerIdDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__OWNER_ID_DESC',
  CatalogItemByParentCatalogItemIdRemarksAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__REMARKS_ASC',
  CatalogItemByParentCatalogItemIdRemarksDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__REMARKS_DESC',
  CatalogItemByParentCatalogItemIdSortCodeAsc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__SORT_CODE_ASC',
  CatalogItemByParentCatalogItemIdSortCodeDesc = 'CATALOG_ITEM_BY_PARENT_CATALOG_ITEM_ID__SORT_CODE_DESC',
  ChildCatalogItemIdAsc = 'CHILD_CATALOG_ITEM_ID_ASC',
  ChildCatalogItemIdDesc = 'CHILD_CATALOG_ITEM_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  ParentCatalogItemIdAsc = 'PARENT_CATALOG_ITEM_ID_ASC',
  ParentCatalogItemIdDesc = 'PARENT_CATALOG_ITEM_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against many `CatalogItemFile` object types. All fields are combined with a logical ‘and.’ */
export type CatalogItemToManyCatalogItemFileFilter = {
  /** Every related `CatalogItemFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CatalogItemFileFilter>;
  /** No related `CatalogItemFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CatalogItemFileFilter>;
  /** Some related `CatalogItemFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CatalogItemFileFilter>;
};

/** A filter to be used against many `CatalogItemRelation` object types. All fields are combined with a logical ‘and.’ */
export type CatalogItemToManyCatalogItemRelationFilter = {
  /** Every related `CatalogItemRelation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CatalogItemRelationFilter>;
  /** No related `CatalogItemRelation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CatalogItemRelationFilter>;
  /** Some related `CatalogItemRelation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CatalogItemRelationFilter>;
};

/** A connection to a list of `CatalogItem` values. */
export type CatalogItemsConnection = {
  __typename?: 'CatalogItemsConnection';
  /** A list of edges which contains the `CatalogItem` and cursor to aid in pagination. */
  edges: Array<CatalogItemsEdge>;
  /** A list of `CatalogItem` objects. */
  nodes: Array<CatalogItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CatalogItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CatalogItem` edge in the connection. */
export type CatalogItemsEdge = {
  __typename?: 'CatalogItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CatalogItem` at the end of the edge. */
  node: CatalogItem;
};

/** Methods to use when ordering `CatalogItem`. */
export enum CatalogItemsOrderBy {
  CatalogItemFilesByCatalogItemIdCountAsc = 'CATALOG_ITEM_FILES_BY_CATALOG_ITEM_ID__COUNT_ASC',
  CatalogItemFilesByCatalogItemIdCountDesc = 'CATALOG_ITEM_FILES_BY_CATALOG_ITEM_ID__COUNT_DESC',
  CatalogItemRelationsByChildCatalogItemIdCountAsc = 'CATALOG_ITEM_RELATIONS_BY_CHILD_CATALOG_ITEM_ID__COUNT_ASC',
  CatalogItemRelationsByChildCatalogItemIdCountDesc = 'CATALOG_ITEM_RELATIONS_BY_CHILD_CATALOG_ITEM_ID__COUNT_DESC',
  CatalogItemRelationsByParentCatalogItemIdCountAsc = 'CATALOG_ITEM_RELATIONS_BY_PARENT_CATALOG_ITEM_ID__COUNT_ASC',
  CatalogItemRelationsByParentCatalogItemIdCountDesc = 'CATALOG_ITEM_RELATIONS_BY_PARENT_CATALOG_ITEM_ID__COUNT_DESC',
  CatalogSubGroupByCatalogSubGroupIdCatalogGroupIdAsc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__CATALOG_GROUP_ID_ASC',
  CatalogSubGroupByCatalogSubGroupIdCatalogGroupIdDesc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__CATALOG_GROUP_ID_DESC',
  CatalogSubGroupByCatalogSubGroupIdCreatedAsc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__CREATED_ASC',
  CatalogSubGroupByCatalogSubGroupIdCreatedDesc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__CREATED_DESC',
  CatalogSubGroupByCatalogSubGroupIdIdAsc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__ID_ASC',
  CatalogSubGroupByCatalogSubGroupIdIdDesc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__ID_DESC',
  CatalogSubGroupByCatalogSubGroupIdModifiedAsc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__MODIFIED_ASC',
  CatalogSubGroupByCatalogSubGroupIdModifiedDesc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__MODIFIED_DESC',
  CatalogSubGroupByCatalogSubGroupIdNameAsc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__NAME_ASC',
  CatalogSubGroupByCatalogSubGroupIdNameDesc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__NAME_DESC',
  CatalogSubGroupByCatalogSubGroupIdOwnerIdAsc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__OWNER_ID_ASC',
  CatalogSubGroupByCatalogSubGroupIdOwnerIdDesc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__OWNER_ID_DESC',
  CatalogSubGroupByCatalogSubGroupIdSortCodeAsc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__SORT_CODE_ASC',
  CatalogSubGroupByCatalogSubGroupIdSortCodeDesc = 'CATALOG_SUB_GROUP_BY_CATALOG_SUB_GROUP_ID__SORT_CODE_DESC',
  CatalogSubGroupIdAsc = 'CATALOG_SUB_GROUP_ID_ASC',
  CatalogSubGroupIdDesc = 'CATALOG_SUB_GROUP_ID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DefaultItemAsc = 'DEFAULT_ITEM_ASC',
  DefaultItemDesc = 'DEFAULT_ITEM_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  SortCodeAsc = 'SORT_CODE_ASC',
  SortCodeDesc = 'SORT_CODE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type CatalogSubGroup = Node & {
  __typename?: 'CatalogSubGroup';
  /** Reads a single `CatalogGroup` that is related to this `CatalogSubGroup`. */
  catalogGroupByCatalogGroupId?: Maybe<CatalogGroup>;
  catalogGroupId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `CatalogItem`. */
  catalogItemsByCatalogSubGroupId: CatalogItemsConnection;
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  sortCode?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `CatalogSubGroup`. */
  userByOwnerId?: Maybe<User>;
};


export type CatalogSubGroupCatalogItemsByCatalogSubGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemCondition>;
  filter?: InputMaybe<CatalogItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemsOrderBy>>;
};

/**
 * A condition to be used against `CatalogSubGroup` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CatalogSubGroupCondition = {
  /** Checks for equality with the object’s `catalogGroupId` field. */
  catalogGroupId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sortCode` field. */
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `CatalogSubGroup` object types. All fields are combined with a logical ‘and.’ */
export type CatalogSubGroupFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CatalogSubGroupFilter>>;
  /** Filter by the object’s `catalogGroupByCatalogGroupId` relation. */
  catalogGroupByCatalogGroupId?: InputMaybe<CatalogGroupFilter>;
  /** Filter by the object’s `catalogGroupId` field. */
  catalogGroupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `catalogItemsByCatalogSubGroupId` relation. */
  catalogItemsByCatalogSubGroupId?: InputMaybe<CatalogSubGroupToManyCatalogItemFilter>;
  /** Some related `catalogItemsByCatalogSubGroupId` exist. */
  catalogItemsByCatalogSubGroupIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CatalogSubGroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CatalogSubGroupFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sortCode` field. */
  sortCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `CatalogSubGroup` */
export type CatalogSubGroupInput = {
  catalogGroupId: Scalars['Int']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `CatalogSubGroup`. Fields that are set will be updated. */
export type CatalogSubGroupPatch = {
  catalogGroupId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sortCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `CatalogItem` object types. All fields are combined with a logical ‘and.’ */
export type CatalogSubGroupToManyCatalogItemFilter = {
  /** Every related `CatalogItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CatalogItemFilter>;
  /** No related `CatalogItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CatalogItemFilter>;
  /** Some related `CatalogItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CatalogItemFilter>;
};

/** A connection to a list of `CatalogSubGroup` values. */
export type CatalogSubGroupsConnection = {
  __typename?: 'CatalogSubGroupsConnection';
  /** A list of edges which contains the `CatalogSubGroup` and cursor to aid in pagination. */
  edges: Array<CatalogSubGroupsEdge>;
  /** A list of `CatalogSubGroup` objects. */
  nodes: Array<CatalogSubGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CatalogSubGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CatalogSubGroup` edge in the connection. */
export type CatalogSubGroupsEdge = {
  __typename?: 'CatalogSubGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CatalogSubGroup` at the end of the edge. */
  node: CatalogSubGroup;
};

/** Methods to use when ordering `CatalogSubGroup`. */
export enum CatalogSubGroupsOrderBy {
  CatalogGroupByCatalogGroupIdCreatedAsc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__CREATED_ASC',
  CatalogGroupByCatalogGroupIdCreatedDesc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__CREATED_DESC',
  CatalogGroupByCatalogGroupIdIdAsc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__ID_ASC',
  CatalogGroupByCatalogGroupIdIdDesc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__ID_DESC',
  CatalogGroupByCatalogGroupIdModifiedAsc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__MODIFIED_ASC',
  CatalogGroupByCatalogGroupIdModifiedDesc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__MODIFIED_DESC',
  CatalogGroupByCatalogGroupIdNameAsc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__NAME_ASC',
  CatalogGroupByCatalogGroupIdNameDesc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__NAME_DESC',
  CatalogGroupByCatalogGroupIdOwnerIdAsc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__OWNER_ID_ASC',
  CatalogGroupByCatalogGroupIdOwnerIdDesc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__OWNER_ID_DESC',
  CatalogGroupByCatalogGroupIdSortCodeAsc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__SORT_CODE_ASC',
  CatalogGroupByCatalogGroupIdSortCodeDesc = 'CATALOG_GROUP_BY_CATALOG_GROUP_ID__SORT_CODE_DESC',
  CatalogGroupIdAsc = 'CATALOG_GROUP_ID_ASC',
  CatalogGroupIdDesc = 'CATALOG_GROUP_ID_DESC',
  CatalogItemsByCatalogSubGroupIdCountAsc = 'CATALOG_ITEMS_BY_CATALOG_SUB_GROUP_ID__COUNT_ASC',
  CatalogItemsByCatalogSubGroupIdCountDesc = 'CATALOG_ITEMS_BY_CATALOG_SUB_GROUP_ID__COUNT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SortCodeAsc = 'SORT_CODE_ASC',
  SortCodeDesc = 'SORT_CODE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type CdartikelJoin = {
  __typename?: 'CdartikelJoin';
  advice?: Maybe<Scalars['Int']['output']>;
  artikelId?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  verkoopgegevensId?: Maybe<Scalars['String']['output']>;
  voorradenId?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `CdartikelJoin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CdartikelJoinCondition = {
  /** Checks for equality with the object’s `advice` field. */
  advice?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `artikelId` field. */
  artikelId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verkoopgegevensId` field. */
  verkoopgegevensId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorradenId` field. */
  voorradenId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `CdartikelJoin` object types. All fields are combined with a logical ‘and.’ */
export type CdartikelJoinFilter = {
  /** Filter by the object’s `advice` field. */
  advice?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CdartikelJoinFilter>>;
  /** Filter by the object’s `artikelId` field. */
  artikelId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CdartikelJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CdartikelJoinFilter>>;
  /** Filter by the object’s `verkoopgegevensId` field. */
  verkoopgegevensId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorradenId` field. */
  voorradenId?: InputMaybe<StringFilter>;
};

/** A connection to a list of `CdartikelJoin` values. */
export type CdartikelJoinsConnection = {
  __typename?: 'CdartikelJoinsConnection';
  /** A list of edges which contains the `CdartikelJoin` and cursor to aid in pagination. */
  edges: Array<CdartikelJoinsEdge>;
  /** A list of `CdartikelJoin` objects. */
  nodes: Array<CdartikelJoin>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CdartikelJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CdartikelJoin` edge in the connection. */
export type CdartikelJoinsEdge = {
  __typename?: 'CdartikelJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CdartikelJoin` at the end of the edge. */
  node: CdartikelJoin;
};

/** Methods to use when ordering `CdartikelJoin`. */
export enum CdartikelJoinsOrderBy {
  AdviceAsc = 'ADVICE_ASC',
  AdviceDesc = 'ADVICE_DESC',
  ArtikelIdAsc = 'ARTIKEL_ID_ASC',
  ArtikelIdDesc = 'ARTIKEL_ID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  Natural = 'NATURAL',
  VerkoopgegevensIdAsc = 'VERKOOPGEGEVENS_ID_ASC',
  VerkoopgegevensIdDesc = 'VERKOOPGEGEVENS_ID_DESC',
  VoorradenIdAsc = 'VOORRADEN_ID_ASC',
  VoorradenIdDesc = 'VOORRADEN_ID_DESC'
}

export type ChemicalCompound = Node & {
  __typename?: 'ChemicalCompound';
  cas?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  density?: Maybe<Scalars['Float']['output']>;
  formula?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Gas`. */
  gasesByChemicalCompoundId: GasesConnection;
  icsc?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  molarMass?: Maybe<Scalars['Float']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  otherName?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `ChemicalCompound`. */
  userByOwnerId?: Maybe<User>;
};


export type ChemicalCompoundGasesByChemicalCompoundIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GasCondition>;
  filter?: InputMaybe<GasFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GasesOrderBy>>;
};

/**
 * A condition to be used against `ChemicalCompound` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ChemicalCompoundCondition = {
  /** Checks for equality with the object’s `cas` field. */
  cas?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `density` field. */
  density?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `formula` field. */
  formula?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `icsc` field. */
  icsc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `molarMass` field. */
  molarMass?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `otherName` field. */
  otherName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ChemicalCompound` object types. All fields are combined with a logical ‘and.’ */
export type ChemicalCompoundFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ChemicalCompoundFilter>>;
  /** Filter by the object’s `cas` field. */
  cas?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `density` field. */
  density?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `formula` field. */
  formula?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gasesByChemicalCompoundId` relation. */
  gasesByChemicalCompoundId?: InputMaybe<ChemicalCompoundToManyGasFilter>;
  /** Some related `gasesByChemicalCompoundId` exist. */
  gasesByChemicalCompoundIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `icsc` field. */
  icsc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `molarMass` field. */
  molarMass?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ChemicalCompoundFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ChemicalCompoundFilter>>;
  /** Filter by the object’s `otherName` field. */
  otherName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `url` field. */
  url?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `ChemicalCompound` */
export type ChemicalCompoundInput = {
  cas?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  density?: InputMaybe<Scalars['Float']['input']>;
  formula?: InputMaybe<Scalars['String']['input']>;
  icsc?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  molarMass?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  otherName?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `ChemicalCompound`. Fields that are set will be updated. */
export type ChemicalCompoundPatch = {
  cas?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  density?: InputMaybe<Scalars['Float']['input']>;
  formula?: InputMaybe<Scalars['String']['input']>;
  icsc?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  molarMass?: InputMaybe<Scalars['Float']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  otherName?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `Gas` object types. All fields are combined with a logical ‘and.’ */
export type ChemicalCompoundToManyGasFilter = {
  /** Every related `Gas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<GasFilter>;
  /** No related `Gas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<GasFilter>;
  /** Some related `Gas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<GasFilter>;
};

/** A connection to a list of `ChemicalCompound` values. */
export type ChemicalCompoundsConnection = {
  __typename?: 'ChemicalCompoundsConnection';
  /** A list of edges which contains the `ChemicalCompound` and cursor to aid in pagination. */
  edges: Array<ChemicalCompoundsEdge>;
  /** A list of `ChemicalCompound` objects. */
  nodes: Array<ChemicalCompound>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ChemicalCompound` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ChemicalCompound` edge in the connection. */
export type ChemicalCompoundsEdge = {
  __typename?: 'ChemicalCompoundsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ChemicalCompound` at the end of the edge. */
  node: ChemicalCompound;
};

/** Methods to use when ordering `ChemicalCompound`. */
export enum ChemicalCompoundsOrderBy {
  CasAsc = 'CAS_ASC',
  CasDesc = 'CAS_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DensityAsc = 'DENSITY_ASC',
  DensityDesc = 'DENSITY_DESC',
  FormulaAsc = 'FORMULA_ASC',
  FormulaDesc = 'FORMULA_DESC',
  GasesByChemicalCompoundIdCountAsc = 'GASES_BY_CHEMICAL_COMPOUND_ID__COUNT_ASC',
  GasesByChemicalCompoundIdCountDesc = 'GASES_BY_CHEMICAL_COMPOUND_ID__COUNT_DESC',
  IcscAsc = 'ICSC_ASC',
  IcscDesc = 'ICSC_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  MolarMassAsc = 'MOLAR_MASS_ASC',
  MolarMassDesc = 'MOLAR_MASS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OtherNameAsc = 'OTHER_NAME_ASC',
  OtherNameDesc = 'OTHER_NAME_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type ContactpersoonMv = {
  __typename?: 'ContactpersoonMv';
  cdaanhef?: Maybe<Scalars['String']['output']>;
  cdcontact?: Maybe<Scalars['String']['output']>;
  cdfunctie?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdtitelna?: Maybe<Scalars['String']['output']>;
  cdtitelvoor?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  geslacht?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  voorletters?: Maybe<Scalars['String']['output']>;
  voornaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ContactpersoonMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ContactpersoonMvCondition = {
  /** Checks for equality with the object’s `cdaanhef` field. */
  cdaanhef?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcontact` field. */
  cdcontact?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfunctie` field. */
  cdfunctie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geslacht` field. */
  geslacht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorletters` field. */
  voorletters?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voornaam` field. */
  voornaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ContactpersoonMv` object types. All fields are combined with a logical ‘and.’ */
export type ContactpersoonMvFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ContactpersoonMvFilter>>;
  /** Filter by the object’s `cdaanhef` field. */
  cdaanhef?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcontact` field. */
  cdcontact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfunctie` field. */
  cdfunctie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geslacht` field. */
  geslacht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ContactpersoonMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ContactpersoonMvFilter>>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorletters` field. */
  voorletters?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voornaam` field. */
  voornaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `ContactpersoonMv` values. */
export type ContactpersoonMvsConnection = {
  __typename?: 'ContactpersoonMvsConnection';
  /** A list of edges which contains the `ContactpersoonMv` and cursor to aid in pagination. */
  edges: Array<ContactpersoonMvsEdge>;
  /** A list of `ContactpersoonMv` objects. */
  nodes: Array<ContactpersoonMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContactpersoonMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ContactpersoonMv` edge in the connection. */
export type ContactpersoonMvsEdge = {
  __typename?: 'ContactpersoonMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ContactpersoonMv` at the end of the edge. */
  node: ContactpersoonMv;
};

/** Methods to use when ordering `ContactpersoonMv`. */
export enum ContactpersoonMvsOrderBy {
  CdaanhefAsc = 'CDAANHEF_ASC',
  CdaanhefDesc = 'CDAANHEF_DESC',
  CdcontactAsc = 'CDCONTACT_ASC',
  CdcontactDesc = 'CDCONTACT_DESC',
  CdfunctieAsc = 'CDFUNCTIE_ASC',
  CdfunctieDesc = 'CDFUNCTIE_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdtitelnaAsc = 'CDTITELNA_ASC',
  CdtitelnaDesc = 'CDTITELNA_DESC',
  CdtitelvoorAsc = 'CDTITELVOOR_ASC',
  CdtitelvoorDesc = 'CDTITELVOOR_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  GeslachtAsc = 'GESLACHT_ASC',
  GeslachtDesc = 'GESLACHT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  VoorlettersAsc = 'VOORLETTERS_ASC',
  VoorlettersDesc = 'VOORLETTERS_DESC',
  VoornaamAsc = 'VOORNAAM_ASC',
  VoornaamDesc = 'VOORNAAM_DESC'
}

/** All input for the create `Aco` mutation. */
export type CreateAcoInput = {
  /** The `Aco` to be created by this mutation. */
  aco: AcoInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Aco` mutation. */
export type CreateAcoPayload = {
  __typename?: 'CreateAcoPayload';
  /** The `Aco` that was created by this mutation. */
  aco?: Maybe<Aco>;
  /** An edge for our `Aco`. May be used by Relay 1. */
  acoEdge?: Maybe<AcosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Aco` mutation. */
export type CreateAcoPayloadAcoEdgeArgs = {
  orderBy?: InputMaybe<Array<AcosOrderBy>>;
};

/** All input for the create `Action` mutation. */
export type CreateActionInput = {
  /** The `Action` to be created by this mutation. */
  action: ActionInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Action` mutation. */
export type CreateActionPayload = {
  __typename?: 'CreateActionPayload';
  /** The `Action` that was created by this mutation. */
  action?: Maybe<Action>;
  /** An edge for our `Action`. May be used by Relay 1. */
  actionEdge?: Maybe<ActionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `Action`. */
  groupByGroupId?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `Action`. */
  reportByReportId?: Maybe<Report>;
  /** Reads a single `User` that is related to this `Action`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Action`. */
  userByUserId?: Maybe<User>;
};


/** The output of our create `Action` mutation. */
export type CreateActionPayloadActionEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionsOrderBy>>;
};

/** All input for the create `_Adre` mutation. */
export type CreateAdreInput = {
  /** The `_Adre` to be created by this mutation. */
  _adre: _AdreInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `_Adre` mutation. */
export type CreateAdrePayload = {
  __typename?: 'CreateAdrePayload';
  /** The `_Adre` that was created by this mutation. */
  _adre?: Maybe<_Adre>;
  /** An edge for our `_Adre`. May be used by Relay 1. */
  _adreEdge?: Maybe<_AdresEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `_Adre` mutation. */
export type CreateAdrePayload_AdreEdgeArgs = {
  orderBy?: InputMaybe<Array<_AdresOrderBy>>;
};

/** All input for the create `AnotherRefreshToken` mutation. */
export type CreateAnotherRefreshTokenInput = {
  /** The `AnotherRefreshToken` to be created by this mutation. */
  anotherRefreshToken: AnotherRefreshTokenInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AnotherRefreshToken` mutation. */
export type CreateAnotherRefreshTokenPayload = {
  __typename?: 'CreateAnotherRefreshTokenPayload';
  /** The `AnotherRefreshToken` that was created by this mutation. */
  anotherRefreshToken?: Maybe<AnotherRefreshToken>;
  /** An edge for our `AnotherRefreshToken`. May be used by Relay 1. */
  anotherRefreshTokenEdge?: Maybe<AnotherRefreshTokensEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AnotherRefreshToken` mutation. */
export type CreateAnotherRefreshTokenPayloadAnotherRefreshTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<AnotherRefreshTokensOrderBy>>;
};

/** All input for the create `Application` mutation. */
export type CreateApplicationInput = {
  /** The `Application` to be created by this mutation. */
  application: ApplicationInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Application` mutation. */
export type CreateApplicationPayload = {
  __typename?: 'CreateApplicationPayload';
  /** The `Application` that was created by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Application`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Application` mutation. */
export type CreateApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the create `Area` mutation. */
export type CreateAreaInput = {
  /** The `Area` to be created by this mutation. */
  area: AreaInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Area` mutation. */
export type CreateAreaPayload = {
  __typename?: 'CreateAreaPayload';
  /** The `Area` that was created by this mutation. */
  area?: Maybe<Area>;
  /** An edge for our `Area`. May be used by Relay 1. */
  areaEdge?: Maybe<AreasEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Floor` that is related to this `Area`. */
  floorByFloorId?: Maybe<Floor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Area`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Area` mutation. */
export type CreateAreaPayloadAreaEdgeArgs = {
  orderBy?: InputMaybe<Array<AreasOrderBy>>;
};

/** All input for the create `Aro` mutation. */
export type CreateAroInput = {
  /** The `Aro` to be created by this mutation. */
  aro: AroInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Aro` mutation. */
export type CreateAroPayload = {
  __typename?: 'CreateAroPayload';
  /** The `Aro` that was created by this mutation. */
  aro?: Maybe<Aro>;
  /** An edge for our `Aro`. May be used by Relay 1. */
  aroEdge?: Maybe<ArosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Aro` mutation. */
export type CreateAroPayloadAroEdgeArgs = {
  orderBy?: InputMaybe<Array<ArosOrderBy>>;
};

/** All input for the create `ArosAco` mutation. */
export type CreateArosAcoInput = {
  /** The `ArosAco` to be created by this mutation. */
  arosAco: ArosAcoInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ArosAco` mutation. */
export type CreateArosAcoPayload = {
  __typename?: 'CreateArosAcoPayload';
  /** The `ArosAco` that was created by this mutation. */
  arosAco?: Maybe<ArosAco>;
  /** An edge for our `ArosAco`. May be used by Relay 1. */
  arosAcoEdge?: Maybe<ArosAcosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ArosAco` mutation. */
export type CreateArosAcoPayloadArosAcoEdgeArgs = {
  orderBy?: InputMaybe<Array<ArosAcosOrderBy>>;
};

/** All input for the create `Artikel` mutation. */
export type CreateArtikelInput = {
  /** The `Artikel` to be created by this mutation. */
  artikel: ArtikelInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the create `ArtikelLog` mutation. */
export type CreateArtikelLogInput = {
  /** The `ArtikelLog` to be created by this mutation. */
  artikelLog: ArtikelLogInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ArtikelLog` mutation. */
export type CreateArtikelLogPayload = {
  __typename?: 'CreateArtikelLogPayload';
  /** The `ArtikelLog` that was created by this mutation. */
  artikelLog?: Maybe<ArtikelLog>;
  /** An edge for our `ArtikelLog`. May be used by Relay 1. */
  artikelLogEdge?: Maybe<ArtikelLogsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ArtikelLog` mutation. */
export type CreateArtikelLogPayloadArtikelLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelLogsOrderBy>>;
};

/** The output of our create `Artikel` mutation. */
export type CreateArtikelPayload = {
  __typename?: 'CreateArtikelPayload';
  /** The `Artikel` that was created by this mutation. */
  artikel?: Maybe<Artikel>;
  /** An edge for our `Artikel`. May be used by Relay 1. */
  artikelEdge?: Maybe<ArtikelsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Artikel` mutation. */
export type CreateArtikelPayloadArtikelEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelsOrderBy>>;
};

/** All input for the create `Artikelomschr` mutation. */
export type CreateArtikelomschrInput = {
  /** The `Artikelomschr` to be created by this mutation. */
  artikelomschr: ArtikelomschrInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Artikelomschr` mutation. */
export type CreateArtikelomschrPayload = {
  __typename?: 'CreateArtikelomschrPayload';
  /** The `Artikelomschr` that was created by this mutation. */
  artikelomschr?: Maybe<Artikelomschr>;
  /** An edge for our `Artikelomschr`. May be used by Relay 1. */
  artikelomschrEdge?: Maybe<ArtikelomschrsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Artikelomschr` mutation. */
export type CreateArtikelomschrPayloadArtikelomschrEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelomschrsOrderBy>>;
};

/** All input for the create `AspNetRoleClaim` mutation. */
export type CreateAspNetRoleClaimInput = {
  /** The `AspNetRoleClaim` to be created by this mutation. */
  aspNetRoleClaim: AspNetRoleClaimInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AspNetRoleClaim` mutation. */
export type CreateAspNetRoleClaimPayload = {
  __typename?: 'CreateAspNetRoleClaimPayload';
  /** Reads a single `AspNetRole` that is related to this `AspNetRoleClaim`. */
  aspNetRoleByRoleId?: Maybe<AspNetRole>;
  /** The `AspNetRoleClaim` that was created by this mutation. */
  aspNetRoleClaim?: Maybe<AspNetRoleClaim>;
  /** An edge for our `AspNetRoleClaim`. May be used by Relay 1. */
  aspNetRoleClaimEdge?: Maybe<AspNetRoleClaimsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AspNetRoleClaim` mutation. */
export type CreateAspNetRoleClaimPayloadAspNetRoleClaimEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetRoleClaimsOrderBy>>;
};

/** All input for the create `AspNetRole` mutation. */
export type CreateAspNetRoleInput = {
  /** The `AspNetRole` to be created by this mutation. */
  aspNetRole: AspNetRoleInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AspNetRole` mutation. */
export type CreateAspNetRolePayload = {
  __typename?: 'CreateAspNetRolePayload';
  /** The `AspNetRole` that was created by this mutation. */
  aspNetRole?: Maybe<AspNetRole>;
  /** An edge for our `AspNetRole`. May be used by Relay 1. */
  aspNetRoleEdge?: Maybe<AspNetRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AspNetRole` mutation. */
export type CreateAspNetRolePayloadAspNetRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetRolesOrderBy>>;
};

/** All input for the create `AspNetUserClaim` mutation. */
export type CreateAspNetUserClaimInput = {
  /** The `AspNetUserClaim` to be created by this mutation. */
  aspNetUserClaim: AspNetUserClaimInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AspNetUserClaim` mutation. */
export type CreateAspNetUserClaimPayload = {
  __typename?: 'CreateAspNetUserClaimPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserClaim`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserClaim` that was created by this mutation. */
  aspNetUserClaim?: Maybe<AspNetUserClaim>;
  /** An edge for our `AspNetUserClaim`. May be used by Relay 1. */
  aspNetUserClaimEdge?: Maybe<AspNetUserClaimsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AspNetUserClaim` mutation. */
export type CreateAspNetUserClaimPayloadAspNetUserClaimEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserClaimsOrderBy>>;
};

/** All input for the create `AspNetUser` mutation. */
export type CreateAspNetUserInput = {
  /** The `AspNetUser` to be created by this mutation. */
  aspNetUser: AspNetUserInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the create `AspNetUserLogin` mutation. */
export type CreateAspNetUserLoginInput = {
  /** The `AspNetUserLogin` to be created by this mutation. */
  aspNetUserLogin: AspNetUserLoginInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AspNetUserLogin` mutation. */
export type CreateAspNetUserLoginPayload = {
  __typename?: 'CreateAspNetUserLoginPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserLogin`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserLogin` that was created by this mutation. */
  aspNetUserLogin?: Maybe<AspNetUserLogin>;
  /** An edge for our `AspNetUserLogin`. May be used by Relay 1. */
  aspNetUserLoginEdge?: Maybe<AspNetUserLoginsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AspNetUserLogin` mutation. */
export type CreateAspNetUserLoginPayloadAspNetUserLoginEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserLoginsOrderBy>>;
};

/** The output of our create `AspNetUser` mutation. */
export type CreateAspNetUserPayload = {
  __typename?: 'CreateAspNetUserPayload';
  /** The `AspNetUser` that was created by this mutation. */
  aspNetUser?: Maybe<AspNetUser>;
  /** An edge for our `AspNetUser`. May be used by Relay 1. */
  aspNetUserEdge?: Maybe<AspNetUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AspNetUser` mutation. */
export type CreateAspNetUserPayloadAspNetUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUsersOrderBy>>;
};

/** All input for the create `AspNetUserRole` mutation. */
export type CreateAspNetUserRoleInput = {
  /** The `AspNetUserRole` to be created by this mutation. */
  aspNetUserRole: AspNetUserRoleInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AspNetUserRole` mutation. */
export type CreateAspNetUserRolePayload = {
  __typename?: 'CreateAspNetUserRolePayload';
  /** Reads a single `AspNetRole` that is related to this `AspNetUserRole`. */
  aspNetRoleByRoleId?: Maybe<AspNetRole>;
  /** Reads a single `AspNetUser` that is related to this `AspNetUserRole`. */
  aspNetUserByAppUserId?: Maybe<AspNetUser>;
  /** Reads a single `AspNetUser` that is related to this `AspNetUserRole`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserRole` that was created by this mutation. */
  aspNetUserRole?: Maybe<AspNetUserRole>;
  /** An edge for our `AspNetUserRole`. May be used by Relay 1. */
  aspNetUserRoleEdge?: Maybe<AspNetUserRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AspNetUserRole` mutation. */
export type CreateAspNetUserRolePayloadAspNetUserRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserRolesOrderBy>>;
};

/** All input for the create `AspNetUserToken` mutation. */
export type CreateAspNetUserTokenInput = {
  /** The `AspNetUserToken` to be created by this mutation. */
  aspNetUserToken: AspNetUserTokenInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AspNetUserToken` mutation. */
export type CreateAspNetUserTokenPayload = {
  __typename?: 'CreateAspNetUserTokenPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserToken`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserToken` that was created by this mutation. */
  aspNetUserToken?: Maybe<AspNetUserToken>;
  /** An edge for our `AspNetUserToken`. May be used by Relay 1. */
  aspNetUserTokenEdge?: Maybe<AspNetUserTokensEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AspNetUserToken` mutation. */
export type CreateAspNetUserTokenPayloadAspNetUserTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserTokensOrderBy>>;
};

/** All input for the create `Assembly` mutation. */
export type CreateAssemblyInput = {
  /** The `Assembly` to be created by this mutation. */
  assembly: AssemblyInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the create `AssemblyPart` mutation. */
export type CreateAssemblyPartInput = {
  /** The `AssemblyPart` to be created by this mutation. */
  assemblyPart: AssemblyPartInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AssemblyPart` mutation. */
export type CreateAssemblyPartPayload = {
  __typename?: 'CreateAssemblyPartPayload';
  /** The `AssemblyPart` that was created by this mutation. */
  assemblyPart?: Maybe<AssemblyPart>;
  /** An edge for our `AssemblyPart`. May be used by Relay 1. */
  assemblyPartEdge?: Maybe<AssemblyPartsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyPart`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `AssemblyPart` mutation. */
export type CreateAssemblyPartPayloadAssemblyPartEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyPartsOrderBy>>;
};

/** The output of our create `Assembly` mutation. */
export type CreateAssemblyPayload = {
  __typename?: 'CreateAssemblyPayload';
  /** The `Assembly` that was created by this mutation. */
  assembly?: Maybe<Assembly>;
  /** An edge for our `Assembly`. May be used by Relay 1. */
  assemblyEdge?: Maybe<AssembliesEdge>;
  /** Reads a single `AssemblyType` that is related to this `Assembly`. */
  assemblyTypeByAssemblyTypeId?: Maybe<AssemblyType>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Assembly`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Assembly` mutation. */
export type CreateAssemblyPayloadAssemblyEdgeArgs = {
  orderBy?: InputMaybe<Array<AssembliesOrderBy>>;
};

/** All input for the create `AssemblyType` mutation. */
export type CreateAssemblyTypeInput = {
  /** The `AssemblyType` to be created by this mutation. */
  assemblyType: AssemblyTypeInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the create `AssemblyTypePart` mutation. */
export type CreateAssemblyTypePartInput = {
  /** The `AssemblyTypePart` to be created by this mutation. */
  assemblyTypePart: AssemblyTypePartInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AssemblyTypePart` mutation. */
export type CreateAssemblyTypePartPayload = {
  __typename?: 'CreateAssemblyTypePartPayload';
  /** Reads a single `AssemblyType` that is related to this `AssemblyTypePart`. */
  assemblyTypeByAssemblyTypeId?: Maybe<AssemblyType>;
  /** The `AssemblyTypePart` that was created by this mutation. */
  assemblyTypePart?: Maybe<AssemblyTypePart>;
  /** An edge for our `AssemblyTypePart`. May be used by Relay 1. */
  assemblyTypePartEdge?: Maybe<AssemblyTypePartsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyTypePart`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `AssemblyTypePart` mutation. */
export type CreateAssemblyTypePartPayloadAssemblyTypePartEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyTypePartsOrderBy>>;
};

/** The output of our create `AssemblyType` mutation. */
export type CreateAssemblyTypePayload = {
  __typename?: 'CreateAssemblyTypePayload';
  /** Reads a single `Artikel` that is related to this `AssemblyType`. */
  artikelByCdartikel?: Maybe<Artikel>;
  /** The `AssemblyType` that was created by this mutation. */
  assemblyType?: Maybe<AssemblyType>;
  /** An edge for our `AssemblyType`. May be used by Relay 1. */
  assemblyTypeEdge?: Maybe<AssemblyTypesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `AssemblyType` mutation. */
export type CreateAssemblyTypePayloadAssemblyTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyTypesOrderBy>>;
};

/** All input for the create `Building` mutation. */
export type CreateBuildingInput = {
  /** The `Building` to be created by this mutation. */
  building: BuildingInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Building` mutation. */
export type CreateBuildingPayload = {
  __typename?: 'CreateBuildingPayload';
  /** The `Building` that was created by this mutation. */
  building?: Maybe<Building>;
  /** An edge for our `Building`. May be used by Relay 1. */
  buildingEdge?: Maybe<BuildingsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `Building`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Building`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Building` mutation. */
export type CreateBuildingPayloadBuildingEdgeArgs = {
  orderBy?: InputMaybe<Array<BuildingsOrderBy>>;
};

/** All input for the create `CalGas` mutation. */
export type CreateCalGasInput = {
  /** The `CalGas` to be created by this mutation. */
  calGas: CalGasInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CalGas` mutation. */
export type CreateCalGasPayload = {
  __typename?: 'CreateCalGasPayload';
  /** The `CalGas` that was created by this mutation. */
  calGas?: Maybe<CalGas>;
  /** An edge for our `CalGas`. May be used by Relay 1. */
  calGasEdge?: Maybe<CalGasesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Gas` that is related to this `CalGas`. */
  gasByGasId?: Maybe<Gas>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CalGas`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `CalGas` mutation. */
export type CreateCalGasPayloadCalGasEdgeArgs = {
  orderBy?: InputMaybe<Array<CalGasesOrderBy>>;
};

/** All input for the create `CatalogGroup` mutation. */
export type CreateCatalogGroupInput = {
  /** The `CatalogGroup` to be created by this mutation. */
  catalogGroup: CatalogGroupInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CatalogGroup` mutation. */
export type CreateCatalogGroupPayload = {
  __typename?: 'CreateCatalogGroupPayload';
  /** The `CatalogGroup` that was created by this mutation. */
  catalogGroup?: Maybe<CatalogGroup>;
  /** An edge for our `CatalogGroup`. May be used by Relay 1. */
  catalogGroupEdge?: Maybe<CatalogGroupsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `CatalogGroup` mutation. */
export type CreateCatalogGroupPayloadCatalogGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogGroupsOrderBy>>;
};

/** All input for the create `CatalogItemFile` mutation. */
export type CreateCatalogItemFileInput = {
  /** The `CatalogItemFile` to be created by this mutation. */
  catalogItemFile: CatalogItemFileInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CatalogItemFile` mutation. */
export type CreateCatalogItemFilePayload = {
  __typename?: 'CreateCatalogItemFilePayload';
  /** Reads a single `CatalogItem` that is related to this `CatalogItemFile`. */
  catalogItemByCatalogItemId?: Maybe<CatalogItem>;
  /** The `CatalogItemFile` that was created by this mutation. */
  catalogItemFile?: Maybe<CatalogItemFile>;
  /** An edge for our `CatalogItemFile`. May be used by Relay 1. */
  catalogItemFileEdge?: Maybe<CatalogItemFilesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogItemFile`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `CatalogItemFile` mutation. */
export type CreateCatalogItemFilePayloadCatalogItemFileEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemFilesOrderBy>>;
};

/** All input for the create `CatalogItem` mutation. */
export type CreateCatalogItemInput = {
  /** The `CatalogItem` to be created by this mutation. */
  catalogItem: CatalogItemInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CatalogItem` mutation. */
export type CreateCatalogItemPayload = {
  __typename?: 'CreateCatalogItemPayload';
  /** The `CatalogItem` that was created by this mutation. */
  catalogItem?: Maybe<CatalogItem>;
  /** An edge for our `CatalogItem`. May be used by Relay 1. */
  catalogItemEdge?: Maybe<CatalogItemsEdge>;
  /** Reads a single `CatalogSubGroup` that is related to this `CatalogItem`. */
  catalogSubGroupByCatalogSubGroupId?: Maybe<CatalogSubGroup>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogItem`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `CatalogItem` mutation. */
export type CreateCatalogItemPayloadCatalogItemEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemsOrderBy>>;
};

/** All input for the create `CatalogItemRelation` mutation. */
export type CreateCatalogItemRelationInput = {
  /** The `CatalogItemRelation` to be created by this mutation. */
  catalogItemRelation: CatalogItemRelationInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CatalogItemRelation` mutation. */
export type CreateCatalogItemRelationPayload = {
  __typename?: 'CreateCatalogItemRelationPayload';
  /** Reads a single `CatalogItem` that is related to this `CatalogItemRelation`. */
  catalogItemByChildCatalogItemId?: Maybe<CatalogItem>;
  /** Reads a single `CatalogItem` that is related to this `CatalogItemRelation`. */
  catalogItemByParentCatalogItemId?: Maybe<CatalogItem>;
  /** The `CatalogItemRelation` that was created by this mutation. */
  catalogItemRelation?: Maybe<CatalogItemRelation>;
  /** An edge for our `CatalogItemRelation`. May be used by Relay 1. */
  catalogItemRelationEdge?: Maybe<CatalogItemRelationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `CatalogItemRelation` mutation. */
export type CreateCatalogItemRelationPayloadCatalogItemRelationEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemRelationsOrderBy>>;
};

/** All input for the create `CatalogSubGroup` mutation. */
export type CreateCatalogSubGroupInput = {
  /** The `CatalogSubGroup` to be created by this mutation. */
  catalogSubGroup: CatalogSubGroupInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `CatalogSubGroup` mutation. */
export type CreateCatalogSubGroupPayload = {
  __typename?: 'CreateCatalogSubGroupPayload';
  /** Reads a single `CatalogGroup` that is related to this `CatalogSubGroup`. */
  catalogGroupByCatalogGroupId?: Maybe<CatalogGroup>;
  /** The `CatalogSubGroup` that was created by this mutation. */
  catalogSubGroup?: Maybe<CatalogSubGroup>;
  /** An edge for our `CatalogSubGroup`. May be used by Relay 1. */
  catalogSubGroupEdge?: Maybe<CatalogSubGroupsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogSubGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `CatalogSubGroup` mutation. */
export type CreateCatalogSubGroupPayloadCatalogSubGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogSubGroupsOrderBy>>;
};

/** All input for the create `ChemicalCompound` mutation. */
export type CreateChemicalCompoundInput = {
  /** The `ChemicalCompound` to be created by this mutation. */
  chemicalCompound: ChemicalCompoundInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ChemicalCompound` mutation. */
export type CreateChemicalCompoundPayload = {
  __typename?: 'CreateChemicalCompoundPayload';
  /** The `ChemicalCompound` that was created by this mutation. */
  chemicalCompound?: Maybe<ChemicalCompound>;
  /** An edge for our `ChemicalCompound`. May be used by Relay 1. */
  chemicalCompoundEdge?: Maybe<ChemicalCompoundsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ChemicalCompound`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `ChemicalCompound` mutation. */
export type CreateChemicalCompoundPayloadChemicalCompoundEdgeArgs = {
  orderBy?: InputMaybe<Array<ChemicalCompoundsOrderBy>>;
};

/** All input for the create `Detector` mutation. */
export type CreateDetectorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Detector` to be created by this mutation. */
  detector: DetectorInput;
};

/** All input for the create `DetectorLocation` mutation. */
export type CreateDetectorLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DetectorLocation` to be created by this mutation. */
  detectorLocation: DetectorLocationInput;
};

/** The output of our create `DetectorLocation` mutation. */
export type CreateDetectorLocationPayload = {
  __typename?: 'CreateDetectorLocationPayload';
  /** Reads a single `Area` that is related to this `DetectorLocation`. */
  areaByAreaId?: Maybe<Area>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorLocation`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorLocation` that was created by this mutation. */
  detectorLocation?: Maybe<DetectorLocation>;
  /** An edge for our `DetectorLocation`. May be used by Relay 1. */
  detectorLocationEdge?: Maybe<DetectorLocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `DetectorLocation` mutation. */
export type CreateDetectorLocationPayloadDetectorLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorLocationsOrderBy>>;
};

/** All input for the create `DetectorOrder` mutation. */
export type CreateDetectorOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DetectorOrder` to be created by this mutation. */
  detectorOrder: DetectorOrderInput;
};

/** The output of our create `DetectorOrder` mutation. */
export type CreateDetectorOrderPayload = {
  __typename?: 'CreateDetectorOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorOrder`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorOrder` that was created by this mutation. */
  detectorOrder?: Maybe<DetectorOrder>;
  /** An edge for our `DetectorOrder`. May be used by Relay 1. */
  detectorOrderEdge?: Maybe<DetectorOrdersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorOrder`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `DetectorOrder` mutation. */
export type CreateDetectorOrderPayloadDetectorOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorOrdersOrderBy>>;
};

/** The output of our create `Detector` mutation. */
export type CreateDetectorPayload = {
  __typename?: 'CreateDetectorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Detector` that was created by this mutation. */
  detector?: Maybe<Detector>;
  /** An edge for our `Detector`. May be used by Relay 1. */
  detectorEdge?: Maybe<DetectorsEdge>;
  /** Reads a single `DetectorType` that is related to this `Detector`. */
  detectorTypeByDetectorTypeId?: Maybe<DetectorType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Detector`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Detector` mutation. */
export type CreateDetectorPayloadDetectorEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorsOrderBy>>;
};

/** All input for the create `DetectorSensor` mutation. */
export type CreateDetectorSensorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DetectorSensor` to be created by this mutation. */
  detectorSensor: DetectorSensorInput;
};

/** All input for the create `DetectorSensorLocation` mutation. */
export type CreateDetectorSensorLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DetectorSensorLocation` to be created by this mutation. */
  detectorSensorLocation: DetectorSensorLocationInput;
};

/** The output of our create `DetectorSensorLocation` mutation. */
export type CreateDetectorSensorLocationPayload = {
  __typename?: 'CreateDetectorSensorLocationPayload';
  /** Reads a single `Application` that is related to this `DetectorSensorLocation`. */
  applicationByApplicationId?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DetectorLocation` that is related to this `DetectorSensorLocation`. */
  detectorLocationByDetectorLocationId?: Maybe<DetectorLocation>;
  /** Reads a single `DetectorSensor` that is related to this `DetectorSensorLocation`. */
  detectorSensorByDetectorSensorId?: Maybe<DetectorSensor>;
  /** The `DetectorSensorLocation` that was created by this mutation. */
  detectorSensorLocation?: Maybe<DetectorSensorLocation>;
  /** An edge for our `DetectorSensorLocation`. May be used by Relay 1. */
  detectorSensorLocationEdge?: Maybe<DetectorSensorLocationsEdge>;
  /** Reads a single `License` that is related to this `DetectorSensorLocation`. */
  licenseByLicenseId?: Maybe<License>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SamplePoint` that is related to this `DetectorSensorLocation`. */
  samplePointBySamplePointId?: Maybe<SamplePoint>;
  /** Reads a single `User` that is related to this `DetectorSensorLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `DetectorSensorLocation` mutation. */
export type CreateDetectorSensorLocationPayloadDetectorSensorLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};

/** The output of our create `DetectorSensor` mutation. */
export type CreateDetectorSensorPayload = {
  __typename?: 'CreateDetectorSensorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorSensor`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorSensor` that was created by this mutation. */
  detectorSensor?: Maybe<DetectorSensor>;
  /** An edge for our `DetectorSensor`. May be used by Relay 1. */
  detectorSensorEdge?: Maybe<DetectorSensorsEdge>;
  /** Reads a single `Filter` that is related to this `DetectorSensor`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `Pyrolyser` that is related to this `DetectorSensor`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `DetectorSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `User` that is related to this `DetectorSensor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `DetectorSensor` mutation. */
export type CreateDetectorSensorPayloadDetectorSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};

/** All input for the create `DetectorSensorType` mutation. */
export type CreateDetectorSensorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DetectorSensorType` to be created by this mutation. */
  detectorSensorType: DetectorSensorTypeInput;
};

/** The output of our create `DetectorSensorType` mutation. */
export type CreateDetectorSensorTypePayload = {
  __typename?: 'CreateDetectorSensorTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DetectorSensorType` that was created by this mutation. */
  detectorSensorType?: Maybe<DetectorSensorType>;
  /** An edge for our `DetectorSensorType`. May be used by Relay 1. */
  detectorSensorTypeEdge?: Maybe<DetectorSensorTypesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SensorType` that is related to this `DetectorSensorType`. */
  sensorTypeBySensorTypeId?: Maybe<SensorType>;
  /** Reads a single `User` that is related to this `DetectorSensorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `DetectorSensorType` mutation. */
export type CreateDetectorSensorTypePayloadDetectorSensorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorTypesOrderBy>>;
};

/** All input for the create `DetectorType` mutation. */
export type CreateDetectorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DetectorType` to be created by this mutation. */
  detectorType: DetectorTypeInput;
};

/** The output of our create `DetectorType` mutation. */
export type CreateDetectorTypePayload = {
  __typename?: 'CreateDetectorTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DetectorType` that was created by this mutation. */
  detectorType?: Maybe<DetectorType>;
  /** An edge for our `DetectorType`. May be used by Relay 1. */
  detectorTypeEdge?: Maybe<DetectorTypesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `DetectorType` mutation. */
export type CreateDetectorTypePayloadDetectorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorTypesOrderBy>>;
};

/** All input for the create `DpCard` mutation. */
export type CreateDpCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DpCard` to be created by this mutation. */
  dpCard: DpCardInput;
};

/** The output of our create `DpCard` mutation. */
export type CreateDpCardPayload = {
  __typename?: 'CreateDpCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DpCard` that was created by this mutation. */
  dpCard?: Maybe<DpCard>;
  /** An edge for our `DpCard`. May be used by Relay 1. */
  dpCardEdge?: Maybe<DpCardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DpCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `DpCard` mutation. */
export type CreateDpCardPayloadDpCardEdgeArgs = {
  orderBy?: InputMaybe<Array<DpCardsOrderBy>>;
};

/** All input for the create `Electrolyte` mutation. */
export type CreateElectrolyteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Electrolyte` to be created by this mutation. */
  electrolyte: ElectrolyteInput;
};

/** The output of our create `Electrolyte` mutation. */
export type CreateElectrolytePayload = {
  __typename?: 'CreateElectrolytePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Electrolyte` that was created by this mutation. */
  electrolyte?: Maybe<Electrolyte>;
  /** An edge for our `Electrolyte`. May be used by Relay 1. */
  electrolyteEdge?: Maybe<ElectrolytesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Electrolyte`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Electrolyte` mutation. */
export type CreateElectrolytePayloadElectrolyteEdgeArgs = {
  orderBy?: InputMaybe<Array<ElectrolytesOrderBy>>;
};

/** All input for the create `EndUser` mutation. */
export type CreateEndUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `EndUser` to be created by this mutation. */
  endUser: EndUserInput;
};

/** The output of our create `EndUser` mutation. */
export type CreateEndUserPayload = {
  __typename?: 'CreateEndUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `EndUser` that was created by this mutation. */
  endUser?: Maybe<EndUser>;
  /** An edge for our `EndUser`. May be used by Relay 1. */
  endUserEdge?: Maybe<EndUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `EndUser`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `EndUser` mutation. */
export type CreateEndUserPayloadEndUserEdgeArgs = {
  orderBy?: InputMaybe<Array<EndUsersOrderBy>>;
};

/** All input for the create `FactopdrachtArtikelExclusion` mutation. */
export type CreateFactopdrachtArtikelExclusionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FactopdrachtArtikelExclusion` to be created by this mutation. */
  factopdrachtArtikelExclusion: FactopdrachtArtikelExclusionInput;
};

/** The output of our create `FactopdrachtArtikelExclusion` mutation. */
export type CreateFactopdrachtArtikelExclusionPayload = {
  __typename?: 'CreateFactopdrachtArtikelExclusionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtArtikelExclusion` that was created by this mutation. */
  factopdrachtArtikelExclusion?: Maybe<FactopdrachtArtikelExclusion>;
  /** An edge for our `FactopdrachtArtikelExclusion`. May be used by Relay 1. */
  factopdrachtArtikelExclusionEdge?: Maybe<FactopdrachtArtikelExclusionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FactopdrachtArtikelExclusion` mutation. */
export type CreateFactopdrachtArtikelExclusionPayloadFactopdrachtArtikelExclusionEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtArtikelExclusionsOrderBy>>;
};

/** All input for the create `FactopdrachtregelLineDate` mutation. */
export type CreateFactopdrachtregelLineDateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FactopdrachtregelLineDate` to be created by this mutation. */
  factopdrachtregelLineDate: FactopdrachtregelLineDateInput;
};

/** The output of our create `FactopdrachtregelLineDate` mutation. */
export type CreateFactopdrachtregelLineDatePayload = {
  __typename?: 'CreateFactopdrachtregelLineDatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtregelLineDate` that was created by this mutation. */
  factopdrachtregelLineDate?: Maybe<FactopdrachtregelLineDate>;
  /** An edge for our `FactopdrachtregelLineDate`. May be used by Relay 1. */
  factopdrachtregelLineDateEdge?: Maybe<FactopdrachtregelLineDatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FactopdrachtregelLineDate` mutation. */
export type CreateFactopdrachtregelLineDatePayloadFactopdrachtregelLineDateEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLineDatesOrderBy>>;
};

/** All input for the create `FactopdrachtregelLine` mutation. */
export type CreateFactopdrachtregelLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FactopdrachtregelLine` to be created by this mutation. */
  factopdrachtregelLine: FactopdrachtregelLineInput;
};

/** The output of our create `FactopdrachtregelLine` mutation. */
export type CreateFactopdrachtregelLinePayload = {
  __typename?: 'CreateFactopdrachtregelLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtregelLine` that was created by this mutation. */
  factopdrachtregelLine?: Maybe<FactopdrachtregelLine>;
  /** An edge for our `FactopdrachtregelLine`. May be used by Relay 1. */
  factopdrachtregelLineEdge?: Maybe<FactopdrachtregelLinesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FactopdrachtregelLine` mutation. */
export type CreateFactopdrachtregelLinePayloadFactopdrachtregelLineEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLinesOrderBy>>;
};

/** All input for the create `FactopdrachtregelLineRemark` mutation. */
export type CreateFactopdrachtregelLineRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FactopdrachtregelLineRemark` to be created by this mutation. */
  factopdrachtregelLineRemark: FactopdrachtregelLineRemarkInput;
};

/** The output of our create `FactopdrachtregelLineRemark` mutation. */
export type CreateFactopdrachtregelLineRemarkPayload = {
  __typename?: 'CreateFactopdrachtregelLineRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtregelLineRemark` that was created by this mutation. */
  factopdrachtregelLineRemark?: Maybe<FactopdrachtregelLineRemark>;
  /** An edge for our `FactopdrachtregelLineRemark`. May be used by Relay 1. */
  factopdrachtregelLineRemarkEdge?: Maybe<FactopdrachtregelLineRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FactopdrachtregelLineRemark`. */
  userByUserId?: Maybe<User>;
};


/** The output of our create `FactopdrachtregelLineRemark` mutation. */
export type CreateFactopdrachtregelLineRemarkPayloadFactopdrachtregelLineRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLineRemarksOrderBy>>;
};

/** All input for the create `FactopdrachtregelLineWeek` mutation. */
export type CreateFactopdrachtregelLineWeekInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FactopdrachtregelLineWeek` to be created by this mutation. */
  factopdrachtregelLineWeek: FactopdrachtregelLineWeekInput;
};

/** The output of our create `FactopdrachtregelLineWeek` mutation. */
export type CreateFactopdrachtregelLineWeekPayload = {
  __typename?: 'CreateFactopdrachtregelLineWeekPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtregelLineWeek` that was created by this mutation. */
  factopdrachtregelLineWeek?: Maybe<FactopdrachtregelLineWeek>;
  /** An edge for our `FactopdrachtregelLineWeek`. May be used by Relay 1. */
  factopdrachtregelLineWeekEdge?: Maybe<FactopdrachtregelLineWeeksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FactopdrachtregelLineWeek` mutation. */
export type CreateFactopdrachtregelLineWeekPayloadFactopdrachtregelLineWeekEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLineWeeksOrderBy>>;
};

/** All input for the create `Factuur` mutation. */
export type CreateFactuurInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Factuur` to be created by this mutation. */
  factuur: FactuurInput;
};

/** The output of our create `Factuur` mutation. */
export type CreateFactuurPayload = {
  __typename?: 'CreateFactuurPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Factuur` that was created by this mutation. */
  factuur?: Maybe<Factuur>;
  /** An edge for our `Factuur`. May be used by Relay 1. */
  factuurEdge?: Maybe<FactuursEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userByCheckedId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userBySentId?: Maybe<User>;
};


/** The output of our create `Factuur` mutation. */
export type CreateFactuurPayloadFactuurEdgeArgs = {
  orderBy?: InputMaybe<Array<FactuursOrderBy>>;
};

/** All input for the create `Filter` mutation. */
export type CreateFilterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Filter` to be created by this mutation. */
  filter: FilterInput;
};

/** The output of our create `Filter` mutation. */
export type CreateFilterPayload = {
  __typename?: 'CreateFilterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Filter` that was created by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Filter`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Filter` mutation. */
export type CreateFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the create `Floor` mutation. */
export type CreateFloorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Floor` to be created by this mutation. */
  floor: FloorInput;
};

/** The output of our create `Floor` mutation. */
export type CreateFloorPayload = {
  __typename?: 'CreateFloorPayload';
  /** Reads a single `Building` that is related to this `Floor`. */
  buildingByBuildingId?: Maybe<Building>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Floor` that was created by this mutation. */
  floor?: Maybe<Floor>;
  /** An edge for our `Floor`. May be used by Relay 1. */
  floorEdge?: Maybe<FloorsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Floor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Floor` mutation. */
export type CreateFloorPayloadFloorEdgeArgs = {
  orderBy?: InputMaybe<Array<FloorsOrderBy>>;
};

/** All input for the create `Gas` mutation. */
export type CreateGasInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Gas` to be created by this mutation. */
  gas: GasInput;
};

/** The output of our create `Gas` mutation. */
export type CreateGasPayload = {
  __typename?: 'CreateGasPayload';
  /** Reads a single `ChemicalCompound` that is related to this `Gas`. */
  chemicalCompoundByChemicalCompoundId?: Maybe<ChemicalCompound>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Gas` that was created by this mutation. */
  gas?: Maybe<Gas>;
  /** An edge for our `Gas`. May be used by Relay 1. */
  gasEdge?: Maybe<GasesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Gas`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Gas` mutation. */
export type CreateGasPayloadGasEdgeArgs = {
  orderBy?: InputMaybe<Array<GasesOrderBy>>;
};

/** All input for the `createGroup` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `createGroup` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Group`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our `createGroup` mutation. */
export type CreateGroupPayloadGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** All input for the create `GroupPermission` mutation. */
export type CreateGroupPermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `GroupPermission` to be created by this mutation. */
  groupPermission: GroupPermissionInput;
};

/** The output of our create `GroupPermission` mutation. */
export type CreateGroupPermissionPayload = {
  __typename?: 'CreateGroupPermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `GroupPermission`. */
  groupByGroupId?: Maybe<Group>;
  /** The `GroupPermission` that was created by this mutation. */
  groupPermission?: Maybe<GroupPermission>;
  /** An edge for our `GroupPermission`. May be used by Relay 1. */
  groupPermissionEdge?: Maybe<GroupPermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `GroupPermission` mutation. */
export type CreateGroupPermissionPayloadGroupPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupPermissionsOrderBy>>;
};

/** All input for the create `GroupRight` mutation. */
export type CreateGroupRightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `GroupRight` to be created by this mutation. */
  groupRight: GroupRightInput;
};

/** The output of our create `GroupRight` mutation. */
export type CreateGroupRightPayload = {
  __typename?: 'CreateGroupRightPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `GroupRight`. */
  groupByGroupId?: Maybe<Group>;
  /** The `GroupRight` that was created by this mutation. */
  groupRight?: Maybe<GroupRight>;
  /** An edge for our `GroupRight`. May be used by Relay 1. */
  groupRightEdge?: Maybe<GroupRightsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `GroupRight` mutation. */
export type CreateGroupRightPayloadGroupRightEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupRightsOrderBy>>;
};

/** All input for the create `Hardware` mutation. */
export type CreateHardwareInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Hardware` to be created by this mutation. */
  hardware: HardwareInput;
};

/** The output of our create `Hardware` mutation. */
export type CreateHardwarePayload = {
  __typename?: 'CreateHardwarePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Hardware` that was created by this mutation. */
  hardware?: Maybe<Hardware>;
  /** An edge for our `Hardware`. May be used by Relay 1. */
  hardwareEdge?: Maybe<HardwaresEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Hardware`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Hardware`. */
  userByUserId?: Maybe<User>;
};


/** The output of our create `Hardware` mutation. */
export type CreateHardwarePayloadHardwareEdgeArgs = {
  orderBy?: InputMaybe<Array<HardwaresOrderBy>>;
};

/** All input for the create `IncomingDocument` mutation. */
export type CreateIncomingDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `IncomingDocument` to be created by this mutation. */
  incomingDocument: IncomingDocumentInput;
};

/** The output of our create `IncomingDocument` mutation. */
export type CreateIncomingDocumentPayload = {
  __typename?: 'CreateIncomingDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `IncomingDocument` that was created by this mutation. */
  incomingDocument?: Maybe<IncomingDocument>;
  /** An edge for our `IncomingDocument`. May be used by Relay 1. */
  incomingDocumentEdge?: Maybe<IncomingDocumentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `IncomingDocument`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `IncomingDocument`. */
  userByUserId?: Maybe<User>;
};


/** The output of our create `IncomingDocument` mutation. */
export type CreateIncomingDocumentPayloadIncomingDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<IncomingDocumentsOrderBy>>;
};

/** All input for the create `Inkoopgegeven` mutation. */
export type CreateInkoopgegevenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Inkoopgegeven` to be created by this mutation. */
  inkoopgegeven: InkoopgegevenInput;
};

/** The output of our create `Inkoopgegeven` mutation. */
export type CreateInkoopgegevenPayload = {
  __typename?: 'CreateInkoopgegevenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Inkoopgegeven` that was created by this mutation. */
  inkoopgegeven?: Maybe<Inkoopgegeven>;
  /** An edge for our `Inkoopgegeven`. May be used by Relay 1. */
  inkoopgegevenEdge?: Maybe<InkoopgegevensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Inkoopgegeven` mutation. */
export type CreateInkoopgegevenPayloadInkoopgegevenEdgeArgs = {
  orderBy?: InputMaybe<Array<InkoopgegevensOrderBy>>;
};

/** All input for the create `InkoopgegevensLog` mutation. */
export type CreateInkoopgegevensLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `InkoopgegevensLog` to be created by this mutation. */
  inkoopgegevensLog: InkoopgegevensLogInput;
};

/** The output of our create `InkoopgegevensLog` mutation. */
export type CreateInkoopgegevensLogPayload = {
  __typename?: 'CreateInkoopgegevensLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `InkoopgegevensLog` that was created by this mutation. */
  inkoopgegevensLog?: Maybe<InkoopgegevensLog>;
  /** An edge for our `InkoopgegevensLog`. May be used by Relay 1. */
  inkoopgegevensLogEdge?: Maybe<InkoopgegevensLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `InkoopgegevensLog` mutation. */
export type CreateInkoopgegevensLogPayloadInkoopgegevensLogEdgeArgs = {
  orderBy?: InputMaybe<Array<InkoopgegevensLogsOrderBy>>;
};

/** All input for the create `InkooporderregelLine` mutation. */
export type CreateInkooporderregelLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `InkooporderregelLine` to be created by this mutation. */
  inkooporderregelLine: InkooporderregelLineInput;
};

/** The output of our create `InkooporderregelLine` mutation. */
export type CreateInkooporderregelLinePayload = {
  __typename?: 'CreateInkooporderregelLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `InkooporderregelLine` that was created by this mutation. */
  inkooporderregelLine?: Maybe<InkooporderregelLine>;
  /** An edge for our `InkooporderregelLine`. May be used by Relay 1. */
  inkooporderregelLineEdge?: Maybe<InkooporderregelLinesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `InkooporderregelLine` mutation. */
export type CreateInkooporderregelLinePayloadInkooporderregelLineEdgeArgs = {
  orderBy?: InputMaybe<Array<InkooporderregelLinesOrderBy>>;
};

/** All input for the create `Item` mutation. */
export type CreateItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Item` to be created by this mutation. */
  item: ItemInput;
};

/** The output of our create `Item` mutation. */
export type CreateItemPayload = {
  __typename?: 'CreateItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `Item`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `Item` that was created by this mutation. */
  item?: Maybe<Item>;
  /** An edge for our `Item`. May be used by Relay 1. */
  itemEdge?: Maybe<ItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Item`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Item` mutation. */
export type CreateItemPayloadItemEdgeArgs = {
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
};

/** All input for the create `Job` mutation. */
export type CreateJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Job` to be created by this mutation. */
  job: JobInput;
};

/** The output of our create `Job` mutation. */
export type CreateJobPayload = {
  __typename?: 'CreateJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `Job`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `Job` that was created by this mutation. */
  job?: Maybe<Job>;
  /** An edge for our `Job`. May be used by Relay 1. */
  jobEdge?: Maybe<JobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Job`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Job` mutation. */
export type CreateJobPayloadJobEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** All input for the create `JunctionBox` mutation. */
export type CreateJunctionBoxInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `JunctionBox` to be created by this mutation. */
  junctionBox: JunctionBoxInput;
};

/** The output of our create `JunctionBox` mutation. */
export type CreateJunctionBoxPayload = {
  __typename?: 'CreateJunctionBoxPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `JunctionBox` that was created by this mutation. */
  junctionBox?: Maybe<JunctionBox>;
  /** An edge for our `JunctionBox`. May be used by Relay 1. */
  junctionBoxEdge?: Maybe<JunctionBoxesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `JunctionBox`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `JunctionBox` mutation. */
export type CreateJunctionBoxPayloadJunctionBoxEdgeArgs = {
  orderBy?: InputMaybe<Array<JunctionBoxesOrderBy>>;
};

/** All input for the create `_Land` mutation. */
export type CreateLandInput = {
  /** The `_Land` to be created by this mutation. */
  _land: _LandInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `_Land` mutation. */
export type CreateLandPayload = {
  __typename?: 'CreateLandPayload';
  /** The `_Land` that was created by this mutation. */
  _land?: Maybe<_Land>;
  /** An edge for our `_Land`. May be used by Relay 1. */
  _landEdge?: Maybe<_LandsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `_Land` mutation. */
export type CreateLandPayload_LandEdgeArgs = {
  orderBy?: InputMaybe<Array<_LandsOrderBy>>;
};

/** All input for the create `Lead` mutation. */
export type CreateLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Lead` to be created by this mutation. */
  lead: LeadInput;
};

/** The output of our create `Lead` mutation. */
export type CreateLeadPayload = {
  __typename?: 'CreateLeadPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Lead` that was created by this mutation. */
  lead?: Maybe<Lead>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Lead`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Lead` mutation. */
export type CreateLeadPayloadLeadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the create `LicenseCustomer` mutation. */
export type CreateLicenseCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `LicenseCustomer` to be created by this mutation. */
  licenseCustomer: LicenseCustomerInput;
};

/** The output of our create `LicenseCustomer` mutation. */
export type CreateLicenseCustomerPayload = {
  __typename?: 'CreateLicenseCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `LicenseCustomer` that was created by this mutation. */
  licenseCustomer?: Maybe<LicenseCustomer>;
  /** An edge for our `LicenseCustomer`. May be used by Relay 1. */
  licenseCustomerEdge?: Maybe<LicenseCustomersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseCustomer`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `LicenseCustomer` mutation. */
export type CreateLicenseCustomerPayloadLicenseCustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseCustomersOrderBy>>;
};

/** All input for the create `License` mutation. */
export type CreateLicenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `License` to be created by this mutation. */
  license: LicenseInput;
};

/** All input for the create `LicenseModule` mutation. */
export type CreateLicenseModuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `LicenseModule` to be created by this mutation. */
  licenseModule: LicenseModuleInput;
};

/** The output of our create `LicenseModule` mutation. */
export type CreateLicenseModulePayload = {
  __typename?: 'CreateLicenseModulePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `LicenseModule` that was created by this mutation. */
  licenseModule?: Maybe<LicenseModule>;
  /** An edge for our `LicenseModule`. May be used by Relay 1. */
  licenseModuleEdge?: Maybe<LicenseModulesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseModule`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `LicenseModule` mutation. */
export type CreateLicenseModulePayloadLicenseModuleEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseModulesOrderBy>>;
};

/** All input for the create `LicenseOrder` mutation. */
export type CreateLicenseOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `LicenseOrder` to be created by this mutation. */
  licenseOrder: LicenseOrderInput;
};

/** The output of our create `LicenseOrder` mutation. */
export type CreateLicenseOrderPayload = {
  __typename?: 'CreateLicenseOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `License` that is related to this `LicenseOrder`. */
  licenseByLicenseId?: Maybe<License>;
  /** The `LicenseOrder` that was created by this mutation. */
  licenseOrder?: Maybe<LicenseOrder>;
  /** An edge for our `LicenseOrder`. May be used by Relay 1. */
  licenseOrderEdge?: Maybe<LicenseOrdersEdge>;
  /** Reads a single `LicenseRegistration` that is related to this `LicenseOrder`. */
  licenseRegistrationByLicenseRegistrationId?: Maybe<LicenseRegistration>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseOrder`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `LicenseOrder` mutation. */
export type CreateLicenseOrderPayloadLicenseOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseOrdersOrderBy>>;
};

/** The output of our create `License` mutation. */
export type CreateLicensePayload = {
  __typename?: 'CreateLicensePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `License`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `License` that was created by this mutation. */
  license?: Maybe<License>;
  /** Reads a single `LicenseCustomer` that is related to this `License`. */
  licenseCustomerByLicenseCustomerId?: Maybe<LicenseCustomer>;
  /** An edge for our `License`. May be used by Relay 1. */
  licenseEdge?: Maybe<LicensesEdge>;
  /** Reads a single `LicenseModule` that is related to this `License`. */
  licenseModuleByLicenseModuleId?: Maybe<LicenseModule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `License`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `License` mutation. */
export type CreateLicensePayloadLicenseEdgeArgs = {
  orderBy?: InputMaybe<Array<LicensesOrderBy>>;
};

/** All input for the create `LicenseRegistration` mutation. */
export type CreateLicenseRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `LicenseRegistration` to be created by this mutation. */
  licenseRegistration: LicenseRegistrationInput;
};

/** The output of our create `LicenseRegistration` mutation. */
export type CreateLicenseRegistrationPayload = {
  __typename?: 'CreateLicenseRegistrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `License` that is related to this `LicenseRegistration`. */
  licenseByLicenseId?: Maybe<License>;
  /** The `LicenseRegistration` that was created by this mutation. */
  licenseRegistration?: Maybe<LicenseRegistration>;
  /** An edge for our `LicenseRegistration`. May be used by Relay 1. */
  licenseRegistrationEdge?: Maybe<LicenseRegistrationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseRegistration`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `LicenseRegistration` mutation. */
export type CreateLicenseRegistrationPayloadLicenseRegistrationEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseRegistrationsOrderBy>>;
};

/** All input for the create `MaintenanceVisit` mutation. */
export type CreateMaintenanceVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MaintenanceVisit` to be created by this mutation. */
  maintenanceVisit: MaintenanceVisitInput;
};

/** All input for the create `MaintenanceVisitLine` mutation. */
export type CreateMaintenanceVisitLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MaintenanceVisitLine` to be created by this mutation. */
  maintenanceVisitLine: MaintenanceVisitLineInput;
};

/** The output of our create `MaintenanceVisitLine` mutation. */
export type CreateMaintenanceVisitLinePayload = {
  __typename?: 'CreateMaintenanceVisitLinePayload';
  /** Reads a single `CalGas` that is related to this `MaintenanceVisitLine`. */
  calGasByCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DetectorSensor` that is related to this `MaintenanceVisitLine`. */
  detectorSensorByDetectorSensorId?: Maybe<DetectorSensor>;
  /** Reads a single `DetectorSensorLocation` that is related to this `MaintenanceVisitLine`. */
  detectorSensorLocationByDetectorSensorLocationId?: Maybe<DetectorSensorLocation>;
  /** Reads a single `Filter` that is related to this `MaintenanceVisitLine`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `MaintenanceVisit` that is related to this `MaintenanceVisitLine`. */
  maintenanceVisitByMaintenanceVisitId?: Maybe<MaintenanceVisit>;
  /** The `MaintenanceVisitLine` that was created by this mutation. */
  maintenanceVisitLine?: Maybe<MaintenanceVisitLine>;
  /** An edge for our `MaintenanceVisitLine`. May be used by Relay 1. */
  maintenanceVisitLineEdge?: Maybe<MaintenanceVisitLinesEdge>;
  /** Reads a single `Pyrolyser` that is related to this `MaintenanceVisitLine`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `MaintenanceVisitLine`. */
  sensorByOriginalSensorId?: Maybe<Sensor>;
  /** Reads a single `Sensor` that is related to this `MaintenanceVisitLine`. */
  sensorBySensorId?: Maybe<Sensor>;
};


/** The output of our create `MaintenanceVisitLine` mutation. */
export type CreateMaintenanceVisitLinePayloadMaintenanceVisitLineEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};

/** The output of our create `MaintenanceVisit` mutation. */
export type CreateMaintenanceVisitPayload = {
  __typename?: 'CreateMaintenanceVisitPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `MaintenanceVisit`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `MaintenanceVisit` that was created by this mutation. */
  maintenanceVisit?: Maybe<MaintenanceVisit>;
  /** An edge for our `MaintenanceVisit`. May be used by Relay 1. */
  maintenanceVisitEdge?: Maybe<MaintenanceVisitsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `MaintenanceVisit`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `MaintenanceVisit`. */
  userByUserId?: Maybe<User>;
};


/** The output of our create `MaintenanceVisit` mutation. */
export type CreateMaintenanceVisitPayloadMaintenanceVisitEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitsOrderBy>>;
};

/** All input for the create `MaintenanceVisitRemark` mutation. */
export type CreateMaintenanceVisitRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MaintenanceVisitRemark` to be created by this mutation. */
  maintenanceVisitRemark: MaintenanceVisitRemarkInput;
};

/** The output of our create `MaintenanceVisitRemark` mutation. */
export type CreateMaintenanceVisitRemarkPayload = {
  __typename?: 'CreateMaintenanceVisitRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MaintenanceVisit` that is related to this `MaintenanceVisitRemark`. */
  maintenanceVisitByMaintenanceVisitId?: Maybe<MaintenanceVisit>;
  /** The `MaintenanceVisitRemark` that was created by this mutation. */
  maintenanceVisitRemark?: Maybe<MaintenanceVisitRemark>;
  /** An edge for our `MaintenanceVisitRemark`. May be used by Relay 1. */
  maintenanceVisitRemarkEdge?: Maybe<MaintenanceVisitRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `MaintenanceVisitRemark` mutation. */
export type CreateMaintenanceVisitRemarkPayloadMaintenanceVisitRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitRemarksOrderBy>>;
};

/** All input for the create `Membrane` mutation. */
export type CreateMembraneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Membrane` to be created by this mutation. */
  membrane: MembraneInput;
};

/** The output of our create `Membrane` mutation. */
export type CreateMembranePayload = {
  __typename?: 'CreateMembranePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Membrane` that was created by this mutation. */
  membrane?: Maybe<Membrane>;
  /** An edge for our `Membrane`. May be used by Relay 1. */
  membraneEdge?: Maybe<MembranesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Membrane`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Membrane` mutation. */
export type CreateMembranePayloadMembraneEdgeArgs = {
  orderBy?: InputMaybe<Array<MembranesOrderBy>>;
};

/** All input for the create `ORing` mutation. */
export type CreateORingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ORing` to be created by this mutation. */
  oRing: ORingInput;
};

/** The output of our create `ORing` mutation. */
export type CreateORingPayload = {
  __typename?: 'CreateORingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ORing` that was created by this mutation. */
  oRing?: Maybe<ORing>;
  /** An edge for our `ORing`. May be used by Relay 1. */
  oRingEdge?: Maybe<ORingsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ORing`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `ORing` mutation. */
export type CreateORingPayloadORingEdgeArgs = {
  orderBy?: InputMaybe<Array<ORingsOrderBy>>;
};

/** All input for the create `OfferteRemark` mutation. */
export type CreateOfferteRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `OfferteRemark` to be created by this mutation. */
  offerteRemark: OfferteRemarkInput;
};

/** The output of our create `OfferteRemark` mutation. */
export type CreateOfferteRemarkPayload = {
  __typename?: 'CreateOfferteRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `OfferteRemark` that was created by this mutation. */
  offerteRemark?: Maybe<OfferteRemark>;
  /** An edge for our `OfferteRemark`. May be used by Relay 1. */
  offerteRemarkEdge?: Maybe<OfferteRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `OfferteRemark`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `OfferteRemark` mutation. */
export type CreateOfferteRemarkPayloadOfferteRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<OfferteRemarksOrderBy>>;
};

/** All input for the create `Opportunity` mutation. */
export type CreateOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Opportunity` to be created by this mutation. */
  opportunity: OpportunityInput;
};

/** The output of our create `Opportunity` mutation. */
export type CreateOpportunityPayload = {
  __typename?: 'CreateOpportunityPayload';
  /** Reads a single `_Land` that is related to this `Opportunity`. */
  _landByCdland?: Maybe<_Land>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Opportunity` that was created by this mutation. */
  opportunity?: Maybe<Opportunity>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Opportunity`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Opportunity` mutation. */
export type CreateOpportunityPayloadOpportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the create `Permission` mutation. */
export type CreatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Permission` to be created by this mutation. */
  permission: PermissionInput;
};

/** The output of our create `Permission` mutation. */
export type CreatePermissionPayload = {
  __typename?: 'CreatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Permission` that was created by this mutation. */
  permission?: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Permission` mutation. */
export type CreatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the create `PersoonRol` mutation. */
export type CreatePersoonRolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PersoonRol` to be created by this mutation. */
  persoonRol: PersoonRolInput;
};

/** The output of our create `PersoonRol` mutation. */
export type CreatePersoonRolPayload = {
  __typename?: 'CreatePersoonRolPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PersoonRol` that was created by this mutation. */
  persoonRol?: Maybe<PersoonRol>;
  /** An edge for our `PersoonRol`. May be used by Relay 1. */
  persoonRolEdge?: Maybe<PersoonRolsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PersoonRol` mutation. */
export type CreatePersoonRolPayloadPersoonRolEdgeArgs = {
  orderBy?: InputMaybe<Array<PersoonRolsOrderBy>>;
};

/** All input for the create `Plug` mutation. */
export type CreatePlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Plug` to be created by this mutation. */
  plug: PlugInput;
};

/** The output of our create `Plug` mutation. */
export type CreatePlugPayload = {
  __typename?: 'CreatePlugPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Plug` that was created by this mutation. */
  plug?: Maybe<Plug>;
  /** An edge for our `Plug`. May be used by Relay 1. */
  plugEdge?: Maybe<PlugsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Plug`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Plug` mutation. */
export type CreatePlugPayloadPlugEdgeArgs = {
  orderBy?: InputMaybe<Array<PlugsOrderBy>>;
};

/** All input for the create `Principle` mutation. */
export type CreatePrincipleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Principle` to be created by this mutation. */
  principle: PrincipleInput;
};

/** The output of our create `Principle` mutation. */
export type CreatePrinciplePayload = {
  __typename?: 'CreatePrinciplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Principle` that was created by this mutation. */
  principle?: Maybe<Principle>;
  /** An edge for our `Principle`. May be used by Relay 1. */
  principleEdge?: Maybe<PrinciplesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Principle`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Principle` mutation. */
export type CreatePrinciplePayloadPrincipleEdgeArgs = {
  orderBy?: InputMaybe<Array<PrinciplesOrderBy>>;
};

/** All input for the create `Production` mutation. */
export type CreateProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Production` to be created by this mutation. */
  production: ProductionInput;
};

/** The output of our create `Production` mutation. */
export type CreateProductionPayload = {
  __typename?: 'CreateProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Production` that was created by this mutation. */
  production?: Maybe<Production>;
  /** An edge for our `Production`. May be used by Relay 1. */
  productionEdge?: Maybe<ProductionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Production` mutation. */
export type CreateProductionPayloadProductionEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductionsOrderBy>>;
};

/** All input for the create `Pyrolyser` mutation. */
export type CreatePyrolyserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Pyrolyser` to be created by this mutation. */
  pyrolyser: PyrolyserInput;
};

/** The output of our create `Pyrolyser` mutation. */
export type CreatePyrolyserPayload = {
  __typename?: 'CreatePyrolyserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Pyrolyser` that was created by this mutation. */
  pyrolyser?: Maybe<Pyrolyser>;
  /** An edge for our `Pyrolyser`. May be used by Relay 1. */
  pyrolyserEdge?: Maybe<PyrolysersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pyrolyser`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Pyrolyser` mutation. */
export type CreatePyrolyserPayloadPyrolyserEdgeArgs = {
  orderBy?: InputMaybe<Array<PyrolysersOrderBy>>;
};

/** All input for the create `Range` mutation. */
export type CreateRangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Range` to be created by this mutation. */
  range: RangeInput;
};

/** The output of our create `Range` mutation. */
export type CreateRangePayload = {
  __typename?: 'CreateRangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Gas` that is related to this `Range`. */
  gasByGasId?: Maybe<Gas>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Range` that was created by this mutation. */
  range?: Maybe<Range>;
  /** An edge for our `Range`. May be used by Relay 1. */
  rangeEdge?: Maybe<RangesEdge>;
  /** Reads a single `User` that is related to this `Range`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Range` mutation. */
export type CreateRangePayloadRangeEdgeArgs = {
  orderBy?: InputMaybe<Array<RangesOrderBy>>;
};

/** All input for the create `RcCard` mutation. */
export type CreateRcCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RcCard` to be created by this mutation. */
  rcCard: RcCardInput;
};

/** The output of our create `RcCard` mutation. */
export type CreateRcCardPayload = {
  __typename?: 'CreateRcCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RcCard` that was created by this mutation. */
  rcCard?: Maybe<RcCard>;
  /** An edge for our `RcCard`. May be used by Relay 1. */
  rcCardEdge?: Maybe<RcCardsEdge>;
  /** Reads a single `User` that is related to this `RcCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `RcCard` mutation. */
export type CreateRcCardPayloadRcCardEdgeArgs = {
  orderBy?: InputMaybe<Array<RcCardsOrderBy>>;
};

/** All input for the create `RefreshToken` mutation. */
export type CreateRefreshTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RefreshToken` to be created by this mutation. */
  refreshToken: RefreshTokenInput;
};

/** The output of our create `RefreshToken` mutation. */
export type CreateRefreshTokenPayload = {
  __typename?: 'CreateRefreshTokenPayload';
  /** Reads a single `AspNetUser` that is related to this `RefreshToken`. */
  aspNetUserByAppUserId?: Maybe<AspNetUser>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RefreshToken` that was created by this mutation. */
  refreshToken?: Maybe<RefreshToken>;
  /** An edge for our `RefreshToken`. May be used by Relay 1. */
  refreshTokenEdge?: Maybe<RefreshTokensEdge>;
};


/** The output of our create `RefreshToken` mutation. */
export type CreateRefreshTokenPayloadRefreshTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<RefreshTokensOrderBy>>;
};

/** All input for the create `ReportDetector` mutation. */
export type CreateReportDetectorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReportDetector` to be created by this mutation. */
  reportDetector: ReportDetectorInput;
};

/** The output of our create `ReportDetector` mutation. */
export type CreateReportDetectorPayload = {
  __typename?: 'CreateReportDetectorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `ReportDetector`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportDetector`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportDetector` that was created by this mutation. */
  reportDetector?: Maybe<ReportDetector>;
  /** An edge for our `ReportDetector`. May be used by Relay 1. */
  reportDetectorEdge?: Maybe<ReportDetectorsEdge>;
};


/** The output of our create `ReportDetector` mutation. */
export type CreateReportDetectorPayloadReportDetectorEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportDetectorsOrderBy>>;
};

/** All input for the create `Report` mutation. */
export type CreateReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Report` to be created by this mutation. */
  report: ReportInput;
};

/** All input for the create `ReportItem` mutation. */
export type CreateReportItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReportItem` to be created by this mutation. */
  reportItem: ReportItemInput;
};

/** The output of our create `ReportItem` mutation. */
export type CreateReportItemPayload = {
  __typename?: 'CreateReportItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Item` that is related to this `ReportItem`. */
  itemByItemId?: Maybe<Item>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportItem`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportItem` that was created by this mutation. */
  reportItem?: Maybe<ReportItem>;
  /** An edge for our `ReportItem`. May be used by Relay 1. */
  reportItemEdge?: Maybe<ReportItemsEdge>;
};


/** The output of our create `ReportItem` mutation. */
export type CreateReportItemPayloadReportItemEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportItemsOrderBy>>;
};

/** The output of our create `Report` mutation. */
export type CreateReportPayload = {
  __typename?: 'CreateReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `Report`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Report` that was created by this mutation. */
  report?: Maybe<Report>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
  /** Reads a single `User` that is related to this `Report`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Report`. */
  userByUserId?: Maybe<User>;
};


/** The output of our create `Report` mutation. */
export type CreateReportPayloadReportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the create `ReportSensor` mutation. */
export type CreateReportSensorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReportSensor` to be created by this mutation. */
  reportSensor: ReportSensorInput;
};

/** The output of our create `ReportSensor` mutation. */
export type CreateReportSensorPayload = {
  __typename?: 'CreateReportSensorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportSensor`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportSensor` that was created by this mutation. */
  reportSensor?: Maybe<ReportSensor>;
  /** An edge for our `ReportSensor`. May be used by Relay 1. */
  reportSensorEdge?: Maybe<ReportSensorsEdge>;
  /** Reads a single `Sensor` that is related to this `ReportSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
};


/** The output of our create `ReportSensor` mutation. */
export type CreateReportSensorPayloadReportSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportSensorsOrderBy>>;
};

/** All input for the create `Request` mutation. */
export type CreateRequestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Request` to be created by this mutation. */
  request: RequestInput;
};

/** The output of our create `Request` mutation. */
export type CreateRequestPayload = {
  __typename?: 'CreateRequestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Request` that was created by this mutation. */
  request?: Maybe<Request>;
  /** An edge for our `Request`. May be used by Relay 1. */
  requestEdge?: Maybe<RequestsEdge>;
  /** Reads a single `User` that is related to this `Request`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Request` mutation. */
export type CreateRequestPayloadRequestEdgeArgs = {
  orderBy?: InputMaybe<Array<RequestsOrderBy>>;
};

/** All input for the create `RxCard` mutation. */
export type CreateRxCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `RxCard` to be created by this mutation. */
  rxCard: RxCardInput;
};

/** The output of our create `RxCard` mutation. */
export type CreateRxCardPayload = {
  __typename?: 'CreateRxCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RxCard` that was created by this mutation. */
  rxCard?: Maybe<RxCard>;
  /** An edge for our `RxCard`. May be used by Relay 1. */
  rxCardEdge?: Maybe<RxCardsEdge>;
  /** Reads a single `User` that is related to this `RxCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `RxCard` mutation. */
export type CreateRxCardPayloadRxCardEdgeArgs = {
  orderBy?: InputMaybe<Array<RxCardsOrderBy>>;
};

/** All input for the create `SamplePoint` mutation. */
export type CreateSamplePointInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SamplePoint` to be created by this mutation. */
  samplePoint: SamplePointInput;
};

/** The output of our create `SamplePoint` mutation. */
export type CreateSamplePointPayload = {
  __typename?: 'CreateSamplePointPayload';
  /** Reads a single `Area` that is related to this `SamplePoint`. */
  areaByAreaId?: Maybe<Area>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SamplePoint` that was created by this mutation. */
  samplePoint?: Maybe<SamplePoint>;
  /** An edge for our `SamplePoint`. May be used by Relay 1. */
  samplePointEdge?: Maybe<SamplePointsEdge>;
  /** Reads a single `User` that is related to this `SamplePoint`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `SamplePoint` mutation. */
export type CreateSamplePointPayloadSamplePointEdgeArgs = {
  orderBy?: InputMaybe<Array<SamplePointsOrderBy>>;
};

/** All input for the create `SensorBaseType` mutation. */
export type CreateSensorBaseTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorBaseType` to be created by this mutation. */
  sensorBaseType: SensorBaseTypeInput;
};

/** The output of our create `SensorBaseType` mutation. */
export type CreateSensorBaseTypePayload = {
  __typename?: 'CreateSensorBaseTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Principle` that is related to this `SensorBaseType`. */
  principleByPrincipleId?: Maybe<Principle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorBaseType` that was created by this mutation. */
  sensorBaseType?: Maybe<SensorBaseType>;
  /** An edge for our `SensorBaseType`. May be used by Relay 1. */
  sensorBaseTypeEdge?: Maybe<SensorBaseTypesEdge>;
};


/** The output of our create `SensorBaseType` mutation. */
export type CreateSensorBaseTypePayloadSensorBaseTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorBaseTypesOrderBy>>;
};

/** All input for the create `SensorElement` mutation. */
export type CreateSensorElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorElement` to be created by this mutation. */
  sensorElement: SensorElementInput;
};

/** All input for the create `SensorElementLocation` mutation. */
export type CreateSensorElementLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorElementLocation` to be created by this mutation. */
  sensorElementLocation: SensorElementLocationInput;
};

/** The output of our create `SensorElementLocation` mutation. */
export type CreateSensorElementLocationPayload = {
  __typename?: 'CreateSensorElementLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DetectorSensorLocation` that is related to this `SensorElementLocation`. */
  detectorSensorLocationByDetectorSensorLocationId?: Maybe<DetectorSensorLocation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SensorElement` that is related to this `SensorElementLocation`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorElementLocation` that was created by this mutation. */
  sensorElementLocation?: Maybe<SensorElementLocation>;
  /** An edge for our `SensorElementLocation`. May be used by Relay 1. */
  sensorElementLocationEdge?: Maybe<SensorElementLocationsEdge>;
  /** Reads a single `User` that is related to this `SensorElementLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `SensorElementLocation` mutation. */
export type CreateSensorElementLocationPayloadSensorElementLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementLocationsOrderBy>>;
};

/** All input for the create `SensorElementLog` mutation. */
export type CreateSensorElementLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorElementLog` to be created by this mutation. */
  sensorElementLog: SensorElementLogInput;
};

/** The output of our create `SensorElementLog` mutation. */
export type CreateSensorElementLogPayload = {
  __typename?: 'CreateSensorElementLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorElementLog`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` that is related to this `SensorElementLog`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorElementLog` that was created by this mutation. */
  sensorElementLog?: Maybe<SensorElementLog>;
  /** An edge for our `SensorElementLog`. May be used by Relay 1. */
  sensorElementLogEdge?: Maybe<SensorElementLogsEdge>;
};


/** The output of our create `SensorElementLog` mutation. */
export type CreateSensorElementLogPayloadSensorElementLogEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementLogsOrderBy>>;
};

/** The output of our create `SensorElement` mutation. */
export type CreateSensorElementPayload = {
  __typename?: 'CreateSensorElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorElement` that was created by this mutation. */
  sensorElement?: Maybe<SensorElement>;
  /** An edge for our `SensorElement`. May be used by Relay 1. */
  sensorElementEdge?: Maybe<SensorElementsEdge>;
  /** Reads a single `SensorElementType` that is related to this `SensorElement`. */
  sensorElementTypeBySensorElementTypeId?: Maybe<SensorElementType>;
  /** Reads a single `User` that is related to this `SensorElement`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `SensorElement` mutation. */
export type CreateSensorElementPayloadSensorElementEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementsOrderBy>>;
};

/** All input for the create `SensorElementType` mutation. */
export type CreateSensorElementTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorElementType` to be created by this mutation. */
  sensorElementType: SensorElementTypeInput;
};

/** The output of our create `SensorElementType` mutation. */
export type CreateSensorElementTypePayload = {
  __typename?: 'CreateSensorElementTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Range` that is related to this `SensorElementType`. */
  rangeByCalRangeId?: Maybe<Range>;
  /** Reads a single `Range` that is related to this `SensorElementType`. */
  rangeByRangeId?: Maybe<Range>;
  /** Reads a single `SensorBaseType` that is related to this `SensorElementType`. */
  sensorBaseTypeBySensorBaseTypeId?: Maybe<SensorBaseType>;
  /** The `SensorElementType` that was created by this mutation. */
  sensorElementType?: Maybe<SensorElementType>;
  /** An edge for our `SensorElementType`. May be used by Relay 1. */
  sensorElementTypeEdge?: Maybe<SensorElementTypesEdge>;
  /** Reads a single `User` that is related to this `SensorElementType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `SensorElementType` mutation. */
export type CreateSensorElementTypePayloadSensorElementTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementTypesOrderBy>>;
};

/** An input for mutations affecting `CreateSensor` */
export type CreateSensorInput = {
  date?: InputMaybe<Scalars['Date']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  spanResponse?: InputMaybe<Scalars['Float']['input']>;
  usedSpanConcentration?: InputMaybe<Scalars['Float']['input']>;
  zeroResponse?: InputMaybe<Scalars['Float']['input']>;
};

/** All input for the create `SensorOrder` mutation. */
export type CreateSensorOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorOrder` to be created by this mutation. */
  sensorOrder: SensorOrderInput;
};

/** The output of our create `SensorOrder` mutation. */
export type CreateSensorOrderPayload = {
  __typename?: 'CreateSensorOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Factureeropdracht` that is related to this `SensorOrder`. */
  factureeropdrachtByFactuuropdracht?: Maybe<Factureeropdracht>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorOrder`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** The `SensorOrder` that was created by this mutation. */
  sensorOrder?: Maybe<SensorOrder>;
  /** An edge for our `SensorOrder`. May be used by Relay 1. */
  sensorOrderEdge?: Maybe<SensorOrdersEdge>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByCheckedUserId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByVerifiedUserId?: Maybe<User>;
};


/** The output of our create `SensorOrder` mutation. */
export type CreateSensorOrderPayloadSensorOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};

/** All input for the create `SensorSensorElement` mutation. */
export type CreateSensorSensorElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorSensorElement` to be created by this mutation. */
  sensorSensorElement: SensorSensorElementInput;
};

/** The output of our create `SensorSensorElement` mutation. */
export type CreateSensorSensorElementPayload = {
  __typename?: 'CreateSensorSensorElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorSensorElement`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` that is related to this `SensorSensorElement`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorSensorElement` that was created by this mutation. */
  sensorSensorElement?: Maybe<SensorSensorElement>;
  /** An edge for our `SensorSensorElement`. May be used by Relay 1. */
  sensorSensorElementEdge?: Maybe<SensorSensorElementsEdge>;
  /** Reads a single `User` that is related to this `SensorSensorElement`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `SensorSensorElement` mutation. */
export type CreateSensorSensorElementPayloadSensorSensorElementEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorSensorElementsOrderBy>>;
};

/** All input for the create `SensorSetting` mutation. */
export type CreateSensorSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorSetting` to be created by this mutation. */
  sensorSetting: SensorSettingInput;
};

/** The output of our create `SensorSetting` mutation. */
export type CreateSensorSettingPayload = {
  __typename?: 'CreateSensorSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorSetting` that was created by this mutation. */
  sensorSetting?: Maybe<SensorSetting>;
  /** An edge for our `SensorSetting`. May be used by Relay 1. */
  sensorSettingEdge?: Maybe<SensorSettingsEdge>;
};


/** The output of our create `SensorSetting` mutation. */
export type CreateSensorSettingPayloadSensorSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorSettingsOrderBy>>;
};

/** All input for the create `SensorTestResult` mutation. */
export type CreateSensorTestResultInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorTestResult` to be created by this mutation. */
  sensorTestResult: SensorTestResultInput;
};

/** The output of our create `SensorTestResult` mutation. */
export type CreateSensorTestResultPayload = {
  __typename?: 'CreateSensorTestResultPayload';
  /** Reads a single `CalGas` that is related to this `SensorTestResult`. */
  calGasByFsCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorTestResult`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorOrder` that is related to this `SensorTestResult`. */
  sensorOrderBySensorOrderId?: Maybe<SensorOrder>;
  /** The `SensorTestResult` that was created by this mutation. */
  sensorTestResult?: Maybe<SensorTestResult>;
  /** An edge for our `SensorTestResult`. May be used by Relay 1. */
  sensorTestResultEdge?: Maybe<SensorTestResultsEdge>;
  /** Reads a single `User` that is related to this `SensorTestResult`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorTestResult`. */
  userByUserId?: Maybe<User>;
};


/** The output of our create `SensorTestResult` mutation. */
export type CreateSensorTestResultPayloadSensorTestResultEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};

/** All input for the create `SensorType` mutation. */
export type CreateSensorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SensorType` to be created by this mutation. */
  sensorType: SensorTypeInput;
};

/** The output of our create `SensorType` mutation. */
export type CreateSensorTypePayload = {
  __typename?: 'CreateSensorTypePayload';
  /** Reads a single `CalGas` that is related to this `SensorType`. */
  calGasByCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Electrolyte` that is related to this `SensorType`. */
  electrolyteByElectrolyteId?: Maybe<Electrolyte>;
  /** Reads a single `Filter` that is related to this `SensorType`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `Membrane` that is related to this `SensorType`. */
  membraneByMembraneId?: Maybe<Membrane>;
  /** Reads a single `ORing` that is related to this `SensorType`. */
  oRingByORingId?: Maybe<ORing>;
  /** Reads a single `Plug` that is related to this `SensorType`. */
  plugByPlugId?: Maybe<Plug>;
  /** Reads a single `Pyrolyser` that is related to this `SensorType`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Range` that is related to this `SensorType`. */
  rangeByRangeId?: Maybe<Range>;
  /** Reads a single `SensorBaseType` that is related to this `SensorType`. */
  sensorBaseTypeBySensorBaseTypeId?: Maybe<SensorBaseType>;
  /** The `SensorType` that was created by this mutation. */
  sensorType?: Maybe<SensorType>;
  /** An edge for our `SensorType`. May be used by Relay 1. */
  sensorTypeEdge?: Maybe<SensorTypesEdge>;
  /** Reads a single `User` that is related to this `SensorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `SensorType` mutation. */
export type CreateSensorTypePayloadSensorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/** All input for the `createSensors` mutation. */
export type CreateSensorsInput = {
  calGasId?: InputMaybe<Scalars['Int']['input']>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  sensors?: InputMaybe<Array<InputMaybe<CreateSensorInput>>>;
};

/** The output of our `createSensors` mutation. */
export type CreateSensorsPayload = {
  __typename?: 'CreateSensorsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  sensors?: Maybe<Array<Sensor>>;
};

/** All input for the create `Software` mutation. */
export type CreateSoftwareInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Software` to be created by this mutation. */
  software: SoftwareInput;
};

/** The output of our create `Software` mutation. */
export type CreateSoftwarePayload = {
  __typename?: 'CreateSoftwarePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Hardware` that is related to this `Software`. */
  hardwareByHardwareId?: Maybe<Hardware>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Software` that was created by this mutation. */
  software?: Maybe<Software>;
  /** An edge for our `Software`. May be used by Relay 1. */
  softwareEdge?: Maybe<SoftwaresEdge>;
  /** Reads a single `User` that is related to this `Software`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Software` mutation. */
export type CreateSoftwarePayloadSoftwareEdgeArgs = {
  orderBy?: InputMaybe<Array<SoftwaresOrderBy>>;
};

/** All input for the create `StockGroup` mutation. */
export type CreateStockGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `StockGroup` to be created by this mutation. */
  stockGroup: StockGroupInput;
};

/** The output of our create `StockGroup` mutation. */
export type CreateStockGroupPayload = {
  __typename?: 'CreateStockGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `StockGroup` that was created by this mutation. */
  stockGroup?: Maybe<StockGroup>;
  /** An edge for our `StockGroup`. May be used by Relay 1. */
  stockGroupEdge?: Maybe<StockGroupsEdge>;
  /** Reads a single `User` that is related to this `StockGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `StockGroup` mutation. */
export type CreateStockGroupPayloadStockGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<StockGroupsOrderBy>>;
};

/** All input for the create `StockItem` mutation. */
export type CreateStockItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `StockItem` to be created by this mutation. */
  stockItem: StockItemInput;
};

/** The output of our create `StockItem` mutation. */
export type CreateStockItemPayload = {
  __typename?: 'CreateStockItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StockGroup` that is related to this `StockItem`. */
  stockGroupByStockGroupId?: Maybe<StockGroup>;
  /** The `StockItem` that was created by this mutation. */
  stockItem?: Maybe<StockItem>;
  /** An edge for our `StockItem`. May be used by Relay 1. */
  stockItemEdge?: Maybe<StockItemsEdge>;
  /** Reads a single `User` that is related to this `StockItem`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `StockItem` mutation. */
export type CreateStockItemPayloadStockItemEdgeArgs = {
  orderBy?: InputMaybe<Array<StockItemsOrderBy>>;
};

/** All input for the create `StockSupplier` mutation. */
export type CreateStockSupplierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `StockSupplier` to be created by this mutation. */
  stockSupplier: StockSupplierInput;
};

/** The output of our create `StockSupplier` mutation. */
export type CreateStockSupplierPayload = {
  __typename?: 'CreateStockSupplierPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `StockSupplier` that was created by this mutation. */
  stockSupplier?: Maybe<StockSupplier>;
  /** An edge for our `StockSupplier`. May be used by Relay 1. */
  stockSupplierEdge?: Maybe<StockSuppliersEdge>;
  /** Reads a single `User` that is related to this `StockSupplier`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `StockSupplier` mutation. */
export type CreateStockSupplierPayloadStockSupplierEdgeArgs = {
  orderBy?: InputMaybe<Array<StockSuppliersOrderBy>>;
};

/** All input for the create `Task` mutation. */
export type CreateTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Task` to be created by this mutation. */
  task: TaskInput;
};

/** The output of our create `Task` mutation. */
export type CreateTaskPayload = {
  __typename?: 'CreateTaskPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Task` that was created by this mutation. */
  task?: Maybe<Task>;
  /** An edge for our `Task`. May be used by Relay 1. */
  taskEdge?: Maybe<TasksEdge>;
  /** Reads a single `User` that is related to this `Task`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our create `Task` mutation. */
export type CreateTaskPayloadTaskEdgeArgs = {
  orderBy?: InputMaybe<Array<TasksOrderBy>>;
};

/** All input for the create `TempFactopdrachtregel` mutation. */
export type CreateTempFactopdrachtregelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TempFactopdrachtregel` to be created by this mutation. */
  tempFactopdrachtregel: TempFactopdrachtregelInput;
};

/** The output of our create `TempFactopdrachtregel` mutation. */
export type CreateTempFactopdrachtregelPayload = {
  __typename?: 'CreateTempFactopdrachtregelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempFactopdrachtregel` that was created by this mutation. */
  tempFactopdrachtregel?: Maybe<TempFactopdrachtregel>;
  /** An edge for our `TempFactopdrachtregel`. May be used by Relay 1. */
  tempFactopdrachtregelEdge?: Maybe<TempFactopdrachtregelsEdge>;
};


/** The output of our create `TempFactopdrachtregel` mutation. */
export type CreateTempFactopdrachtregelPayloadTempFactopdrachtregelEdgeArgs = {
  orderBy?: InputMaybe<Array<TempFactopdrachtregelsOrderBy>>;
};

/** All input for the create `TempLicense` mutation. */
export type CreateTempLicenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TempLicense` to be created by this mutation. */
  tempLicense: TempLicenseInput;
};

/** The output of our create `TempLicense` mutation. */
export type CreateTempLicensePayload = {
  __typename?: 'CreateTempLicensePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempLicense` that was created by this mutation. */
  tempLicense?: Maybe<TempLicense>;
  /** An edge for our `TempLicense`. May be used by Relay 1. */
  tempLicenseEdge?: Maybe<TempLicensesEdge>;
};


/** The output of our create `TempLicense` mutation. */
export type CreateTempLicensePayloadTempLicenseEdgeArgs = {
  orderBy?: InputMaybe<Array<TempLicensesOrderBy>>;
};

/** All input for the create `TempRegistrationHistory` mutation. */
export type CreateTempRegistrationHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TempRegistrationHistory` to be created by this mutation. */
  tempRegistrationHistory: TempRegistrationHistoryInput;
};

/** The output of our create `TempRegistrationHistory` mutation. */
export type CreateTempRegistrationHistoryPayload = {
  __typename?: 'CreateTempRegistrationHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistrationHistory` that was created by this mutation. */
  tempRegistrationHistory?: Maybe<TempRegistrationHistory>;
  /** An edge for our `TempRegistrationHistory`. May be used by Relay 1. */
  tempRegistrationHistoryEdge?: Maybe<TempRegistrationHistoriesEdge>;
};


/** The output of our create `TempRegistrationHistory` mutation. */
export type CreateTempRegistrationHistoryPayloadTempRegistrationHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrationHistoriesOrderBy>>;
};

/** All input for the create `TempRegistration` mutation. */
export type CreateTempRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TempRegistration` to be created by this mutation. */
  tempRegistration: TempRegistrationInput;
};

/** The output of our create `TempRegistration` mutation. */
export type CreateTempRegistrationPayload = {
  __typename?: 'CreateTempRegistrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistration` that was created by this mutation. */
  tempRegistration?: Maybe<TempRegistration>;
  /** An edge for our `TempRegistration`. May be used by Relay 1. */
  tempRegistrationEdge?: Maybe<TempRegistrationsEdge>;
};


/** The output of our create `TempRegistration` mutation. */
export type CreateTempRegistrationPayloadTempRegistrationEdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrationsOrderBy>>;
};

/** All input for the create `TempRegistrations2` mutation. */
export type CreateTempRegistrations2Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TempRegistrations2` to be created by this mutation. */
  tempRegistrations2: TempRegistrations2Input;
};

/** The output of our create `TempRegistrations2` mutation. */
export type CreateTempRegistrations2Payload = {
  __typename?: 'CreateTempRegistrations2Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistrations2` that was created by this mutation. */
  tempRegistrations2?: Maybe<TempRegistrations2>;
  /** An edge for our `TempRegistrations2`. May be used by Relay 1. */
  tempRegistrations2Edge?: Maybe<TempRegistrations2SEdge>;
};


/** The output of our create `TempRegistrations2` mutation. */
export type CreateTempRegistrations2PayloadTempRegistrations2EdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrations2SOrderBy>>;
};

/** All input for the create `Test` mutation. */
export type CreateTestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Test` to be created by this mutation. */
  test: TestInput;
};

/** The output of our create `Test` mutation. */
export type CreateTestPayload = {
  __typename?: 'CreateTestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Test` that was created by this mutation. */
  test?: Maybe<Test>;
  /** An edge for our `Test`. May be used by Relay 1. */
  testEdge?: Maybe<TestsEdge>;
};


/** The output of our create `Test` mutation. */
export type CreateTestPayloadTestEdgeArgs = {
  orderBy?: InputMaybe<Array<TestsOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `User`. */
  groupByGroupId?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `UserRight` mutation. */
export type CreateUserRightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserRight` to be created by this mutation. */
  userRight: UserRightInput;
};

/** The output of our create `UserRight` mutation. */
export type CreateUserRightPayload = {
  __typename?: 'CreateUserRightPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserRight`. */
  userByUserId?: Maybe<User>;
  /** The `UserRight` that was created by this mutation. */
  userRight?: Maybe<UserRight>;
  /** An edge for our `UserRight`. May be used by Relay 1. */
  userRightEdge?: Maybe<UserRightsEdge>;
};


/** The output of our create `UserRight` mutation. */
export type CreateUserRightPayloadUserRightEdgeArgs = {
  orderBy?: InputMaybe<Array<UserRightsOrderBy>>;
};

/** All input for the create `UserTask` mutation. */
export type CreateUserTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserTask` to be created by this mutation. */
  userTask: UserTaskInput;
};

/** The output of our create `UserTask` mutation. */
export type CreateUserTaskPayload = {
  __typename?: 'CreateUserTaskPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `UserTask`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `UserTask`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `UserTask`. */
  userByUserId?: Maybe<User>;
  /** The `UserTask` that was created by this mutation. */
  userTask?: Maybe<UserTask>;
  /** An edge for our `UserTask`. May be used by Relay 1. */
  userTaskEdge?: Maybe<UserTasksEdge>;
};


/** The output of our create `UserTask` mutation. */
export type CreateUserTaskPayloadUserTaskEdgeArgs = {
  orderBy?: InputMaybe<Array<UserTasksOrderBy>>;
};

/** All input for the create `Voorraden` mutation. */
export type CreateVoorradenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Voorraden` to be created by this mutation. */
  voorraden: VoorradenInput;
};

/** All input for the create `VoorradenLog` mutation. */
export type CreateVoorradenLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `VoorradenLog` to be created by this mutation. */
  voorradenLog: VoorradenLogInput;
};

/** The output of our create `VoorradenLog` mutation. */
export type CreateVoorradenLogPayload = {
  __typename?: 'CreateVoorradenLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VoorradenLog` that was created by this mutation. */
  voorradenLog?: Maybe<VoorradenLog>;
  /** An edge for our `VoorradenLog`. May be used by Relay 1. */
  voorradenLogEdge?: Maybe<VoorradenLogsEdge>;
};


/** The output of our create `VoorradenLog` mutation. */
export type CreateVoorradenLogPayloadVoorradenLogEdgeArgs = {
  orderBy?: InputMaybe<Array<VoorradenLogsOrderBy>>;
};

/** The output of our create `Voorraden` mutation. */
export type CreateVoorradenPayload = {
  __typename?: 'CreateVoorradenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Voorraden` that was created by this mutation. */
  voorraden?: Maybe<Voorraden>;
  /** An edge for our `Voorraden`. May be used by Relay 1. */
  voorradenEdge?: Maybe<VoorradensEdge>;
};


/** The output of our create `Voorraden` mutation. */
export type CreateVoorradenPayloadVoorradenEdgeArgs = {
  orderBy?: InputMaybe<Array<VoorradensOrderBy>>;
};

/** All input for the create `WeeklyHour` mutation. */
export type CreateWeeklyHourInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `WeeklyHour` to be created by this mutation. */
  weeklyHour: WeeklyHourInput;
};

/** The output of our create `WeeklyHour` mutation. */
export type CreateWeeklyHourPayload = {
  __typename?: 'CreateWeeklyHourPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `WeeklyHour`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `WeeklyHour`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `WeeklyHour`. */
  userByUserId?: Maybe<User>;
  /** The `WeeklyHour` that was created by this mutation. */
  weeklyHour?: Maybe<WeeklyHour>;
  /** An edge for our `WeeklyHour`. May be used by Relay 1. */
  weeklyHourEdge?: Maybe<WeeklyHoursEdge>;
};


/** The output of our create `WeeklyHour` mutation. */
export type CreateWeeklyHourPayloadWeeklyHourEdgeArgs = {
  orderBy?: InputMaybe<Array<WeeklyHoursOrderBy>>;
};

/** All input for the create `WeeklyHourRemark` mutation. */
export type CreateWeeklyHourRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `WeeklyHourRemark` to be created by this mutation. */
  weeklyHourRemark: WeeklyHourRemarkInput;
};

/** The output of our create `WeeklyHourRemark` mutation. */
export type CreateWeeklyHourRemarkPayload = {
  __typename?: 'CreateWeeklyHourRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `WeeklyHourRemark`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `WeeklyHourRemark`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `WeeklyHourRemark`. */
  userByUserId?: Maybe<User>;
  /** The `WeeklyHourRemark` that was created by this mutation. */
  weeklyHourRemark?: Maybe<WeeklyHourRemark>;
  /** An edge for our `WeeklyHourRemark`. May be used by Relay 1. */
  weeklyHourRemarkEdge?: Maybe<WeeklyHourRemarksEdge>;
};


/** The output of our create `WeeklyHourRemark` mutation. */
export type CreateWeeklyHourRemarkPayloadWeeklyHourRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<WeeklyHourRemarksOrderBy>>;
};

export type Crediteur = {
  __typename?: 'Crediteur';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  btwnummer?: Maybe<Scalars['String']['output']>;
  btwopkredb?: Maybe<Scalars['String']['output']>;
  btwscenario?: Maybe<Scalars['Int']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cdgoedcode?: Maybe<Scalars['Int']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdjournaal?: Maybe<Scalars['Int']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdonderaannemer?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdstelsel?: Maybe<Scalars['Int']['output']>;
  cdstroom?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdtype?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  cdverkeer?: Maybe<Scalars['Int']['output']>;
  cdvervoer?: Maybe<Scalars['Int']['output']>;
  controleBetkenmerk?: Maybe<Scalars['String']['output']>;
  datumkvk?: Maybe<Scalars['Date']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  datumverif?: Maybe<Scalars['Date']['output']>;
  debnrcred?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  ficheaard?: Maybe<Scalars['String']['output']>;
  ficheberoep?: Maybe<Scalars['String']['output']>;
  ficheburgstand?: Maybe<Scalars['String']['output']>;
  fichegeboortedatum?: Maybe<Scalars['Date']['output']>;
  fichegezinstoestand?: Maybe<Scalars['String']['output']>;
  fichehandicap?: Maybe<Scalars['String']['output']>;
  fichekinderen?: Maybe<Scalars['Int']['output']>;
  fichenaam?: Maybe<Scalars['String']['output']>;
  fichenaamechtgenoot?: Maybe<Scalars['String']['output']>;
  fichenationaalnr?: Maybe<Scalars['BigFloat']['output']>;
  fichetenlaste?: Maybe<Scalars['Int']['output']>;
  fichevoornaam?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  krbperc?: Maybe<Scalars['BigFloat']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  nummerkvk?: Maybe<Scalars['String']['output']>;
  ondernemersnr?: Maybe<Scalars['String']['output']>;
  opslpercinkoop?: Maybe<Scalars['BigFloat']['output']>;
  overhIdNr?: Maybe<Scalars['String']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  plaatskvk?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  telebankfact?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Crediteur` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CrediteurCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwopkredb` field. */
  btwopkredb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdjournaal` field. */
  cdjournaal?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdonderaannemer` field. */
  cdonderaannemer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtype` field. */
  cdtype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `controleBetkenmerk` field. */
  controleBetkenmerk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumverif` field. */
  datumverif?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `debnrcred` field. */
  debnrcred?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ficheaard` field. */
  ficheaard?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ficheberoep` field. */
  ficheberoep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ficheburgstand` field. */
  ficheburgstand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichegeboortedatum` field. */
  fichegeboortedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `fichegezinstoestand` field. */
  fichegezinstoestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichehandicap` field. */
  fichehandicap?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichekinderen` field. */
  fichekinderen?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `fichenaam` field. */
  fichenaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichenaamechtgenoot` field. */
  fichenaamechtgenoot?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichenationaalnr` field. */
  fichenationaalnr?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `fichetenlaste` field. */
  fichetenlaste?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `fichevoornaam` field. */
  fichevoornaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `krbperc` field. */
  krbperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `opslpercinkoop` field. */
  opslpercinkoop?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `straat` field. */
  straat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telebankfact` field. */
  telebankfact?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Crediteur` object types. All fields are combined with a logical ‘and.’ */
export type CrediteurFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CrediteurFilter>>;
  /** Filter by the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwopkredb` field. */
  btwopkredb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdjournaal` field. */
  cdjournaal?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdonderaannemer` field. */
  cdonderaannemer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtype` field. */
  cdtype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `controleBetkenmerk` field. */
  controleBetkenmerk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumverif` field. */
  datumverif?: InputMaybe<DateFilter>;
  /** Filter by the object’s `debnrcred` field. */
  debnrcred?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ficheaard` field. */
  ficheaard?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ficheberoep` field. */
  ficheberoep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ficheburgstand` field. */
  ficheburgstand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichegeboortedatum` field. */
  fichegeboortedatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `fichegezinstoestand` field. */
  fichegezinstoestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichehandicap` field. */
  fichehandicap?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichekinderen` field. */
  fichekinderen?: InputMaybe<IntFilter>;
  /** Filter by the object’s `fichenaam` field. */
  fichenaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichenaamechtgenoot` field. */
  fichenaamechtgenoot?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichenationaalnr` field. */
  fichenationaalnr?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `fichetenlaste` field. */
  fichetenlaste?: InputMaybe<IntFilter>;
  /** Filter by the object’s `fichevoornaam` field. */
  fichevoornaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `krbperc` field. */
  krbperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CrediteurFilter>;
  /** Filter by the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `opslpercinkoop` field. */
  opslpercinkoop?: InputMaybe<BigFloatFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CrediteurFilter>>;
  /** Filter by the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postcode` field. */
  postcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `straat` field. */
  straat?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telebankfact` field. */
  telebankfact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

export type CrediteurMv = {
  __typename?: 'CrediteurMv';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  btwnummer?: Maybe<Scalars['String']['output']>;
  btwopkredb?: Maybe<Scalars['String']['output']>;
  btwscenario?: Maybe<Scalars['Int']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cdgoedcode?: Maybe<Scalars['Int']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdjournaal?: Maybe<Scalars['Int']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdonderaannemer?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdstelsel?: Maybe<Scalars['Int']['output']>;
  cdstroom?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdtype?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  cdverkeer?: Maybe<Scalars['Int']['output']>;
  cdvervoer?: Maybe<Scalars['Int']['output']>;
  controleBetkenmerk?: Maybe<Scalars['String']['output']>;
  datumkvk?: Maybe<Scalars['Date']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  datumverif?: Maybe<Scalars['Date']['output']>;
  debnrcred?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  ficheaard?: Maybe<Scalars['String']['output']>;
  ficheberoep?: Maybe<Scalars['String']['output']>;
  ficheburgstand?: Maybe<Scalars['String']['output']>;
  fichegeboortedatum?: Maybe<Scalars['Date']['output']>;
  fichegezinstoestand?: Maybe<Scalars['String']['output']>;
  fichehandicap?: Maybe<Scalars['String']['output']>;
  fichekinderen?: Maybe<Scalars['Int']['output']>;
  fichenaam?: Maybe<Scalars['String']['output']>;
  fichenaamechtgenoot?: Maybe<Scalars['String']['output']>;
  fichenationaalnr?: Maybe<Scalars['BigFloat']['output']>;
  fichetenlaste?: Maybe<Scalars['Int']['output']>;
  fichevoornaam?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  krbperc?: Maybe<Scalars['BigFloat']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  nummerkvk?: Maybe<Scalars['String']['output']>;
  ondernemersnr?: Maybe<Scalars['String']['output']>;
  opslpercinkoop?: Maybe<Scalars['BigFloat']['output']>;
  overhIdNr?: Maybe<Scalars['String']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  plaatskvk?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  telebankfact?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `CrediteurMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CrediteurMvCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwopkredb` field. */
  btwopkredb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdjournaal` field. */
  cdjournaal?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdonderaannemer` field. */
  cdonderaannemer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtype` field. */
  cdtype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `controleBetkenmerk` field. */
  controleBetkenmerk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumverif` field. */
  datumverif?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `debnrcred` field. */
  debnrcred?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ficheaard` field. */
  ficheaard?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ficheberoep` field. */
  ficheberoep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ficheburgstand` field. */
  ficheburgstand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichegeboortedatum` field. */
  fichegeboortedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `fichegezinstoestand` field. */
  fichegezinstoestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichehandicap` field. */
  fichehandicap?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichekinderen` field. */
  fichekinderen?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `fichenaam` field. */
  fichenaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichenaamechtgenoot` field. */
  fichenaamechtgenoot?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fichenationaalnr` field. */
  fichenationaalnr?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `fichetenlaste` field. */
  fichetenlaste?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `fichevoornaam` field. */
  fichevoornaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `krbperc` field. */
  krbperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `opslpercinkoop` field. */
  opslpercinkoop?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `straat` field. */
  straat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telebankfact` field. */
  telebankfact?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `CrediteurMv` object types. All fields are combined with a logical ‘and.’ */
export type CrediteurMvFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CrediteurMvFilter>>;
  /** Filter by the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwopkredb` field. */
  btwopkredb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdjournaal` field. */
  cdjournaal?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdonderaannemer` field. */
  cdonderaannemer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtype` field. */
  cdtype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `controleBetkenmerk` field. */
  controleBetkenmerk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumverif` field. */
  datumverif?: InputMaybe<DateFilter>;
  /** Filter by the object’s `debnrcred` field. */
  debnrcred?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ficheaard` field. */
  ficheaard?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ficheberoep` field. */
  ficheberoep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ficheburgstand` field. */
  ficheburgstand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichegeboortedatum` field. */
  fichegeboortedatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `fichegezinstoestand` field. */
  fichegezinstoestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichehandicap` field. */
  fichehandicap?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichekinderen` field. */
  fichekinderen?: InputMaybe<IntFilter>;
  /** Filter by the object’s `fichenaam` field. */
  fichenaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichenaamechtgenoot` field. */
  fichenaamechtgenoot?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fichenationaalnr` field. */
  fichenationaalnr?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `fichetenlaste` field. */
  fichetenlaste?: InputMaybe<IntFilter>;
  /** Filter by the object’s `fichevoornaam` field. */
  fichevoornaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `krbperc` field. */
  krbperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CrediteurMvFilter>;
  /** Filter by the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `opslpercinkoop` field. */
  opslpercinkoop?: InputMaybe<BigFloatFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CrediteurMvFilter>>;
  /** Filter by the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postcode` field. */
  postcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `straat` field. */
  straat?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telebankfact` field. */
  telebankfact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `CrediteurMv` values. */
export type CrediteurMvsConnection = {
  __typename?: 'CrediteurMvsConnection';
  /** A list of edges which contains the `CrediteurMv` and cursor to aid in pagination. */
  edges: Array<CrediteurMvsEdge>;
  /** A list of `CrediteurMv` objects. */
  nodes: Array<CrediteurMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CrediteurMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CrediteurMv` edge in the connection. */
export type CrediteurMvsEdge = {
  __typename?: 'CrediteurMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CrediteurMv` at the end of the edge. */
  node: CrediteurMv;
};

/** Methods to use when ordering `CrediteurMv`. */
export enum CrediteurMvsOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  BtwnummerAsc = 'BTWNUMMER_ASC',
  BtwnummerDesc = 'BTWNUMMER_DESC',
  BtwopkredbAsc = 'BTWOPKREDB_ASC',
  BtwopkredbDesc = 'BTWOPKREDB_DESC',
  BtwscenarioAsc = 'BTWSCENARIO_ASC',
  BtwscenarioDesc = 'BTWSCENARIO_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CdgoedcodeAsc = 'CDGOEDCODE_ASC',
  CdgoedcodeDesc = 'CDGOEDCODE_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdjournaalAsc = 'CDJOURNAAL_ASC',
  CdjournaalDesc = 'CDJOURNAAL_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdonderaannemerAsc = 'CDONDERAANNEMER_ASC',
  CdonderaannemerDesc = 'CDONDERAANNEMER_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdstelselAsc = 'CDSTELSEL_ASC',
  CdstelselDesc = 'CDSTELSEL_DESC',
  CdstroomAsc = 'CDSTROOM_ASC',
  CdstroomDesc = 'CDSTROOM_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdtypeAsc = 'CDTYPE_ASC',
  CdtypeDesc = 'CDTYPE_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  CdverkeerAsc = 'CDVERKEER_ASC',
  CdverkeerDesc = 'CDVERKEER_DESC',
  CdvervoerAsc = 'CDVERVOER_ASC',
  CdvervoerDesc = 'CDVERVOER_DESC',
  ControleBetkenmerkAsc = 'CONTROLE_BETKENMERK_ASC',
  ControleBetkenmerkDesc = 'CONTROLE_BETKENMERK_DESC',
  DatumkvkAsc = 'DATUMKVK_ASC',
  DatumkvkDesc = 'DATUMKVK_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  DatumverifAsc = 'DATUMVERIF_ASC',
  DatumverifDesc = 'DATUMVERIF_DESC',
  DebnrcredAsc = 'DEBNRCRED_ASC',
  DebnrcredDesc = 'DEBNRCRED_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FicheaardAsc = 'FICHEAARD_ASC',
  FicheaardDesc = 'FICHEAARD_DESC',
  FicheberoepAsc = 'FICHEBEROEP_ASC',
  FicheberoepDesc = 'FICHEBEROEP_DESC',
  FicheburgstandAsc = 'FICHEBURGSTAND_ASC',
  FicheburgstandDesc = 'FICHEBURGSTAND_DESC',
  FichegeboortedatumAsc = 'FICHEGEBOORTEDATUM_ASC',
  FichegeboortedatumDesc = 'FICHEGEBOORTEDATUM_DESC',
  FichegezinstoestandAsc = 'FICHEGEZINSTOESTAND_ASC',
  FichegezinstoestandDesc = 'FICHEGEZINSTOESTAND_DESC',
  FichehandicapAsc = 'FICHEHANDICAP_ASC',
  FichehandicapDesc = 'FICHEHANDICAP_DESC',
  FichekinderenAsc = 'FICHEKINDEREN_ASC',
  FichekinderenDesc = 'FICHEKINDEREN_DESC',
  FichenaamechtgenootAsc = 'FICHENAAMECHTGENOOT_ASC',
  FichenaamechtgenootDesc = 'FICHENAAMECHTGENOOT_DESC',
  FichenaamAsc = 'FICHENAAM_ASC',
  FichenaamDesc = 'FICHENAAM_DESC',
  FichenationaalnrAsc = 'FICHENATIONAALNR_ASC',
  FichenationaalnrDesc = 'FICHENATIONAALNR_DESC',
  FichetenlasteAsc = 'FICHETENLASTE_ASC',
  FichetenlasteDesc = 'FICHETENLASTE_DESC',
  FichevoornaamAsc = 'FICHEVOORNAAM_ASC',
  FichevoornaamDesc = 'FICHEVOORNAAM_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  KrbpercAsc = 'KRBPERC_ASC',
  KrbpercDesc = 'KRBPERC_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  NummerkvkAsc = 'NUMMERKVK_ASC',
  NummerkvkDesc = 'NUMMERKVK_DESC',
  OndernemersnrAsc = 'ONDERNEMERSNR_ASC',
  OndernemersnrDesc = 'ONDERNEMERSNR_DESC',
  OpslpercinkoopAsc = 'OPSLPERCINKOOP_ASC',
  OpslpercinkoopDesc = 'OPSLPERCINKOOP_DESC',
  OverhIdNrAsc = 'OVERH_ID_NR_ASC',
  OverhIdNrDesc = 'OVERH_ID_NR_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  PlaatskvkAsc = 'PLAATSKVK_ASC',
  PlaatskvkDesc = 'PLAATSKVK_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  TelebankfactAsc = 'TELEBANKFACT_ASC',
  TelebankfactDesc = 'TELEBANKFACT_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A connection to a list of `Crediteur` values. */
export type CrediteursConnection = {
  __typename?: 'CrediteursConnection';
  /** A list of edges which contains the `Crediteur` and cursor to aid in pagination. */
  edges: Array<CrediteursEdge>;
  /** A list of `Crediteur` objects. */
  nodes: Array<Crediteur>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Crediteur` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Crediteur` edge in the connection. */
export type CrediteursEdge = {
  __typename?: 'CrediteursEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Crediteur` at the end of the edge. */
  node: Crediteur;
};

/** Methods to use when ordering `Crediteur`. */
export enum CrediteursOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  BtwnummerAsc = 'BTWNUMMER_ASC',
  BtwnummerDesc = 'BTWNUMMER_DESC',
  BtwopkredbAsc = 'BTWOPKREDB_ASC',
  BtwopkredbDesc = 'BTWOPKREDB_DESC',
  BtwscenarioAsc = 'BTWSCENARIO_ASC',
  BtwscenarioDesc = 'BTWSCENARIO_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CdgoedcodeAsc = 'CDGOEDCODE_ASC',
  CdgoedcodeDesc = 'CDGOEDCODE_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdjournaalAsc = 'CDJOURNAAL_ASC',
  CdjournaalDesc = 'CDJOURNAAL_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdonderaannemerAsc = 'CDONDERAANNEMER_ASC',
  CdonderaannemerDesc = 'CDONDERAANNEMER_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdstelselAsc = 'CDSTELSEL_ASC',
  CdstelselDesc = 'CDSTELSEL_DESC',
  CdstroomAsc = 'CDSTROOM_ASC',
  CdstroomDesc = 'CDSTROOM_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdtypeAsc = 'CDTYPE_ASC',
  CdtypeDesc = 'CDTYPE_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  CdverkeerAsc = 'CDVERKEER_ASC',
  CdverkeerDesc = 'CDVERKEER_DESC',
  CdvervoerAsc = 'CDVERVOER_ASC',
  CdvervoerDesc = 'CDVERVOER_DESC',
  ControleBetkenmerkAsc = 'CONTROLE_BETKENMERK_ASC',
  ControleBetkenmerkDesc = 'CONTROLE_BETKENMERK_DESC',
  DatumkvkAsc = 'DATUMKVK_ASC',
  DatumkvkDesc = 'DATUMKVK_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  DatumverifAsc = 'DATUMVERIF_ASC',
  DatumverifDesc = 'DATUMVERIF_DESC',
  DebnrcredAsc = 'DEBNRCRED_ASC',
  DebnrcredDesc = 'DEBNRCRED_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FicheaardAsc = 'FICHEAARD_ASC',
  FicheaardDesc = 'FICHEAARD_DESC',
  FicheberoepAsc = 'FICHEBEROEP_ASC',
  FicheberoepDesc = 'FICHEBEROEP_DESC',
  FicheburgstandAsc = 'FICHEBURGSTAND_ASC',
  FicheburgstandDesc = 'FICHEBURGSTAND_DESC',
  FichegeboortedatumAsc = 'FICHEGEBOORTEDATUM_ASC',
  FichegeboortedatumDesc = 'FICHEGEBOORTEDATUM_DESC',
  FichegezinstoestandAsc = 'FICHEGEZINSTOESTAND_ASC',
  FichegezinstoestandDesc = 'FICHEGEZINSTOESTAND_DESC',
  FichehandicapAsc = 'FICHEHANDICAP_ASC',
  FichehandicapDesc = 'FICHEHANDICAP_DESC',
  FichekinderenAsc = 'FICHEKINDEREN_ASC',
  FichekinderenDesc = 'FICHEKINDEREN_DESC',
  FichenaamechtgenootAsc = 'FICHENAAMECHTGENOOT_ASC',
  FichenaamechtgenootDesc = 'FICHENAAMECHTGENOOT_DESC',
  FichenaamAsc = 'FICHENAAM_ASC',
  FichenaamDesc = 'FICHENAAM_DESC',
  FichenationaalnrAsc = 'FICHENATIONAALNR_ASC',
  FichenationaalnrDesc = 'FICHENATIONAALNR_DESC',
  FichetenlasteAsc = 'FICHETENLASTE_ASC',
  FichetenlasteDesc = 'FICHETENLASTE_DESC',
  FichevoornaamAsc = 'FICHEVOORNAAM_ASC',
  FichevoornaamDesc = 'FICHEVOORNAAM_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  KrbpercAsc = 'KRBPERC_ASC',
  KrbpercDesc = 'KRBPERC_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  NummerkvkAsc = 'NUMMERKVK_ASC',
  NummerkvkDesc = 'NUMMERKVK_DESC',
  OndernemersnrAsc = 'ONDERNEMERSNR_ASC',
  OndernemersnrDesc = 'ONDERNEMERSNR_DESC',
  OpslpercinkoopAsc = 'OPSLPERCINKOOP_ASC',
  OpslpercinkoopDesc = 'OPSLPERCINKOOP_DESC',
  OverhIdNrAsc = 'OVERH_ID_NR_ASC',
  OverhIdNrDesc = 'OVERH_ID_NR_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  PlaatskvkAsc = 'PLAATSKVK_ASC',
  PlaatskvkDesc = 'PLAATSKVK_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  TelebankfactAsc = 'TELEBANKFACT_ASC',
  TelebankfactDesc = 'TELEBANKFACT_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A filter to be used against Date fields. All fields are combined with a logical ‘and.’ */
export type DateFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Date']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Date']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Date']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['Date']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Date']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Date']['input']>>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

export type Debiteur = {
  __typename?: 'Debiteur';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  berekenordkost?: Maybe<Scalars['String']['output']>;
  btwExIncl?: Maybe<Scalars['String']['output']>;
  btwnummer?: Maybe<Scalars['String']['output']>;
  btwscenario?: Maybe<Scalars['Int']['output']>;
  cdaanmanen?: Maybe<Scalars['String']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdbtwberekenen?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cddebiteurInkorg?: Maybe<Scalars['String']['output']>;
  cdgoedcode?: Maybe<Scalars['Int']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdjournaal?: Maybe<Scalars['Int']['output']>;
  cdkredbep?: Maybe<Scalars['String']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdprijslijst?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdstelsel?: Maybe<Scalars['Int']['output']>;
  cdstroom?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdtype?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  cdverkeer?: Maybe<Scalars['Int']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  cdvervoer?: Maybe<Scalars['Int']['output']>;
  cdverzamel?: Maybe<Scalars['Int']['output']>;
  controleBetkenmerk?: Maybe<Scalars['String']['output']>;
  datumkvk?: Maybe<Scalars['Date']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  datumverif?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Factureeropdracht`. */
  factureeropdrachtsByCddebiteur: FactureeropdrachtsConnection;
  guidItem?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  inFactoring?: Maybe<Scalars['String']['output']>;
  isinkooporg?: Maybe<Scalars['String']['output']>;
  kortperc?: Maybe<Scalars['BigFloat']['output']>;
  kredietlimiet?: Maybe<Scalars['Int']['output']>;
  lidnrBijInkorg?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  nummerkvk?: Maybe<Scalars['String']['output']>;
  ondernemersnr?: Maybe<Scalars['String']['output']>;
  ontvBorderel?: Maybe<Scalars['String']['output']>;
  ontvFactIpvLid?: Maybe<Scalars['String']['output']>;
  overhIdNr?: Maybe<Scalars['String']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  plaatskvk?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  telebankfact?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  vertegenwoordiger?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};


export type DebiteurFactureeropdrachtsByCddebiteurArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactureeropdrachtCondition>;
  filter?: InputMaybe<FactureeropdrachtFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactureeropdrachtsOrderBy>>;
};

/**
 * A condition to be used against `Debiteur` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DebiteurCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `berekenordkost` field. */
  berekenordkost?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwExIncl` field. */
  btwExIncl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdaanmanen` field. */
  cdaanmanen?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbtwberekenen` field. */
  cdbtwberekenen?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteurInkorg` field. */
  cddebiteurInkorg?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdjournaal` field. */
  cdjournaal?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdkredbep` field. */
  cdkredbep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdprijslijst` field. */
  cdprijslijst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtype` field. */
  cdtype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdverzamel` field. */
  cdverzamel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `controleBetkenmerk` field. */
  controleBetkenmerk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumverif` field. */
  datumverif?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inFactoring` field. */
  inFactoring?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isinkooporg` field. */
  isinkooporg?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortperc` field. */
  kortperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kredietlimiet` field. */
  kredietlimiet?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lidnrBijInkorg` field. */
  lidnrBijInkorg?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ontvBorderel` field. */
  ontvBorderel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ontvFactIpvLid` field. */
  ontvFactIpvLid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `straat` field. */
  straat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telebankfact` field. */
  telebankfact?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Debiteur` object types. All fields are combined with a logical ‘and.’ */
export type DebiteurFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DebiteurFilter>>;
  /** Filter by the object’s `berekenordkost` field. */
  berekenordkost?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwExIncl` field. */
  btwExIncl?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdaanmanen` field. */
  cdaanmanen?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbtwberekenen` field. */
  cdbtwberekenen?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteurInkorg` field. */
  cddebiteurInkorg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdjournaal` field. */
  cdjournaal?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdkredbep` field. */
  cdkredbep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdprijslijst` field. */
  cdprijslijst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtype` field. */
  cdtype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdverzamel` field. */
  cdverzamel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `controleBetkenmerk` field. */
  controleBetkenmerk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumverif` field. */
  datumverif?: InputMaybe<DateFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factureeropdrachtsByCddebiteur` relation. */
  factureeropdrachtsByCddebiteur?: InputMaybe<DebiteurToManyFactureeropdrachtFilter>;
  /** Some related `factureeropdrachtsByCddebiteur` exist. */
  factureeropdrachtsByCddebiteurExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inFactoring` field. */
  inFactoring?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isinkooporg` field. */
  isinkooporg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortperc` field. */
  kortperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kredietlimiet` field. */
  kredietlimiet?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lidnrBijInkorg` field. */
  lidnrBijInkorg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DebiteurFilter>;
  /** Filter by the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ontvBorderel` field. */
  ontvBorderel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ontvFactIpvLid` field. */
  ontvFactIpvLid?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DebiteurFilter>>;
  /** Filter by the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postcode` field. */
  postcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `straat` field. */
  straat?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telebankfact` field. */
  telebankfact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<StringFilter>;
  /** Filter by the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

export type DebiteurMv = {
  __typename?: 'DebiteurMv';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  berekenordkost?: Maybe<Scalars['String']['output']>;
  btwExIncl?: Maybe<Scalars['String']['output']>;
  btwnummer?: Maybe<Scalars['String']['output']>;
  btwscenario?: Maybe<Scalars['Int']['output']>;
  cdaanmanen?: Maybe<Scalars['String']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdbtwberekenen?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cddebiteurInkorg?: Maybe<Scalars['String']['output']>;
  cdgoedcode?: Maybe<Scalars['Int']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdjournaal?: Maybe<Scalars['Int']['output']>;
  cdkredbep?: Maybe<Scalars['String']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdprijslijst?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdstelsel?: Maybe<Scalars['Int']['output']>;
  cdstroom?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdtype?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  cdverkeer?: Maybe<Scalars['Int']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  cdvervoer?: Maybe<Scalars['Int']['output']>;
  cdverzamel?: Maybe<Scalars['Int']['output']>;
  controleBetkenmerk?: Maybe<Scalars['String']['output']>;
  datumkvk?: Maybe<Scalars['Date']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  datumverif?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  inFactoring?: Maybe<Scalars['String']['output']>;
  isinkooporg?: Maybe<Scalars['String']['output']>;
  kortperc?: Maybe<Scalars['BigFloat']['output']>;
  kredietlimiet?: Maybe<Scalars['Int']['output']>;
  lidnrBijInkorg?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  nummerkvk?: Maybe<Scalars['String']['output']>;
  ondernemersnr?: Maybe<Scalars['String']['output']>;
  ontvBorderel?: Maybe<Scalars['String']['output']>;
  ontvFactIpvLid?: Maybe<Scalars['String']['output']>;
  overhIdNr?: Maybe<Scalars['String']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  plaatskvk?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  telebankfact?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  vertegenwoordiger?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DebiteurMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DebiteurMvCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `berekenordkost` field. */
  berekenordkost?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwExIncl` field. */
  btwExIncl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdaanmanen` field. */
  cdaanmanen?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbtwberekenen` field. */
  cdbtwberekenen?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteurInkorg` field. */
  cddebiteurInkorg?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdjournaal` field. */
  cdjournaal?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdkredbep` field. */
  cdkredbep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdprijslijst` field. */
  cdprijslijst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtype` field. */
  cdtype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdverzamel` field. */
  cdverzamel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `controleBetkenmerk` field. */
  controleBetkenmerk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumverif` field. */
  datumverif?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inFactoring` field. */
  inFactoring?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isinkooporg` field. */
  isinkooporg?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortperc` field. */
  kortperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kredietlimiet` field. */
  kredietlimiet?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lidnrBijInkorg` field. */
  lidnrBijInkorg?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ontvBorderel` field. */
  ontvBorderel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ontvFactIpvLid` field. */
  ontvFactIpvLid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `straat` field. */
  straat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telebankfact` field. */
  telebankfact?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DebiteurMv` object types. All fields are combined with a logical ‘and.’ */
export type DebiteurMvFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DebiteurMvFilter>>;
  /** Filter by the object’s `berekenordkost` field. */
  berekenordkost?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwExIncl` field. */
  btwExIncl?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdaanmanen` field. */
  cdaanmanen?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbtwberekenen` field. */
  cdbtwberekenen?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteurInkorg` field. */
  cddebiteurInkorg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgoedcode` field. */
  cdgoedcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdjournaal` field. */
  cdjournaal?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdkredbep` field. */
  cdkredbep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdprijslijst` field. */
  cdprijslijst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtype` field. */
  cdtype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdverzamel` field. */
  cdverzamel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `controleBetkenmerk` field. */
  controleBetkenmerk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumverif` field. */
  datumverif?: InputMaybe<DateFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inFactoring` field. */
  inFactoring?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isinkooporg` field. */
  isinkooporg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortperc` field. */
  kortperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kredietlimiet` field. */
  kredietlimiet?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lidnrBijInkorg` field. */
  lidnrBijInkorg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DebiteurMvFilter>;
  /** Filter by the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ontvBorderel` field. */
  ontvBorderel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ontvFactIpvLid` field. */
  ontvFactIpvLid?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DebiteurMvFilter>>;
  /** Filter by the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postcode` field. */
  postcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `straat` field. */
  straat?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telebankfact` field. */
  telebankfact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<StringFilter>;
  /** Filter by the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `DebiteurMv` values. */
export type DebiteurMvsConnection = {
  __typename?: 'DebiteurMvsConnection';
  /** A list of edges which contains the `DebiteurMv` and cursor to aid in pagination. */
  edges: Array<DebiteurMvsEdge>;
  /** A list of `DebiteurMv` objects. */
  nodes: Array<DebiteurMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DebiteurMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DebiteurMv` edge in the connection. */
export type DebiteurMvsEdge = {
  __typename?: 'DebiteurMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DebiteurMv` at the end of the edge. */
  node: DebiteurMv;
};

/** Methods to use when ordering `DebiteurMv`. */
export enum DebiteurMvsOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  BerekenordkostAsc = 'BEREKENORDKOST_ASC',
  BerekenordkostDesc = 'BEREKENORDKOST_DESC',
  BtwnummerAsc = 'BTWNUMMER_ASC',
  BtwnummerDesc = 'BTWNUMMER_DESC',
  BtwscenarioAsc = 'BTWSCENARIO_ASC',
  BtwscenarioDesc = 'BTWSCENARIO_DESC',
  BtwExInclAsc = 'BTW_EX_INCL_ASC',
  BtwExInclDesc = 'BTW_EX_INCL_DESC',
  CdaanmanenAsc = 'CDAANMANEN_ASC',
  CdaanmanenDesc = 'CDAANMANEN_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  CdbtwberekenenAsc = 'CDBTWBEREKENEN_ASC',
  CdbtwberekenenDesc = 'CDBTWBEREKENEN_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CddebiteurInkorgAsc = 'CDDEBITEUR_INKORG_ASC',
  CddebiteurInkorgDesc = 'CDDEBITEUR_INKORG_DESC',
  CdgoedcodeAsc = 'CDGOEDCODE_ASC',
  CdgoedcodeDesc = 'CDGOEDCODE_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdjournaalAsc = 'CDJOURNAAL_ASC',
  CdjournaalDesc = 'CDJOURNAAL_DESC',
  CdkredbepAsc = 'CDKREDBEP_ASC',
  CdkredbepDesc = 'CDKREDBEP_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdprijslijstAsc = 'CDPRIJSLIJST_ASC',
  CdprijslijstDesc = 'CDPRIJSLIJST_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdstelselAsc = 'CDSTELSEL_ASC',
  CdstelselDesc = 'CDSTELSEL_DESC',
  CdstroomAsc = 'CDSTROOM_ASC',
  CdstroomDesc = 'CDSTROOM_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdtypeAsc = 'CDTYPE_ASC',
  CdtypeDesc = 'CDTYPE_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  CdverkeerAsc = 'CDVERKEER_ASC',
  CdverkeerDesc = 'CDVERKEER_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  CdvervoerAsc = 'CDVERVOER_ASC',
  CdvervoerDesc = 'CDVERVOER_DESC',
  CdverzamelAsc = 'CDVERZAMEL_ASC',
  CdverzamelDesc = 'CDVERZAMEL_DESC',
  ControleBetkenmerkAsc = 'CONTROLE_BETKENMERK_ASC',
  ControleBetkenmerkDesc = 'CONTROLE_BETKENMERK_DESC',
  DatumkvkAsc = 'DATUMKVK_ASC',
  DatumkvkDesc = 'DATUMKVK_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  DatumverifAsc = 'DATUMVERIF_ASC',
  DatumverifDesc = 'DATUMVERIF_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  InFactoringAsc = 'IN_FACTORING_ASC',
  InFactoringDesc = 'IN_FACTORING_DESC',
  IsinkooporgAsc = 'ISINKOOPORG_ASC',
  IsinkooporgDesc = 'ISINKOOPORG_DESC',
  KortpercAsc = 'KORTPERC_ASC',
  KortpercDesc = 'KORTPERC_DESC',
  KredietlimietAsc = 'KREDIETLIMIET_ASC',
  KredietlimietDesc = 'KREDIETLIMIET_DESC',
  LidnrBijInkorgAsc = 'LIDNR_BIJ_INKORG_ASC',
  LidnrBijInkorgDesc = 'LIDNR_BIJ_INKORG_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  NummerkvkAsc = 'NUMMERKVK_ASC',
  NummerkvkDesc = 'NUMMERKVK_DESC',
  OndernemersnrAsc = 'ONDERNEMERSNR_ASC',
  OndernemersnrDesc = 'ONDERNEMERSNR_DESC',
  OntvBorderelAsc = 'ONTV_BORDEREL_ASC',
  OntvBorderelDesc = 'ONTV_BORDEREL_DESC',
  OntvFactIpvLidAsc = 'ONTV_FACT_IPV_LID_ASC',
  OntvFactIpvLidDesc = 'ONTV_FACT_IPV_LID_DESC',
  OverhIdNrAsc = 'OVERH_ID_NR_ASC',
  OverhIdNrDesc = 'OVERH_ID_NR_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  PlaatskvkAsc = 'PLAATSKVK_ASC',
  PlaatskvkDesc = 'PLAATSKVK_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  TelebankfactAsc = 'TELEBANKFACT_ASC',
  TelebankfactDesc = 'TELEBANKFACT_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  VertegenwoordigerAsc = 'VERTEGENWOORDIGER_ASC',
  VertegenwoordigerDesc = 'VERTEGENWOORDIGER_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A filter to be used against many `Factureeropdracht` object types. All fields are combined with a logical ‘and.’ */
export type DebiteurToManyFactureeropdrachtFilter = {
  /** Every related `Factureeropdracht` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FactureeropdrachtFilter>;
  /** No related `Factureeropdracht` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FactureeropdrachtFilter>;
  /** Some related `Factureeropdracht` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FactureeropdrachtFilter>;
};

/** A connection to a list of `Debiteur` values. */
export type DebiteursConnection = {
  __typename?: 'DebiteursConnection';
  /** A list of edges which contains the `Debiteur` and cursor to aid in pagination. */
  edges: Array<DebiteursEdge>;
  /** A list of `Debiteur` objects. */
  nodes: Array<Debiteur>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Debiteur` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Debiteur` edge in the connection. */
export type DebiteursEdge = {
  __typename?: 'DebiteursEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Debiteur` at the end of the edge. */
  node: Debiteur;
};

/** Methods to use when ordering `Debiteur`. */
export enum DebiteursOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  BerekenordkostAsc = 'BEREKENORDKOST_ASC',
  BerekenordkostDesc = 'BEREKENORDKOST_DESC',
  BtwnummerAsc = 'BTWNUMMER_ASC',
  BtwnummerDesc = 'BTWNUMMER_DESC',
  BtwscenarioAsc = 'BTWSCENARIO_ASC',
  BtwscenarioDesc = 'BTWSCENARIO_DESC',
  BtwExInclAsc = 'BTW_EX_INCL_ASC',
  BtwExInclDesc = 'BTW_EX_INCL_DESC',
  CdaanmanenAsc = 'CDAANMANEN_ASC',
  CdaanmanenDesc = 'CDAANMANEN_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  CdbtwberekenenAsc = 'CDBTWBEREKENEN_ASC',
  CdbtwberekenenDesc = 'CDBTWBEREKENEN_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CddebiteurInkorgAsc = 'CDDEBITEUR_INKORG_ASC',
  CddebiteurInkorgDesc = 'CDDEBITEUR_INKORG_DESC',
  CdgoedcodeAsc = 'CDGOEDCODE_ASC',
  CdgoedcodeDesc = 'CDGOEDCODE_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdjournaalAsc = 'CDJOURNAAL_ASC',
  CdjournaalDesc = 'CDJOURNAAL_DESC',
  CdkredbepAsc = 'CDKREDBEP_ASC',
  CdkredbepDesc = 'CDKREDBEP_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdprijslijstAsc = 'CDPRIJSLIJST_ASC',
  CdprijslijstDesc = 'CDPRIJSLIJST_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdstelselAsc = 'CDSTELSEL_ASC',
  CdstelselDesc = 'CDSTELSEL_DESC',
  CdstroomAsc = 'CDSTROOM_ASC',
  CdstroomDesc = 'CDSTROOM_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdtypeAsc = 'CDTYPE_ASC',
  CdtypeDesc = 'CDTYPE_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  CdverkeerAsc = 'CDVERKEER_ASC',
  CdverkeerDesc = 'CDVERKEER_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  CdvervoerAsc = 'CDVERVOER_ASC',
  CdvervoerDesc = 'CDVERVOER_DESC',
  CdverzamelAsc = 'CDVERZAMEL_ASC',
  CdverzamelDesc = 'CDVERZAMEL_DESC',
  ControleBetkenmerkAsc = 'CONTROLE_BETKENMERK_ASC',
  ControleBetkenmerkDesc = 'CONTROLE_BETKENMERK_DESC',
  DatumkvkAsc = 'DATUMKVK_ASC',
  DatumkvkDesc = 'DATUMKVK_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  DatumverifAsc = 'DATUMVERIF_ASC',
  DatumverifDesc = 'DATUMVERIF_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FactureeropdrachtsByCddebiteurCountAsc = 'FACTUREEROPDRACHTS_BY_CDDEBITEUR__COUNT_ASC',
  FactureeropdrachtsByCddebiteurCountDesc = 'FACTUREEROPDRACHTS_BY_CDDEBITEUR__COUNT_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  InFactoringAsc = 'IN_FACTORING_ASC',
  InFactoringDesc = 'IN_FACTORING_DESC',
  IsinkooporgAsc = 'ISINKOOPORG_ASC',
  IsinkooporgDesc = 'ISINKOOPORG_DESC',
  KortpercAsc = 'KORTPERC_ASC',
  KortpercDesc = 'KORTPERC_DESC',
  KredietlimietAsc = 'KREDIETLIMIET_ASC',
  KredietlimietDesc = 'KREDIETLIMIET_DESC',
  LidnrBijInkorgAsc = 'LIDNR_BIJ_INKORG_ASC',
  LidnrBijInkorgDesc = 'LIDNR_BIJ_INKORG_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  NummerkvkAsc = 'NUMMERKVK_ASC',
  NummerkvkDesc = 'NUMMERKVK_DESC',
  OndernemersnrAsc = 'ONDERNEMERSNR_ASC',
  OndernemersnrDesc = 'ONDERNEMERSNR_DESC',
  OntvBorderelAsc = 'ONTV_BORDEREL_ASC',
  OntvBorderelDesc = 'ONTV_BORDEREL_DESC',
  OntvFactIpvLidAsc = 'ONTV_FACT_IPV_LID_ASC',
  OntvFactIpvLidDesc = 'ONTV_FACT_IPV_LID_DESC',
  OverhIdNrAsc = 'OVERH_ID_NR_ASC',
  OverhIdNrDesc = 'OVERH_ID_NR_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  PlaatskvkAsc = 'PLAATSKVK_ASC',
  PlaatskvkDesc = 'PLAATSKVK_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  TelebankfactAsc = 'TELEBANKFACT_ASC',
  TelebankfactDesc = 'TELEBANKFACT_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  VertegenwoordigerAsc = 'VERTEGENWOORDIGER_ASC',
  VertegenwoordigerDesc = 'VERTEGENWOORDIGER_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** All input for the `deleteAcoById` mutation. */
export type DeleteAcoByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAco` mutation. */
export type DeleteAcoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Aco` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Aco` mutation. */
export type DeleteAcoPayload = {
  __typename?: 'DeleteAcoPayload';
  /** The `Aco` that was deleted by this mutation. */
  aco?: Maybe<Aco>;
  /** An edge for our `Aco`. May be used by Relay 1. */
  acoEdge?: Maybe<AcosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAcoId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Aco` mutation. */
export type DeleteAcoPayloadAcoEdgeArgs = {
  orderBy?: InputMaybe<Array<AcosOrderBy>>;
};

/** All input for the `deleteActionById` mutation. */
export type DeleteActionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAction` mutation. */
export type DeleteActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Action` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Action` mutation. */
export type DeleteActionPayload = {
  __typename?: 'DeleteActionPayload';
  /** The `Action` that was deleted by this mutation. */
  action?: Maybe<Action>;
  /** An edge for our `Action`. May be used by Relay 1. */
  actionEdge?: Maybe<ActionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedActionId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Group` that is related to this `Action`. */
  groupByGroupId?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `Action`. */
  reportByReportId?: Maybe<Report>;
  /** Reads a single `User` that is related to this `Action`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Action`. */
  userByUserId?: Maybe<User>;
};


/** The output of our delete `Action` mutation. */
export type DeleteActionPayloadActionEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionsOrderBy>>;
};

/** All input for the `deleteAdreByAdresGuid` mutation. */
export type DeleteAdreByAdresGuidInput = {
  adresGuid: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `deleteAdre` mutation. */
export type DeleteAdreInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `_Adre` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `_Adre` mutation. */
export type DeleteAdrePayload = {
  __typename?: 'DeleteAdrePayload';
  /** The `_Adre` that was deleted by this mutation. */
  _adre?: Maybe<_Adre>;
  /** An edge for our `_Adre`. May be used by Relay 1. */
  _adreEdge?: Maybe<_AdresEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAdreId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `_Adre` mutation. */
export type DeleteAdrePayload_AdreEdgeArgs = {
  orderBy?: InputMaybe<Array<_AdresOrderBy>>;
};

/** All input for the `deleteApplicationById` mutation. */
export type DeleteApplicationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteApplicationByName` mutation. */
export type DeleteApplicationByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteApplication` mutation. */
export type DeleteApplicationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Application` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Application` mutation. */
export type DeleteApplicationPayload = {
  __typename?: 'DeleteApplicationPayload';
  /** The `Application` that was deleted by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Application`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Application` mutation. */
export type DeleteApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the `deleteAreaByFloorIdAndName` mutation. */
export type DeleteAreaByFloorIdAndNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  floorId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

/** All input for the `deleteAreaById` mutation. */
export type DeleteAreaByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteArea` mutation. */
export type DeleteAreaInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Area` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Area` mutation. */
export type DeleteAreaPayload = {
  __typename?: 'DeleteAreaPayload';
  /** The `Area` that was deleted by this mutation. */
  area?: Maybe<Area>;
  /** An edge for our `Area`. May be used by Relay 1. */
  areaEdge?: Maybe<AreasEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAreaId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Floor` that is related to this `Area`. */
  floorByFloorId?: Maybe<Floor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Area`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Area` mutation. */
export type DeleteAreaPayloadAreaEdgeArgs = {
  orderBy?: InputMaybe<Array<AreasOrderBy>>;
};

/** All input for the `deleteAroById` mutation. */
export type DeleteAroByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAro` mutation. */
export type DeleteAroInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Aro` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Aro` mutation. */
export type DeleteAroPayload = {
  __typename?: 'DeleteAroPayload';
  /** The `Aro` that was deleted by this mutation. */
  aro?: Maybe<Aro>;
  /** An edge for our `Aro`. May be used by Relay 1. */
  aroEdge?: Maybe<ArosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAroId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Aro` mutation. */
export type DeleteAroPayloadAroEdgeArgs = {
  orderBy?: InputMaybe<Array<ArosOrderBy>>;
};

/** All input for the `deleteArosAcoById` mutation. */
export type DeleteArosAcoByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteArosAco` mutation. */
export type DeleteArosAcoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ArosAco` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `ArosAco` mutation. */
export type DeleteArosAcoPayload = {
  __typename?: 'DeleteArosAcoPayload';
  /** The `ArosAco` that was deleted by this mutation. */
  arosAco?: Maybe<ArosAco>;
  /** An edge for our `ArosAco`. May be used by Relay 1. */
  arosAcoEdge?: Maybe<ArosAcosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedArosAcoId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ArosAco` mutation. */
export type DeleteArosAcoPayloadArosAcoEdgeArgs = {
  orderBy?: InputMaybe<Array<ArosAcosOrderBy>>;
};

/** All input for the `deleteArtikelByCdartikel` mutation. */
export type DeleteArtikelByCdartikelInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `deleteArtikel` mutation. */
export type DeleteArtikelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Artikel` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteArtikelLogById` mutation. */
export type DeleteArtikelLogByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteArtikelLog` mutation. */
export type DeleteArtikelLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ArtikelLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `ArtikelLog` mutation. */
export type DeleteArtikelLogPayload = {
  __typename?: 'DeleteArtikelLogPayload';
  /** The `ArtikelLog` that was deleted by this mutation. */
  artikelLog?: Maybe<ArtikelLog>;
  /** An edge for our `ArtikelLog`. May be used by Relay 1. */
  artikelLogEdge?: Maybe<ArtikelLogsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedArtikelLogId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ArtikelLog` mutation. */
export type DeleteArtikelLogPayloadArtikelLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelLogsOrderBy>>;
};

/** The output of our delete `Artikel` mutation. */
export type DeleteArtikelPayload = {
  __typename?: 'DeleteArtikelPayload';
  /** The `Artikel` that was deleted by this mutation. */
  artikel?: Maybe<Artikel>;
  /** An edge for our `Artikel`. May be used by Relay 1. */
  artikelEdge?: Maybe<ArtikelsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedArtikelId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Artikel` mutation. */
export type DeleteArtikelPayloadArtikelEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelsOrderBy>>;
};

/** All input for the `deleteArtikelomschrByCdartikelAndCdtaal` mutation. */
export type DeleteArtikelomschrByCdartikelAndCdtaalInput = {
  cdartikel: Scalars['String']['input'];
  cdtaal: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `deleteArtikelomschr` mutation. */
export type DeleteArtikelomschrInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Artikelomschr` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Artikelomschr` mutation. */
export type DeleteArtikelomschrPayload = {
  __typename?: 'DeleteArtikelomschrPayload';
  /** The `Artikelomschr` that was deleted by this mutation. */
  artikelomschr?: Maybe<Artikelomschr>;
  /** An edge for our `Artikelomschr`. May be used by Relay 1. */
  artikelomschrEdge?: Maybe<ArtikelomschrsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedArtikelomschrId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Artikelomschr` mutation. */
export type DeleteArtikelomschrPayloadArtikelomschrEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelomschrsOrderBy>>;
};

/** All input for the `deleteAspNetRoleById` mutation. */
export type DeleteAspNetRoleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** All input for the `deleteAspNetRoleClaimById` mutation. */
export type DeleteAspNetRoleClaimByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAspNetRoleClaim` mutation. */
export type DeleteAspNetRoleClaimInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetRoleClaim` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `AspNetRoleClaim` mutation. */
export type DeleteAspNetRoleClaimPayload = {
  __typename?: 'DeleteAspNetRoleClaimPayload';
  /** Reads a single `AspNetRole` that is related to this `AspNetRoleClaim`. */
  aspNetRoleByRoleId?: Maybe<AspNetRole>;
  /** The `AspNetRoleClaim` that was deleted by this mutation. */
  aspNetRoleClaim?: Maybe<AspNetRoleClaim>;
  /** An edge for our `AspNetRoleClaim`. May be used by Relay 1. */
  aspNetRoleClaimEdge?: Maybe<AspNetRoleClaimsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAspNetRoleClaimId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `AspNetRoleClaim` mutation. */
export type DeleteAspNetRoleClaimPayloadAspNetRoleClaimEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetRoleClaimsOrderBy>>;
};

/** All input for the `deleteAspNetRole` mutation. */
export type DeleteAspNetRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetRole` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `AspNetRole` mutation. */
export type DeleteAspNetRolePayload = {
  __typename?: 'DeleteAspNetRolePayload';
  /** The `AspNetRole` that was deleted by this mutation. */
  aspNetRole?: Maybe<AspNetRole>;
  /** An edge for our `AspNetRole`. May be used by Relay 1. */
  aspNetRoleEdge?: Maybe<AspNetRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAspNetRoleId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `AspNetRole` mutation. */
export type DeleteAspNetRolePayloadAspNetRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetRolesOrderBy>>;
};

/** All input for the `deleteAspNetUserById` mutation. */
export type DeleteAspNetUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** All input for the `deleteAspNetUserClaimById` mutation. */
export type DeleteAspNetUserClaimByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAspNetUserClaim` mutation. */
export type DeleteAspNetUserClaimInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUserClaim` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `AspNetUserClaim` mutation. */
export type DeleteAspNetUserClaimPayload = {
  __typename?: 'DeleteAspNetUserClaimPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserClaim`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserClaim` that was deleted by this mutation. */
  aspNetUserClaim?: Maybe<AspNetUserClaim>;
  /** An edge for our `AspNetUserClaim`. May be used by Relay 1. */
  aspNetUserClaimEdge?: Maybe<AspNetUserClaimsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAspNetUserClaimId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `AspNetUserClaim` mutation. */
export type DeleteAspNetUserClaimPayloadAspNetUserClaimEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserClaimsOrderBy>>;
};

/** All input for the `deleteAspNetUser` mutation. */
export type DeleteAspNetUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteAspNetUserLoginByLoginProviderAndProviderKey` mutation. */
export type DeleteAspNetUserLoginByLoginProviderAndProviderKeyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  loginProvider: Scalars['String']['input'];
  providerKey: Scalars['String']['input'];
};

/** All input for the `deleteAspNetUserLogin` mutation. */
export type DeleteAspNetUserLoginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUserLogin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `AspNetUserLogin` mutation. */
export type DeleteAspNetUserLoginPayload = {
  __typename?: 'DeleteAspNetUserLoginPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserLogin`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserLogin` that was deleted by this mutation. */
  aspNetUserLogin?: Maybe<AspNetUserLogin>;
  /** An edge for our `AspNetUserLogin`. May be used by Relay 1. */
  aspNetUserLoginEdge?: Maybe<AspNetUserLoginsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAspNetUserLoginId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `AspNetUserLogin` mutation. */
export type DeleteAspNetUserLoginPayloadAspNetUserLoginEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserLoginsOrderBy>>;
};

/** The output of our delete `AspNetUser` mutation. */
export type DeleteAspNetUserPayload = {
  __typename?: 'DeleteAspNetUserPayload';
  /** The `AspNetUser` that was deleted by this mutation. */
  aspNetUser?: Maybe<AspNetUser>;
  /** An edge for our `AspNetUser`. May be used by Relay 1. */
  aspNetUserEdge?: Maybe<AspNetUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAspNetUserId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `AspNetUser` mutation. */
export type DeleteAspNetUserPayloadAspNetUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUsersOrderBy>>;
};

/** All input for the `deleteAspNetUserRoleByUserIdAndRoleId` mutation. */
export type DeleteAspNetUserRoleByUserIdAndRoleIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  roleId: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};

/** All input for the `deleteAspNetUserRole` mutation. */
export type DeleteAspNetUserRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUserRole` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `AspNetUserRole` mutation. */
export type DeleteAspNetUserRolePayload = {
  __typename?: 'DeleteAspNetUserRolePayload';
  /** Reads a single `AspNetRole` that is related to this `AspNetUserRole`. */
  aspNetRoleByRoleId?: Maybe<AspNetRole>;
  /** Reads a single `AspNetUser` that is related to this `AspNetUserRole`. */
  aspNetUserByAppUserId?: Maybe<AspNetUser>;
  /** Reads a single `AspNetUser` that is related to this `AspNetUserRole`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserRole` that was deleted by this mutation. */
  aspNetUserRole?: Maybe<AspNetUserRole>;
  /** An edge for our `AspNetUserRole`. May be used by Relay 1. */
  aspNetUserRoleEdge?: Maybe<AspNetUserRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAspNetUserRoleId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `AspNetUserRole` mutation. */
export type DeleteAspNetUserRolePayloadAspNetUserRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserRolesOrderBy>>;
};

/** All input for the `deleteAspNetUserTokenByUserIdAndLoginProviderAndName` mutation. */
export type DeleteAspNetUserTokenByUserIdAndLoginProviderAndNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  loginProvider: Scalars['String']['input'];
  name: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};

/** All input for the `deleteAspNetUserToken` mutation. */
export type DeleteAspNetUserTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUserToken` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `AspNetUserToken` mutation. */
export type DeleteAspNetUserTokenPayload = {
  __typename?: 'DeleteAspNetUserTokenPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserToken`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserToken` that was deleted by this mutation. */
  aspNetUserToken?: Maybe<AspNetUserToken>;
  /** An edge for our `AspNetUserToken`. May be used by Relay 1. */
  aspNetUserTokenEdge?: Maybe<AspNetUserTokensEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAspNetUserTokenId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `AspNetUserToken` mutation. */
export type DeleteAspNetUserTokenPayloadAspNetUserTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserTokensOrderBy>>;
};

/** All input for the `deleteAssemblyByCode` mutation. */
export type DeleteAssemblyByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** All input for the `deleteAssemblyById` mutation. */
export type DeleteAssemblyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAssembly` mutation. */
export type DeleteAssemblyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Assembly` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteAssemblyPartByAssemblyIdAndCdartikel` mutation. */
export type DeleteAssemblyPartByAssemblyIdAndCdartikelInput = {
  assemblyId: Scalars['Int']['input'];
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `deleteAssemblyPartById` mutation. */
export type DeleteAssemblyPartByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAssemblyPart` mutation. */
export type DeleteAssemblyPartInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AssemblyPart` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `AssemblyPart` mutation. */
export type DeleteAssemblyPartPayload = {
  __typename?: 'DeleteAssemblyPartPayload';
  /** The `AssemblyPart` that was deleted by this mutation. */
  assemblyPart?: Maybe<AssemblyPart>;
  /** An edge for our `AssemblyPart`. May be used by Relay 1. */
  assemblyPartEdge?: Maybe<AssemblyPartsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAssemblyPartId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyPart`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `AssemblyPart` mutation. */
export type DeleteAssemblyPartPayloadAssemblyPartEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyPartsOrderBy>>;
};

/** The output of our delete `Assembly` mutation. */
export type DeleteAssemblyPayload = {
  __typename?: 'DeleteAssemblyPayload';
  /** The `Assembly` that was deleted by this mutation. */
  assembly?: Maybe<Assembly>;
  /** An edge for our `Assembly`. May be used by Relay 1. */
  assemblyEdge?: Maybe<AssembliesEdge>;
  /** Reads a single `AssemblyType` that is related to this `Assembly`. */
  assemblyTypeByAssemblyTypeId?: Maybe<AssemblyType>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAssemblyId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Assembly`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Assembly` mutation. */
export type DeleteAssemblyPayloadAssemblyEdgeArgs = {
  orderBy?: InputMaybe<Array<AssembliesOrderBy>>;
};

/** All input for the `deleteAssemblyTypeById` mutation. */
export type DeleteAssemblyTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAssemblyType` mutation. */
export type DeleteAssemblyTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AssemblyType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteAssemblyTypePartByAssemblyTypeIdAndCdartikel` mutation. */
export type DeleteAssemblyTypePartByAssemblyTypeIdAndCdartikelInput = {
  assemblyTypeId: Scalars['Int']['input'];
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `deleteAssemblyTypePartById` mutation. */
export type DeleteAssemblyTypePartByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteAssemblyTypePart` mutation. */
export type DeleteAssemblyTypePartInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AssemblyTypePart` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `AssemblyTypePart` mutation. */
export type DeleteAssemblyTypePartPayload = {
  __typename?: 'DeleteAssemblyTypePartPayload';
  /** Reads a single `AssemblyType` that is related to this `AssemblyTypePart`. */
  assemblyTypeByAssemblyTypeId?: Maybe<AssemblyType>;
  /** The `AssemblyTypePart` that was deleted by this mutation. */
  assemblyTypePart?: Maybe<AssemblyTypePart>;
  /** An edge for our `AssemblyTypePart`. May be used by Relay 1. */
  assemblyTypePartEdge?: Maybe<AssemblyTypePartsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAssemblyTypePartId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyTypePart`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `AssemblyTypePart` mutation. */
export type DeleteAssemblyTypePartPayloadAssemblyTypePartEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyTypePartsOrderBy>>;
};

/** The output of our delete `AssemblyType` mutation. */
export type DeleteAssemblyTypePayload = {
  __typename?: 'DeleteAssemblyTypePayload';
  /** Reads a single `Artikel` that is related to this `AssemblyType`. */
  artikelByCdartikel?: Maybe<Artikel>;
  /** The `AssemblyType` that was deleted by this mutation. */
  assemblyType?: Maybe<AssemblyType>;
  /** An edge for our `AssemblyType`. May be used by Relay 1. */
  assemblyTypeEdge?: Maybe<AssemblyTypesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAssemblyTypeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `AssemblyType` mutation. */
export type DeleteAssemblyTypePayloadAssemblyTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyTypesOrderBy>>;
};

/** All input for the `deleteBuildingByEndUserIdAndName` mutation. */
export type DeleteBuildingByEndUserIdAndNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  endUserId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

/** All input for the `deleteBuildingById` mutation. */
export type DeleteBuildingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteBuilding` mutation. */
export type DeleteBuildingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Building` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Building` mutation. */
export type DeleteBuildingPayload = {
  __typename?: 'DeleteBuildingPayload';
  /** The `Building` that was deleted by this mutation. */
  building?: Maybe<Building>;
  /** An edge for our `Building`. May be used by Relay 1. */
  buildingEdge?: Maybe<BuildingsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedBuildingId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `EndUser` that is related to this `Building`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Building`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Building` mutation. */
export type DeleteBuildingPayloadBuildingEdgeArgs = {
  orderBy?: InputMaybe<Array<BuildingsOrderBy>>;
};

/** All input for the `deleteCalGasByConcentrationAndEngineeringUnitsAndGasId` mutation. */
export type DeleteCalGasByConcentrationAndEngineeringUnitsAndGasIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  concentration: Scalars['Float']['input'];
  engineeringUnits: Scalars['String']['input'];
  gasId: Scalars['Int']['input'];
};

/** All input for the `deleteCalGasById` mutation. */
export type DeleteCalGasByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteCalGas` mutation. */
export type DeleteCalGasInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CalGas` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `CalGas` mutation. */
export type DeleteCalGasPayload = {
  __typename?: 'DeleteCalGasPayload';
  /** The `CalGas` that was deleted by this mutation. */
  calGas?: Maybe<CalGas>;
  /** An edge for our `CalGas`. May be used by Relay 1. */
  calGasEdge?: Maybe<CalGasesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCalGasId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Gas` that is related to this `CalGas`. */
  gasByGasId?: Maybe<Gas>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CalGas`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `CalGas` mutation. */
export type DeleteCalGasPayloadCalGasEdgeArgs = {
  orderBy?: InputMaybe<Array<CalGasesOrderBy>>;
};

/** All input for the `deleteCatalogGroupById` mutation. */
export type DeleteCatalogGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteCatalogGroup` mutation. */
export type DeleteCatalogGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogGroup` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `CatalogGroup` mutation. */
export type DeleteCatalogGroupPayload = {
  __typename?: 'DeleteCatalogGroupPayload';
  /** The `CatalogGroup` that was deleted by this mutation. */
  catalogGroup?: Maybe<CatalogGroup>;
  /** An edge for our `CatalogGroup`. May be used by Relay 1. */
  catalogGroupEdge?: Maybe<CatalogGroupsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCatalogGroupId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `CatalogGroup` mutation. */
export type DeleteCatalogGroupPayloadCatalogGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogGroupsOrderBy>>;
};

/** All input for the `deleteCatalogItemById` mutation. */
export type DeleteCatalogItemByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteCatalogItemFileById` mutation. */
export type DeleteCatalogItemFileByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteCatalogItemFile` mutation. */
export type DeleteCatalogItemFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogItemFile` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `CatalogItemFile` mutation. */
export type DeleteCatalogItemFilePayload = {
  __typename?: 'DeleteCatalogItemFilePayload';
  /** Reads a single `CatalogItem` that is related to this `CatalogItemFile`. */
  catalogItemByCatalogItemId?: Maybe<CatalogItem>;
  /** The `CatalogItemFile` that was deleted by this mutation. */
  catalogItemFile?: Maybe<CatalogItemFile>;
  /** An edge for our `CatalogItemFile`. May be used by Relay 1. */
  catalogItemFileEdge?: Maybe<CatalogItemFilesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCatalogItemFileId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogItemFile`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `CatalogItemFile` mutation. */
export type DeleteCatalogItemFilePayloadCatalogItemFileEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemFilesOrderBy>>;
};

/** All input for the `deleteCatalogItem` mutation. */
export type DeleteCatalogItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogItem` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `CatalogItem` mutation. */
export type DeleteCatalogItemPayload = {
  __typename?: 'DeleteCatalogItemPayload';
  /** The `CatalogItem` that was deleted by this mutation. */
  catalogItem?: Maybe<CatalogItem>;
  /** An edge for our `CatalogItem`. May be used by Relay 1. */
  catalogItemEdge?: Maybe<CatalogItemsEdge>;
  /** Reads a single `CatalogSubGroup` that is related to this `CatalogItem`. */
  catalogSubGroupByCatalogSubGroupId?: Maybe<CatalogSubGroup>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCatalogItemId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogItem`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `CatalogItem` mutation. */
export type DeleteCatalogItemPayloadCatalogItemEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemsOrderBy>>;
};

/** All input for the `deleteCatalogItemRelationById` mutation. */
export type DeleteCatalogItemRelationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteCatalogItemRelation` mutation. */
export type DeleteCatalogItemRelationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogItemRelation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `CatalogItemRelation` mutation. */
export type DeleteCatalogItemRelationPayload = {
  __typename?: 'DeleteCatalogItemRelationPayload';
  /** Reads a single `CatalogItem` that is related to this `CatalogItemRelation`. */
  catalogItemByChildCatalogItemId?: Maybe<CatalogItem>;
  /** Reads a single `CatalogItem` that is related to this `CatalogItemRelation`. */
  catalogItemByParentCatalogItemId?: Maybe<CatalogItem>;
  /** The `CatalogItemRelation` that was deleted by this mutation. */
  catalogItemRelation?: Maybe<CatalogItemRelation>;
  /** An edge for our `CatalogItemRelation`. May be used by Relay 1. */
  catalogItemRelationEdge?: Maybe<CatalogItemRelationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCatalogItemRelationId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `CatalogItemRelation` mutation. */
export type DeleteCatalogItemRelationPayloadCatalogItemRelationEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemRelationsOrderBy>>;
};

/** All input for the `deleteCatalogSubGroupById` mutation. */
export type DeleteCatalogSubGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteCatalogSubGroup` mutation. */
export type DeleteCatalogSubGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogSubGroup` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `CatalogSubGroup` mutation. */
export type DeleteCatalogSubGroupPayload = {
  __typename?: 'DeleteCatalogSubGroupPayload';
  /** Reads a single `CatalogGroup` that is related to this `CatalogSubGroup`. */
  catalogGroupByCatalogGroupId?: Maybe<CatalogGroup>;
  /** The `CatalogSubGroup` that was deleted by this mutation. */
  catalogSubGroup?: Maybe<CatalogSubGroup>;
  /** An edge for our `CatalogSubGroup`. May be used by Relay 1. */
  catalogSubGroupEdge?: Maybe<CatalogSubGroupsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedCatalogSubGroupId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogSubGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `CatalogSubGroup` mutation. */
export type DeleteCatalogSubGroupPayloadCatalogSubGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogSubGroupsOrderBy>>;
};

/** All input for the `deleteChemicalCompoundById` mutation. */
export type DeleteChemicalCompoundByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteChemicalCompound` mutation. */
export type DeleteChemicalCompoundInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ChemicalCompound` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `ChemicalCompound` mutation. */
export type DeleteChemicalCompoundPayload = {
  __typename?: 'DeleteChemicalCompoundPayload';
  /** The `ChemicalCompound` that was deleted by this mutation. */
  chemicalCompound?: Maybe<ChemicalCompound>;
  /** An edge for our `ChemicalCompound`. May be used by Relay 1. */
  chemicalCompoundEdge?: Maybe<ChemicalCompoundsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedChemicalCompoundId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ChemicalCompound`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `ChemicalCompound` mutation. */
export type DeleteChemicalCompoundPayloadChemicalCompoundEdgeArgs = {
  orderBy?: InputMaybe<Array<ChemicalCompoundsOrderBy>>;
};

/** All input for the `deleteDetectorById` mutation. */
export type DeleteDetectorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorBySerialNumberAndDetectorTypeId` mutation. */
export type DeleteDetectorBySerialNumberAndDetectorTypeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorTypeId: Scalars['Int']['input'];
  serialNumber: Scalars['String']['input'];
};

/** All input for the `deleteDetector` mutation. */
export type DeleteDetectorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Detector` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDetectorLocationByDetectorId` mutation. */
export type DeleteDetectorLocationByDetectorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorLocationById` mutation. */
export type DeleteDetectorLocationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorLocation` mutation. */
export type DeleteDetectorLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DetectorLocation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `DetectorLocation` mutation. */
export type DeleteDetectorLocationPayload = {
  __typename?: 'DeleteDetectorLocationPayload';
  /** Reads a single `Area` that is related to this `DetectorLocation`. */
  areaByAreaId?: Maybe<Area>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDetectorLocationId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorLocation`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorLocation` that was deleted by this mutation. */
  detectorLocation?: Maybe<DetectorLocation>;
  /** An edge for our `DetectorLocation`. May be used by Relay 1. */
  detectorLocationEdge?: Maybe<DetectorLocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `DetectorLocation` mutation. */
export type DeleteDetectorLocationPayloadDetectorLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorLocationsOrderBy>>;
};

/** All input for the `deleteDetectorOrderByFactuuropdrachtAndDetectorId` mutation. */
export type DeleteDetectorOrderByFactuuropdrachtAndDetectorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  factuuropdracht: Scalars['String']['input'];
};

/** All input for the `deleteDetectorOrderById` mutation. */
export type DeleteDetectorOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorOrder` mutation. */
export type DeleteDetectorOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DetectorOrder` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `DetectorOrder` mutation. */
export type DeleteDetectorOrderPayload = {
  __typename?: 'DeleteDetectorOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDetectorOrderId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorOrder`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorOrder` that was deleted by this mutation. */
  detectorOrder?: Maybe<DetectorOrder>;
  /** An edge for our `DetectorOrder`. May be used by Relay 1. */
  detectorOrderEdge?: Maybe<DetectorOrdersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorOrder`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `DetectorOrder` mutation. */
export type DeleteDetectorOrderPayloadDetectorOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorOrdersOrderBy>>;
};

/** The output of our delete `Detector` mutation. */
export type DeleteDetectorPayload = {
  __typename?: 'DeleteDetectorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDetectorId?: Maybe<Scalars['ID']['output']>;
  /** The `Detector` that was deleted by this mutation. */
  detector?: Maybe<Detector>;
  /** An edge for our `Detector`. May be used by Relay 1. */
  detectorEdge?: Maybe<DetectorsEdge>;
  /** Reads a single `DetectorType` that is related to this `Detector`. */
  detectorTypeByDetectorTypeId?: Maybe<DetectorType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Detector`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Detector` mutation. */
export type DeleteDetectorPayloadDetectorEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorsOrderBy>>;
};

/** All input for the `deleteDetectorSensorByDetectorIdAndDetectorPosition` mutation. */
export type DeleteDetectorSensorByDetectorIdAndDetectorPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  detectorPosition: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorSensorById` mutation. */
export type DeleteDetectorSensorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorSensorBySensorId` mutation. */
export type DeleteDetectorSensorBySensorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorId: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorSensor` mutation. */
export type DeleteDetectorSensorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DetectorSensor` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDetectorSensorLocationByDetectorSensorId` mutation. */
export type DeleteDetectorSensorLocationByDetectorSensorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorSensorId: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorSensorLocationById` mutation. */
export type DeleteDetectorSensorLocationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorSensorLocationByLicenseIdAndSimsChannel` mutation. */
export type DeleteDetectorSensorLocationByLicenseIdAndSimsChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  licenseId: Scalars['Int']['input'];
  simsChannel: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorSensorLocation` mutation. */
export type DeleteDetectorSensorLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DetectorSensorLocation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `DetectorSensorLocation` mutation. */
export type DeleteDetectorSensorLocationPayload = {
  __typename?: 'DeleteDetectorSensorLocationPayload';
  /** Reads a single `Application` that is related to this `DetectorSensorLocation`. */
  applicationByApplicationId?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDetectorSensorLocationId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `DetectorLocation` that is related to this `DetectorSensorLocation`. */
  detectorLocationByDetectorLocationId?: Maybe<DetectorLocation>;
  /** Reads a single `DetectorSensor` that is related to this `DetectorSensorLocation`. */
  detectorSensorByDetectorSensorId?: Maybe<DetectorSensor>;
  /** The `DetectorSensorLocation` that was deleted by this mutation. */
  detectorSensorLocation?: Maybe<DetectorSensorLocation>;
  /** An edge for our `DetectorSensorLocation`. May be used by Relay 1. */
  detectorSensorLocationEdge?: Maybe<DetectorSensorLocationsEdge>;
  /** Reads a single `License` that is related to this `DetectorSensorLocation`. */
  licenseByLicenseId?: Maybe<License>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SamplePoint` that is related to this `DetectorSensorLocation`. */
  samplePointBySamplePointId?: Maybe<SamplePoint>;
  /** Reads a single `User` that is related to this `DetectorSensorLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `DetectorSensorLocation` mutation. */
export type DeleteDetectorSensorLocationPayloadDetectorSensorLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};

/** The output of our delete `DetectorSensor` mutation. */
export type DeleteDetectorSensorPayload = {
  __typename?: 'DeleteDetectorSensorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDetectorSensorId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorSensor`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorSensor` that was deleted by this mutation. */
  detectorSensor?: Maybe<DetectorSensor>;
  /** An edge for our `DetectorSensor`. May be used by Relay 1. */
  detectorSensorEdge?: Maybe<DetectorSensorsEdge>;
  /** Reads a single `Filter` that is related to this `DetectorSensor`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `Pyrolyser` that is related to this `DetectorSensor`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `DetectorSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `User` that is related to this `DetectorSensor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `DetectorSensor` mutation. */
export type DeleteDetectorSensorPayloadDetectorSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};

/** All input for the `deleteDetectorSensorTypeByDetectorIdAndDetectorPosition` mutation. */
export type DeleteDetectorSensorTypeByDetectorIdAndDetectorPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  detectorPosition: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorSensorTypeById` mutation. */
export type DeleteDetectorSensorTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorSensorType` mutation. */
export type DeleteDetectorSensorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DetectorSensorType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `DetectorSensorType` mutation. */
export type DeleteDetectorSensorTypePayload = {
  __typename?: 'DeleteDetectorSensorTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDetectorSensorTypeId?: Maybe<Scalars['ID']['output']>;
  /** The `DetectorSensorType` that was deleted by this mutation. */
  detectorSensorType?: Maybe<DetectorSensorType>;
  /** An edge for our `DetectorSensorType`. May be used by Relay 1. */
  detectorSensorTypeEdge?: Maybe<DetectorSensorTypesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SensorType` that is related to this `DetectorSensorType`. */
  sensorTypeBySensorTypeId?: Maybe<SensorType>;
  /** Reads a single `User` that is related to this `DetectorSensorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `DetectorSensorType` mutation. */
export type DeleteDetectorSensorTypePayloadDetectorSensorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorTypesOrderBy>>;
};

/** All input for the `deleteDetectorTypeById` mutation. */
export type DeleteDetectorTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDetectorTypeByPrefixAndCodeAndSuffix` mutation. */
export type DeleteDetectorTypeByPrefixAndCodeAndSuffixInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  prefix: Scalars['String']['input'];
  suffix: Scalars['String']['input'];
};

/** All input for the `deleteDetectorType` mutation. */
export type DeleteDetectorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DetectorType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `DetectorType` mutation. */
export type DeleteDetectorTypePayload = {
  __typename?: 'DeleteDetectorTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDetectorTypeId?: Maybe<Scalars['ID']['output']>;
  /** The `DetectorType` that was deleted by this mutation. */
  detectorType?: Maybe<DetectorType>;
  /** An edge for our `DetectorType`. May be used by Relay 1. */
  detectorTypeEdge?: Maybe<DetectorTypesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `DetectorType` mutation. */
export type DeleteDetectorTypePayloadDetectorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorTypesOrderBy>>;
};

/** All input for the `deleteDpCardById` mutation. */
export type DeleteDpCardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDpCard` mutation. */
export type DeleteDpCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DpCard` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `DpCard` mutation. */
export type DeleteDpCardPayload = {
  __typename?: 'DeleteDpCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDpCardId?: Maybe<Scalars['ID']['output']>;
  /** The `DpCard` that was deleted by this mutation. */
  dpCard?: Maybe<DpCard>;
  /** An edge for our `DpCard`. May be used by Relay 1. */
  dpCardEdge?: Maybe<DpCardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DpCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `DpCard` mutation. */
export type DeleteDpCardPayloadDpCardEdgeArgs = {
  orderBy?: InputMaybe<Array<DpCardsOrderBy>>;
};

/** All input for the `deleteElectrolyteById` mutation. */
export type DeleteElectrolyteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteElectrolyteByName` mutation. */
export type DeleteElectrolyteByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteElectrolyte` mutation. */
export type DeleteElectrolyteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Electrolyte` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Electrolyte` mutation. */
export type DeleteElectrolytePayload = {
  __typename?: 'DeleteElectrolytePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedElectrolyteId?: Maybe<Scalars['ID']['output']>;
  /** The `Electrolyte` that was deleted by this mutation. */
  electrolyte?: Maybe<Electrolyte>;
  /** An edge for our `Electrolyte`. May be used by Relay 1. */
  electrolyteEdge?: Maybe<ElectrolytesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Electrolyte`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Electrolyte` mutation. */
export type DeleteElectrolytePayloadElectrolyteEdgeArgs = {
  orderBy?: InputMaybe<Array<ElectrolytesOrderBy>>;
};

/** All input for the `deleteEndUserById` mutation. */
export type DeleteEndUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteEndUserByNameAndLocationAndSubLocation` mutation. */
export type DeleteEndUserByNameAndLocationAndSubLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  location: Scalars['String']['input'];
  name: Scalars['String']['input'];
  subLocation: Scalars['String']['input'];
};

/** All input for the `deleteEndUser` mutation. */
export type DeleteEndUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `EndUser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `EndUser` mutation. */
export type DeleteEndUserPayload = {
  __typename?: 'DeleteEndUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedEndUserId?: Maybe<Scalars['ID']['output']>;
  /** The `EndUser` that was deleted by this mutation. */
  endUser?: Maybe<EndUser>;
  /** An edge for our `EndUser`. May be used by Relay 1. */
  endUserEdge?: Maybe<EndUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `EndUser`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `EndUser` mutation. */
export type DeleteEndUserPayloadEndUserEdgeArgs = {
  orderBy?: InputMaybe<Array<EndUsersOrderBy>>;
};

/** All input for the `deleteFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikel` mutation. */
export type DeleteFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikelInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
};

/** All input for the `deleteFactopdrachtArtikelExclusionById` mutation. */
export type DeleteFactopdrachtArtikelExclusionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteFactopdrachtArtikelExclusion` mutation. */
export type DeleteFactopdrachtArtikelExclusionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FactopdrachtArtikelExclusion` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `FactopdrachtArtikelExclusion` mutation. */
export type DeleteFactopdrachtArtikelExclusionPayload = {
  __typename?: 'DeleteFactopdrachtArtikelExclusionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFactopdrachtArtikelExclusionId?: Maybe<Scalars['ID']['output']>;
  /** The `FactopdrachtArtikelExclusion` that was deleted by this mutation. */
  factopdrachtArtikelExclusion?: Maybe<FactopdrachtArtikelExclusion>;
  /** An edge for our `FactopdrachtArtikelExclusion`. May be used by Relay 1. */
  factopdrachtArtikelExclusionEdge?: Maybe<FactopdrachtArtikelExclusionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FactopdrachtArtikelExclusion` mutation. */
export type DeleteFactopdrachtArtikelExclusionPayloadFactopdrachtArtikelExclusionEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtArtikelExclusionsOrderBy>>;
};

/** All input for the `deleteFactopdrachtregelLineByFactopdrRglGuid` mutation. */
export type DeleteFactopdrachtregelLineByFactopdrRglGuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factopdrRglGuid: Scalars['String']['input'];
};

/** All input for the `deleteFactopdrachtregelLineById` mutation. */
export type DeleteFactopdrachtregelLineByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteFactopdrachtregelLineDateById` mutation. */
export type DeleteFactopdrachtregelLineDateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteFactopdrachtregelLineDate` mutation. */
export type DeleteFactopdrachtregelLineDateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FactopdrachtregelLineDate` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `FactopdrachtregelLineDate` mutation. */
export type DeleteFactopdrachtregelLineDatePayload = {
  __typename?: 'DeleteFactopdrachtregelLineDatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFactopdrachtregelLineDateId?: Maybe<Scalars['ID']['output']>;
  /** The `FactopdrachtregelLineDate` that was deleted by this mutation. */
  factopdrachtregelLineDate?: Maybe<FactopdrachtregelLineDate>;
  /** An edge for our `FactopdrachtregelLineDate`. May be used by Relay 1. */
  factopdrachtregelLineDateEdge?: Maybe<FactopdrachtregelLineDatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FactopdrachtregelLineDate` mutation. */
export type DeleteFactopdrachtregelLineDatePayloadFactopdrachtregelLineDateEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLineDatesOrderBy>>;
};

/** All input for the `deleteFactopdrachtregelLine` mutation. */
export type DeleteFactopdrachtregelLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FactopdrachtregelLine` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `FactopdrachtregelLine` mutation. */
export type DeleteFactopdrachtregelLinePayload = {
  __typename?: 'DeleteFactopdrachtregelLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFactopdrachtregelLineId?: Maybe<Scalars['ID']['output']>;
  /** The `FactopdrachtregelLine` that was deleted by this mutation. */
  factopdrachtregelLine?: Maybe<FactopdrachtregelLine>;
  /** An edge for our `FactopdrachtregelLine`. May be used by Relay 1. */
  factopdrachtregelLineEdge?: Maybe<FactopdrachtregelLinesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FactopdrachtregelLine` mutation. */
export type DeleteFactopdrachtregelLinePayloadFactopdrachtregelLineEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLinesOrderBy>>;
};

/** All input for the `deleteFactopdrachtregelLineRemarkById` mutation. */
export type DeleteFactopdrachtregelLineRemarkByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteFactopdrachtregelLineRemark` mutation. */
export type DeleteFactopdrachtregelLineRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `FactopdrachtregelLineRemark` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `FactopdrachtregelLineRemark` mutation. */
export type DeleteFactopdrachtregelLineRemarkPayload = {
  __typename?: 'DeleteFactopdrachtregelLineRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFactopdrachtregelLineRemarkId?: Maybe<Scalars['ID']['output']>;
  /** The `FactopdrachtregelLineRemark` that was deleted by this mutation. */
  factopdrachtregelLineRemark?: Maybe<FactopdrachtregelLineRemark>;
  /** An edge for our `FactopdrachtregelLineRemark`. May be used by Relay 1. */
  factopdrachtregelLineRemarkEdge?: Maybe<FactopdrachtregelLineRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FactopdrachtregelLineRemark`. */
  userByUserId?: Maybe<User>;
};


/** The output of our delete `FactopdrachtregelLineRemark` mutation. */
export type DeleteFactopdrachtregelLineRemarkPayloadFactopdrachtregelLineRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLineRemarksOrderBy>>;
};

/** All input for the `deleteFactuurByFactuuropdracht` mutation. */
export type DeleteFactuurByFactuuropdrachtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
};

/** All input for the `deleteFactuurById` mutation. */
export type DeleteFactuurByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteFactuur` mutation. */
export type DeleteFactuurInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Factuur` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Factuur` mutation. */
export type DeleteFactuurPayload = {
  __typename?: 'DeleteFactuurPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFactuurId?: Maybe<Scalars['ID']['output']>;
  /** The `Factuur` that was deleted by this mutation. */
  factuur?: Maybe<Factuur>;
  /** An edge for our `Factuur`. May be used by Relay 1. */
  factuurEdge?: Maybe<FactuursEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userByCheckedId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userBySentId?: Maybe<User>;
};


/** The output of our delete `Factuur` mutation. */
export type DeleteFactuurPayloadFactuurEdgeArgs = {
  orderBy?: InputMaybe<Array<FactuursOrderBy>>;
};

/** All input for the `deleteFilterById` mutation. */
export type DeleteFilterByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteFilterByName` mutation. */
export type DeleteFilterByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteFilter` mutation. */
export type DeleteFilterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Filter` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Filter` mutation. */
export type DeleteFilterPayload = {
  __typename?: 'DeleteFilterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFilterId?: Maybe<Scalars['ID']['output']>;
  /** The `Filter` that was deleted by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Filter`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Filter` mutation. */
export type DeleteFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the `deleteFloorByBuildingIdAndName` mutation. */
export type DeleteFloorByBuildingIdAndNameInput = {
  buildingId: Scalars['Int']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteFloorById` mutation. */
export type DeleteFloorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteFloor` mutation. */
export type DeleteFloorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Floor` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Floor` mutation. */
export type DeleteFloorPayload = {
  __typename?: 'DeleteFloorPayload';
  /** Reads a single `Building` that is related to this `Floor`. */
  buildingByBuildingId?: Maybe<Building>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFloorId?: Maybe<Scalars['ID']['output']>;
  /** The `Floor` that was deleted by this mutation. */
  floor?: Maybe<Floor>;
  /** An edge for our `Floor`. May be used by Relay 1. */
  floorEdge?: Maybe<FloorsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Floor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Floor` mutation. */
export type DeleteFloorPayloadFloorEdgeArgs = {
  orderBy?: InputMaybe<Array<FloorsOrderBy>>;
};

/** All input for the `deleteGasById` mutation. */
export type DeleteGasByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteGasByName` mutation. */
export type DeleteGasByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteGas` mutation. */
export type DeleteGasInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Gas` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Gas` mutation. */
export type DeleteGasPayload = {
  __typename?: 'DeleteGasPayload';
  /** Reads a single `ChemicalCompound` that is related to this `Gas`. */
  chemicalCompoundByChemicalCompoundId?: Maybe<ChemicalCompound>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedGasId?: Maybe<Scalars['ID']['output']>;
  /** The `Gas` that was deleted by this mutation. */
  gas?: Maybe<Gas>;
  /** An edge for our `Gas`. May be used by Relay 1. */
  gasEdge?: Maybe<GasesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Gas`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Gas` mutation. */
export type DeleteGasPayloadGasEdgeArgs = {
  orderBy?: InputMaybe<Array<GasesOrderBy>>;
};

/** All input for the `deleteGroupById` mutation. */
export type DeleteGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Group` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedGroupId?: Maybe<Scalars['ID']['output']>;
  /** The `Group` that was deleted by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Group`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Group` mutation. */
export type DeleteGroupPayloadGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** All input for the `deleteGroupPermissionByGroupId` mutation. */
export type DeleteGroupPermissionByGroupIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['Int']['input'];
};

/** All input for the `deleteGroupPermissionById` mutation. */
export type DeleteGroupPermissionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteGroupPermission` mutation. */
export type DeleteGroupPermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `GroupPermission` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `GroupPermission` mutation. */
export type DeleteGroupPermissionPayload = {
  __typename?: 'DeleteGroupPermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedGroupPermissionId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Group` that is related to this `GroupPermission`. */
  groupByGroupId?: Maybe<Group>;
  /** The `GroupPermission` that was deleted by this mutation. */
  groupPermission?: Maybe<GroupPermission>;
  /** An edge for our `GroupPermission`. May be used by Relay 1. */
  groupPermissionEdge?: Maybe<GroupPermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `GroupPermission` mutation. */
export type DeleteGroupPermissionPayloadGroupPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupPermissionsOrderBy>>;
};

/** All input for the `deleteGroupRightByGroupIdAndPath` mutation. */
export type DeleteGroupRightByGroupIdAndPathInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['Int']['input'];
  path: Scalars['String']['input'];
};

/** All input for the `deleteGroupRightById` mutation. */
export type DeleteGroupRightByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteGroupRight` mutation. */
export type DeleteGroupRightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `GroupRight` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `GroupRight` mutation. */
export type DeleteGroupRightPayload = {
  __typename?: 'DeleteGroupRightPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedGroupRightId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Group` that is related to this `GroupRight`. */
  groupByGroupId?: Maybe<Group>;
  /** The `GroupRight` that was deleted by this mutation. */
  groupRight?: Maybe<GroupRight>;
  /** An edge for our `GroupRight`. May be used by Relay 1. */
  groupRightEdge?: Maybe<GroupRightsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `GroupRight` mutation. */
export type DeleteGroupRightPayloadGroupRightEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupRightsOrderBy>>;
};

/** All input for the `deleteHardwareById` mutation. */
export type DeleteHardwareByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteHardware` mutation. */
export type DeleteHardwareInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Hardware` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Hardware` mutation. */
export type DeleteHardwarePayload = {
  __typename?: 'DeleteHardwarePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedHardwareId?: Maybe<Scalars['ID']['output']>;
  /** The `Hardware` that was deleted by this mutation. */
  hardware?: Maybe<Hardware>;
  /** An edge for our `Hardware`. May be used by Relay 1. */
  hardwareEdge?: Maybe<HardwaresEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Hardware`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Hardware`. */
  userByUserId?: Maybe<User>;
};


/** The output of our delete `Hardware` mutation. */
export type DeleteHardwarePayloadHardwareEdgeArgs = {
  orderBy?: InputMaybe<Array<HardwaresOrderBy>>;
};

/** All input for the `deleteIncomingDocumentById` mutation. */
export type DeleteIncomingDocumentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteIncomingDocument` mutation. */
export type DeleteIncomingDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `IncomingDocument` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `IncomingDocument` mutation. */
export type DeleteIncomingDocumentPayload = {
  __typename?: 'DeleteIncomingDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedIncomingDocumentId?: Maybe<Scalars['ID']['output']>;
  /** The `IncomingDocument` that was deleted by this mutation. */
  incomingDocument?: Maybe<IncomingDocument>;
  /** An edge for our `IncomingDocument`. May be used by Relay 1. */
  incomingDocumentEdge?: Maybe<IncomingDocumentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `IncomingDocument`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `IncomingDocument`. */
  userByUserId?: Maybe<User>;
};


/** The output of our delete `IncomingDocument` mutation. */
export type DeleteIncomingDocumentPayloadIncomingDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<IncomingDocumentsOrderBy>>;
};

/** All input for the `deleteInkoopgegevenByCdartikelAndInkvolgnr` mutation. */
export type DeleteInkoopgegevenByCdartikelAndInkvolgnrInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  inkvolgnr: Scalars['Int']['input'];
};

/** All input for the `deleteInkoopgegeven` mutation. */
export type DeleteInkoopgegevenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Inkoopgegeven` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Inkoopgegeven` mutation. */
export type DeleteInkoopgegevenPayload = {
  __typename?: 'DeleteInkoopgegevenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedInkoopgegevenId?: Maybe<Scalars['ID']['output']>;
  /** The `Inkoopgegeven` that was deleted by this mutation. */
  inkoopgegeven?: Maybe<Inkoopgegeven>;
  /** An edge for our `Inkoopgegeven`. May be used by Relay 1. */
  inkoopgegevenEdge?: Maybe<InkoopgegevensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Inkoopgegeven` mutation. */
export type DeleteInkoopgegevenPayloadInkoopgegevenEdgeArgs = {
  orderBy?: InputMaybe<Array<InkoopgegevensOrderBy>>;
};

/** All input for the `deleteInkoopgegevensLogById` mutation. */
export type DeleteInkoopgegevensLogByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteInkoopgegevensLog` mutation. */
export type DeleteInkoopgegevensLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `InkoopgegevensLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `InkoopgegevensLog` mutation. */
export type DeleteInkoopgegevensLogPayload = {
  __typename?: 'DeleteInkoopgegevensLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedInkoopgegevensLogId?: Maybe<Scalars['ID']['output']>;
  /** The `InkoopgegevensLog` that was deleted by this mutation. */
  inkoopgegevensLog?: Maybe<InkoopgegevensLog>;
  /** An edge for our `InkoopgegevensLog`. May be used by Relay 1. */
  inkoopgegevensLogEdge?: Maybe<InkoopgegevensLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `InkoopgegevensLog` mutation. */
export type DeleteInkoopgegevensLogPayloadInkoopgegevensLogEdgeArgs = {
  orderBy?: InputMaybe<Array<InkoopgegevensLogsOrderBy>>;
};

/** All input for the `deleteInkooporderregelLineById` mutation. */
export type DeleteInkooporderregelLineByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteInkooporderregelLineByInkopdrRglGuid` mutation. */
export type DeleteInkooporderregelLineByInkopdrRglGuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  inkopdrRglGuid: Scalars['String']['input'];
};

/** All input for the `deleteInkooporderregelLine` mutation. */
export type DeleteInkooporderregelLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `InkooporderregelLine` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `InkooporderregelLine` mutation. */
export type DeleteInkooporderregelLinePayload = {
  __typename?: 'DeleteInkooporderregelLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedInkooporderregelLineId?: Maybe<Scalars['ID']['output']>;
  /** The `InkooporderregelLine` that was deleted by this mutation. */
  inkooporderregelLine?: Maybe<InkooporderregelLine>;
  /** An edge for our `InkooporderregelLine`. May be used by Relay 1. */
  inkooporderregelLineEdge?: Maybe<InkooporderregelLinesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `InkooporderregelLine` mutation. */
export type DeleteInkooporderregelLinePayloadInkooporderregelLineEdgeArgs = {
  orderBy?: InputMaybe<Array<InkooporderregelLinesOrderBy>>;
};

/** All input for the `deleteItemByCdartikelAndSerialNumber` mutation. */
export type DeleteItemByCdartikelAndSerialNumberInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  serialNumber: Scalars['String']['input'];
};

/** All input for the `deleteItemById` mutation. */
export type DeleteItemByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteItem` mutation. */
export type DeleteItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Item` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Item` mutation. */
export type DeleteItemPayload = {
  __typename?: 'DeleteItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedItemId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `EndUser` that is related to this `Item`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `Item` that was deleted by this mutation. */
  item?: Maybe<Item>;
  /** An edge for our `Item`. May be used by Relay 1. */
  itemEdge?: Maybe<ItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Item`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Item` mutation. */
export type DeleteItemPayloadItemEdgeArgs = {
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
};

/** All input for the `deleteJobById` mutation. */
export type DeleteJobByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteJob` mutation. */
export type DeleteJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Job` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Job` mutation. */
export type DeleteJobPayload = {
  __typename?: 'DeleteJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJobId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `EndUser` that is related to this `Job`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `Job` that was deleted by this mutation. */
  job?: Maybe<Job>;
  /** An edge for our `Job`. May be used by Relay 1. */
  jobEdge?: Maybe<JobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Job`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Job` mutation. */
export type DeleteJobPayloadJobEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** All input for the `deleteJunctionBoxById` mutation. */
export type DeleteJunctionBoxByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteJunctionBox` mutation. */
export type DeleteJunctionBoxInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `JunctionBox` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `JunctionBox` mutation. */
export type DeleteJunctionBoxPayload = {
  __typename?: 'DeleteJunctionBoxPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedJunctionBoxId?: Maybe<Scalars['ID']['output']>;
  /** The `JunctionBox` that was deleted by this mutation. */
  junctionBox?: Maybe<JunctionBox>;
  /** An edge for our `JunctionBox`. May be used by Relay 1. */
  junctionBoxEdge?: Maybe<JunctionBoxesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `JunctionBox`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `JunctionBox` mutation. */
export type DeleteJunctionBoxPayloadJunctionBoxEdgeArgs = {
  orderBy?: InputMaybe<Array<JunctionBoxesOrderBy>>;
};

/** All input for the `deleteLandByCdland` mutation. */
export type DeleteLandByCdlandInput = {
  cdland: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `deleteLand` mutation. */
export type DeleteLandInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `_Land` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `_Land` mutation. */
export type DeleteLandPayload = {
  __typename?: 'DeleteLandPayload';
  /** The `_Land` that was deleted by this mutation. */
  _land?: Maybe<_Land>;
  /** An edge for our `_Land`. May be used by Relay 1. */
  _landEdge?: Maybe<_LandsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLandId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `_Land` mutation. */
export type DeleteLandPayload_LandEdgeArgs = {
  orderBy?: InputMaybe<Array<_LandsOrderBy>>;
};

/** All input for the `deleteLeadById` mutation. */
export type DeleteLeadByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteLead` mutation. */
export type DeleteLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Lead` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Lead` mutation. */
export type DeleteLeadPayload = {
  __typename?: 'DeleteLeadPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLeadId?: Maybe<Scalars['ID']['output']>;
  /** The `Lead` that was deleted by this mutation. */
  lead?: Maybe<Lead>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Lead`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Lead` mutation. */
export type DeleteLeadPayloadLeadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the `deleteLicenseById` mutation. */
export type DeleteLicenseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteLicenseCustomerById` mutation. */
export type DeleteLicenseCustomerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteLicenseCustomer` mutation. */
export type DeleteLicenseCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `LicenseCustomer` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `LicenseCustomer` mutation. */
export type DeleteLicenseCustomerPayload = {
  __typename?: 'DeleteLicenseCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLicenseCustomerId?: Maybe<Scalars['ID']['output']>;
  /** The `LicenseCustomer` that was deleted by this mutation. */
  licenseCustomer?: Maybe<LicenseCustomer>;
  /** An edge for our `LicenseCustomer`. May be used by Relay 1. */
  licenseCustomerEdge?: Maybe<LicenseCustomersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseCustomer`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `LicenseCustomer` mutation. */
export type DeleteLicenseCustomerPayloadLicenseCustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseCustomersOrderBy>>;
};

/** All input for the `deleteLicense` mutation. */
export type DeleteLicenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `License` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteLicenseModuleById` mutation. */
export type DeleteLicenseModuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteLicenseModule` mutation. */
export type DeleteLicenseModuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `LicenseModule` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `LicenseModule` mutation. */
export type DeleteLicenseModulePayload = {
  __typename?: 'DeleteLicenseModulePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLicenseModuleId?: Maybe<Scalars['ID']['output']>;
  /** The `LicenseModule` that was deleted by this mutation. */
  licenseModule?: Maybe<LicenseModule>;
  /** An edge for our `LicenseModule`. May be used by Relay 1. */
  licenseModuleEdge?: Maybe<LicenseModulesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseModule`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `LicenseModule` mutation. */
export type DeleteLicenseModulePayloadLicenseModuleEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseModulesOrderBy>>;
};

/** All input for the `deleteLicenseOrderById` mutation. */
export type DeleteLicenseOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteLicenseOrderByLicenseIdAndFactuuropdracht` mutation. */
export type DeleteLicenseOrderByLicenseIdAndFactuuropdrachtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  licenseId: Scalars['Int']['input'];
};

/** All input for the `deleteLicenseOrderByLicenseRegistrationIdAndFactuuropdracht` mutation. */
export type DeleteLicenseOrderByLicenseRegistrationIdAndFactuuropdrachtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  licenseRegistrationId: Scalars['Int']['input'];
};

/** All input for the `deleteLicenseOrder` mutation. */
export type DeleteLicenseOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `LicenseOrder` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `LicenseOrder` mutation. */
export type DeleteLicenseOrderPayload = {
  __typename?: 'DeleteLicenseOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLicenseOrderId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `License` that is related to this `LicenseOrder`. */
  licenseByLicenseId?: Maybe<License>;
  /** The `LicenseOrder` that was deleted by this mutation. */
  licenseOrder?: Maybe<LicenseOrder>;
  /** An edge for our `LicenseOrder`. May be used by Relay 1. */
  licenseOrderEdge?: Maybe<LicenseOrdersEdge>;
  /** Reads a single `LicenseRegistration` that is related to this `LicenseOrder`. */
  licenseRegistrationByLicenseRegistrationId?: Maybe<LicenseRegistration>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseOrder`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `LicenseOrder` mutation. */
export type DeleteLicenseOrderPayloadLicenseOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseOrdersOrderBy>>;
};

/** The output of our delete `License` mutation. */
export type DeleteLicensePayload = {
  __typename?: 'DeleteLicensePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLicenseId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `EndUser` that is related to this `License`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `License` that was deleted by this mutation. */
  license?: Maybe<License>;
  /** Reads a single `LicenseCustomer` that is related to this `License`. */
  licenseCustomerByLicenseCustomerId?: Maybe<LicenseCustomer>;
  /** An edge for our `License`. May be used by Relay 1. */
  licenseEdge?: Maybe<LicensesEdge>;
  /** Reads a single `LicenseModule` that is related to this `License`. */
  licenseModuleByLicenseModuleId?: Maybe<LicenseModule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `License`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `License` mutation. */
export type DeleteLicensePayloadLicenseEdgeArgs = {
  orderBy?: InputMaybe<Array<LicensesOrderBy>>;
};

/** All input for the `deleteLicenseRegistrationById` mutation. */
export type DeleteLicenseRegistrationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteLicenseRegistration` mutation. */
export type DeleteLicenseRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `LicenseRegistration` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `LicenseRegistration` mutation. */
export type DeleteLicenseRegistrationPayload = {
  __typename?: 'DeleteLicenseRegistrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLicenseRegistrationId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `License` that is related to this `LicenseRegistration`. */
  licenseByLicenseId?: Maybe<License>;
  /** The `LicenseRegistration` that was deleted by this mutation. */
  licenseRegistration?: Maybe<LicenseRegistration>;
  /** An edge for our `LicenseRegistration`. May be used by Relay 1. */
  licenseRegistrationEdge?: Maybe<LicenseRegistrationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseRegistration`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `LicenseRegistration` mutation. */
export type DeleteLicenseRegistrationPayloadLicenseRegistrationEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseRegistrationsOrderBy>>;
};

/** All input for the `deleteMaintenanceVisitById` mutation. */
export type DeleteMaintenanceVisitByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteMaintenanceVisit` mutation. */
export type DeleteMaintenanceVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MaintenanceVisit` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteMaintenanceVisitLineById` mutation. */
export type DeleteMaintenanceVisitLineByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationId` mutation. */
export type DeleteMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorSensorLocationId: Scalars['Int']['input'];
  maintenanceVisitId: Scalars['Int']['input'];
};

/** All input for the `deleteMaintenanceVisitLine` mutation. */
export type DeleteMaintenanceVisitLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MaintenanceVisitLine` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `MaintenanceVisitLine` mutation. */
export type DeleteMaintenanceVisitLinePayload = {
  __typename?: 'DeleteMaintenanceVisitLinePayload';
  /** Reads a single `CalGas` that is related to this `MaintenanceVisitLine`. */
  calGasByCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMaintenanceVisitLineId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `DetectorSensor` that is related to this `MaintenanceVisitLine`. */
  detectorSensorByDetectorSensorId?: Maybe<DetectorSensor>;
  /** Reads a single `DetectorSensorLocation` that is related to this `MaintenanceVisitLine`. */
  detectorSensorLocationByDetectorSensorLocationId?: Maybe<DetectorSensorLocation>;
  /** Reads a single `Filter` that is related to this `MaintenanceVisitLine`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `MaintenanceVisit` that is related to this `MaintenanceVisitLine`. */
  maintenanceVisitByMaintenanceVisitId?: Maybe<MaintenanceVisit>;
  /** The `MaintenanceVisitLine` that was deleted by this mutation. */
  maintenanceVisitLine?: Maybe<MaintenanceVisitLine>;
  /** An edge for our `MaintenanceVisitLine`. May be used by Relay 1. */
  maintenanceVisitLineEdge?: Maybe<MaintenanceVisitLinesEdge>;
  /** Reads a single `Pyrolyser` that is related to this `MaintenanceVisitLine`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `MaintenanceVisitLine`. */
  sensorByOriginalSensorId?: Maybe<Sensor>;
  /** Reads a single `Sensor` that is related to this `MaintenanceVisitLine`. */
  sensorBySensorId?: Maybe<Sensor>;
};


/** The output of our delete `MaintenanceVisitLine` mutation. */
export type DeleteMaintenanceVisitLinePayloadMaintenanceVisitLineEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};

/** The output of our delete `MaintenanceVisit` mutation. */
export type DeleteMaintenanceVisitPayload = {
  __typename?: 'DeleteMaintenanceVisitPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMaintenanceVisitId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `EndUser` that is related to this `MaintenanceVisit`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `MaintenanceVisit` that was deleted by this mutation. */
  maintenanceVisit?: Maybe<MaintenanceVisit>;
  /** An edge for our `MaintenanceVisit`. May be used by Relay 1. */
  maintenanceVisitEdge?: Maybe<MaintenanceVisitsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `MaintenanceVisit`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `MaintenanceVisit`. */
  userByUserId?: Maybe<User>;
};


/** The output of our delete `MaintenanceVisit` mutation. */
export type DeleteMaintenanceVisitPayloadMaintenanceVisitEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitsOrderBy>>;
};

/** All input for the `deleteMaintenanceVisitRemarkById` mutation. */
export type DeleteMaintenanceVisitRemarkByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteMaintenanceVisitRemarkByMaintenanceVisitIdAndLine` mutation. */
export type DeleteMaintenanceVisitRemarkByMaintenanceVisitIdAndLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  line: Scalars['Int']['input'];
  maintenanceVisitId: Scalars['Int']['input'];
};

/** All input for the `deleteMaintenanceVisitRemark` mutation. */
export type DeleteMaintenanceVisitRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MaintenanceVisitRemark` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `MaintenanceVisitRemark` mutation. */
export type DeleteMaintenanceVisitRemarkPayload = {
  __typename?: 'DeleteMaintenanceVisitRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMaintenanceVisitRemarkId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `MaintenanceVisit` that is related to this `MaintenanceVisitRemark`. */
  maintenanceVisitByMaintenanceVisitId?: Maybe<MaintenanceVisit>;
  /** The `MaintenanceVisitRemark` that was deleted by this mutation. */
  maintenanceVisitRemark?: Maybe<MaintenanceVisitRemark>;
  /** An edge for our `MaintenanceVisitRemark`. May be used by Relay 1. */
  maintenanceVisitRemarkEdge?: Maybe<MaintenanceVisitRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `MaintenanceVisitRemark` mutation. */
export type DeleteMaintenanceVisitRemarkPayloadMaintenanceVisitRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitRemarksOrderBy>>;
};

/** All input for the `deleteMembraneById` mutation. */
export type DeleteMembraneByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteMembraneByName` mutation. */
export type DeleteMembraneByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteMembrane` mutation. */
export type DeleteMembraneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Membrane` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Membrane` mutation. */
export type DeleteMembranePayload = {
  __typename?: 'DeleteMembranePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMembraneId?: Maybe<Scalars['ID']['output']>;
  /** The `Membrane` that was deleted by this mutation. */
  membrane?: Maybe<Membrane>;
  /** An edge for our `Membrane`. May be used by Relay 1. */
  membraneEdge?: Maybe<MembranesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Membrane`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Membrane` mutation. */
export type DeleteMembranePayloadMembraneEdgeArgs = {
  orderBy?: InputMaybe<Array<MembranesOrderBy>>;
};

/** All input for the `deleteORingById` mutation. */
export type DeleteORingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteORingByName` mutation. */
export type DeleteORingByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteORing` mutation. */
export type DeleteORingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ORing` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `ORing` mutation. */
export type DeleteORingPayload = {
  __typename?: 'DeleteORingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedORingId?: Maybe<Scalars['ID']['output']>;
  /** The `ORing` that was deleted by this mutation. */
  oRing?: Maybe<ORing>;
  /** An edge for our `ORing`. May be used by Relay 1. */
  oRingEdge?: Maybe<ORingsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ORing`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `ORing` mutation. */
export type DeleteORingPayloadORingEdgeArgs = {
  orderBy?: InputMaybe<Array<ORingsOrderBy>>;
};

/** All input for the `deleteOfferteRemarkById` mutation. */
export type DeleteOfferteRemarkByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteOfferteRemarkByOfferteId` mutation. */
export type DeleteOfferteRemarkByOfferteIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  offerteId: Scalars['String']['input'];
};

/** All input for the `deleteOfferteRemark` mutation. */
export type DeleteOfferteRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OfferteRemark` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `OfferteRemark` mutation. */
export type DeleteOfferteRemarkPayload = {
  __typename?: 'DeleteOfferteRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedOfferteRemarkId?: Maybe<Scalars['ID']['output']>;
  /** The `OfferteRemark` that was deleted by this mutation. */
  offerteRemark?: Maybe<OfferteRemark>;
  /** An edge for our `OfferteRemark`. May be used by Relay 1. */
  offerteRemarkEdge?: Maybe<OfferteRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `OfferteRemark`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `OfferteRemark` mutation. */
export type DeleteOfferteRemarkPayloadOfferteRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<OfferteRemarksOrderBy>>;
};

/** All input for the `deleteOpportunityById` mutation. */
export type DeleteOpportunityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteOpportunity` mutation. */
export type DeleteOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Opportunity` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Opportunity` mutation. */
export type DeleteOpportunityPayload = {
  __typename?: 'DeleteOpportunityPayload';
  /** Reads a single `_Land` that is related to this `Opportunity`. */
  _landByCdland?: Maybe<_Land>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedOpportunityId?: Maybe<Scalars['ID']['output']>;
  /** The `Opportunity` that was deleted by this mutation. */
  opportunity?: Maybe<Opportunity>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Opportunity`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Opportunity` mutation. */
export type DeleteOpportunityPayloadOpportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the `deletePermissionById` mutation. */
export type DeletePermissionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deletePermission` mutation. */
export type DeletePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Permission` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayload = {
  __typename?: 'DeletePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPermissionId?: Maybe<Scalars['ID']['output']>;
  /** The `Permission` that was deleted by this mutation. */
  permission?: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `deletePersoonRolByPersoonRolGuid` mutation. */
export type DeletePersoonRolByPersoonRolGuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  persoonRolGuid: Scalars['String']['input'];
};

/** All input for the `deletePersoonRol` mutation. */
export type DeletePersoonRolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PersoonRol` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `PersoonRol` mutation. */
export type DeletePersoonRolPayload = {
  __typename?: 'DeletePersoonRolPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPersoonRolId?: Maybe<Scalars['ID']['output']>;
  /** The `PersoonRol` that was deleted by this mutation. */
  persoonRol?: Maybe<PersoonRol>;
  /** An edge for our `PersoonRol`. May be used by Relay 1. */
  persoonRolEdge?: Maybe<PersoonRolsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PersoonRol` mutation. */
export type DeletePersoonRolPayloadPersoonRolEdgeArgs = {
  orderBy?: InputMaybe<Array<PersoonRolsOrderBy>>;
};

/** All input for the `deletePlugById` mutation. */
export type DeletePlugByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deletePlugByName` mutation. */
export type DeletePlugByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deletePlug` mutation. */
export type DeletePlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Plug` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Plug` mutation. */
export type DeletePlugPayload = {
  __typename?: 'DeletePlugPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPlugId?: Maybe<Scalars['ID']['output']>;
  /** The `Plug` that was deleted by this mutation. */
  plug?: Maybe<Plug>;
  /** An edge for our `Plug`. May be used by Relay 1. */
  plugEdge?: Maybe<PlugsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Plug`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Plug` mutation. */
export type DeletePlugPayloadPlugEdgeArgs = {
  orderBy?: InputMaybe<Array<PlugsOrderBy>>;
};

/** All input for the `deletePrincipleById` mutation. */
export type DeletePrincipleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deletePrincipleByName` mutation. */
export type DeletePrincipleByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deletePrinciple` mutation. */
export type DeletePrincipleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Principle` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Principle` mutation. */
export type DeletePrinciplePayload = {
  __typename?: 'DeletePrinciplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPrincipleId?: Maybe<Scalars['ID']['output']>;
  /** The `Principle` that was deleted by this mutation. */
  principle?: Maybe<Principle>;
  /** An edge for our `Principle`. May be used by Relay 1. */
  principleEdge?: Maybe<PrinciplesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Principle`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Principle` mutation. */
export type DeletePrinciplePayloadPrincipleEdgeArgs = {
  orderBy?: InputMaybe<Array<PrinciplesOrderBy>>;
};

/** All input for the `deleteProductionById` mutation. */
export type DeleteProductionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteProduction` mutation. */
export type DeleteProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Production` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Production` mutation. */
export type DeleteProductionPayload = {
  __typename?: 'DeleteProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedProductionId?: Maybe<Scalars['ID']['output']>;
  /** The `Production` that was deleted by this mutation. */
  production?: Maybe<Production>;
  /** An edge for our `Production`. May be used by Relay 1. */
  productionEdge?: Maybe<ProductionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Production` mutation. */
export type DeleteProductionPayloadProductionEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductionsOrderBy>>;
};

/** All input for the `deletePyrolyserById` mutation. */
export type DeletePyrolyserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deletePyrolyserByName` mutation. */
export type DeletePyrolyserByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deletePyrolyser` mutation. */
export type DeletePyrolyserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Pyrolyser` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Pyrolyser` mutation. */
export type DeletePyrolyserPayload = {
  __typename?: 'DeletePyrolyserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPyrolyserId?: Maybe<Scalars['ID']['output']>;
  /** The `Pyrolyser` that was deleted by this mutation. */
  pyrolyser?: Maybe<Pyrolyser>;
  /** An edge for our `Pyrolyser`. May be used by Relay 1. */
  pyrolyserEdge?: Maybe<PyrolysersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pyrolyser`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Pyrolyser` mutation. */
export type DeletePyrolyserPayloadPyrolyserEdgeArgs = {
  orderBy?: InputMaybe<Array<PyrolysersOrderBy>>;
};

/** All input for the `deleteRangeById` mutation. */
export type DeleteRangeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteRangeByLowEuAndHighEuAndEngineeringUnitsAndGasId` mutation. */
export type DeleteRangeByLowEuAndHighEuAndEngineeringUnitsAndGasIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  engineeringUnits: Scalars['String']['input'];
  gasId: Scalars['Int']['input'];
  highEu: Scalars['Float']['input'];
  lowEu: Scalars['Float']['input'];
};

/** All input for the `deleteRange` mutation. */
export type DeleteRangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Range` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Range` mutation. */
export type DeleteRangePayload = {
  __typename?: 'DeleteRangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRangeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Gas` that is related to this `Range`. */
  gasByGasId?: Maybe<Gas>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Range` that was deleted by this mutation. */
  range?: Maybe<Range>;
  /** An edge for our `Range`. May be used by Relay 1. */
  rangeEdge?: Maybe<RangesEdge>;
  /** Reads a single `User` that is related to this `Range`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Range` mutation. */
export type DeleteRangePayloadRangeEdgeArgs = {
  orderBy?: InputMaybe<Array<RangesOrderBy>>;
};

/** All input for the `deleteRcCardById` mutation. */
export type DeleteRcCardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteRcCard` mutation. */
export type DeleteRcCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RcCard` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `RcCard` mutation. */
export type DeleteRcCardPayload = {
  __typename?: 'DeleteRcCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRcCardId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RcCard` that was deleted by this mutation. */
  rcCard?: Maybe<RcCard>;
  /** An edge for our `RcCard`. May be used by Relay 1. */
  rcCardEdge?: Maybe<RcCardsEdge>;
  /** Reads a single `User` that is related to this `RcCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `RcCard` mutation. */
export type DeleteRcCardPayloadRcCardEdgeArgs = {
  orderBy?: InputMaybe<Array<RcCardsOrderBy>>;
};

/** All input for the `deleteRefreshTokenById` mutation. */
export type DeleteRefreshTokenByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteRefreshToken` mutation. */
export type DeleteRefreshTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RefreshToken` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `RefreshToken` mutation. */
export type DeleteRefreshTokenPayload = {
  __typename?: 'DeleteRefreshTokenPayload';
  /** Reads a single `AspNetUser` that is related to this `RefreshToken`. */
  aspNetUserByAppUserId?: Maybe<AspNetUser>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRefreshTokenId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RefreshToken` that was deleted by this mutation. */
  refreshToken?: Maybe<RefreshToken>;
  /** An edge for our `RefreshToken`. May be used by Relay 1. */
  refreshTokenEdge?: Maybe<RefreshTokensEdge>;
};


/** The output of our delete `RefreshToken` mutation. */
export type DeleteRefreshTokenPayloadRefreshTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<RefreshTokensOrderBy>>;
};

/** All input for the `deleteReportByFilename` mutation. */
export type DeleteReportByFilenameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  filename: Scalars['String']['input'];
};

/** All input for the `deleteReportById` mutation. */
export type DeleteReportByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteReportByTsrNumberAndVersion` mutation. */
export type DeleteReportByTsrNumberAndVersionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  tsrNumber: Scalars['String']['input'];
  version: Scalars['String']['input'];
};

/** All input for the `deleteReportDetectorById` mutation. */
export type DeleteReportDetectorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteReportDetectorByReportIdAndDetectorId` mutation. */
export type DeleteReportDetectorByReportIdAndDetectorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  reportId: Scalars['Int']['input'];
};

/** All input for the `deleteReportDetector` mutation. */
export type DeleteReportDetectorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReportDetector` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `ReportDetector` mutation. */
export type DeleteReportDetectorPayload = {
  __typename?: 'DeleteReportDetectorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReportDetectorId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Detector` that is related to this `ReportDetector`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportDetector`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportDetector` that was deleted by this mutation. */
  reportDetector?: Maybe<ReportDetector>;
  /** An edge for our `ReportDetector`. May be used by Relay 1. */
  reportDetectorEdge?: Maybe<ReportDetectorsEdge>;
};


/** The output of our delete `ReportDetector` mutation. */
export type DeleteReportDetectorPayloadReportDetectorEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportDetectorsOrderBy>>;
};

/** All input for the `deleteReport` mutation. */
export type DeleteReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Report` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReportItemById` mutation. */
export type DeleteReportItemByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteReportItem` mutation. */
export type DeleteReportItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReportItem` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `ReportItem` mutation. */
export type DeleteReportItemPayload = {
  __typename?: 'DeleteReportItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReportItemId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Item` that is related to this `ReportItem`. */
  itemByItemId?: Maybe<Item>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportItem`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportItem` that was deleted by this mutation. */
  reportItem?: Maybe<ReportItem>;
  /** An edge for our `ReportItem`. May be used by Relay 1. */
  reportItemEdge?: Maybe<ReportItemsEdge>;
};


/** The output of our delete `ReportItem` mutation. */
export type DeleteReportItemPayloadReportItemEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportItemsOrderBy>>;
};

/** The output of our delete `Report` mutation. */
export type DeleteReportPayload = {
  __typename?: 'DeleteReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReportId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `EndUser` that is related to this `Report`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Report` that was deleted by this mutation. */
  report?: Maybe<Report>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
  /** Reads a single `User` that is related to this `Report`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Report`. */
  userByUserId?: Maybe<User>;
};


/** The output of our delete `Report` mutation. */
export type DeleteReportPayloadReportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the `deleteReportSensorById` mutation. */
export type DeleteReportSensorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteReportSensorByReportIdAndSensorId` mutation. */
export type DeleteReportSensorByReportIdAndSensorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  reportId: Scalars['Int']['input'];
  sensorId: Scalars['Int']['input'];
};

/** All input for the `deleteReportSensor` mutation. */
export type DeleteReportSensorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReportSensor` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `ReportSensor` mutation. */
export type DeleteReportSensorPayload = {
  __typename?: 'DeleteReportSensorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReportSensorId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportSensor`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportSensor` that was deleted by this mutation. */
  reportSensor?: Maybe<ReportSensor>;
  /** An edge for our `ReportSensor`. May be used by Relay 1. */
  reportSensorEdge?: Maybe<ReportSensorsEdge>;
  /** Reads a single `Sensor` that is related to this `ReportSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
};


/** The output of our delete `ReportSensor` mutation. */
export type DeleteReportSensorPayloadReportSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportSensorsOrderBy>>;
};

/** All input for the `deleteRequestById` mutation. */
export type DeleteRequestByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteRequest` mutation. */
export type DeleteRequestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Request` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Request` mutation. */
export type DeleteRequestPayload = {
  __typename?: 'DeleteRequestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRequestId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Request` that was deleted by this mutation. */
  request?: Maybe<Request>;
  /** An edge for our `Request`. May be used by Relay 1. */
  requestEdge?: Maybe<RequestsEdge>;
  /** Reads a single `User` that is related to this `Request`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Request` mutation. */
export type DeleteRequestPayloadRequestEdgeArgs = {
  orderBy?: InputMaybe<Array<RequestsOrderBy>>;
};

/** All input for the `deleteRxCardById` mutation. */
export type DeleteRxCardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteRxCard` mutation. */
export type DeleteRxCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RxCard` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `RxCard` mutation. */
export type DeleteRxCardPayload = {
  __typename?: 'DeleteRxCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedRxCardId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RxCard` that was deleted by this mutation. */
  rxCard?: Maybe<RxCard>;
  /** An edge for our `RxCard`. May be used by Relay 1. */
  rxCardEdge?: Maybe<RxCardsEdge>;
  /** Reads a single `User` that is related to this `RxCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `RxCard` mutation. */
export type DeleteRxCardPayloadRxCardEdgeArgs = {
  orderBy?: InputMaybe<Array<RxCardsOrderBy>>;
};

/** All input for the `deleteSamplePointByAreaIdAndName` mutation. */
export type DeleteSamplePointByAreaIdAndNameInput = {
  areaId: Scalars['Int']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteSamplePointById` mutation. */
export type DeleteSamplePointByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSamplePoint` mutation. */
export type DeleteSamplePointInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SamplePoint` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SamplePoint` mutation. */
export type DeleteSamplePointPayload = {
  __typename?: 'DeleteSamplePointPayload';
  /** Reads a single `Area` that is related to this `SamplePoint`. */
  areaByAreaId?: Maybe<Area>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSamplePointId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SamplePoint` that was deleted by this mutation. */
  samplePoint?: Maybe<SamplePoint>;
  /** An edge for our `SamplePoint`. May be used by Relay 1. */
  samplePointEdge?: Maybe<SamplePointsEdge>;
  /** Reads a single `User` that is related to this `SamplePoint`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `SamplePoint` mutation. */
export type DeleteSamplePointPayloadSamplePointEdgeArgs = {
  orderBy?: InputMaybe<Array<SamplePointsOrderBy>>;
};

/** All input for the `deleteSensorBaseTypeById` mutation. */
export type DeleteSensorBaseTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorBaseTypeByPrefixAndSuffix` mutation. */
export type DeleteSensorBaseTypeByPrefixAndSuffixInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  prefix: Scalars['String']['input'];
  suffix: Scalars['String']['input'];
};

/** All input for the `deleteSensorBaseType` mutation. */
export type DeleteSensorBaseTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorBaseType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorBaseType` mutation. */
export type DeleteSensorBaseTypePayload = {
  __typename?: 'DeleteSensorBaseTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorBaseTypeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Principle` that is related to this `SensorBaseType`. */
  principleByPrincipleId?: Maybe<Principle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorBaseType` that was deleted by this mutation. */
  sensorBaseType?: Maybe<SensorBaseType>;
  /** An edge for our `SensorBaseType`. May be used by Relay 1. */
  sensorBaseTypeEdge?: Maybe<SensorBaseTypesEdge>;
};


/** The output of our delete `SensorBaseType` mutation. */
export type DeleteSensorBaseTypePayloadSensorBaseTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorBaseTypesOrderBy>>;
};

/** All input for the `deleteSensorById` mutation. */
export type DeleteSensorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorBySerialNumberAndSensorTypeId` mutation. */
export type DeleteSensorBySerialNumberAndSensorTypeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorTypeId: Scalars['Int']['input'];
  serialNumber: Scalars['String']['input'];
};

/** All input for the `deleteSensorElementById` mutation. */
export type DeleteSensorElementByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorElement` mutation. */
export type DeleteSensorElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorElement` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSensorElementLocationById` mutation. */
export type DeleteSensorElementLocationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorElementLocationBySensorElementId` mutation. */
export type DeleteSensorElementLocationBySensorElementIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorElementId: Scalars['Int']['input'];
};

/** All input for the `deleteSensorElementLocation` mutation. */
export type DeleteSensorElementLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorElementLocation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorElementLocation` mutation. */
export type DeleteSensorElementLocationPayload = {
  __typename?: 'DeleteSensorElementLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorElementLocationId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `DetectorSensorLocation` that is related to this `SensorElementLocation`. */
  detectorSensorLocationByDetectorSensorLocationId?: Maybe<DetectorSensorLocation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SensorElement` that is related to this `SensorElementLocation`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorElementLocation` that was deleted by this mutation. */
  sensorElementLocation?: Maybe<SensorElementLocation>;
  /** An edge for our `SensorElementLocation`. May be used by Relay 1. */
  sensorElementLocationEdge?: Maybe<SensorElementLocationsEdge>;
  /** Reads a single `User` that is related to this `SensorElementLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `SensorElementLocation` mutation. */
export type DeleteSensorElementLocationPayloadSensorElementLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementLocationsOrderBy>>;
};

/** All input for the `deleteSensorElementLogById` mutation. */
export type DeleteSensorElementLogByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorElementLog` mutation. */
export type DeleteSensorElementLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorElementLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorElementLog` mutation. */
export type DeleteSensorElementLogPayload = {
  __typename?: 'DeleteSensorElementLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorElementLogId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorElementLog`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` that is related to this `SensorElementLog`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorElementLog` that was deleted by this mutation. */
  sensorElementLog?: Maybe<SensorElementLog>;
  /** An edge for our `SensorElementLog`. May be used by Relay 1. */
  sensorElementLogEdge?: Maybe<SensorElementLogsEdge>;
};


/** The output of our delete `SensorElementLog` mutation. */
export type DeleteSensorElementLogPayloadSensorElementLogEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementLogsOrderBy>>;
};

/** The output of our delete `SensorElement` mutation. */
export type DeleteSensorElementPayload = {
  __typename?: 'DeleteSensorElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorElementId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorElement` that was deleted by this mutation. */
  sensorElement?: Maybe<SensorElement>;
  /** An edge for our `SensorElement`. May be used by Relay 1. */
  sensorElementEdge?: Maybe<SensorElementsEdge>;
  /** Reads a single `SensorElementType` that is related to this `SensorElement`. */
  sensorElementTypeBySensorElementTypeId?: Maybe<SensorElementType>;
  /** Reads a single `User` that is related to this `SensorElement`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `SensorElement` mutation. */
export type DeleteSensorElementPayloadSensorElementEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementsOrderBy>>;
};

/** All input for the `deleteSensorElementTypeById` mutation. */
export type DeleteSensorElementTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorElementType` mutation. */
export type DeleteSensorElementTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorElementType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorElementType` mutation. */
export type DeleteSensorElementTypePayload = {
  __typename?: 'DeleteSensorElementTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorElementTypeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Range` that is related to this `SensorElementType`. */
  rangeByCalRangeId?: Maybe<Range>;
  /** Reads a single `Range` that is related to this `SensorElementType`. */
  rangeByRangeId?: Maybe<Range>;
  /** Reads a single `SensorBaseType` that is related to this `SensorElementType`. */
  sensorBaseTypeBySensorBaseTypeId?: Maybe<SensorBaseType>;
  /** The `SensorElementType` that was deleted by this mutation. */
  sensorElementType?: Maybe<SensorElementType>;
  /** An edge for our `SensorElementType`. May be used by Relay 1. */
  sensorElementTypeEdge?: Maybe<SensorElementTypesEdge>;
  /** Reads a single `User` that is related to this `SensorElementType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `SensorElementType` mutation. */
export type DeleteSensorElementTypePayloadSensorElementTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementTypesOrderBy>>;
};

/** All input for the `deleteSensor` mutation. */
export type DeleteSensorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Sensor` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSensorOrderById` mutation. */
export type DeleteSensorOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorOrderBySensorIdAndFactuuropdracht` mutation. */
export type DeleteSensorOrderBySensorIdAndFactuuropdrachtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  sensorId: Scalars['Int']['input'];
};

/** All input for the `deleteSensorOrder` mutation. */
export type DeleteSensorOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorOrder` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorOrder` mutation. */
export type DeleteSensorOrderPayload = {
  __typename?: 'DeleteSensorOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorOrderId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Factureeropdracht` that is related to this `SensorOrder`. */
  factureeropdrachtByFactuuropdracht?: Maybe<Factureeropdracht>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorOrder`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** The `SensorOrder` that was deleted by this mutation. */
  sensorOrder?: Maybe<SensorOrder>;
  /** An edge for our `SensorOrder`. May be used by Relay 1. */
  sensorOrderEdge?: Maybe<SensorOrdersEdge>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByCheckedUserId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByVerifiedUserId?: Maybe<User>;
};


/** The output of our delete `SensorOrder` mutation. */
export type DeleteSensorOrderPayloadSensorOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};

/** The output of our delete `Sensor` mutation. */
export type DeleteSensorPayload = {
  __typename?: 'DeleteSensorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Sensor` that was deleted by this mutation. */
  sensor?: Maybe<Sensor>;
  /** An edge for our `Sensor`. May be used by Relay 1. */
  sensorEdge?: Maybe<SensorsEdge>;
  /** Reads a single `SensorType` that is related to this `Sensor`. */
  sensorTypeBySensorTypeId?: Maybe<SensorType>;
  /** Reads a single `User` that is related to this `Sensor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Sensor` mutation. */
export type DeleteSensorPayloadSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorsOrderBy>>;
};

/** All input for the `deleteSensorSensorElementById` mutation. */
export type DeleteSensorSensorElementByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorSensorElementBySensorElementId` mutation. */
export type DeleteSensorSensorElementBySensorElementIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorElementId: Scalars['Int']['input'];
};

/** All input for the `deleteSensorSensorElementBySensorIdAndSensorPosition` mutation. */
export type DeleteSensorSensorElementBySensorIdAndSensorPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorId: Scalars['Int']['input'];
  sensorPosition: Scalars['Int']['input'];
};

/** All input for the `deleteSensorSensorElement` mutation. */
export type DeleteSensorSensorElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorSensorElement` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorSensorElement` mutation. */
export type DeleteSensorSensorElementPayload = {
  __typename?: 'DeleteSensorSensorElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorSensorElementId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorSensorElement`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` that is related to this `SensorSensorElement`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorSensorElement` that was deleted by this mutation. */
  sensorSensorElement?: Maybe<SensorSensorElement>;
  /** An edge for our `SensorSensorElement`. May be used by Relay 1. */
  sensorSensorElementEdge?: Maybe<SensorSensorElementsEdge>;
  /** Reads a single `User` that is related to this `SensorSensorElement`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `SensorSensorElement` mutation. */
export type DeleteSensorSensorElementPayloadSensorSensorElementEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorSensorElementsOrderBy>>;
};

/** All input for the `deleteSensorSettingById` mutation. */
export type DeleteSensorSettingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorSettingByTypeTarget` mutation. */
export type DeleteSensorSettingByTypeTargetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  typeTarget: Scalars['String']['input'];
};

/** All input for the `deleteSensorSetting` mutation. */
export type DeleteSensorSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorSetting` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorSetting` mutation. */
export type DeleteSensorSettingPayload = {
  __typename?: 'DeleteSensorSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorSettingId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorSetting` that was deleted by this mutation. */
  sensorSetting?: Maybe<SensorSetting>;
  /** An edge for our `SensorSetting`. May be used by Relay 1. */
  sensorSettingEdge?: Maybe<SensorSettingsEdge>;
};


/** The output of our delete `SensorSetting` mutation. */
export type DeleteSensorSettingPayloadSensorSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorSettingsOrderBy>>;
};

/** All input for the `deleteSensorTestResultById` mutation. */
export type DeleteSensorTestResultByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorTestResult` mutation. */
export type DeleteSensorTestResultInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorTestResult` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorTestResult` mutation. */
export type DeleteSensorTestResultPayload = {
  __typename?: 'DeleteSensorTestResultPayload';
  /** Reads a single `CalGas` that is related to this `SensorTestResult`. */
  calGasByFsCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorTestResultId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorTestResult`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorOrder` that is related to this `SensorTestResult`. */
  sensorOrderBySensorOrderId?: Maybe<SensorOrder>;
  /** The `SensorTestResult` that was deleted by this mutation. */
  sensorTestResult?: Maybe<SensorTestResult>;
  /** An edge for our `SensorTestResult`. May be used by Relay 1. */
  sensorTestResultEdge?: Maybe<SensorTestResultsEdge>;
  /** Reads a single `User` that is related to this `SensorTestResult`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorTestResult`. */
  userByUserId?: Maybe<User>;
};


/** The output of our delete `SensorTestResult` mutation. */
export type DeleteSensorTestResultPayloadSensorTestResultEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};

/** All input for the `deleteSensorTypeById` mutation. */
export type DeleteSensorTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserId` mutation. */
export type DeleteSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  model: Scalars['String']['input'];
  pyrolyserId: Scalars['Int']['input'];
  rangeId: Scalars['Int']['input'];
  sensorBaseTypeId: Scalars['Int']['input'];
};

/** All input for the `deleteSensorTypeBySensorTypeId` mutation. */
export type DeleteSensorTypeBySensorTypeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorTypeId: Scalars['Int']['input'];
};

/** All input for the `deleteSensorType` mutation. */
export type DeleteSensorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorType` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `SensorType` mutation. */
export type DeleteSensorTypePayload = {
  __typename?: 'DeleteSensorTypePayload';
  /** Reads a single `CalGas` that is related to this `SensorType`. */
  calGasByCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSensorTypeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Electrolyte` that is related to this `SensorType`. */
  electrolyteByElectrolyteId?: Maybe<Electrolyte>;
  /** Reads a single `Filter` that is related to this `SensorType`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `Membrane` that is related to this `SensorType`. */
  membraneByMembraneId?: Maybe<Membrane>;
  /** Reads a single `ORing` that is related to this `SensorType`. */
  oRingByORingId?: Maybe<ORing>;
  /** Reads a single `Plug` that is related to this `SensorType`. */
  plugByPlugId?: Maybe<Plug>;
  /** Reads a single `Pyrolyser` that is related to this `SensorType`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Range` that is related to this `SensorType`. */
  rangeByRangeId?: Maybe<Range>;
  /** Reads a single `SensorBaseType` that is related to this `SensorType`. */
  sensorBaseTypeBySensorBaseTypeId?: Maybe<SensorBaseType>;
  /** The `SensorType` that was deleted by this mutation. */
  sensorType?: Maybe<SensorType>;
  /** An edge for our `SensorType`. May be used by Relay 1. */
  sensorTypeEdge?: Maybe<SensorTypesEdge>;
  /** Reads a single `User` that is related to this `SensorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `SensorType` mutation. */
export type DeleteSensorTypePayloadSensorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/** All input for the `deleteSoftwareById` mutation. */
export type DeleteSoftwareByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteSoftware` mutation. */
export type DeleteSoftwareInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Software` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Software` mutation. */
export type DeleteSoftwarePayload = {
  __typename?: 'DeleteSoftwarePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSoftwareId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Hardware` that is related to this `Software`. */
  hardwareByHardwareId?: Maybe<Hardware>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Software` that was deleted by this mutation. */
  software?: Maybe<Software>;
  /** An edge for our `Software`. May be used by Relay 1. */
  softwareEdge?: Maybe<SoftwaresEdge>;
  /** Reads a single `User` that is related to this `Software`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Software` mutation. */
export type DeleteSoftwarePayloadSoftwareEdgeArgs = {
  orderBy?: InputMaybe<Array<SoftwaresOrderBy>>;
};

/** All input for the `deleteStockGroupById` mutation. */
export type DeleteStockGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteStockGroup` mutation. */
export type DeleteStockGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `StockGroup` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `StockGroup` mutation. */
export type DeleteStockGroupPayload = {
  __typename?: 'DeleteStockGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedStockGroupId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `StockGroup` that was deleted by this mutation. */
  stockGroup?: Maybe<StockGroup>;
  /** An edge for our `StockGroup`. May be used by Relay 1. */
  stockGroupEdge?: Maybe<StockGroupsEdge>;
  /** Reads a single `User` that is related to this `StockGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `StockGroup` mutation. */
export type DeleteStockGroupPayloadStockGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<StockGroupsOrderBy>>;
};

/** All input for the `deleteStockItemById` mutation. */
export type DeleteStockItemByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteStockItemByStockGroupIdAndCdartikel` mutation. */
export type DeleteStockItemByStockGroupIdAndCdartikelInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  stockGroupId: Scalars['Int']['input'];
};

/** All input for the `deleteStockItem` mutation. */
export type DeleteStockItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `StockItem` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `StockItem` mutation. */
export type DeleteStockItemPayload = {
  __typename?: 'DeleteStockItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedStockItemId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StockGroup` that is related to this `StockItem`. */
  stockGroupByStockGroupId?: Maybe<StockGroup>;
  /** The `StockItem` that was deleted by this mutation. */
  stockItem?: Maybe<StockItem>;
  /** An edge for our `StockItem`. May be used by Relay 1. */
  stockItemEdge?: Maybe<StockItemsEdge>;
  /** Reads a single `User` that is related to this `StockItem`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `StockItem` mutation. */
export type DeleteStockItemPayloadStockItemEdgeArgs = {
  orderBy?: InputMaybe<Array<StockItemsOrderBy>>;
};

/** All input for the `deleteStockSupplierById` mutation. */
export type DeleteStockSupplierByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteStockSupplier` mutation. */
export type DeleteStockSupplierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `StockSupplier` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `StockSupplier` mutation. */
export type DeleteStockSupplierPayload = {
  __typename?: 'DeleteStockSupplierPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedStockSupplierId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `StockSupplier` that was deleted by this mutation. */
  stockSupplier?: Maybe<StockSupplier>;
  /** An edge for our `StockSupplier`. May be used by Relay 1. */
  stockSupplierEdge?: Maybe<StockSuppliersEdge>;
  /** Reads a single `User` that is related to this `StockSupplier`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `StockSupplier` mutation. */
export type DeleteStockSupplierPayloadStockSupplierEdgeArgs = {
  orderBy?: InputMaybe<Array<StockSuppliersOrderBy>>;
};

/** All input for the `deleteTaskById` mutation. */
export type DeleteTaskByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteTask` mutation. */
export type DeleteTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Task` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Task` mutation. */
export type DeleteTaskPayload = {
  __typename?: 'DeleteTaskPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTaskId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Task` that was deleted by this mutation. */
  task?: Maybe<Task>;
  /** An edge for our `Task`. May be used by Relay 1. */
  taskEdge?: Maybe<TasksEdge>;
  /** Reads a single `User` that is related to this `Task`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our delete `Task` mutation. */
export type DeleteTaskPayloadTaskEdgeArgs = {
  orderBy?: InputMaybe<Array<TasksOrderBy>>;
};

/** All input for the `deleteTempFactopdrachtregelByFactuuropdrachtAndFactuurregel` mutation. */
export type DeleteTempFactopdrachtregelByFactuuropdrachtAndFactuurregelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  factuurregel: Scalars['Int']['input'];
};

/** All input for the `deleteTempFactopdrachtregelById` mutation. */
export type DeleteTempFactopdrachtregelByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** All input for the `deleteTempFactopdrachtregel` mutation. */
export type DeleteTempFactopdrachtregelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempFactopdrachtregel` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `TempFactopdrachtregel` mutation. */
export type DeleteTempFactopdrachtregelPayload = {
  __typename?: 'DeleteTempFactopdrachtregelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTempFactopdrachtregelId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempFactopdrachtregel` that was deleted by this mutation. */
  tempFactopdrachtregel?: Maybe<TempFactopdrachtregel>;
  /** An edge for our `TempFactopdrachtregel`. May be used by Relay 1. */
  tempFactopdrachtregelEdge?: Maybe<TempFactopdrachtregelsEdge>;
};


/** The output of our delete `TempFactopdrachtregel` mutation. */
export type DeleteTempFactopdrachtregelPayloadTempFactopdrachtregelEdgeArgs = {
  orderBy?: InputMaybe<Array<TempFactopdrachtregelsOrderBy>>;
};

/** All input for the `deleteTempLicenseById` mutation. */
export type DeleteTempLicenseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteTempLicense` mutation. */
export type DeleteTempLicenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempLicense` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `TempLicense` mutation. */
export type DeleteTempLicensePayload = {
  __typename?: 'DeleteTempLicensePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTempLicenseId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempLicense` that was deleted by this mutation. */
  tempLicense?: Maybe<TempLicense>;
  /** An edge for our `TempLicense`. May be used by Relay 1. */
  tempLicenseEdge?: Maybe<TempLicensesEdge>;
};


/** The output of our delete `TempLicense` mutation. */
export type DeleteTempLicensePayloadTempLicenseEdgeArgs = {
  orderBy?: InputMaybe<Array<TempLicensesOrderBy>>;
};

/** All input for the `deleteTempRegistrationById` mutation. */
export type DeleteTempRegistrationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteTempRegistrationHistoryById` mutation. */
export type DeleteTempRegistrationHistoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteTempRegistrationHistory` mutation. */
export type DeleteTempRegistrationHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempRegistrationHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `TempRegistrationHistory` mutation. */
export type DeleteTempRegistrationHistoryPayload = {
  __typename?: 'DeleteTempRegistrationHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTempRegistrationHistoryId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistrationHistory` that was deleted by this mutation. */
  tempRegistrationHistory?: Maybe<TempRegistrationHistory>;
  /** An edge for our `TempRegistrationHistory`. May be used by Relay 1. */
  tempRegistrationHistoryEdge?: Maybe<TempRegistrationHistoriesEdge>;
};


/** The output of our delete `TempRegistrationHistory` mutation. */
export type DeleteTempRegistrationHistoryPayloadTempRegistrationHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrationHistoriesOrderBy>>;
};

/** All input for the `deleteTempRegistration` mutation. */
export type DeleteTempRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempRegistration` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `TempRegistration` mutation. */
export type DeleteTempRegistrationPayload = {
  __typename?: 'DeleteTempRegistrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTempRegistrationId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistration` that was deleted by this mutation. */
  tempRegistration?: Maybe<TempRegistration>;
  /** An edge for our `TempRegistration`. May be used by Relay 1. */
  tempRegistrationEdge?: Maybe<TempRegistrationsEdge>;
};


/** The output of our delete `TempRegistration` mutation. */
export type DeleteTempRegistrationPayloadTempRegistrationEdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrationsOrderBy>>;
};

/** All input for the `deleteTempRegistrations2ById` mutation. */
export type DeleteTempRegistrations2ByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteTempRegistrations2` mutation. */
export type DeleteTempRegistrations2Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempRegistrations2` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `TempRegistrations2` mutation. */
export type DeleteTempRegistrations2Payload = {
  __typename?: 'DeleteTempRegistrations2Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTempRegistrations2Id?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistrations2` that was deleted by this mutation. */
  tempRegistrations2?: Maybe<TempRegistrations2>;
  /** An edge for our `TempRegistrations2`. May be used by Relay 1. */
  tempRegistrations2Edge?: Maybe<TempRegistrations2SEdge>;
};


/** The output of our delete `TempRegistrations2` mutation. */
export type DeleteTempRegistrations2PayloadTempRegistrations2EdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrations2SOrderBy>>;
};

/** All input for the `deleteTestById` mutation. */
export type DeleteTestByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteTest` mutation. */
export type DeleteTestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Test` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `Test` mutation. */
export type DeleteTestPayload = {
  __typename?: 'DeleteTestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTestId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Test` that was deleted by this mutation. */
  test?: Maybe<Test>;
  /** An edge for our `Test`. May be used by Relay 1. */
  testEdge?: Maybe<TestsEdge>;
};


/** The output of our delete `Test` mutation. */
export type DeleteTestPayloadTestEdgeArgs = {
  orderBy?: InputMaybe<Array<TestsOrderBy>>;
};

/** All input for the `deleteUserById` mutation. */
export type DeleteUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Group` that is related to this `User`. */
  groupByGroupId?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteUserRightById` mutation. */
export type DeleteUserRightByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteUserRightByUserIdAndPath` mutation. */
export type DeleteUserRightByUserIdAndPathInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  path: Scalars['String']['input'];
  userId: Scalars['Int']['input'];
};

/** All input for the `deleteUserRight` mutation. */
export type DeleteUserRightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserRight` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `UserRight` mutation. */
export type DeleteUserRightPayload = {
  __typename?: 'DeleteUserRightPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserRightId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserRight`. */
  userByUserId?: Maybe<User>;
  /** The `UserRight` that was deleted by this mutation. */
  userRight?: Maybe<UserRight>;
  /** An edge for our `UserRight`. May be used by Relay 1. */
  userRightEdge?: Maybe<UserRightsEdge>;
};


/** The output of our delete `UserRight` mutation. */
export type DeleteUserRightPayloadUserRightEdgeArgs = {
  orderBy?: InputMaybe<Array<UserRightsOrderBy>>;
};

/** All input for the `deleteUserTaskById` mutation. */
export type DeleteUserTaskByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteUserTaskByUserIdAndTaskId` mutation. */
export type DeleteUserTaskByUserIdAndTaskIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  taskId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** All input for the `deleteUserTask` mutation. */
export type DeleteUserTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserTask` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `UserTask` mutation. */
export type DeleteUserTaskPayload = {
  __typename?: 'DeleteUserTaskPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserTaskId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `UserTask`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `UserTask`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `UserTask`. */
  userByUserId?: Maybe<User>;
  /** The `UserTask` that was deleted by this mutation. */
  userTask?: Maybe<UserTask>;
  /** An edge for our `UserTask`. May be used by Relay 1. */
  userTaskEdge?: Maybe<UserTasksEdge>;
};


/** The output of our delete `UserTask` mutation. */
export type DeleteUserTaskPayloadUserTaskEdgeArgs = {
  orderBy?: InputMaybe<Array<UserTasksOrderBy>>;
};

/** All input for the `deleteUsersGroupById` mutation. */
export type DeleteUsersGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteUsersGroupByUserIdAndGroupId` mutation. */
export type DeleteUsersGroupByUserIdAndGroupIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** All input for the `deleteUsersGroup` mutation. */
export type DeleteUsersGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UsersGroup` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `UsersGroup` mutation. */
export type DeleteUsersGroupPayload = {
  __typename?: 'DeleteUsersGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUsersGroupId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Group` that is related to this `UsersGroup`. */
  groupByGroupId?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UsersGroup`. */
  userByUserId?: Maybe<User>;
  /** The `UsersGroup` that was deleted by this mutation. */
  usersGroup?: Maybe<UsersGroup>;
  /** An edge for our `UsersGroup`. May be used by Relay 1. */
  usersGroupEdge?: Maybe<UsersGroupsEdge>;
};


/** The output of our delete `UsersGroup` mutation. */
export type DeleteUsersGroupPayloadUsersGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersGroupsOrderBy>>;
};

/** All input for the `deleteVoorradenByCdartikelAndCdmagazijn` mutation. */
export type DeleteVoorradenByCdartikelAndCdmagazijnInput = {
  cdartikel: Scalars['String']['input'];
  cdmagazijn: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `deleteVoorraden` mutation. */
export type DeleteVoorradenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Voorraden` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteVoorradenLogById` mutation. */
export type DeleteVoorradenLogByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteVoorradenLog` mutation. */
export type DeleteVoorradenLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `VoorradenLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `VoorradenLog` mutation. */
export type DeleteVoorradenLogPayload = {
  __typename?: 'DeleteVoorradenLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedVoorradenLogId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VoorradenLog` that was deleted by this mutation. */
  voorradenLog?: Maybe<VoorradenLog>;
  /** An edge for our `VoorradenLog`. May be used by Relay 1. */
  voorradenLogEdge?: Maybe<VoorradenLogsEdge>;
};


/** The output of our delete `VoorradenLog` mutation. */
export type DeleteVoorradenLogPayloadVoorradenLogEdgeArgs = {
  orderBy?: InputMaybe<Array<VoorradenLogsOrderBy>>;
};

/** The output of our delete `Voorraden` mutation. */
export type DeleteVoorradenPayload = {
  __typename?: 'DeleteVoorradenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedVoorradenId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Voorraden` that was deleted by this mutation. */
  voorraden?: Maybe<Voorraden>;
  /** An edge for our `Voorraden`. May be used by Relay 1. */
  voorradenEdge?: Maybe<VoorradensEdge>;
};


/** The output of our delete `Voorraden` mutation. */
export type DeleteVoorradenPayloadVoorradenEdgeArgs = {
  orderBy?: InputMaybe<Array<VoorradensOrderBy>>;
};

/** All input for the `deleteWeeklyHourById` mutation. */
export type DeleteWeeklyHourByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteWeeklyHour` mutation. */
export type DeleteWeeklyHourInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WeeklyHour` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `WeeklyHour` mutation. */
export type DeleteWeeklyHourPayload = {
  __typename?: 'DeleteWeeklyHourPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedWeeklyHourId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `WeeklyHour`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `WeeklyHour`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `WeeklyHour`. */
  userByUserId?: Maybe<User>;
  /** The `WeeklyHour` that was deleted by this mutation. */
  weeklyHour?: Maybe<WeeklyHour>;
  /** An edge for our `WeeklyHour`. May be used by Relay 1. */
  weeklyHourEdge?: Maybe<WeeklyHoursEdge>;
};


/** The output of our delete `WeeklyHour` mutation. */
export type DeleteWeeklyHourPayloadWeeklyHourEdgeArgs = {
  orderBy?: InputMaybe<Array<WeeklyHoursOrderBy>>;
};

/** All input for the `deleteWeeklyHourRemarkById` mutation. */
export type DeleteWeeklyHourRemarkByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteWeeklyHourRemarkByUserIdAndTaskIdAndDate` mutation. */
export type DeleteWeeklyHourRemarkByUserIdAndTaskIdAndDateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Date']['input'];
  taskId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** All input for the `deleteWeeklyHourRemark` mutation. */
export type DeleteWeeklyHourRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WeeklyHourRemark` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our delete `WeeklyHourRemark` mutation. */
export type DeleteWeeklyHourRemarkPayload = {
  __typename?: 'DeleteWeeklyHourRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedWeeklyHourRemarkId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `WeeklyHourRemark`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `WeeklyHourRemark`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `WeeklyHourRemark`. */
  userByUserId?: Maybe<User>;
  /** The `WeeklyHourRemark` that was deleted by this mutation. */
  weeklyHourRemark?: Maybe<WeeklyHourRemark>;
  /** An edge for our `WeeklyHourRemark`. May be used by Relay 1. */
  weeklyHourRemarkEdge?: Maybe<WeeklyHourRemarksEdge>;
};


/** The output of our delete `WeeklyHourRemark` mutation. */
export type DeleteWeeklyHourRemarkPayloadWeeklyHourRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<WeeklyHourRemarksOrderBy>>;
};

export type Detector = Node & {
  __typename?: 'Detector';
  created: Scalars['Datetime']['output'];
  /** Reads a single `DetectorLocation` that is related to this `Detector`. */
  detectorLocationByDetectorId?: Maybe<DetectorLocation>;
  /**
   * Reads and enables pagination through a set of `DetectorLocation`.
   * @deprecated Please use detectorLocationByDetectorId instead
   */
  detectorLocationsByDetectorId: DetectorLocationsConnection;
  /** Reads and enables pagination through a set of `DetectorOrder`. */
  detectorOrdersByDetectorId: DetectorOrdersConnection;
  /** Reads and enables pagination through a set of `DetectorSensor`. */
  detectorSensorsByDetectorId: DetectorSensorsConnection;
  /** Reads a single `DetectorType` that is related to this `Detector`. */
  detectorTypeByDetectorTypeId?: Maybe<DetectorType>;
  detectorTypeId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  labelDate?: Maybe<Scalars['Date']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ReportDetector`. */
  reportDetectorsByDetectorId: ReportDetectorsConnection;
  serialNumber: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `Detector`. */
  userByOwnerId?: Maybe<User>;
};


export type DetectorDetectorLocationsByDetectorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorLocationCondition>;
  filter?: InputMaybe<DetectorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorLocationsOrderBy>>;
};


export type DetectorDetectorOrdersByDetectorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorOrderCondition>;
  filter?: InputMaybe<DetectorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorOrdersOrderBy>>;
};


export type DetectorDetectorSensorsByDetectorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorCondition>;
  filter?: InputMaybe<DetectorSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};


export type DetectorReportDetectorsByDetectorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportDetectorCondition>;
  filter?: InputMaybe<ReportDetectorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportDetectorsOrderBy>>;
};

/**
 * A condition to be used against `Detector` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DetectorCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `labelDate` field. */
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DetectorEntity` values. */
export type DetectorEntitiesConnection = {
  __typename?: 'DetectorEntitiesConnection';
  /** A list of edges which contains the `DetectorEntity` and cursor to aid in pagination. */
  edges: Array<DetectorEntitiesEdge>;
  /** A list of `DetectorEntity` objects. */
  nodes: Array<DetectorEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorEntity` edge in the connection. */
export type DetectorEntitiesEdge = {
  __typename?: 'DetectorEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorEntity` at the end of the edge. */
  node: DetectorEntity;
};

/** Methods to use when ordering `DetectorEntity`. */
export enum DetectorEntitiesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorTypeIdAsc = 'DETECTOR_TYPE_ID_ASC',
  DetectorTypeIdDesc = 'DETECTOR_TYPE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  LabelDateAsc = 'LABEL_DATE_ASC',
  LabelDateDesc = 'LABEL_DATE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrefixAsc = 'PREFIX_ASC',
  PrefixDesc = 'PREFIX_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  SuffixAsc = 'SUFFIX_ASC',
  SuffixDesc = 'SUFFIX_DESC'
}

export type DetectorEntity = {
  __typename?: 'DetectorEntity';
  code?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  detectorTypeId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  labelDate?: Maybe<Scalars['Date']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  prefix?: Maybe<Scalars['String']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
  suffix?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DetectorEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DetectorEntityCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `labelDate` field. */
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prefix` field. */
  prefix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `suffix` field. */
  suffix?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DetectorEntity` object types. All fields are combined with a logical ‘and.’ */
export type DetectorEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorEntityFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `labelDate` field. */
  labelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorEntityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prefix` field. */
  prefix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `suffix` field. */
  suffix?: InputMaybe<StringFilter>;
};

/** A filter to be used against `Detector` object types. All fields are combined with a logical ‘and.’ */
export type DetectorFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorLocationByDetectorId` relation. */
  detectorLocationByDetectorId?: InputMaybe<DetectorLocationFilter>;
  /** A related `detectorLocationByDetectorId` exists. */
  detectorLocationByDetectorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorOrdersByDetectorId` relation. */
  detectorOrdersByDetectorId?: InputMaybe<DetectorToManyDetectorOrderFilter>;
  /** Some related `detectorOrdersByDetectorId` exist. */
  detectorOrdersByDetectorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorSensorsByDetectorId` relation. */
  detectorSensorsByDetectorId?: InputMaybe<DetectorToManyDetectorSensorFilter>;
  /** Some related `detectorSensorsByDetectorId` exist. */
  detectorSensorsByDetectorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorTypeByDetectorTypeId` relation. */
  detectorTypeByDetectorTypeId?: InputMaybe<DetectorTypeFilter>;
  /** Filter by the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `labelDate` field. */
  labelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reportDetectorsByDetectorId` relation. */
  reportDetectorsByDetectorId?: InputMaybe<DetectorToManyReportDetectorFilter>;
  /** Some related `reportDetectorsByDetectorId` exist. */
  reportDetectorsByDetectorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

export type DetectorIndex = {
  __typename?: 'DetectorIndex';
  cddebiteur?: Maybe<Scalars['String']['output']>;
  createdDate?: Maybe<Scalars['String']['output']>;
  debiteurNaam?: Maybe<Scalars['String']['output']>;
  detectorLocationId?: Maybe<Scalars['Int']['output']>;
  detectorSensorId?: Maybe<Scalars['Int']['output']>;
  detectorType?: Maybe<Scalars['String']['output']>;
  detectorTypeId?: Maybe<Scalars['Int']['output']>;
  detectorTypeSort?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  formattedLabelDate?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DetectorIndex` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DetectorIndexCondition = {
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdDate` field. */
  createdDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `debiteurNaam` field. */
  debiteurNaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorLocationId` field. */
  detectorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorType` field. */
  detectorType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorTypeSort` field. */
  detectorTypeSort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `formattedLabelDate` field. */
  formattedLabelDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DetectorIndex` object types. All fields are combined with a logical ‘and.’ */
export type DetectorIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorIndexFilter>>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdDate` field. */
  createdDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `debiteurNaam` field. */
  debiteurNaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorLocationId` field. */
  detectorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorType` field. */
  detectorType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorTypeSort` field. */
  detectorTypeSort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `formattedLabelDate` field. */
  formattedLabelDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorIndexFilter>>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
};

/** A connection to a list of `DetectorIndex` values. */
export type DetectorIndicesConnection = {
  __typename?: 'DetectorIndicesConnection';
  /** A list of edges which contains the `DetectorIndex` and cursor to aid in pagination. */
  edges: Array<DetectorIndicesEdge>;
  /** A list of `DetectorIndex` objects. */
  nodes: Array<DetectorIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorIndex` edge in the connection. */
export type DetectorIndicesEdge = {
  __typename?: 'DetectorIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorIndex` at the end of the edge. */
  node: DetectorIndex;
};

/** Methods to use when ordering `DetectorIndex`. */
export enum DetectorIndicesOrderBy {
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CreatedDateAsc = 'CREATED_DATE_ASC',
  CreatedDateDesc = 'CREATED_DATE_DESC',
  DebiteurNaamAsc = 'DEBITEUR_NAAM_ASC',
  DebiteurNaamDesc = 'DEBITEUR_NAAM_DESC',
  DetectorLocationIdAsc = 'DETECTOR_LOCATION_ID_ASC',
  DetectorLocationIdDesc = 'DETECTOR_LOCATION_ID_DESC',
  DetectorSensorIdAsc = 'DETECTOR_SENSOR_ID_ASC',
  DetectorSensorIdDesc = 'DETECTOR_SENSOR_ID_DESC',
  DetectorTypeAsc = 'DETECTOR_TYPE_ASC',
  DetectorTypeDesc = 'DETECTOR_TYPE_DESC',
  DetectorTypeIdAsc = 'DETECTOR_TYPE_ID_ASC',
  DetectorTypeIdDesc = 'DETECTOR_TYPE_ID_DESC',
  DetectorTypeSortAsc = 'DETECTOR_TYPE_SORT_ASC',
  DetectorTypeSortDesc = 'DETECTOR_TYPE_SORT_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FormattedLabelDateAsc = 'FORMATTED_LABEL_DATE_ASC',
  FormattedLabelDateDesc = 'FORMATTED_LABEL_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  Natural = 'NATURAL',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC'
}

/** An input for mutations affecting `Detector` */
export type DetectorInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorTypeId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber: Scalars['String']['input'];
};

export type DetectorLocation = Node & {
  __typename?: 'DetectorLocation';
  address?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Area` that is related to this `DetectorLocation`. */
  areaByAreaId?: Maybe<Area>;
  areaId: Scalars['Int']['output'];
  bus?: Maybe<Scalars['Int']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorLocation`. */
  detectorByDetectorId?: Maybe<Detector>;
  detectorId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `DetectorSensorLocation`. */
  detectorSensorLocationsByDetectorLocationId: DetectorSensorLocationsConnection;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `DetectorLocation`. */
  userByOwnerId?: Maybe<User>;
};


export type DetectorLocationDetectorSensorLocationsByDetectorLocationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationCondition>;
  filter?: InputMaybe<DetectorSensorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};

/**
 * A condition to be used against `DetectorLocation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DetectorLocationCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `areaId` field. */
  areaId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `bus` field. */
  bus?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `detectorId` field. */
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `DetectorLocation` object types. All fields are combined with a logical ‘and.’ */
export type DetectorLocationFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorLocationFilter>>;
  /** Filter by the object’s `areaByAreaId` relation. */
  areaByAreaId?: InputMaybe<AreaFilter>;
  /** Filter by the object’s `areaId` field. */
  areaId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `bus` field. */
  bus?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorByDetectorId` relation. */
  detectorByDetectorId?: InputMaybe<DetectorFilter>;
  /** A related `detectorByDetectorId` exists. */
  detectorByDetectorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorId` field. */
  detectorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationsByDetectorLocationId` relation. */
  detectorSensorLocationsByDetectorLocationId?: InputMaybe<DetectorLocationToManyDetectorSensorLocationFilter>;
  /** Some related `detectorSensorLocationsByDetectorLocationId` exist. */
  detectorSensorLocationsByDetectorLocationIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorLocationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorLocationFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `DetectorLocation` */
export type DetectorLocationInput = {
  address?: InputMaybe<Scalars['Int']['input']>;
  areaId: Scalars['Int']['input'];
  bus?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `DetectorLocation`. Fields that are set will be updated. */
export type DetectorLocationPatch = {
  address?: InputMaybe<Scalars['Int']['input']>;
  areaId?: InputMaybe<Scalars['Int']['input']>;
  bus?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `DetectorSensorLocation` object types. All fields are combined with a logical ‘and.’ */
export type DetectorLocationToManyDetectorSensorLocationFilter = {
  /** Every related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorLocationFilter>;
  /** No related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorLocationFilter>;
  /** Some related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorLocationFilter>;
};

/** A connection to a list of `DetectorLocation` values. */
export type DetectorLocationsConnection = {
  __typename?: 'DetectorLocationsConnection';
  /** A list of edges which contains the `DetectorLocation` and cursor to aid in pagination. */
  edges: Array<DetectorLocationsEdge>;
  /** A list of `DetectorLocation` objects. */
  nodes: Array<DetectorLocation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorLocation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorLocation` edge in the connection. */
export type DetectorLocationsEdge = {
  __typename?: 'DetectorLocationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorLocation` at the end of the edge. */
  node: DetectorLocation;
};

/** Methods to use when ordering `DetectorLocation`. */
export enum DetectorLocationsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  AreaByAreaIdCreatedAsc = 'AREA_BY_AREA_ID__CREATED_ASC',
  AreaByAreaIdCreatedDesc = 'AREA_BY_AREA_ID__CREATED_DESC',
  AreaByAreaIdFloorIdAsc = 'AREA_BY_AREA_ID__FLOOR_ID_ASC',
  AreaByAreaIdFloorIdDesc = 'AREA_BY_AREA_ID__FLOOR_ID_DESC',
  AreaByAreaIdIdAsc = 'AREA_BY_AREA_ID__ID_ASC',
  AreaByAreaIdIdDesc = 'AREA_BY_AREA_ID__ID_DESC',
  AreaByAreaIdModifiedAsc = 'AREA_BY_AREA_ID__MODIFIED_ASC',
  AreaByAreaIdModifiedDesc = 'AREA_BY_AREA_ID__MODIFIED_DESC',
  AreaByAreaIdNameAsc = 'AREA_BY_AREA_ID__NAME_ASC',
  AreaByAreaIdNameDesc = 'AREA_BY_AREA_ID__NAME_DESC',
  AreaByAreaIdOwnerIdAsc = 'AREA_BY_AREA_ID__OWNER_ID_ASC',
  AreaByAreaIdOwnerIdDesc = 'AREA_BY_AREA_ID__OWNER_ID_DESC',
  AreaByAreaIdRemarksAsc = 'AREA_BY_AREA_ID__REMARKS_ASC',
  AreaByAreaIdRemarksDesc = 'AREA_BY_AREA_ID__REMARKS_DESC',
  AreaIdAsc = 'AREA_ID_ASC',
  AreaIdDesc = 'AREA_ID_DESC',
  BusAsc = 'BUS_ASC',
  BusDesc = 'BUS_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorByDetectorIdCreatedAsc = 'DETECTOR_BY_DETECTOR_ID__CREATED_ASC',
  DetectorByDetectorIdCreatedDesc = 'DETECTOR_BY_DETECTOR_ID__CREATED_DESC',
  DetectorByDetectorIdDetectorTypeIdAsc = 'DETECTOR_BY_DETECTOR_ID__DETECTOR_TYPE_ID_ASC',
  DetectorByDetectorIdDetectorTypeIdDesc = 'DETECTOR_BY_DETECTOR_ID__DETECTOR_TYPE_ID_DESC',
  DetectorByDetectorIdIdAsc = 'DETECTOR_BY_DETECTOR_ID__ID_ASC',
  DetectorByDetectorIdIdDesc = 'DETECTOR_BY_DETECTOR_ID__ID_DESC',
  DetectorByDetectorIdLabelDateAsc = 'DETECTOR_BY_DETECTOR_ID__LABEL_DATE_ASC',
  DetectorByDetectorIdLabelDateDesc = 'DETECTOR_BY_DETECTOR_ID__LABEL_DATE_DESC',
  DetectorByDetectorIdModifiedAsc = 'DETECTOR_BY_DETECTOR_ID__MODIFIED_ASC',
  DetectorByDetectorIdModifiedDesc = 'DETECTOR_BY_DETECTOR_ID__MODIFIED_DESC',
  DetectorByDetectorIdOwnerIdAsc = 'DETECTOR_BY_DETECTOR_ID__OWNER_ID_ASC',
  DetectorByDetectorIdOwnerIdDesc = 'DETECTOR_BY_DETECTOR_ID__OWNER_ID_DESC',
  DetectorByDetectorIdRemarksAsc = 'DETECTOR_BY_DETECTOR_ID__REMARKS_ASC',
  DetectorByDetectorIdRemarksDesc = 'DETECTOR_BY_DETECTOR_ID__REMARKS_DESC',
  DetectorByDetectorIdSerialNumberAsc = 'DETECTOR_BY_DETECTOR_ID__SERIAL_NUMBER_ASC',
  DetectorByDetectorIdSerialNumberDesc = 'DETECTOR_BY_DETECTOR_ID__SERIAL_NUMBER_DESC',
  DetectorIdAsc = 'DETECTOR_ID_ASC',
  DetectorIdDesc = 'DETECTOR_ID_DESC',
  DetectorSensorLocationsByDetectorLocationIdCountAsc = 'DETECTOR_SENSOR_LOCATIONS_BY_DETECTOR_LOCATION_ID__COUNT_ASC',
  DetectorSensorLocationsByDetectorLocationIdCountDesc = 'DETECTOR_SENSOR_LOCATIONS_BY_DETECTOR_LOCATION_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type DetectorOrder = Node & {
  __typename?: 'DetectorOrder';
  completed?: Maybe<Scalars['Boolean']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads a single `Detector` that is related to this `DetectorOrder`. */
  detectorByDetectorId?: Maybe<Detector>;
  detectorId: Scalars['Int']['output'];
  factuuropdracht: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `DetectorOrder`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `DetectorOrder` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DetectorOrderCondition = {
  /** Checks for equality with the object’s `completed` field. */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `detectorId` field. */
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `DetectorOrder` object types. All fields are combined with a logical ‘and.’ */
export type DetectorOrderFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorOrderFilter>>;
  /** Filter by the object’s `completed` field. */
  completed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorByDetectorId` relation. */
  detectorByDetectorId?: InputMaybe<DetectorFilter>;
  /** Filter by the object’s `detectorId` field. */
  detectorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorOrderFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorOrderFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `DetectorOrder` */
export type DetectorOrderInput = {
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorId: Scalars['Int']['input'];
  factuuropdracht: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
};

/** Represents an update to a `DetectorOrder`. Fields that are set will be updated. */
export type DetectorOrderPatch = {
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DetectorOrder` values. */
export type DetectorOrdersConnection = {
  __typename?: 'DetectorOrdersConnection';
  /** A list of edges which contains the `DetectorOrder` and cursor to aid in pagination. */
  edges: Array<DetectorOrdersEdge>;
  /** A list of `DetectorOrder` objects. */
  nodes: Array<DetectorOrder>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorOrder` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorOrder` edge in the connection. */
export type DetectorOrdersEdge = {
  __typename?: 'DetectorOrdersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorOrder` at the end of the edge. */
  node: DetectorOrder;
};

/** Methods to use when ordering `DetectorOrder`. */
export enum DetectorOrdersOrderBy {
  CompletedAsc = 'COMPLETED_ASC',
  CompletedDesc = 'COMPLETED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorByDetectorIdCreatedAsc = 'DETECTOR_BY_DETECTOR_ID__CREATED_ASC',
  DetectorByDetectorIdCreatedDesc = 'DETECTOR_BY_DETECTOR_ID__CREATED_DESC',
  DetectorByDetectorIdDetectorTypeIdAsc = 'DETECTOR_BY_DETECTOR_ID__DETECTOR_TYPE_ID_ASC',
  DetectorByDetectorIdDetectorTypeIdDesc = 'DETECTOR_BY_DETECTOR_ID__DETECTOR_TYPE_ID_DESC',
  DetectorByDetectorIdIdAsc = 'DETECTOR_BY_DETECTOR_ID__ID_ASC',
  DetectorByDetectorIdIdDesc = 'DETECTOR_BY_DETECTOR_ID__ID_DESC',
  DetectorByDetectorIdLabelDateAsc = 'DETECTOR_BY_DETECTOR_ID__LABEL_DATE_ASC',
  DetectorByDetectorIdLabelDateDesc = 'DETECTOR_BY_DETECTOR_ID__LABEL_DATE_DESC',
  DetectorByDetectorIdModifiedAsc = 'DETECTOR_BY_DETECTOR_ID__MODIFIED_ASC',
  DetectorByDetectorIdModifiedDesc = 'DETECTOR_BY_DETECTOR_ID__MODIFIED_DESC',
  DetectorByDetectorIdOwnerIdAsc = 'DETECTOR_BY_DETECTOR_ID__OWNER_ID_ASC',
  DetectorByDetectorIdOwnerIdDesc = 'DETECTOR_BY_DETECTOR_ID__OWNER_ID_DESC',
  DetectorByDetectorIdRemarksAsc = 'DETECTOR_BY_DETECTOR_ID__REMARKS_ASC',
  DetectorByDetectorIdRemarksDesc = 'DETECTOR_BY_DETECTOR_ID__REMARKS_DESC',
  DetectorByDetectorIdSerialNumberAsc = 'DETECTOR_BY_DETECTOR_ID__SERIAL_NUMBER_ASC',
  DetectorByDetectorIdSerialNumberDesc = 'DETECTOR_BY_DETECTOR_ID__SERIAL_NUMBER_DESC',
  DetectorIdAsc = 'DETECTOR_ID_ASC',
  DetectorIdDesc = 'DETECTOR_ID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** Represents an update to a `Detector`. Fields that are set will be updated. */
export type DetectorPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorTypeId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

export type DetectorSensor = Node & {
  __typename?: 'DetectorSensor';
  _filterLabelDate?: Maybe<Scalars['Date']['output']>;
  _pyrolyserLabelDate?: Maybe<Scalars['Date']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorSensor`. */
  detectorByDetectorId?: Maybe<Detector>;
  detectorId: Scalars['Int']['output'];
  detectorPosition: Scalars['Int']['output'];
  /** Reads a single `DetectorSensorLocation` that is related to this `DetectorSensor`. */
  detectorSensorLocationByDetectorSensorId?: Maybe<DetectorSensorLocation>;
  /**
   * Reads and enables pagination through a set of `DetectorSensorLocation`.
   * @deprecated Please use detectorSensorLocationByDetectorSensorId instead
   */
  detectorSensorLocationsByDetectorSensorId: DetectorSensorLocationsConnection;
  /** Reads a single `Filter` that is related to this `DetectorSensor`. */
  filterByFilterId?: Maybe<Filter>;
  filterId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  maintenanceVisitLinesByDetectorSensorId: MaintenanceVisitLinesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `Pyrolyser` that is related to this `DetectorSensor`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  pyrolyserId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Sensor` that is related to this `DetectorSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
  sensorId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `DetectorSensor`. */
  userByOwnerId?: Maybe<User>;
};


export type DetectorSensorDetectorSensorLocationsByDetectorSensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationCondition>;
  filter?: InputMaybe<DetectorSensorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};


export type DetectorSensorMaintenanceVisitLinesByDetectorSensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};

/**
 * A condition to be used against `DetectorSensor` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DetectorSensorCondition = {
  /** Checks for equality with the object’s `_filterLabelDate` field. */
  _filterLabelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `_pyrolyserLabelDate` field. */
  _pyrolyserLabelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `detectorId` field. */
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `filterId` field. */
  filterId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `DetectorSensor` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorFilter = {
  /** Filter by the object’s `_filterLabelDate` field. */
  _filterLabelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `_pyrolyserLabelDate` field. */
  _pyrolyserLabelDate?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorSensorFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorByDetectorId` relation. */
  detectorByDetectorId?: InputMaybe<DetectorFilter>;
  /** Filter by the object’s `detectorId` field. */
  detectorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationByDetectorSensorId` relation. */
  detectorSensorLocationByDetectorSensorId?: InputMaybe<DetectorSensorLocationFilter>;
  /** A related `detectorSensorLocationByDetectorSensorId` exists. */
  detectorSensorLocationByDetectorSensorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `filterByFilterId` relation. */
  filterByFilterId?: InputMaybe<FilterFilter>;
  /** A related `filterByFilterId` exists. */
  filterByFilterIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `filterId` field. */
  filterId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitLinesByDetectorSensorId` relation. */
  maintenanceVisitLinesByDetectorSensorId?: InputMaybe<DetectorSensorToManyMaintenanceVisitLineFilter>;
  /** Some related `maintenanceVisitLinesByDetectorSensorId` exist. */
  maintenanceVisitLinesByDetectorSensorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorSensorFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorSensorFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pyrolyserByPyrolyserId` relation. */
  pyrolyserByPyrolyserId?: InputMaybe<PyrolyserFilter>;
  /** A related `pyrolyserByPyrolyserId` exists. */
  pyrolyserByPyrolyserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorBySensorId` relation. */
  sensorBySensorId?: InputMaybe<SensorFilter>;
  /** A related `sensorBySensorId` exists. */
  sensorBySensorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

export type DetectorSensorIndex = {
  __typename?: 'DetectorSensorIndex';
  areaId?: Maybe<Scalars['Int']['output']>;
  buildingId?: Maybe<Scalars['Int']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  debiteurNaam?: Maybe<Scalars['String']['output']>;
  detectorId?: Maybe<Scalars['Int']['output']>;
  detectorPosition?: Maybe<Scalars['Int']['output']>;
  detectorSensorId?: Maybe<Scalars['Int']['output']>;
  detectorSensorLocationId?: Maybe<Scalars['Int']['output']>;
  detectorSensorLocationJson?: Maybe<Scalars['JSON']['output']>;
  detectorSensorLocationLabel?: Maybe<Scalars['String']['output']>;
  detectorType?: Maybe<Scalars['String']['output']>;
  detectorTypeId?: Maybe<Scalars['Int']['output']>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  endUserName?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  floorId?: Maybe<Scalars['Int']['output']>;
  sensorId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `DetectorSensorIndex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type DetectorSensorIndexCondition = {
  /** Checks for equality with the object’s `areaId` field. */
  areaId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `buildingId` field. */
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `debiteurNaam` field. */
  debiteurNaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorId` field. */
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationJson` field. */
  detectorSensorLocationJson?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationLabel` field. */
  detectorSensorLocationLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorType` field. */
  detectorType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserName` field. */
  endUserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `floorId` field. */
  floorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `DetectorSensorIndex` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorSensorIndexFilter>>;
  /** Filter by the object’s `areaId` field. */
  areaId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `buildingId` field. */
  buildingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `debiteurNaam` field. */
  debiteurNaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorId` field. */
  detectorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationLabel` field. */
  detectorSensorLocationLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorType` field. */
  detectorType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserName` field. */
  endUserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `floorId` field. */
  floorId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorSensorIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorSensorIndexFilter>>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `DetectorSensorIndex` values. */
export type DetectorSensorIndicesConnection = {
  __typename?: 'DetectorSensorIndicesConnection';
  /** A list of edges which contains the `DetectorSensorIndex` and cursor to aid in pagination. */
  edges: Array<DetectorSensorIndicesEdge>;
  /** A list of `DetectorSensorIndex` objects. */
  nodes: Array<DetectorSensorIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorSensorIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorSensorIndex` edge in the connection. */
export type DetectorSensorIndicesEdge = {
  __typename?: 'DetectorSensorIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorSensorIndex` at the end of the edge. */
  node: DetectorSensorIndex;
};

/** Methods to use when ordering `DetectorSensorIndex`. */
export enum DetectorSensorIndicesOrderBy {
  AreaIdAsc = 'AREA_ID_ASC',
  AreaIdDesc = 'AREA_ID_DESC',
  BuildingIdAsc = 'BUILDING_ID_ASC',
  BuildingIdDesc = 'BUILDING_ID_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  DebiteurNaamAsc = 'DEBITEUR_NAAM_ASC',
  DebiteurNaamDesc = 'DEBITEUR_NAAM_DESC',
  DetectorIdAsc = 'DETECTOR_ID_ASC',
  DetectorIdDesc = 'DETECTOR_ID_DESC',
  DetectorPositionAsc = 'DETECTOR_POSITION_ASC',
  DetectorPositionDesc = 'DETECTOR_POSITION_DESC',
  DetectorSensorIdAsc = 'DETECTOR_SENSOR_ID_ASC',
  DetectorSensorIdDesc = 'DETECTOR_SENSOR_ID_DESC',
  DetectorSensorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_ID_ASC',
  DetectorSensorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_ID_DESC',
  DetectorSensorLocationJsonAsc = 'DETECTOR_SENSOR_LOCATION_JSON_ASC',
  DetectorSensorLocationJsonDesc = 'DETECTOR_SENSOR_LOCATION_JSON_DESC',
  DetectorSensorLocationLabelAsc = 'DETECTOR_SENSOR_LOCATION_LABEL_ASC',
  DetectorSensorLocationLabelDesc = 'DETECTOR_SENSOR_LOCATION_LABEL_DESC',
  DetectorTypeAsc = 'DETECTOR_TYPE_ASC',
  DetectorTypeDesc = 'DETECTOR_TYPE_DESC',
  DetectorTypeIdAsc = 'DETECTOR_TYPE_ID_ASC',
  DetectorTypeIdDesc = 'DETECTOR_TYPE_ID_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  EndUserNameAsc = 'END_USER_NAME_ASC',
  EndUserNameDesc = 'END_USER_NAME_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FloorIdAsc = 'FLOOR_ID_ASC',
  FloorIdDesc = 'FLOOR_ID_DESC',
  Natural = 'NATURAL',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC'
}

/** An input for mutations affecting `DetectorSensor` */
export type DetectorSensorInput = {
  _filterLabelDate?: InputMaybe<Scalars['Date']['input']>;
  _pyrolyserLabelDate?: InputMaybe<Scalars['Date']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorId: Scalars['Int']['input'];
  detectorPosition: Scalars['Int']['input'];
  filterId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
};

export type DetectorSensorLocation = Node & {
  __typename?: 'DetectorSensorLocation';
  /** Reads a single `Application` that is related to this `DetectorSensorLocation`. */
  applicationByApplicationId?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  calcFilterReplacementInterval?: Maybe<Interval>;
  calcPyrolyserReplacementInterval?: Maybe<Interval>;
  calcSensorMaintenanceInterval?: Maybe<Interval>;
  calcSensorReplacementInterval?: Maybe<Interval>;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `DetectorLocation` that is related to this `DetectorSensorLocation`. */
  detectorLocationByDetectorLocationId?: Maybe<DetectorLocation>;
  detectorLocationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `DetectorSensor` that is related to this `DetectorSensorLocation`. */
  detectorSensorByDetectorSensorId?: Maybe<DetectorSensor>;
  detectorSensorId: Scalars['Int']['output'];
  filterReplacementDueDate?: Maybe<Scalars['Date']['output']>;
  filterReplacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** Reads a single `License` that is related to this `DetectorSensorLocation`. */
  licenseByLicenseId?: Maybe<License>;
  licenseId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  maintenanceVisitLinesByDetectorSensorLocationId: MaintenanceVisitLinesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  pyrolyserReplacementDueDate?: Maybe<Scalars['Date']['output']>;
  pyrolyserReplacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads a single `SamplePoint` that is related to this `DetectorSensorLocation`. */
  samplePointBySamplePointId?: Maybe<SamplePoint>;
  samplePointId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `SensorElementLocation`. */
  sensorElementLocationsByDetectorSensorLocationId: SensorElementLocationsConnection;
  sensorMaintenanceDueDate?: Maybe<Scalars['Date']['output']>;
  sensorMaintenanceIntervalMonths?: Maybe<Scalars['Int']['output']>;
  sensorReplacementDueDate?: Maybe<Scalars['Date']['output']>;
  sensorReplacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  simsChannel?: Maybe<Scalars['Int']['output']>;
  simsTag?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `DetectorSensorLocation`. */
  userByOwnerId?: Maybe<User>;
};


export type DetectorSensorLocationMaintenanceVisitLinesByDetectorSensorLocationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};


export type DetectorSensorLocationSensorElementLocationsByDetectorSensorLocationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementLocationCondition>;
  filter?: InputMaybe<SensorElementLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementLocationsOrderBy>>;
};

/**
 * A condition to be used against `DetectorSensorLocation` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type DetectorSensorLocationCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `detectorLocationId` field. */
  detectorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `filterReplacementIntervalMonths` field. */
  filterReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `licenseId` field. */
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserReplacementIntervalMonths` field. */
  pyrolyserReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samplePointId` field. */
  samplePointId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceIntervalMonths` field. */
  sensorMaintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorReplacementIntervalMonths` field. */
  sensorReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `simsChannel` field. */
  simsChannel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `simsTag` field. */
  simsTag?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DetectorSensorLocation` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorLocationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorSensorLocationFilter>>;
  /** Filter by the object’s `applicationByApplicationId` relation. */
  applicationByApplicationId?: InputMaybe<ApplicationFilter>;
  /** A related `applicationByApplicationId` exists. */
  applicationByApplicationIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `calcFilterReplacementInterval` field. */
  calcFilterReplacementInterval?: InputMaybe<IntervalFilter>;
  /** Filter by the object’s `calcPyrolyserReplacementInterval` field. */
  calcPyrolyserReplacementInterval?: InputMaybe<IntervalFilter>;
  /** Filter by the object’s `calcSensorMaintenanceInterval` field. */
  calcSensorMaintenanceInterval?: InputMaybe<IntervalFilter>;
  /** Filter by the object’s `calcSensorReplacementInterval` field. */
  calcSensorReplacementInterval?: InputMaybe<IntervalFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorLocationByDetectorLocationId` relation. */
  detectorLocationByDetectorLocationId?: InputMaybe<DetectorLocationFilter>;
  /** A related `detectorLocationByDetectorLocationId` exists. */
  detectorLocationByDetectorLocationIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorLocationId` field. */
  detectorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorByDetectorSensorId` relation. */
  detectorSensorByDetectorSensorId?: InputMaybe<DetectorSensorFilter>;
  /** Filter by the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `filterReplacementDueDate` field. */
  filterReplacementDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `filterReplacementIntervalMonths` field. */
  filterReplacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licenseByLicenseId` relation. */
  licenseByLicenseId?: InputMaybe<LicenseFilter>;
  /** A related `licenseByLicenseId` exists. */
  licenseByLicenseIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseId` field. */
  licenseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitLinesByDetectorSensorLocationId` relation. */
  maintenanceVisitLinesByDetectorSensorLocationId?: InputMaybe<DetectorSensorLocationToManyMaintenanceVisitLineFilter>;
  /** Some related `maintenanceVisitLinesByDetectorSensorLocationId` exist. */
  maintenanceVisitLinesByDetectorSensorLocationIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorSensorLocationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorSensorLocationFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pyrolyserReplacementDueDate` field. */
  pyrolyserReplacementDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `pyrolyserReplacementIntervalMonths` field. */
  pyrolyserReplacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samplePointBySamplePointId` relation. */
  samplePointBySamplePointId?: InputMaybe<SamplePointFilter>;
  /** Filter by the object’s `samplePointId` field. */
  samplePointId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorElementLocationsByDetectorSensorLocationId` relation. */
  sensorElementLocationsByDetectorSensorLocationId?: InputMaybe<DetectorSensorLocationToManySensorElementLocationFilter>;
  /** Some related `sensorElementLocationsByDetectorSensorLocationId` exist. */
  sensorElementLocationsByDetectorSensorLocationIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorMaintenanceIntervalMonths` field. */
  sensorMaintenanceIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorReplacementDueDate` field. */
  sensorReplacementDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorReplacementIntervalMonths` field. */
  sensorReplacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `simsChannel` field. */
  simsChannel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `simsTag` field. */
  simsTag?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `DetectorSensorLocation` */
export type DetectorSensorLocationInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorLocationId?: InputMaybe<Scalars['Int']['input']>;
  detectorSensorId: Scalars['Int']['input'];
  filterReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  samplePointId: Scalars['Int']['input'];
  sensorMaintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  sensorReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  simsChannel?: InputMaybe<Scalars['Int']['input']>;
  simsTag?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DetectorSensorLocation`. Fields that are set will be updated. */
export type DetectorSensorLocationPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorLocationId?: InputMaybe<Scalars['Int']['input']>;
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  filterReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  samplePointId?: InputMaybe<Scalars['Int']['input']>;
  sensorMaintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  sensorReplacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  simsChannel?: InputMaybe<Scalars['Int']['input']>;
  simsTag?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `MaintenanceVisitLine` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorLocationToManyMaintenanceVisitLineFilter = {
  /** Every related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitLineFilter>;
  /** No related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitLineFilter>;
  /** Some related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitLineFilter>;
};

/** A filter to be used against many `SensorElementLocation` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorLocationToManySensorElementLocationFilter = {
  /** Every related `SensorElementLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementLocationFilter>;
  /** No related `SensorElementLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementLocationFilter>;
  /** Some related `SensorElementLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementLocationFilter>;
};

/** A connection to a list of `DetectorSensorLocation` values. */
export type DetectorSensorLocationsConnection = {
  __typename?: 'DetectorSensorLocationsConnection';
  /** A list of edges which contains the `DetectorSensorLocation` and cursor to aid in pagination. */
  edges: Array<DetectorSensorLocationsEdge>;
  /** A list of `DetectorSensorLocation` objects. */
  nodes: Array<DetectorSensorLocation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorSensorLocation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorSensorLocation` edge in the connection. */
export type DetectorSensorLocationsEdge = {
  __typename?: 'DetectorSensorLocationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorSensorLocation` at the end of the edge. */
  node: DetectorSensorLocation;
};

export type DetectorSensorLocationsEndUser = {
  __typename?: 'DetectorSensorLocationsEndUser';
  contactEmail?: Maybe<Scalars['String']['output']>;
  contactName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DetectorSensorLocationsEndUser` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type DetectorSensorLocationsEndUserCondition = {
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactName` field. */
  contactName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DetectorSensorLocationsEndUser` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorLocationsEndUserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorSensorLocationsEndUserFilter>>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactName` field. */
  contactName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorSensorLocationsEndUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorSensorLocationsEndUserFilter>>;
};

/** A connection to a list of `DetectorSensorLocationsEndUser` values. */
export type DetectorSensorLocationsEndUsersConnection = {
  __typename?: 'DetectorSensorLocationsEndUsersConnection';
  /** A list of edges which contains the `DetectorSensorLocationsEndUser` and cursor to aid in pagination. */
  edges: Array<DetectorSensorLocationsEndUsersEdge>;
  /** A list of `DetectorSensorLocationsEndUser` objects. */
  nodes: Array<DetectorSensorLocationsEndUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorSensorLocationsEndUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorSensorLocationsEndUser` edge in the connection. */
export type DetectorSensorLocationsEndUsersEdge = {
  __typename?: 'DetectorSensorLocationsEndUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorSensorLocationsEndUser` at the end of the edge. */
  node: DetectorSensorLocationsEndUser;
};

/** Methods to use when ordering `DetectorSensorLocationsEndUser`. */
export enum DetectorSensorLocationsEndUsersOrderBy {
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactNameAsc = 'CONTACT_NAME_ASC',
  ContactNameDesc = 'CONTACT_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL'
}

export type DetectorSensorLocationsIndex = {
  __typename?: 'DetectorSensorLocationsIndex';
  applicationId?: Maybe<Scalars['Int']['output']>;
  applicationName?: Maybe<Scalars['String']['output']>;
  areaId?: Maybe<Scalars['Int']['output']>;
  areaName?: Maybe<Scalars['String']['output']>;
  buildingId?: Maybe<Scalars['Int']['output']>;
  buildingName?: Maybe<Scalars['String']['output']>;
  calFlowRate?: Maybe<Scalars['Float']['output']>;
  calGasConcentration?: Maybe<Scalars['Float']['output']>;
  calGasEngineeringUnits?: Maybe<Scalars['String']['output']>;
  calGasGasName?: Maybe<Scalars['String']['output']>;
  calResponse?: Maybe<Scalars['Float']['output']>;
  detectorId?: Maybe<Scalars['Int']['output']>;
  detectorLabelDate?: Maybe<Scalars['Date']['output']>;
  detectorLocationAddress?: Maybe<Scalars['Int']['output']>;
  detectorLocationBus?: Maybe<Scalars['Int']['output']>;
  detectorModel?: Maybe<Scalars['String']['output']>;
  detectorPosition?: Maybe<Scalars['Int']['output']>;
  detectorSensorLocationId?: Maybe<Scalars['Int']['output']>;
  detectorSerialNumber?: Maybe<Scalars['String']['output']>;
  electrolyteName?: Maybe<Scalars['String']['output']>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  endUserName?: Maybe<Scalars['String']['output']>;
  filterInstallDueClass?: Maybe<Scalars['String']['output']>;
  filterInstallDueDate?: Maybe<Scalars['Date']['output']>;
  filterInstallDueDateLabel?: Maybe<Scalars['String']['output']>;
  filterName?: Maybe<Scalars['String']['output']>;
  floorName?: Maybe<Scalars['String']['output']>;
  flowRate?: Maybe<Scalars['Float']['output']>;
  gasName?: Maybe<Scalars['String']['output']>;
  lastFilterInstallDate?: Maybe<Scalars['Date']['output']>;
  lastPyrolyserInstallDate?: Maybe<Scalars['Date']['output']>;
  lastSensorInstallDate?: Maybe<Scalars['Date']['output']>;
  lastSensorMaintenanceDate?: Maybe<Scalars['Date']['output']>;
  membraneName?: Maybe<Scalars['String']['output']>;
  oRingName?: Maybe<Scalars['String']['output']>;
  pyrolyserInstallDueClass?: Maybe<Scalars['String']['output']>;
  pyrolyserInstallDueDate?: Maybe<Scalars['Date']['output']>;
  pyrolyserInstallDueDateLabel?: Maybe<Scalars['String']['output']>;
  pyrolyserName?: Maybe<Scalars['String']['output']>;
  rangeEngineeringUnits?: Maybe<Scalars['String']['output']>;
  rangeHighEu?: Maybe<Scalars['Float']['output']>;
  rangeLowEu?: Maybe<Scalars['Float']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  samplePointId?: Maybe<Scalars['Int']['output']>;
  samplePointName?: Maybe<Scalars['String']['output']>;
  sensorId?: Maybe<Scalars['Int']['output']>;
  sensorInstallDueClass?: Maybe<Scalars['String']['output']>;
  sensorInstallDueDate?: Maybe<Scalars['Date']['output']>;
  sensorInstallDueDateLabel?: Maybe<Scalars['String']['output']>;
  sensorLabelDate?: Maybe<Scalars['Date']['output']>;
  sensorMaintenanceDueClass?: Maybe<Scalars['String']['output']>;
  sensorMaintenanceDueDate?: Maybe<Scalars['Date']['output']>;
  sensorMaintenanceDueDateLabel?: Maybe<Scalars['String']['output']>;
  sensorModel?: Maybe<Scalars['String']['output']>;
  sensorSerialNumber?: Maybe<Scalars['String']['output']>;
  sensorTypeMembraneSeal?: Maybe<Scalars['Boolean']['output']>;
  sensorTypeSiliconeSheet?: Maybe<Scalars['Boolean']['output']>;
  simsChannel?: Maybe<Scalars['Int']['output']>;
  simsTag?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DetectorSensorLocationsIndex` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DetectorSensorLocationsIndexCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `applicationName` field. */
  applicationName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `areaId` field. */
  areaId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `areaName` field. */
  areaName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `buildingId` field. */
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `buildingName` field. */
  buildingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `calGasConcentration` field. */
  calGasConcentration?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `calGasEngineeringUnits` field. */
  calGasEngineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calGasGasName` field. */
  calGasGasName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calResponse` field. */
  calResponse?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `detectorId` field. */
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorLabelDate` field. */
  detectorLabelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `detectorLocationAddress` field. */
  detectorLocationAddress?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorLocationBus` field. */
  detectorLocationBus?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorModel` field. */
  detectorModel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSerialNumber` field. */
  detectorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserName` field. */
  endUserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterInstallDueClass` field. */
  filterInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterInstallDueDate` field. */
  filterInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `filterInstallDueDateLabel` field. */
  filterInstallDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterName` field. */
  filterName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `floorName` field. */
  floorName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `flowRate` field. */
  flowRate?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `gasName` field. */
  gasName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lastFilterInstallDate` field. */
  lastFilterInstallDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `lastPyrolyserInstallDate` field. */
  lastPyrolyserInstallDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `lastSensorInstallDate` field. */
  lastSensorInstallDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `lastSensorMaintenanceDate` field. */
  lastSensorMaintenanceDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `membraneName` field. */
  membraneName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `oRingName` field. */
  oRingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueClass` field. */
  pyrolyserInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueDate` field. */
  pyrolyserInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueDateLabel` field. */
  pyrolyserInstallDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyrolyserName` field. */
  pyrolyserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rangeEngineeringUnits` field. */
  rangeEngineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rangeHighEu` field. */
  rangeHighEu?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `rangeLowEu` field. */
  rangeLowEu?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samplePointId` field. */
  samplePointId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `samplePointName` field. */
  samplePointName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueClass` field. */
  sensorInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueDate` field. */
  sensorInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueDateLabel` field. */
  sensorInstallDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorLabelDate` field. */
  sensorLabelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueClass` field. */
  sensorMaintenanceDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueDateLabel` field. */
  sensorMaintenanceDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorModel` field. */
  sensorModel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypeMembraneSeal` field. */
  sensorTypeMembraneSeal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `sensorTypeSiliconeSheet` field. */
  sensorTypeSiliconeSheet?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `simsChannel` field. */
  simsChannel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `simsTag` field. */
  simsTag?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DetectorSensorLocationsIndex` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorLocationsIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorSensorLocationsIndexFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationName` field. */
  applicationName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `areaId` field. */
  areaId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `areaName` field. */
  areaName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `buildingId` field. */
  buildingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `buildingName` field. */
  buildingName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `calGasConcentration` field. */
  calGasConcentration?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `calGasEngineeringUnits` field. */
  calGasEngineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calGasGasName` field. */
  calGasGasName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calResponse` field. */
  calResponse?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `detectorId` field. */
  detectorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorLabelDate` field. */
  detectorLabelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `detectorLocationAddress` field. */
  detectorLocationAddress?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorLocationBus` field. */
  detectorLocationBus?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorModel` field. */
  detectorModel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSerialNumber` field. */
  detectorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserName` field. */
  endUserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterInstallDueClass` field. */
  filterInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterInstallDueDate` field. */
  filterInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `filterInstallDueDateLabel` field. */
  filterInstallDueDateLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterName` field. */
  filterName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `floorName` field. */
  floorName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `flowRate` field. */
  flowRate?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `gasName` field. */
  gasName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lastFilterInstallDate` field. */
  lastFilterInstallDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `lastPyrolyserInstallDate` field. */
  lastPyrolyserInstallDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `lastSensorInstallDate` field. */
  lastSensorInstallDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `lastSensorMaintenanceDate` field. */
  lastSensorMaintenanceDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `membraneName` field. */
  membraneName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorSensorLocationsIndexFilter>;
  /** Filter by the object’s `oRingName` field. */
  oRingName?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorSensorLocationsIndexFilter>>;
  /** Filter by the object’s `pyrolyserInstallDueClass` field. */
  pyrolyserInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pyrolyserInstallDueDate` field. */
  pyrolyserInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `pyrolyserInstallDueDateLabel` field. */
  pyrolyserInstallDueDateLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pyrolyserName` field. */
  pyrolyserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `rangeEngineeringUnits` field. */
  rangeEngineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `rangeHighEu` field. */
  rangeHighEu?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `rangeLowEu` field. */
  rangeLowEu?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samplePointId` field. */
  samplePointId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `samplePointName` field. */
  samplePointName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorInstallDueClass` field. */
  sensorInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorInstallDueDate` field. */
  sensorInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorInstallDueDateLabel` field. */
  sensorInstallDueDateLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorLabelDate` field. */
  sensorLabelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorMaintenanceDueClass` field. */
  sensorMaintenanceDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorMaintenanceDueDateLabel` field. */
  sensorMaintenanceDueDateLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorModel` field. */
  sensorModel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorTypeMembraneSeal` field. */
  sensorTypeMembraneSeal?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `sensorTypeSiliconeSheet` field. */
  sensorTypeSiliconeSheet?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `simsChannel` field. */
  simsChannel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `simsTag` field. */
  simsTag?: InputMaybe<StringFilter>;
};

/** A connection to a list of `DetectorSensorLocationsIndex` values. */
export type DetectorSensorLocationsIndicesConnection = {
  __typename?: 'DetectorSensorLocationsIndicesConnection';
  /** A list of edges which contains the `DetectorSensorLocationsIndex` and cursor to aid in pagination. */
  edges: Array<DetectorSensorLocationsIndicesEdge>;
  /** A list of `DetectorSensorLocationsIndex` objects. */
  nodes: Array<DetectorSensorLocationsIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorSensorLocationsIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorSensorLocationsIndex` edge in the connection. */
export type DetectorSensorLocationsIndicesEdge = {
  __typename?: 'DetectorSensorLocationsIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorSensorLocationsIndex` at the end of the edge. */
  node: DetectorSensorLocationsIndex;
};

/** Methods to use when ordering `DetectorSensorLocationsIndex`. */
export enum DetectorSensorLocationsIndicesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ApplicationNameAsc = 'APPLICATION_NAME_ASC',
  ApplicationNameDesc = 'APPLICATION_NAME_DESC',
  AreaIdAsc = 'AREA_ID_ASC',
  AreaIdDesc = 'AREA_ID_DESC',
  AreaNameAsc = 'AREA_NAME_ASC',
  AreaNameDesc = 'AREA_NAME_DESC',
  BuildingIdAsc = 'BUILDING_ID_ASC',
  BuildingIdDesc = 'BUILDING_ID_DESC',
  BuildingNameAsc = 'BUILDING_NAME_ASC',
  BuildingNameDesc = 'BUILDING_NAME_DESC',
  CalFlowRateAsc = 'CAL_FLOW_RATE_ASC',
  CalFlowRateDesc = 'CAL_FLOW_RATE_DESC',
  CalGasConcentrationAsc = 'CAL_GAS_CONCENTRATION_ASC',
  CalGasConcentrationDesc = 'CAL_GAS_CONCENTRATION_DESC',
  CalGasEngineeringUnitsAsc = 'CAL_GAS_ENGINEERING_UNITS_ASC',
  CalGasEngineeringUnitsDesc = 'CAL_GAS_ENGINEERING_UNITS_DESC',
  CalGasGasNameAsc = 'CAL_GAS_GAS_NAME_ASC',
  CalGasGasNameDesc = 'CAL_GAS_GAS_NAME_DESC',
  CalResponseAsc = 'CAL_RESPONSE_ASC',
  CalResponseDesc = 'CAL_RESPONSE_DESC',
  DetectorIdAsc = 'DETECTOR_ID_ASC',
  DetectorIdDesc = 'DETECTOR_ID_DESC',
  DetectorLabelDateAsc = 'DETECTOR_LABEL_DATE_ASC',
  DetectorLabelDateDesc = 'DETECTOR_LABEL_DATE_DESC',
  DetectorLocationAddressAsc = 'DETECTOR_LOCATION_ADDRESS_ASC',
  DetectorLocationAddressDesc = 'DETECTOR_LOCATION_ADDRESS_DESC',
  DetectorLocationBusAsc = 'DETECTOR_LOCATION_BUS_ASC',
  DetectorLocationBusDesc = 'DETECTOR_LOCATION_BUS_DESC',
  DetectorModelAsc = 'DETECTOR_MODEL_ASC',
  DetectorModelDesc = 'DETECTOR_MODEL_DESC',
  DetectorPositionAsc = 'DETECTOR_POSITION_ASC',
  DetectorPositionDesc = 'DETECTOR_POSITION_DESC',
  DetectorSensorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_ID_ASC',
  DetectorSensorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_ID_DESC',
  DetectorSerialNumberAsc = 'DETECTOR_SERIAL_NUMBER_ASC',
  DetectorSerialNumberDesc = 'DETECTOR_SERIAL_NUMBER_DESC',
  ElectrolyteNameAsc = 'ELECTROLYTE_NAME_ASC',
  ElectrolyteNameDesc = 'ELECTROLYTE_NAME_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  EndUserNameAsc = 'END_USER_NAME_ASC',
  EndUserNameDesc = 'END_USER_NAME_DESC',
  FilterInstallDueClassAsc = 'FILTER_INSTALL_DUE_CLASS_ASC',
  FilterInstallDueClassDesc = 'FILTER_INSTALL_DUE_CLASS_DESC',
  FilterInstallDueDateAsc = 'FILTER_INSTALL_DUE_DATE_ASC',
  FilterInstallDueDateDesc = 'FILTER_INSTALL_DUE_DATE_DESC',
  FilterInstallDueDateLabelAsc = 'FILTER_INSTALL_DUE_DATE_LABEL_ASC',
  FilterInstallDueDateLabelDesc = 'FILTER_INSTALL_DUE_DATE_LABEL_DESC',
  FilterNameAsc = 'FILTER_NAME_ASC',
  FilterNameDesc = 'FILTER_NAME_DESC',
  FloorNameAsc = 'FLOOR_NAME_ASC',
  FloorNameDesc = 'FLOOR_NAME_DESC',
  FlowRateAsc = 'FLOW_RATE_ASC',
  FlowRateDesc = 'FLOW_RATE_DESC',
  GasNameAsc = 'GAS_NAME_ASC',
  GasNameDesc = 'GAS_NAME_DESC',
  LastFilterInstallDateAsc = 'LAST_FILTER_INSTALL_DATE_ASC',
  LastFilterInstallDateDesc = 'LAST_FILTER_INSTALL_DATE_DESC',
  LastPyrolyserInstallDateAsc = 'LAST_PYROLYSER_INSTALL_DATE_ASC',
  LastPyrolyserInstallDateDesc = 'LAST_PYROLYSER_INSTALL_DATE_DESC',
  LastSensorInstallDateAsc = 'LAST_SENSOR_INSTALL_DATE_ASC',
  LastSensorInstallDateDesc = 'LAST_SENSOR_INSTALL_DATE_DESC',
  LastSensorMaintenanceDateAsc = 'LAST_SENSOR_MAINTENANCE_DATE_ASC',
  LastSensorMaintenanceDateDesc = 'LAST_SENSOR_MAINTENANCE_DATE_DESC',
  MembraneNameAsc = 'MEMBRANE_NAME_ASC',
  MembraneNameDesc = 'MEMBRANE_NAME_DESC',
  Natural = 'NATURAL',
  ORingNameAsc = 'O_RING_NAME_ASC',
  ORingNameDesc = 'O_RING_NAME_DESC',
  PyrolyserInstallDueClassAsc = 'PYROLYSER_INSTALL_DUE_CLASS_ASC',
  PyrolyserInstallDueClassDesc = 'PYROLYSER_INSTALL_DUE_CLASS_DESC',
  PyrolyserInstallDueDateAsc = 'PYROLYSER_INSTALL_DUE_DATE_ASC',
  PyrolyserInstallDueDateDesc = 'PYROLYSER_INSTALL_DUE_DATE_DESC',
  PyrolyserInstallDueDateLabelAsc = 'PYROLYSER_INSTALL_DUE_DATE_LABEL_ASC',
  PyrolyserInstallDueDateLabelDesc = 'PYROLYSER_INSTALL_DUE_DATE_LABEL_DESC',
  PyrolyserNameAsc = 'PYROLYSER_NAME_ASC',
  PyrolyserNameDesc = 'PYROLYSER_NAME_DESC',
  RangeEngineeringUnitsAsc = 'RANGE_ENGINEERING_UNITS_ASC',
  RangeEngineeringUnitsDesc = 'RANGE_ENGINEERING_UNITS_DESC',
  RangeHighEuAsc = 'RANGE_HIGH_EU_ASC',
  RangeHighEuDesc = 'RANGE_HIGH_EU_DESC',
  RangeLowEuAsc = 'RANGE_LOW_EU_ASC',
  RangeLowEuDesc = 'RANGE_LOW_EU_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  SamplePointIdAsc = 'SAMPLE_POINT_ID_ASC',
  SamplePointIdDesc = 'SAMPLE_POINT_ID_DESC',
  SamplePointNameAsc = 'SAMPLE_POINT_NAME_ASC',
  SamplePointNameDesc = 'SAMPLE_POINT_NAME_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  SensorInstallDueClassAsc = 'SENSOR_INSTALL_DUE_CLASS_ASC',
  SensorInstallDueClassDesc = 'SENSOR_INSTALL_DUE_CLASS_DESC',
  SensorInstallDueDateAsc = 'SENSOR_INSTALL_DUE_DATE_ASC',
  SensorInstallDueDateDesc = 'SENSOR_INSTALL_DUE_DATE_DESC',
  SensorInstallDueDateLabelAsc = 'SENSOR_INSTALL_DUE_DATE_LABEL_ASC',
  SensorInstallDueDateLabelDesc = 'SENSOR_INSTALL_DUE_DATE_LABEL_DESC',
  SensorLabelDateAsc = 'SENSOR_LABEL_DATE_ASC',
  SensorLabelDateDesc = 'SENSOR_LABEL_DATE_DESC',
  SensorMaintenanceDueClassAsc = 'SENSOR_MAINTENANCE_DUE_CLASS_ASC',
  SensorMaintenanceDueClassDesc = 'SENSOR_MAINTENANCE_DUE_CLASS_DESC',
  SensorMaintenanceDueDateAsc = 'SENSOR_MAINTENANCE_DUE_DATE_ASC',
  SensorMaintenanceDueDateDesc = 'SENSOR_MAINTENANCE_DUE_DATE_DESC',
  SensorMaintenanceDueDateLabelAsc = 'SENSOR_MAINTENANCE_DUE_DATE_LABEL_ASC',
  SensorMaintenanceDueDateLabelDesc = 'SENSOR_MAINTENANCE_DUE_DATE_LABEL_DESC',
  SensorModelAsc = 'SENSOR_MODEL_ASC',
  SensorModelDesc = 'SENSOR_MODEL_DESC',
  SensorSerialNumberAsc = 'SENSOR_SERIAL_NUMBER_ASC',
  SensorSerialNumberDesc = 'SENSOR_SERIAL_NUMBER_DESC',
  SensorTypeMembraneSealAsc = 'SENSOR_TYPE_MEMBRANE_SEAL_ASC',
  SensorTypeMembraneSealDesc = 'SENSOR_TYPE_MEMBRANE_SEAL_DESC',
  SensorTypeSiliconeSheetAsc = 'SENSOR_TYPE_SILICONE_SHEET_ASC',
  SensorTypeSiliconeSheetDesc = 'SENSOR_TYPE_SILICONE_SHEET_DESC',
  SimsChannelAsc = 'SIMS_CHANNEL_ASC',
  SimsChannelDesc = 'SIMS_CHANNEL_DESC',
  SimsTagAsc = 'SIMS_TAG_ASC',
  SimsTagDesc = 'SIMS_TAG_DESC'
}

/** Methods to use when ordering `DetectorSensorLocation`. */
export enum DetectorSensorLocationsOrderBy {
  ApplicationByApplicationIdCreatedAsc = 'APPLICATION_BY_APPLICATION_ID__CREATED_ASC',
  ApplicationByApplicationIdCreatedDesc = 'APPLICATION_BY_APPLICATION_ID__CREATED_DESC',
  ApplicationByApplicationIdIdAsc = 'APPLICATION_BY_APPLICATION_ID__ID_ASC',
  ApplicationByApplicationIdIdDesc = 'APPLICATION_BY_APPLICATION_ID__ID_DESC',
  ApplicationByApplicationIdModifiedAsc = 'APPLICATION_BY_APPLICATION_ID__MODIFIED_ASC',
  ApplicationByApplicationIdModifiedDesc = 'APPLICATION_BY_APPLICATION_ID__MODIFIED_DESC',
  ApplicationByApplicationIdNameAsc = 'APPLICATION_BY_APPLICATION_ID__NAME_ASC',
  ApplicationByApplicationIdNameDesc = 'APPLICATION_BY_APPLICATION_ID__NAME_DESC',
  ApplicationByApplicationIdOwnerIdAsc = 'APPLICATION_BY_APPLICATION_ID__OWNER_ID_ASC',
  ApplicationByApplicationIdOwnerIdDesc = 'APPLICATION_BY_APPLICATION_ID__OWNER_ID_DESC',
  ApplicationByApplicationIdToolIdAsc = 'APPLICATION_BY_APPLICATION_ID___TOOL_ID_ASC',
  ApplicationByApplicationIdToolIdDesc = 'APPLICATION_BY_APPLICATION_ID___TOOL_ID_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorLocationByDetectorLocationIdAddressAsc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__ADDRESS_ASC',
  DetectorLocationByDetectorLocationIdAddressDesc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__ADDRESS_DESC',
  DetectorLocationByDetectorLocationIdAreaIdAsc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__AREA_ID_ASC',
  DetectorLocationByDetectorLocationIdAreaIdDesc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__AREA_ID_DESC',
  DetectorLocationByDetectorLocationIdBusAsc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__BUS_ASC',
  DetectorLocationByDetectorLocationIdBusDesc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__BUS_DESC',
  DetectorLocationByDetectorLocationIdCreatedAsc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__CREATED_ASC',
  DetectorLocationByDetectorLocationIdCreatedDesc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__CREATED_DESC',
  DetectorLocationByDetectorLocationIdDetectorIdAsc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__DETECTOR_ID_ASC',
  DetectorLocationByDetectorLocationIdDetectorIdDesc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__DETECTOR_ID_DESC',
  DetectorLocationByDetectorLocationIdIdAsc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__ID_ASC',
  DetectorLocationByDetectorLocationIdIdDesc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__ID_DESC',
  DetectorLocationByDetectorLocationIdModifiedAsc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__MODIFIED_ASC',
  DetectorLocationByDetectorLocationIdModifiedDesc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__MODIFIED_DESC',
  DetectorLocationByDetectorLocationIdOwnerIdAsc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__OWNER_ID_ASC',
  DetectorLocationByDetectorLocationIdOwnerIdDesc = 'DETECTOR_LOCATION_BY_DETECTOR_LOCATION_ID__OWNER_ID_DESC',
  DetectorLocationIdAsc = 'DETECTOR_LOCATION_ID_ASC',
  DetectorLocationIdDesc = 'DETECTOR_LOCATION_ID_DESC',
  DetectorSensorByDetectorSensorIdCreatedAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__CREATED_ASC',
  DetectorSensorByDetectorSensorIdCreatedDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__CREATED_DESC',
  DetectorSensorByDetectorSensorIdDetectorIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__DETECTOR_ID_ASC',
  DetectorSensorByDetectorSensorIdDetectorIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__DETECTOR_ID_DESC',
  DetectorSensorByDetectorSensorIdDetectorPositionAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__DETECTOR_POSITION_ASC',
  DetectorSensorByDetectorSensorIdDetectorPositionDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__DETECTOR_POSITION_DESC',
  DetectorSensorByDetectorSensorIdFilterIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__FILTER_ID_ASC',
  DetectorSensorByDetectorSensorIdFilterIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__FILTER_ID_DESC',
  DetectorSensorByDetectorSensorIdIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__ID_ASC',
  DetectorSensorByDetectorSensorIdIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__ID_DESC',
  DetectorSensorByDetectorSensorIdModifiedAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__MODIFIED_ASC',
  DetectorSensorByDetectorSensorIdModifiedDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__MODIFIED_DESC',
  DetectorSensorByDetectorSensorIdOwnerIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__OWNER_ID_ASC',
  DetectorSensorByDetectorSensorIdOwnerIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__OWNER_ID_DESC',
  DetectorSensorByDetectorSensorIdPyrolyserIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__PYROLYSER_ID_ASC',
  DetectorSensorByDetectorSensorIdPyrolyserIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__PYROLYSER_ID_DESC',
  DetectorSensorByDetectorSensorIdSensorIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__SENSOR_ID_ASC',
  DetectorSensorByDetectorSensorIdSensorIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__SENSOR_ID_DESC',
  DetectorSensorByDetectorSensorIdFilterLabelDateAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID___FILTER_LABEL_DATE_ASC',
  DetectorSensorByDetectorSensorIdFilterLabelDateDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID___FILTER_LABEL_DATE_DESC',
  DetectorSensorByDetectorSensorIdPyrolyserLabelDateAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID___PYROLYSER_LABEL_DATE_ASC',
  DetectorSensorByDetectorSensorIdPyrolyserLabelDateDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID___PYROLYSER_LABEL_DATE_DESC',
  DetectorSensorIdAsc = 'DETECTOR_SENSOR_ID_ASC',
  DetectorSensorIdDesc = 'DETECTOR_SENSOR_ID_DESC',
  FilterReplacementIntervalMonthsAsc = 'FILTER_REPLACEMENT_INTERVAL_MONTHS_ASC',
  FilterReplacementIntervalMonthsDesc = 'FILTER_REPLACEMENT_INTERVAL_MONTHS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LicenseByLicenseIdActivateAsc = 'LICENSE_BY_LICENSE_ID__ACTIVATE_ASC',
  LicenseByLicenseIdActivateDesc = 'LICENSE_BY_LICENSE_ID__ACTIVATE_DESC',
  LicenseByLicenseIdCreatedAsc = 'LICENSE_BY_LICENSE_ID__CREATED_ASC',
  LicenseByLicenseIdCreatedDesc = 'LICENSE_BY_LICENSE_ID__CREATED_DESC',
  LicenseByLicenseIdDurationDaysAsc = 'LICENSE_BY_LICENSE_ID__DURATION_DAYS_ASC',
  LicenseByLicenseIdDurationDaysDesc = 'LICENSE_BY_LICENSE_ID__DURATION_DAYS_DESC',
  LicenseByLicenseIdDurationMonthsAsc = 'LICENSE_BY_LICENSE_ID__DURATION_MONTHS_ASC',
  LicenseByLicenseIdDurationMonthsDesc = 'LICENSE_BY_LICENSE_ID__DURATION_MONTHS_DESC',
  LicenseByLicenseIdEndUserIdAsc = 'LICENSE_BY_LICENSE_ID__END_USER_ID_ASC',
  LicenseByLicenseIdEndUserIdDesc = 'LICENSE_BY_LICENSE_ID__END_USER_ID_DESC',
  LicenseByLicenseIdIdAsc = 'LICENSE_BY_LICENSE_ID__ID_ASC',
  LicenseByLicenseIdIdDesc = 'LICENSE_BY_LICENSE_ID__ID_DESC',
  LicenseByLicenseIdLicenseCodeAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_CODE_ASC',
  LicenseByLicenseIdLicenseCodeDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_CODE_DESC',
  LicenseByLicenseIdLicenseCustomerIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_CUSTOMER_ID_ASC',
  LicenseByLicenseIdLicenseCustomerIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_CUSTOMER_ID_DESC',
  LicenseByLicenseIdLicenseIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_ID_ASC',
  LicenseByLicenseIdLicenseIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_ID_DESC',
  LicenseByLicenseIdLicenseModuleIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_MODULE_ID_ASC',
  LicenseByLicenseIdLicenseModuleIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_MODULE_ID_DESC',
  LicenseByLicenseIdModuleDataAsc = 'LICENSE_BY_LICENSE_ID__MODULE_DATA_ASC',
  LicenseByLicenseIdModuleDataDesc = 'LICENSE_BY_LICENSE_ID__MODULE_DATA_DESC',
  LicenseByLicenseIdOwnerIdAsc = 'LICENSE_BY_LICENSE_ID__OWNER_ID_ASC',
  LicenseByLicenseIdOwnerIdDesc = 'LICENSE_BY_LICENSE_ID__OWNER_ID_DESC',
  LicenseByLicenseIdRemarksAsc = 'LICENSE_BY_LICENSE_ID__REMARKS_ASC',
  LicenseByLicenseIdRemarksDesc = 'LICENSE_BY_LICENSE_ID__REMARKS_DESC',
  LicenseIdAsc = 'LICENSE_ID_ASC',
  LicenseIdDesc = 'LICENSE_ID_DESC',
  MaintenanceVisitLinesByDetectorSensorLocationIdCountAsc = 'MAINTENANCE_VISIT_LINES_BY_DETECTOR_SENSOR_LOCATION_ID__COUNT_ASC',
  MaintenanceVisitLinesByDetectorSensorLocationIdCountDesc = 'MAINTENANCE_VISIT_LINES_BY_DETECTOR_SENSOR_LOCATION_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PyrolyserReplacementIntervalMonthsAsc = 'PYROLYSER_REPLACEMENT_INTERVAL_MONTHS_ASC',
  PyrolyserReplacementIntervalMonthsDesc = 'PYROLYSER_REPLACEMENT_INTERVAL_MONTHS_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  SamplePointBySamplePointIdAreaIdAsc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__AREA_ID_ASC',
  SamplePointBySamplePointIdAreaIdDesc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__AREA_ID_DESC',
  SamplePointBySamplePointIdCreatedAsc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__CREATED_ASC',
  SamplePointBySamplePointIdCreatedDesc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__CREATED_DESC',
  SamplePointBySamplePointIdIdAsc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__ID_ASC',
  SamplePointBySamplePointIdIdDesc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__ID_DESC',
  SamplePointBySamplePointIdModifiedAsc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__MODIFIED_ASC',
  SamplePointBySamplePointIdModifiedDesc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__MODIFIED_DESC',
  SamplePointBySamplePointIdNameAsc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__NAME_ASC',
  SamplePointBySamplePointIdNameDesc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__NAME_DESC',
  SamplePointBySamplePointIdOwnerIdAsc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__OWNER_ID_ASC',
  SamplePointBySamplePointIdOwnerIdDesc = 'SAMPLE_POINT_BY_SAMPLE_POINT_ID__OWNER_ID_DESC',
  SamplePointIdAsc = 'SAMPLE_POINT_ID_ASC',
  SamplePointIdDesc = 'SAMPLE_POINT_ID_DESC',
  SensorElementLocationsByDetectorSensorLocationIdCountAsc = 'SENSOR_ELEMENT_LOCATIONS_BY_DETECTOR_SENSOR_LOCATION_ID__COUNT_ASC',
  SensorElementLocationsByDetectorSensorLocationIdCountDesc = 'SENSOR_ELEMENT_LOCATIONS_BY_DETECTOR_SENSOR_LOCATION_ID__COUNT_DESC',
  SensorMaintenanceIntervalMonthsAsc = 'SENSOR_MAINTENANCE_INTERVAL_MONTHS_ASC',
  SensorMaintenanceIntervalMonthsDesc = 'SENSOR_MAINTENANCE_INTERVAL_MONTHS_DESC',
  SensorReplacementIntervalMonthsAsc = 'SENSOR_REPLACEMENT_INTERVAL_MONTHS_ASC',
  SensorReplacementIntervalMonthsDesc = 'SENSOR_REPLACEMENT_INTERVAL_MONTHS_DESC',
  SimsChannelAsc = 'SIMS_CHANNEL_ASC',
  SimsChannelDesc = 'SIMS_CHANNEL_DESC',
  SimsTagAsc = 'SIMS_TAG_ASC',
  SimsTagDesc = 'SIMS_TAG_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** Represents an update to a `DetectorSensor`. Fields that are set will be updated. */
export type DetectorSensorPatch = {
  _filterLabelDate?: InputMaybe<Scalars['Date']['input']>;
  _pyrolyserLabelDate?: InputMaybe<Scalars['Date']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  filterId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `MaintenanceVisitLine` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorToManyMaintenanceVisitLineFilter = {
  /** Every related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitLineFilter>;
  /** No related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitLineFilter>;
  /** Some related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitLineFilter>;
};

export type DetectorSensorType = Node & {
  __typename?: 'DetectorSensorType';
  created?: Maybe<Scalars['Datetime']['output']>;
  detectorId?: Maybe<Scalars['Int']['output']>;
  detectorPosition?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `SensorType` that is related to this `DetectorSensorType`. */
  sensorTypeBySensorTypeId?: Maybe<SensorType>;
  sensorTypeId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `DetectorSensorType`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `DetectorSensorType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DetectorSensorTypeCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `detectorId` field. */
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `DetectorSensorType` object types. All fields are combined with a logical ‘and.’ */
export type DetectorSensorTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorSensorTypeFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorId` field. */
  detectorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorSensorTypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorSensorTypeFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypeBySensorTypeId` relation. */
  sensorTypeBySensorTypeId?: InputMaybe<SensorTypeFilter>;
  /** Filter by the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `DetectorSensorType` */
export type DetectorSensorTypeInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  sensorTypeId: Scalars['Int']['input'];
};

/** Represents an update to a `DetectorSensorType`. Fields that are set will be updated. */
export type DetectorSensorTypePatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DetectorSensorType` values. */
export type DetectorSensorTypesConnection = {
  __typename?: 'DetectorSensorTypesConnection';
  /** A list of edges which contains the `DetectorSensorType` and cursor to aid in pagination. */
  edges: Array<DetectorSensorTypesEdge>;
  /** A list of `DetectorSensorType` objects. */
  nodes: Array<DetectorSensorType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorSensorType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorSensorType` edge in the connection. */
export type DetectorSensorTypesEdge = {
  __typename?: 'DetectorSensorTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorSensorType` at the end of the edge. */
  node: DetectorSensorType;
};

/** Methods to use when ordering `DetectorSensorType`. */
export enum DetectorSensorTypesOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorIdAsc = 'DETECTOR_ID_ASC',
  DetectorIdDesc = 'DETECTOR_ID_DESC',
  DetectorPositionAsc = 'DETECTOR_POSITION_ASC',
  DetectorPositionDesc = 'DETECTOR_POSITION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorTypeBySensorTypeIdBatteryAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__BATTERY_ASC',
  SensorTypeBySensorTypeIdBatteryDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__BATTERY_DESC',
  SensorTypeBySensorTypeIdBiasMvAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__BIAS_MV_ASC',
  SensorTypeBySensorTypeIdBiasMvDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__BIAS_MV_DESC',
  SensorTypeBySensorTypeIdCalFlowRateAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_FLOW_RATE_ASC',
  SensorTypeBySensorTypeIdCalFlowRateDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_FLOW_RATE_DESC',
  SensorTypeBySensorTypeIdCalGasIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_GAS_ID_ASC',
  SensorTypeBySensorTypeIdCalGasIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_GAS_ID_DESC',
  SensorTypeBySensorTypeIdCalResponseAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_RESPONSE_ASC',
  SensorTypeBySensorTypeIdCalResponseDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_RESPONSE_DESC',
  SensorTypeBySensorTypeIdCdartikelAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CDARTIKEL_ASC',
  SensorTypeBySensorTypeIdCdartikelDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CDARTIKEL_DESC',
  SensorTypeBySensorTypeIdCodeAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CODE_ASC',
  SensorTypeBySensorTypeIdCodeDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CODE_DESC',
  SensorTypeBySensorTypeIdCreatedAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CREATED_ASC',
  SensorTypeBySensorTypeIdCreatedDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CREATED_DESC',
  SensorTypeBySensorTypeIdDirectionAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__DIRECTION_ASC',
  SensorTypeBySensorTypeIdDirectionDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__DIRECTION_DESC',
  SensorTypeBySensorTypeIdElectrodeCountAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELECTRODE_COUNT_ASC',
  SensorTypeBySensorTypeIdElectrodeCountDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELECTRODE_COUNT_DESC',
  SensorTypeBySensorTypeIdElectrolyteIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELECTROLYTE_ID_ASC',
  SensorTypeBySensorTypeIdElectrolyteIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELECTROLYTE_ID_DESC',
  SensorTypeBySensorTypeIdElementCountAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELEMENT_COUNT_ASC',
  SensorTypeBySensorTypeIdElementCountDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELEMENT_COUNT_DESC',
  SensorTypeBySensorTypeIdFilterIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__FILTER_ID_ASC',
  SensorTypeBySensorTypeIdFilterIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__FILTER_ID_DESC',
  SensorTypeBySensorTypeIdFlowRateAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__FLOW_RATE_ASC',
  SensorTypeBySensorTypeIdFlowRateDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__FLOW_RATE_DESC',
  SensorTypeBySensorTypeIdIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ID_ASC',
  SensorTypeBySensorTypeIdIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ID_DESC',
  SensorTypeBySensorTypeIdLowElectrolyteAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__LOW_ELECTROLYTE_ASC',
  SensorTypeBySensorTypeIdLowElectrolyteDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__LOW_ELECTROLYTE_DESC',
  SensorTypeBySensorTypeIdMaintenanceIntervalMonthsAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MAINTENANCE_INTERVAL_MONTHS_ASC',
  SensorTypeBySensorTypeIdMaintenanceIntervalMonthsDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MAINTENANCE_INTERVAL_MONTHS_DESC',
  SensorTypeBySensorTypeIdMembraneIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MEMBRANE_ID_ASC',
  SensorTypeBySensorTypeIdMembraneIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MEMBRANE_ID_DESC',
  SensorTypeBySensorTypeIdMembraneSealAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MEMBRANE_SEAL_ASC',
  SensorTypeBySensorTypeIdMembraneSealDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MEMBRANE_SEAL_DESC',
  SensorTypeBySensorTypeIdModelAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MODEL_ASC',
  SensorTypeBySensorTypeIdModelDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MODEL_DESC',
  SensorTypeBySensorTypeIdModifiedAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MODIFIED_ASC',
  SensorTypeBySensorTypeIdModifiedDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MODIFIED_DESC',
  SensorTypeBySensorTypeIdObsoleteAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__OBSOLETE_ASC',
  SensorTypeBySensorTypeIdObsoleteDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__OBSOLETE_DESC',
  SensorTypeBySensorTypeIdOwnerIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__OWNER_ID_ASC',
  SensorTypeBySensorTypeIdOwnerIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__OWNER_ID_DESC',
  SensorTypeBySensorTypeIdORingIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__O_RING_ID_ASC',
  SensorTypeBySensorTypeIdORingIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__O_RING_ID_DESC',
  SensorTypeBySensorTypeIdPlugIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PLUG_ID_ASC',
  SensorTypeBySensorTypeIdPlugIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PLUG_ID_DESC',
  SensorTypeBySensorTypeIdPrincipleIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PRINCIPLE_ID_ASC',
  SensorTypeBySensorTypeIdPrincipleIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PRINCIPLE_ID_DESC',
  SensorTypeBySensorTypeIdPyrolyserIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PYROLYSER_ID_ASC',
  SensorTypeBySensorTypeIdPyrolyserIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PYROLYSER_ID_DESC',
  SensorTypeBySensorTypeIdPyrolyserVoltageAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PYROLYSER_VOLTAGE_ASC',
  SensorTypeBySensorTypeIdPyrolyserVoltageDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PYROLYSER_VOLTAGE_DESC',
  SensorTypeBySensorTypeIdRangeIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__RANGE_ID_ASC',
  SensorTypeBySensorTypeIdRangeIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__RANGE_ID_DESC',
  SensorTypeBySensorTypeIdReplacementIntervalMonthsAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  SensorTypeBySensorTypeIdReplacementIntervalMonthsDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorTypeBySensorTypeIdRestrictorAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__RESTRICTOR_ASC',
  SensorTypeBySensorTypeIdRestrictorDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__RESTRICTOR_DESC',
  SensorTypeBySensorTypeIdSensorBaseTypeIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SENSOR_BASE_TYPE_ID_ASC',
  SensorTypeBySensorTypeIdSensorBaseTypeIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SENSOR_BASE_TYPE_ID_DESC',
  SensorTypeBySensorTypeIdSensorTypeIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SENSOR_TYPE_ID_ASC',
  SensorTypeBySensorTypeIdSensorTypeIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SENSOR_TYPE_ID_DESC',
  SensorTypeBySensorTypeIdSiliconeSheetAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SILICONE_SHEET_ASC',
  SensorTypeBySensorTypeIdSiliconeSheetDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SILICONE_SHEET_DESC',
  SensorTypeBySensorTypeIdSpanResistorAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SPAN_RESISTOR_ASC',
  SensorTypeBySensorTypeIdSpanResistorDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SPAN_RESISTOR_DESC',
  SensorTypeBySensorTypeIdTransportSwitchAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__TRANSPORT_SWITCH_ASC',
  SensorTypeBySensorTypeIdTransportSwitchDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__TRANSPORT_SWITCH_DESC',
  SensorTypeBySensorTypeIdVolumeAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__VOLUME_ASC',
  SensorTypeBySensorTypeIdVolumeDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__VOLUME_DESC',
  SensorTypeIdAsc = 'SENSOR_TYPE_ID_ASC',
  SensorTypeIdDesc = 'SENSOR_TYPE_ID_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A connection to a list of `DetectorSensor` values. */
export type DetectorSensorsConnection = {
  __typename?: 'DetectorSensorsConnection';
  /** A list of edges which contains the `DetectorSensor` and cursor to aid in pagination. */
  edges: Array<DetectorSensorsEdge>;
  /** A list of `DetectorSensor` objects. */
  nodes: Array<DetectorSensor>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorSensor` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorSensor` edge in the connection. */
export type DetectorSensorsEdge = {
  __typename?: 'DetectorSensorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorSensor` at the end of the edge. */
  node: DetectorSensor;
};

/** Methods to use when ordering `DetectorSensor`. */
export enum DetectorSensorsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorByDetectorIdCreatedAsc = 'DETECTOR_BY_DETECTOR_ID__CREATED_ASC',
  DetectorByDetectorIdCreatedDesc = 'DETECTOR_BY_DETECTOR_ID__CREATED_DESC',
  DetectorByDetectorIdDetectorTypeIdAsc = 'DETECTOR_BY_DETECTOR_ID__DETECTOR_TYPE_ID_ASC',
  DetectorByDetectorIdDetectorTypeIdDesc = 'DETECTOR_BY_DETECTOR_ID__DETECTOR_TYPE_ID_DESC',
  DetectorByDetectorIdIdAsc = 'DETECTOR_BY_DETECTOR_ID__ID_ASC',
  DetectorByDetectorIdIdDesc = 'DETECTOR_BY_DETECTOR_ID__ID_DESC',
  DetectorByDetectorIdLabelDateAsc = 'DETECTOR_BY_DETECTOR_ID__LABEL_DATE_ASC',
  DetectorByDetectorIdLabelDateDesc = 'DETECTOR_BY_DETECTOR_ID__LABEL_DATE_DESC',
  DetectorByDetectorIdModifiedAsc = 'DETECTOR_BY_DETECTOR_ID__MODIFIED_ASC',
  DetectorByDetectorIdModifiedDesc = 'DETECTOR_BY_DETECTOR_ID__MODIFIED_DESC',
  DetectorByDetectorIdOwnerIdAsc = 'DETECTOR_BY_DETECTOR_ID__OWNER_ID_ASC',
  DetectorByDetectorIdOwnerIdDesc = 'DETECTOR_BY_DETECTOR_ID__OWNER_ID_DESC',
  DetectorByDetectorIdRemarksAsc = 'DETECTOR_BY_DETECTOR_ID__REMARKS_ASC',
  DetectorByDetectorIdRemarksDesc = 'DETECTOR_BY_DETECTOR_ID__REMARKS_DESC',
  DetectorByDetectorIdSerialNumberAsc = 'DETECTOR_BY_DETECTOR_ID__SERIAL_NUMBER_ASC',
  DetectorByDetectorIdSerialNumberDesc = 'DETECTOR_BY_DETECTOR_ID__SERIAL_NUMBER_DESC',
  DetectorIdAsc = 'DETECTOR_ID_ASC',
  DetectorIdDesc = 'DETECTOR_ID_DESC',
  DetectorPositionAsc = 'DETECTOR_POSITION_ASC',
  DetectorPositionDesc = 'DETECTOR_POSITION_DESC',
  DetectorSensorLocationByDetectorSensorIdApplicationIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__APPLICATION_ID_ASC',
  DetectorSensorLocationByDetectorSensorIdApplicationIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__APPLICATION_ID_DESC',
  DetectorSensorLocationByDetectorSensorIdCreatedAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__CREATED_ASC',
  DetectorSensorLocationByDetectorSensorIdCreatedDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__CREATED_DESC',
  DetectorSensorLocationByDetectorSensorIdDetectorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__DETECTOR_LOCATION_ID_ASC',
  DetectorSensorLocationByDetectorSensorIdDetectorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__DETECTOR_LOCATION_ID_DESC',
  DetectorSensorLocationByDetectorSensorIdDetectorSensorIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__DETECTOR_SENSOR_ID_ASC',
  DetectorSensorLocationByDetectorSensorIdDetectorSensorIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__DETECTOR_SENSOR_ID_DESC',
  DetectorSensorLocationByDetectorSensorIdFilterReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__FILTER_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorIdFilterReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__FILTER_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorIdIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__ID_ASC',
  DetectorSensorLocationByDetectorSensorIdIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__ID_DESC',
  DetectorSensorLocationByDetectorSensorIdLicenseIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__LICENSE_ID_ASC',
  DetectorSensorLocationByDetectorSensorIdLicenseIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__LICENSE_ID_DESC',
  DetectorSensorLocationByDetectorSensorIdModifiedAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__MODIFIED_ASC',
  DetectorSensorLocationByDetectorSensorIdModifiedDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__MODIFIED_DESC',
  DetectorSensorLocationByDetectorSensorIdOwnerIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__OWNER_ID_ASC',
  DetectorSensorLocationByDetectorSensorIdOwnerIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__OWNER_ID_DESC',
  DetectorSensorLocationByDetectorSensorIdPyrolyserReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__PYROLYSER_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorIdPyrolyserReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__PYROLYSER_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorIdRemarksAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__REMARKS_ASC',
  DetectorSensorLocationByDetectorSensorIdRemarksDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__REMARKS_DESC',
  DetectorSensorLocationByDetectorSensorIdSamplePointIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SAMPLE_POINT_ID_ASC',
  DetectorSensorLocationByDetectorSensorIdSamplePointIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SAMPLE_POINT_ID_DESC',
  DetectorSensorLocationByDetectorSensorIdSensorMaintenanceIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SENSOR_MAINTENANCE_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorIdSensorMaintenanceIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SENSOR_MAINTENANCE_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorIdSensorReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SENSOR_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorIdSensorReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SENSOR_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorIdSimsChannelAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SIMS_CHANNEL_ASC',
  DetectorSensorLocationByDetectorSensorIdSimsChannelDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SIMS_CHANNEL_DESC',
  DetectorSensorLocationByDetectorSensorIdSimsTagAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SIMS_TAG_ASC',
  DetectorSensorLocationByDetectorSensorIdSimsTagDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_ID__SIMS_TAG_DESC',
  FilterByFilterIdCdartikelAsc = 'FILTER_BY_FILTER_ID__CDARTIKEL_ASC',
  FilterByFilterIdCdartikelDesc = 'FILTER_BY_FILTER_ID__CDARTIKEL_DESC',
  FilterByFilterIdConsumableAsc = 'FILTER_BY_FILTER_ID__CONSUMABLE_ASC',
  FilterByFilterIdConsumableDesc = 'FILTER_BY_FILTER_ID__CONSUMABLE_DESC',
  FilterByFilterIdCreatedAsc = 'FILTER_BY_FILTER_ID__CREATED_ASC',
  FilterByFilterIdCreatedDesc = 'FILTER_BY_FILTER_ID__CREATED_DESC',
  FilterByFilterIdIdAsc = 'FILTER_BY_FILTER_ID__ID_ASC',
  FilterByFilterIdIdDesc = 'FILTER_BY_FILTER_ID__ID_DESC',
  FilterByFilterIdModifiedAsc = 'FILTER_BY_FILTER_ID__MODIFIED_ASC',
  FilterByFilterIdModifiedDesc = 'FILTER_BY_FILTER_ID__MODIFIED_DESC',
  FilterByFilterIdNameAsc = 'FILTER_BY_FILTER_ID__NAME_ASC',
  FilterByFilterIdNameDesc = 'FILTER_BY_FILTER_ID__NAME_DESC',
  FilterByFilterIdOwnerIdAsc = 'FILTER_BY_FILTER_ID__OWNER_ID_ASC',
  FilterByFilterIdOwnerIdDesc = 'FILTER_BY_FILTER_ID__OWNER_ID_DESC',
  FilterByFilterIdReplacementIntervalMonthsAsc = 'FILTER_BY_FILTER_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  FilterByFilterIdReplacementIntervalMonthsDesc = 'FILTER_BY_FILTER_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  FilterIdAsc = 'FILTER_ID_ASC',
  FilterIdDesc = 'FILTER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceVisitLinesByDetectorSensorIdCountAsc = 'MAINTENANCE_VISIT_LINES_BY_DETECTOR_SENSOR_ID__COUNT_ASC',
  MaintenanceVisitLinesByDetectorSensorIdCountDesc = 'MAINTENANCE_VISIT_LINES_BY_DETECTOR_SENSOR_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PyrolyserByPyrolyserIdCdartikelAsc = 'PYROLYSER_BY_PYROLYSER_ID__CDARTIKEL_ASC',
  PyrolyserByPyrolyserIdCdartikelDesc = 'PYROLYSER_BY_PYROLYSER_ID__CDARTIKEL_DESC',
  PyrolyserByPyrolyserIdCreatedAsc = 'PYROLYSER_BY_PYROLYSER_ID__CREATED_ASC',
  PyrolyserByPyrolyserIdCreatedDesc = 'PYROLYSER_BY_PYROLYSER_ID__CREATED_DESC',
  PyrolyserByPyrolyserIdIdAsc = 'PYROLYSER_BY_PYROLYSER_ID__ID_ASC',
  PyrolyserByPyrolyserIdIdDesc = 'PYROLYSER_BY_PYROLYSER_ID__ID_DESC',
  PyrolyserByPyrolyserIdModifiedAsc = 'PYROLYSER_BY_PYROLYSER_ID__MODIFIED_ASC',
  PyrolyserByPyrolyserIdModifiedDesc = 'PYROLYSER_BY_PYROLYSER_ID__MODIFIED_DESC',
  PyrolyserByPyrolyserIdNameAsc = 'PYROLYSER_BY_PYROLYSER_ID__NAME_ASC',
  PyrolyserByPyrolyserIdNameDesc = 'PYROLYSER_BY_PYROLYSER_ID__NAME_DESC',
  PyrolyserByPyrolyserIdOwnerIdAsc = 'PYROLYSER_BY_PYROLYSER_ID__OWNER_ID_ASC',
  PyrolyserByPyrolyserIdOwnerIdDesc = 'PYROLYSER_BY_PYROLYSER_ID__OWNER_ID_DESC',
  PyrolyserByPyrolyserIdReplacementIntervalMonthsAsc = 'PYROLYSER_BY_PYROLYSER_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  PyrolyserByPyrolyserIdReplacementIntervalMonthsDesc = 'PYROLYSER_BY_PYROLYSER_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  PyrolyserIdAsc = 'PYROLYSER_ID_ASC',
  PyrolyserIdDesc = 'PYROLYSER_ID_DESC',
  SensorBySensorIdCreatedAsc = 'SENSOR_BY_SENSOR_ID__CREATED_ASC',
  SensorBySensorIdCreatedDesc = 'SENSOR_BY_SENSOR_ID__CREATED_DESC',
  SensorBySensorIdIdAsc = 'SENSOR_BY_SENSOR_ID__ID_ASC',
  SensorBySensorIdIdDesc = 'SENSOR_BY_SENSOR_ID__ID_DESC',
  SensorBySensorIdLabelDateAsc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_ASC',
  SensorBySensorIdLabelDateDesc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_DESC',
  SensorBySensorIdModifiedAsc = 'SENSOR_BY_SENSOR_ID__MODIFIED_ASC',
  SensorBySensorIdModifiedDesc = 'SENSOR_BY_SENSOR_ID__MODIFIED_DESC',
  SensorBySensorIdOwnerIdAsc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_ASC',
  SensorBySensorIdOwnerIdDesc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_DESC',
  SensorBySensorIdRemarksAsc = 'SENSOR_BY_SENSOR_ID__REMARKS_ASC',
  SensorBySensorIdRemarksDesc = 'SENSOR_BY_SENSOR_ID__REMARKS_DESC',
  SensorBySensorIdSensorTypeIdAsc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_ASC',
  SensorBySensorIdSensorTypeIdDesc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_DESC',
  SensorBySensorIdSerialNumberAsc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_ASC',
  SensorBySensorIdSerialNumberDesc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  FilterLabelDateAsc = '_FILTER_LABEL_DATE_ASC',
  FilterLabelDateDesc = '_FILTER_LABEL_DATE_DESC',
  PyrolyserLabelDateAsc = '_PYROLYSER_LABEL_DATE_ASC',
  PyrolyserLabelDateDesc = '_PYROLYSER_LABEL_DATE_DESC'
}

/** A filter to be used against many `DetectorOrder` object types. All fields are combined with a logical ‘and.’ */
export type DetectorToManyDetectorOrderFilter = {
  /** Every related `DetectorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorOrderFilter>;
  /** No related `DetectorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorOrderFilter>;
  /** Some related `DetectorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorOrderFilter>;
};

/** A filter to be used against many `DetectorSensor` object types. All fields are combined with a logical ‘and.’ */
export type DetectorToManyDetectorSensorFilter = {
  /** Every related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorFilter>;
  /** No related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorFilter>;
  /** Some related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorFilter>;
};

/** A filter to be used against many `ReportDetector` object types. All fields are combined with a logical ‘and.’ */
export type DetectorToManyReportDetectorFilter = {
  /** Every related `ReportDetector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReportDetectorFilter>;
  /** No related `ReportDetector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReportDetectorFilter>;
  /** Some related `ReportDetector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReportDetectorFilter>;
};

export type DetectorType = Node & {
  __typename?: 'DetectorType';
  code?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Detector`. */
  detectorsByDetectorTypeId: DetectorsConnection;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  obsolete?: Maybe<Scalars['Boolean']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  prefix?: Maybe<Scalars['String']['output']>;
  sensorCount?: Maybe<Scalars['Int']['output']>;
  suffix?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `DetectorType`. */
  userByOwnerId?: Maybe<User>;
};


export type DetectorTypeDetectorsByDetectorTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorCondition>;
  filter?: InputMaybe<DetectorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorsOrderBy>>;
};

/**
 * A condition to be used against `DetectorType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DetectorTypeCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `obsolete` field. */
  obsolete?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prefix` field. */
  prefix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorCount` field. */
  sensorCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `suffix` field. */
  suffix?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DetectorType` object types. All fields are combined with a logical ‘and.’ */
export type DetectorTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorTypeFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorsByDetectorTypeId` relation. */
  detectorsByDetectorTypeId?: InputMaybe<DetectorTypeToManyDetectorFilter>;
  /** Some related `detectorsByDetectorTypeId` exist. */
  detectorsByDetectorTypeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorTypeFilter>;
  /** Filter by the object’s `obsolete` field. */
  obsolete?: InputMaybe<BooleanFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorTypeFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prefix` field. */
  prefix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorCount` field. */
  sensorCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `suffix` field. */
  suffix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `DetectorType` */
export type DetectorTypeInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  obsolete?: InputMaybe<Scalars['Boolean']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  prefix?: InputMaybe<Scalars['String']['input']>;
  sensorCount?: InputMaybe<Scalars['Int']['input']>;
  suffix?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DetectorType`. Fields that are set will be updated. */
export type DetectorTypePatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  obsolete?: InputMaybe<Scalars['Boolean']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  prefix?: InputMaybe<Scalars['String']['input']>;
  sensorCount?: InputMaybe<Scalars['Int']['input']>;
  suffix?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `Detector` object types. All fields are combined with a logical ‘and.’ */
export type DetectorTypeToManyDetectorFilter = {
  /** Every related `Detector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorFilter>;
  /** No related `Detector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorFilter>;
  /** Some related `Detector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorFilter>;
};

/** A connection to a list of `DetectorType` values. */
export type DetectorTypesConnection = {
  __typename?: 'DetectorTypesConnection';
  /** A list of edges which contains the `DetectorType` and cursor to aid in pagination. */
  edges: Array<DetectorTypesEdge>;
  /** A list of `DetectorType` objects. */
  nodes: Array<DetectorType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorType` edge in the connection. */
export type DetectorTypesEdge = {
  __typename?: 'DetectorTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorType` at the end of the edge. */
  node: DetectorType;
};

/** A connection to a list of `DetectorTypesEntity` values. */
export type DetectorTypesEntitiesConnection = {
  __typename?: 'DetectorTypesEntitiesConnection';
  /** A list of edges which contains the `DetectorTypesEntity` and cursor to aid in pagination. */
  edges: Array<DetectorTypesEntitiesEdge>;
  /** A list of `DetectorTypesEntity` objects. */
  nodes: Array<DetectorTypesEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorTypesEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorTypesEntity` edge in the connection. */
export type DetectorTypesEntitiesEdge = {
  __typename?: 'DetectorTypesEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorTypesEntity` at the end of the edge. */
  node: DetectorTypesEntity;
};

/** Methods to use when ordering `DetectorTypesEntity`. */
export enum DetectorTypesEntitiesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  ObsoleteAsc = 'OBSOLETE_ASC',
  ObsoleteDesc = 'OBSOLETE_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrefixAsc = 'PREFIX_ASC',
  PrefixDesc = 'PREFIX_DESC',
  SensorCountAsc = 'SENSOR_COUNT_ASC',
  SensorCountDesc = 'SENSOR_COUNT_DESC',
  SuffixAsc = 'SUFFIX_ASC',
  SuffixDesc = 'SUFFIX_DESC'
}

export type DetectorTypesEntity = {
  __typename?: 'DetectorTypesEntity';
  code?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  obsolete?: Maybe<Scalars['Boolean']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  prefix?: Maybe<Scalars['String']['output']>;
  sensorCount?: Maybe<Scalars['Int']['output']>;
  suffix?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DetectorTypesEntity` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type DetectorTypesEntityCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `obsolete` field. */
  obsolete?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prefix` field. */
  prefix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorCount` field. */
  sensorCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `suffix` field. */
  suffix?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DetectorTypesEntity` object types. All fields are combined with a logical ‘and.’ */
export type DetectorTypesEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorTypesEntityFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorTypesEntityFilter>;
  /** Filter by the object’s `obsolete` field. */
  obsolete?: InputMaybe<BooleanFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorTypesEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prefix` field. */
  prefix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorCount` field. */
  sensorCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `suffix` field. */
  suffix?: InputMaybe<StringFilter>;
};

/** Methods to use when ordering `DetectorType`. */
export enum DetectorTypesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorsByDetectorTypeIdCountAsc = 'DETECTORS_BY_DETECTOR_TYPE_ID__COUNT_ASC',
  DetectorsByDetectorTypeIdCountDesc = 'DETECTORS_BY_DETECTOR_TYPE_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  ObsoleteAsc = 'OBSOLETE_ASC',
  ObsoleteDesc = 'OBSOLETE_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrefixAsc = 'PREFIX_ASC',
  PrefixDesc = 'PREFIX_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorCountAsc = 'SENSOR_COUNT_ASC',
  SensorCountDesc = 'SENSOR_COUNT_DESC',
  SuffixAsc = 'SUFFIX_ASC',
  SuffixDesc = 'SUFFIX_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type DetectorsChecklist = {
  __typename?: 'DetectorsChecklist';
  battery?: Maybe<Scalars['String']['output']>;
  calFlowRate?: Maybe<Scalars['String']['output']>;
  calGas?: Maybe<Scalars['String']['output']>;
  detectorSerialNumber?: Maybe<Scalars['String']['output']>;
  detectorTypePrefix?: Maybe<Scalars['String']['output']>;
  detectorTypeSuffix?: Maybe<Scalars['String']['output']>;
  electrolyteName?: Maybe<Scalars['String']['output']>;
  engineeringUnits?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  highEu?: Maybe<Scalars['String']['output']>;
  longDate?: Maybe<Scalars['String']['output']>;
  lowEu?: Maybe<Scalars['String']['output']>;
  membraneName?: Maybe<Scalars['String']['output']>;
  oRingName?: Maybe<Scalars['String']['output']>;
  pc5154BS1?: Maybe<Scalars['String']['output']>;
  pc5154BS2?: Maybe<Scalars['String']['output']>;
  pc5155BS1?: Maybe<Scalars['String']['output']>;
  pc5155BS3?: Maybe<Scalars['String']['output']>;
  pc5155BS4?: Maybe<Scalars['String']['output']>;
  pc5155BS5?: Maybe<Scalars['String']['output']>;
  restrictor?: Maybe<Scalars['String']['output']>;
  seal?: Maybe<Scalars['String']['output']>;
  sensorSerialNumber?: Maybe<Scalars['String']['output']>;
  sensorType?: Maybe<Scalars['String']['output']>;
  shortDate?: Maybe<Scalars['String']['output']>;
  target?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DetectorsChecklist` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DetectorsChecklistCondition = {
  /** Checks for equality with the object’s `battery` field. */
  battery?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calGas` field. */
  calGas?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorSerialNumber` field. */
  detectorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorTypePrefix` field. */
  detectorTypePrefix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorTypeSuffix` field. */
  detectorTypeSuffix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `highEu` field. */
  highEu?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `longDate` field. */
  longDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lowEu` field. */
  lowEu?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `membraneName` field. */
  membraneName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `oRingName` field. */
  oRingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5154BS1` field. */
  pc5154BS1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5154BS2` field. */
  pc5154BS2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS1` field. */
  pc5155BS1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS3` field. */
  pc5155BS3?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS4` field. */
  pc5155BS4?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS5` field. */
  pc5155BS5?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `restrictor` field. */
  restrictor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `seal` field. */
  seal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorType` field. */
  sensorType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shortDate` field. */
  shortDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `target` field. */
  target?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DetectorsChecklist` object types. All fields are combined with a logical ‘and.’ */
export type DetectorsChecklistFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DetectorsChecklistFilter>>;
  /** Filter by the object’s `battery` field. */
  battery?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calGas` field. */
  calGas?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorSerialNumber` field. */
  detectorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorTypePrefix` field. */
  detectorTypePrefix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorTypeSuffix` field. */
  detectorTypeSuffix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `highEu` field. */
  highEu?: InputMaybe<StringFilter>;
  /** Filter by the object’s `longDate` field. */
  longDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lowEu` field. */
  lowEu?: InputMaybe<StringFilter>;
  /** Filter by the object’s `membraneName` field. */
  membraneName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DetectorsChecklistFilter>;
  /** Filter by the object’s `oRingName` field. */
  oRingName?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DetectorsChecklistFilter>>;
  /** Filter by the object’s `pc5154BS1` field. */
  pc5154BS1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5154BS2` field. */
  pc5154BS2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS1` field. */
  pc5155BS1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS3` field. */
  pc5155BS3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS4` field. */
  pc5155BS4?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS5` field. */
  pc5155BS5?: InputMaybe<StringFilter>;
  /** Filter by the object’s `restrictor` field. */
  restrictor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `seal` field. */
  seal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorType` field. */
  sensorType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shortDate` field. */
  shortDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `target` field. */
  target?: InputMaybe<StringFilter>;
};

/** A connection to a list of `DetectorsChecklist` values. */
export type DetectorsChecklistsConnection = {
  __typename?: 'DetectorsChecklistsConnection';
  /** A list of edges which contains the `DetectorsChecklist` and cursor to aid in pagination. */
  edges: Array<DetectorsChecklistsEdge>;
  /** A list of `DetectorsChecklist` objects. */
  nodes: Array<DetectorsChecklist>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DetectorsChecklist` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DetectorsChecklist` edge in the connection. */
export type DetectorsChecklistsEdge = {
  __typename?: 'DetectorsChecklistsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DetectorsChecklist` at the end of the edge. */
  node: DetectorsChecklist;
};

/** Methods to use when ordering `DetectorsChecklist`. */
export enum DetectorsChecklistsOrderBy {
  BatteryAsc = 'BATTERY_ASC',
  BatteryDesc = 'BATTERY_DESC',
  CalFlowRateAsc = 'CAL_FLOW_RATE_ASC',
  CalFlowRateDesc = 'CAL_FLOW_RATE_DESC',
  CalGasAsc = 'CAL_GAS_ASC',
  CalGasDesc = 'CAL_GAS_DESC',
  DetectorSerialNumberAsc = 'DETECTOR_SERIAL_NUMBER_ASC',
  DetectorSerialNumberDesc = 'DETECTOR_SERIAL_NUMBER_DESC',
  DetectorTypePrefixAsc = 'DETECTOR_TYPE_PREFIX_ASC',
  DetectorTypePrefixDesc = 'DETECTOR_TYPE_PREFIX_DESC',
  DetectorTypeSuffixAsc = 'DETECTOR_TYPE_SUFFIX_ASC',
  DetectorTypeSuffixDesc = 'DETECTOR_TYPE_SUFFIX_DESC',
  ElectrolyteNameAsc = 'ELECTROLYTE_NAME_ASC',
  ElectrolyteNameDesc = 'ELECTROLYTE_NAME_DESC',
  EngineeringUnitsAsc = 'ENGINEERING_UNITS_ASC',
  EngineeringUnitsDesc = 'ENGINEERING_UNITS_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  HighEuAsc = 'HIGH_EU_ASC',
  HighEuDesc = 'HIGH_EU_DESC',
  LongDateAsc = 'LONG_DATE_ASC',
  LongDateDesc = 'LONG_DATE_DESC',
  LowEuAsc = 'LOW_EU_ASC',
  LowEuDesc = 'LOW_EU_DESC',
  MembraneNameAsc = 'MEMBRANE_NAME_ASC',
  MembraneNameDesc = 'MEMBRANE_NAME_DESC',
  Natural = 'NATURAL',
  ORingNameAsc = 'O_RING_NAME_ASC',
  ORingNameDesc = 'O_RING_NAME_DESC',
  Pc_5154BS1Asc = 'PC_5154B_S1_ASC',
  Pc_5154BS1Desc = 'PC_5154B_S1_DESC',
  Pc_5154BS2Asc = 'PC_5154B_S2_ASC',
  Pc_5154BS2Desc = 'PC_5154B_S2_DESC',
  Pc_5155BS1Asc = 'PC_5155B_S1_ASC',
  Pc_5155BS1Desc = 'PC_5155B_S1_DESC',
  Pc_5155BS3Asc = 'PC_5155B_S3_ASC',
  Pc_5155BS3Desc = 'PC_5155B_S3_DESC',
  Pc_5155BS4Asc = 'PC_5155B_S4_ASC',
  Pc_5155BS4Desc = 'PC_5155B_S4_DESC',
  Pc_5155BS5Asc = 'PC_5155B_S5_ASC',
  Pc_5155BS5Desc = 'PC_5155B_S5_DESC',
  RestrictorAsc = 'RESTRICTOR_ASC',
  RestrictorDesc = 'RESTRICTOR_DESC',
  SealAsc = 'SEAL_ASC',
  SealDesc = 'SEAL_DESC',
  SensorSerialNumberAsc = 'SENSOR_SERIAL_NUMBER_ASC',
  SensorSerialNumberDesc = 'SENSOR_SERIAL_NUMBER_DESC',
  SensorTypeAsc = 'SENSOR_TYPE_ASC',
  SensorTypeDesc = 'SENSOR_TYPE_DESC',
  ShortDateAsc = 'SHORT_DATE_ASC',
  ShortDateDesc = 'SHORT_DATE_DESC',
  TargetAsc = 'TARGET_ASC',
  TargetDesc = 'TARGET_DESC'
}

/** A connection to a list of `Detector` values. */
export type DetectorsConnection = {
  __typename?: 'DetectorsConnection';
  /** A list of edges which contains the `Detector` and cursor to aid in pagination. */
  edges: Array<DetectorsEdge>;
  /** A list of `Detector` objects. */
  nodes: Array<Detector>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Detector` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Detector` edge in the connection. */
export type DetectorsEdge = {
  __typename?: 'DetectorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Detector` at the end of the edge. */
  node: Detector;
};

/** Methods to use when ordering `Detector`. */
export enum DetectorsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorLocationByDetectorIdAddressAsc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__ADDRESS_ASC',
  DetectorLocationByDetectorIdAddressDesc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__ADDRESS_DESC',
  DetectorLocationByDetectorIdAreaIdAsc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__AREA_ID_ASC',
  DetectorLocationByDetectorIdAreaIdDesc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__AREA_ID_DESC',
  DetectorLocationByDetectorIdBusAsc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__BUS_ASC',
  DetectorLocationByDetectorIdBusDesc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__BUS_DESC',
  DetectorLocationByDetectorIdCreatedAsc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__CREATED_ASC',
  DetectorLocationByDetectorIdCreatedDesc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__CREATED_DESC',
  DetectorLocationByDetectorIdDetectorIdAsc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__DETECTOR_ID_ASC',
  DetectorLocationByDetectorIdDetectorIdDesc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__DETECTOR_ID_DESC',
  DetectorLocationByDetectorIdIdAsc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__ID_ASC',
  DetectorLocationByDetectorIdIdDesc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__ID_DESC',
  DetectorLocationByDetectorIdModifiedAsc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__MODIFIED_ASC',
  DetectorLocationByDetectorIdModifiedDesc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__MODIFIED_DESC',
  DetectorLocationByDetectorIdOwnerIdAsc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__OWNER_ID_ASC',
  DetectorLocationByDetectorIdOwnerIdDesc = 'DETECTOR_LOCATION_BY_DETECTOR_ID__OWNER_ID_DESC',
  DetectorOrdersByDetectorIdCountAsc = 'DETECTOR_ORDERS_BY_DETECTOR_ID__COUNT_ASC',
  DetectorOrdersByDetectorIdCountDesc = 'DETECTOR_ORDERS_BY_DETECTOR_ID__COUNT_DESC',
  DetectorSensorsByDetectorIdCountAsc = 'DETECTOR_SENSORS_BY_DETECTOR_ID__COUNT_ASC',
  DetectorSensorsByDetectorIdCountDesc = 'DETECTOR_SENSORS_BY_DETECTOR_ID__COUNT_DESC',
  DetectorTypeByDetectorTypeIdCodeAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__CODE_ASC',
  DetectorTypeByDetectorTypeIdCodeDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__CODE_DESC',
  DetectorTypeByDetectorTypeIdCreatedAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__CREATED_ASC',
  DetectorTypeByDetectorTypeIdCreatedDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__CREATED_DESC',
  DetectorTypeByDetectorTypeIdIdAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__ID_ASC',
  DetectorTypeByDetectorTypeIdIdDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__ID_DESC',
  DetectorTypeByDetectorTypeIdModifiedAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__MODIFIED_ASC',
  DetectorTypeByDetectorTypeIdModifiedDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__MODIFIED_DESC',
  DetectorTypeByDetectorTypeIdObsoleteAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__OBSOLETE_ASC',
  DetectorTypeByDetectorTypeIdObsoleteDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__OBSOLETE_DESC',
  DetectorTypeByDetectorTypeIdOwnerIdAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__OWNER_ID_ASC',
  DetectorTypeByDetectorTypeIdOwnerIdDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__OWNER_ID_DESC',
  DetectorTypeByDetectorTypeIdPrefixAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__PREFIX_ASC',
  DetectorTypeByDetectorTypeIdPrefixDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__PREFIX_DESC',
  DetectorTypeByDetectorTypeIdSensorCountAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__SENSOR_COUNT_ASC',
  DetectorTypeByDetectorTypeIdSensorCountDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__SENSOR_COUNT_DESC',
  DetectorTypeByDetectorTypeIdSuffixAsc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__SUFFIX_ASC',
  DetectorTypeByDetectorTypeIdSuffixDesc = 'DETECTOR_TYPE_BY_DETECTOR_TYPE_ID__SUFFIX_DESC',
  DetectorTypeIdAsc = 'DETECTOR_TYPE_ID_ASC',
  DetectorTypeIdDesc = 'DETECTOR_TYPE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelDateAsc = 'LABEL_DATE_ASC',
  LabelDateDesc = 'LABEL_DATE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  ReportDetectorsByDetectorIdCountAsc = 'REPORT_DETECTORS_BY_DETECTOR_ID__COUNT_ASC',
  ReportDetectorsByDetectorIdCountDesc = 'REPORT_DETECTORS_BY_DETECTOR_ID__COUNT_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type DpCard = Node & {
  __typename?: 'DpCard';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `DpCard`. */
  userByOwnerId?: Maybe<User>;
};

/** A condition to be used against `DpCard` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type DpCardCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DpCard` object types. All fields are combined with a logical ‘and.’ */
export type DpCardFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DpCardFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DpCardFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DpCardFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `DpCard` */
export type DpCardInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DpCard`. Fields that are set will be updated. */
export type DpCardPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DpCard` values. */
export type DpCardsConnection = {
  __typename?: 'DpCardsConnection';
  /** A list of edges which contains the `DpCard` and cursor to aid in pagination. */
  edges: Array<DpCardsEdge>;
  /** A list of `DpCard` objects. */
  nodes: Array<DpCard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DpCard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DpCard` edge in the connection. */
export type DpCardsEdge = {
  __typename?: 'DpCardsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DpCard` at the end of the edge. */
  node: DpCard;
};

/** Methods to use when ordering `DpCard`. */
export enum DpCardsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** All input for the `dueClass` mutation. */
export type DueClassInput = {
  arg0?: InputMaybe<Scalars['Date']['input']>;
  arg1?: InputMaybe<Scalars['Date']['input']>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `dueClass` mutation. */
export type DueClassPayload = {
  __typename?: 'DueClassPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  string?: Maybe<Scalars['String']['output']>;
};

export type Electrolyte = Node & {
  __typename?: 'Electrolyte';
  cdartikel: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByElectrolyteId: SensorTypesConnection;
  /** Reads a single `User` that is related to this `Electrolyte`. */
  userByOwnerId?: Maybe<User>;
  volume?: Maybe<Scalars['Int']['output']>;
};


export type ElectrolyteSensorTypesByElectrolyteIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/**
 * A condition to be used against `Electrolyte` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ElectrolyteCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `volume` field. */
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ElectrolyteEntity` values. */
export type ElectrolyteEntitiesConnection = {
  __typename?: 'ElectrolyteEntitiesConnection';
  /** A list of edges which contains the `ElectrolyteEntity` and cursor to aid in pagination. */
  edges: Array<ElectrolyteEntitiesEdge>;
  /** A list of `ElectrolyteEntity` objects. */
  nodes: Array<ElectrolyteEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ElectrolyteEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ElectrolyteEntity` edge in the connection. */
export type ElectrolyteEntitiesEdge = {
  __typename?: 'ElectrolyteEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ElectrolyteEntity` at the end of the edge. */
  node: ElectrolyteEntity;
};

/** Methods to use when ordering `ElectrolyteEntity`. */
export enum ElectrolyteEntitiesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  VolumeAsc = 'VOLUME_ASC',
  VolumeDesc = 'VOLUME_DESC'
}

export type ElectrolyteEntity = {
  __typename?: 'ElectrolyteEntity';
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  volume?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `ElectrolyteEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ElectrolyteEntityCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `volume` field. */
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ElectrolyteEntity` object types. All fields are combined with a logical ‘and.’ */
export type ElectrolyteEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ElectrolyteEntityFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ElectrolyteEntityFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ElectrolyteEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `volume` field. */
  volume?: InputMaybe<IntFilter>;
};

/** A filter to be used against `Electrolyte` object types. All fields are combined with a logical ‘and.’ */
export type ElectrolyteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ElectrolyteFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ElectrolyteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ElectrolyteFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypesByElectrolyteId` relation. */
  sensorTypesByElectrolyteId?: InputMaybe<ElectrolyteToManySensorTypeFilter>;
  /** Some related `sensorTypesByElectrolyteId` exist. */
  sensorTypesByElectrolyteIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `volume` field. */
  volume?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Electrolyte` */
export type ElectrolyteInput = {
  cdartikel: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Electrolyte`. Fields that are set will be updated. */
export type ElectrolytePatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type ElectrolyteToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `Electrolyte` values. */
export type ElectrolytesConnection = {
  __typename?: 'ElectrolytesConnection';
  /** A list of edges which contains the `Electrolyte` and cursor to aid in pagination. */
  edges: Array<ElectrolytesEdge>;
  /** A list of `Electrolyte` objects. */
  nodes: Array<Electrolyte>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Electrolyte` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Electrolyte` edge in the connection. */
export type ElectrolytesEdge = {
  __typename?: 'ElectrolytesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Electrolyte` at the end of the edge. */
  node: Electrolyte;
};

/** Methods to use when ordering `Electrolyte`. */
export enum ElectrolytesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorTypesByElectrolyteIdCountAsc = 'SENSOR_TYPES_BY_ELECTROLYTE_ID__COUNT_ASC',
  SensorTypesByElectrolyteIdCountDesc = 'SENSOR_TYPES_BY_ELECTROLYTE_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  VolumeAsc = 'VOLUME_ASC',
  VolumeDesc = 'VOLUME_DESC'
}

export type EndUser = Node & {
  __typename?: 'EndUser';
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Building`. */
  buildingsByEndUserId: BuildingsConnection;
  city?: Maybe<Scalars['String']['output']>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  contactName?: Maybe<Scalars['String']['output']>;
  contactPhone?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  formerName1?: Maybe<Scalars['String']['output']>;
  formerName2?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Item`. */
  itemsByEndUserId: ItemsConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobsByEndUserId: JobsConnection;
  /** Reads and enables pagination through a set of `License`. */
  licensesByEndUserId: LicensesConnection;
  location: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `MaintenanceVisit`. */
  maintenanceVisitsByEndUserId: MaintenanceVisitsConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  region?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Report`. */
  reportsByEndUserId: ReportsConnection;
  subLocation: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `EndUser`. */
  userByOwnerId?: Maybe<User>;
  zipCode?: Maybe<Scalars['String']['output']>;
};


export type EndUserBuildingsByEndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BuildingCondition>;
  filter?: InputMaybe<BuildingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BuildingsOrderBy>>;
};


export type EndUserItemsByEndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ItemCondition>;
  filter?: InputMaybe<ItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
};


export type EndUserJobsByEndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type EndUserLicensesByEndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseCondition>;
  filter?: InputMaybe<LicenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicensesOrderBy>>;
};


export type EndUserMaintenanceVisitsByEndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitCondition>;
  filter?: InputMaybe<MaintenanceVisitFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsOrderBy>>;
};


export type EndUserReportsByEndUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportCondition>;
  filter?: InputMaybe<ReportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** A condition to be used against `EndUser` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EndUserCondition = {
  /** Checks for equality with the object’s `address1` field. */
  address1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `address2` field. */
  address2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactName` field. */
  contactName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactPhone` field. */
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formerName1` field. */
  formerName1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `formerName2` field. */
  formerName2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `region` field. */
  region?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `subLocation` field. */
  subLocation?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zipCode` field. */
  zipCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `EndUser` object types. All fields are combined with a logical ‘and.’ */
export type EndUserFilter = {
  /** Filter by the object’s `address1` field. */
  address1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `address2` field. */
  address2?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EndUserFilter>>;
  /** Filter by the object’s `buildingsByEndUserId` relation. */
  buildingsByEndUserId?: InputMaybe<EndUserToManyBuildingFilter>;
  /** Some related `buildingsByEndUserId` exist. */
  buildingsByEndUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `city` field. */
  city?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactName` field. */
  contactName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactPhone` field. */
  contactPhone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formerName1` field. */
  formerName1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `formerName2` field. */
  formerName2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `itemsByEndUserId` relation. */
  itemsByEndUserId?: InputMaybe<EndUserToManyItemFilter>;
  /** Some related `itemsByEndUserId` exist. */
  itemsByEndUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `jobsByEndUserId` relation. */
  jobsByEndUserId?: InputMaybe<EndUserToManyJobFilter>;
  /** Some related `jobsByEndUserId` exist. */
  jobsByEndUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licensesByEndUserId` relation. */
  licensesByEndUserId?: InputMaybe<EndUserToManyLicenseFilter>;
  /** Some related `licensesByEndUserId` exist. */
  licensesByEndUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `location` field. */
  location?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maintenanceVisitsByEndUserId` relation. */
  maintenanceVisitsByEndUserId?: InputMaybe<EndUserToManyMaintenanceVisitFilter>;
  /** Some related `maintenanceVisitsByEndUserId` exist. */
  maintenanceVisitsByEndUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EndUserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EndUserFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `region` field. */
  region?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reportsByEndUserId` relation. */
  reportsByEndUserId?: InputMaybe<EndUserToManyReportFilter>;
  /** Some related `reportsByEndUserId` exist. */
  reportsByEndUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `subLocation` field. */
  subLocation?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `zipCode` field. */
  zipCode?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `EndUser` */
export type EndUserInput = {
  address1?: InputMaybe<Scalars['String']['input']>;
  address2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactName?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  formerName1?: InputMaybe<Scalars['String']['input']>;
  formerName2?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  location: Scalars['String']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
  subLocation: Scalars['String']['input'];
  zipCode?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `EndUser`. Fields that are set will be updated. */
export type EndUserPatch = {
  address1?: InputMaybe<Scalars['String']['input']>;
  address2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactName?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  formerName1?: InputMaybe<Scalars['String']['input']>;
  formerName2?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  region?: InputMaybe<Scalars['String']['input']>;
  subLocation?: InputMaybe<Scalars['String']['input']>;
  zipCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `Building` object types. All fields are combined with a logical ‘and.’ */
export type EndUserToManyBuildingFilter = {
  /** Every related `Building` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<BuildingFilter>;
  /** No related `Building` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<BuildingFilter>;
  /** Some related `Building` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<BuildingFilter>;
};

/** A filter to be used against many `Item` object types. All fields are combined with a logical ‘and.’ */
export type EndUserToManyItemFilter = {
  /** Every related `Item` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ItemFilter>;
  /** No related `Item` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ItemFilter>;
  /** Some related `Item` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ItemFilter>;
};

/** A filter to be used against many `Job` object types. All fields are combined with a logical ‘and.’ */
export type EndUserToManyJobFilter = {
  /** Every related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobFilter>;
  /** No related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobFilter>;
  /** Some related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobFilter>;
};

/** A filter to be used against many `License` object types. All fields are combined with a logical ‘and.’ */
export type EndUserToManyLicenseFilter = {
  /** Every related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseFilter>;
  /** No related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseFilter>;
  /** Some related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseFilter>;
};

/** A filter to be used against many `MaintenanceVisit` object types. All fields are combined with a logical ‘and.’ */
export type EndUserToManyMaintenanceVisitFilter = {
  /** Every related `MaintenanceVisit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitFilter>;
  /** No related `MaintenanceVisit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitFilter>;
  /** Some related `MaintenanceVisit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitFilter>;
};

/** A filter to be used against many `Report` object types. All fields are combined with a logical ‘and.’ */
export type EndUserToManyReportFilter = {
  /** Every related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReportFilter>;
  /** No related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReportFilter>;
  /** Some related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReportFilter>;
};

/** A connection to a list of `EndUser` values. */
export type EndUsersConnection = {
  __typename?: 'EndUsersConnection';
  /** A list of edges which contains the `EndUser` and cursor to aid in pagination. */
  edges: Array<EndUsersEdge>;
  /** A list of `EndUser` objects. */
  nodes: Array<EndUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EndUser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `EndUser` edge in the connection. */
export type EndUsersEdge = {
  __typename?: 'EndUsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EndUser` at the end of the edge. */
  node: EndUser;
};

/** Methods to use when ordering `EndUser`. */
export enum EndUsersOrderBy {
  Address1Asc = 'ADDRESS1_ASC',
  Address1Desc = 'ADDRESS1_DESC',
  Address2Asc = 'ADDRESS2_ASC',
  Address2Desc = 'ADDRESS2_DESC',
  BuildingsByEndUserIdCountAsc = 'BUILDINGS_BY_END_USER_ID__COUNT_ASC',
  BuildingsByEndUserIdCountDesc = 'BUILDINGS_BY_END_USER_ID__COUNT_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactNameAsc = 'CONTACT_NAME_ASC',
  ContactNameDesc = 'CONTACT_NAME_DESC',
  ContactPhoneAsc = 'CONTACT_PHONE_ASC',
  ContactPhoneDesc = 'CONTACT_PHONE_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  FormerName1Asc = 'FORMER_NAME1_ASC',
  FormerName1Desc = 'FORMER_NAME1_DESC',
  FormerName2Asc = 'FORMER_NAME2_ASC',
  FormerName2Desc = 'FORMER_NAME2_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ItemsByEndUserIdCountAsc = 'ITEMS_BY_END_USER_ID__COUNT_ASC',
  ItemsByEndUserIdCountDesc = 'ITEMS_BY_END_USER_ID__COUNT_DESC',
  JobsByEndUserIdCountAsc = 'JOBS_BY_END_USER_ID__COUNT_ASC',
  JobsByEndUserIdCountDesc = 'JOBS_BY_END_USER_ID__COUNT_DESC',
  LicensesByEndUserIdCountAsc = 'LICENSES_BY_END_USER_ID__COUNT_ASC',
  LicensesByEndUserIdCountDesc = 'LICENSES_BY_END_USER_ID__COUNT_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  MaintenanceVisitsByEndUserIdCountAsc = 'MAINTENANCE_VISITS_BY_END_USER_ID__COUNT_ASC',
  MaintenanceVisitsByEndUserIdCountDesc = 'MAINTENANCE_VISITS_BY_END_USER_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RegionAsc = 'REGION_ASC',
  RegionDesc = 'REGION_DESC',
  ReportsByEndUserIdCountAsc = 'REPORTS_BY_END_USER_ID__COUNT_ASC',
  ReportsByEndUserIdCountDesc = 'REPORTS_BY_END_USER_ID__COUNT_DESC',
  SubLocationAsc = 'SUB_LOCATION_ASC',
  SubLocationDesc = 'SUB_LOCATION_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  ZipCodeAsc = 'ZIP_CODE_ASC',
  ZipCodeDesc = 'ZIP_CODE_DESC'
}

/** All input for the `exchangeDetectorsById` mutation. */
export type ExchangeDetectorsByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dstDetectorId?: InputMaybe<Scalars['Int']['input']>;
  srcDetectorId?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our `exchangeDetectorsById` mutation. */
export type ExchangeDetectorsByIdPayload = {
  __typename?: 'ExchangeDetectorsByIdPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  detectorSensors?: Maybe<Array<DetectorSensor>>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `exchangeDetectors` mutation. */
export type ExchangeDetectorsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sourceSerialNumber?: InputMaybe<Scalars['String']['input']>;
  targetSerialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `exchangeDetectors` mutation. */
export type ExchangeDetectorsPayload = {
  __typename?: 'ExchangeDetectorsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `exchangeSensorsById` mutation. */
export type ExchangeSensorsByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sourceId?: InputMaybe<Scalars['Int']['input']>;
  targetId?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our `exchangeSensorsById` mutation. */
export type ExchangeSensorsByIdPayload = {
  __typename?: 'ExchangeSensorsByIdPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `exchangeSensors` mutation. */
export type ExchangeSensorsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sourceSerialNumber?: InputMaybe<Scalars['String']['input']>;
  targetSerialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `exchangeSensors` mutation. */
export type ExchangeSensorsPayload = {
  __typename?: 'ExchangeSensorsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type FactopdrachtArtikelExclusion = Node & {
  __typename?: 'FactopdrachtArtikelExclusion';
  cdartikel: Scalars['String']['output'];
  factuuropdracht: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `FactopdrachtArtikelExclusion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtArtikelExclusionCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtArtikelExclusion` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtArtikelExclusionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtArtikelExclusionFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtArtikelExclusionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtArtikelExclusionFilter>>;
};

/** An input for mutations affecting `FactopdrachtArtikelExclusion` */
export type FactopdrachtArtikelExclusionInput = {
  cdartikel: Scalars['String']['input'];
  factuuropdracht: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `FactopdrachtArtikelExclusion`. Fields that are set will be updated. */
export type FactopdrachtArtikelExclusionPatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `FactopdrachtArtikelExclusion` values. */
export type FactopdrachtArtikelExclusionsConnection = {
  __typename?: 'FactopdrachtArtikelExclusionsConnection';
  /** A list of edges which contains the `FactopdrachtArtikelExclusion` and cursor to aid in pagination. */
  edges: Array<FactopdrachtArtikelExclusionsEdge>;
  /** A list of `FactopdrachtArtikelExclusion` objects. */
  nodes: Array<FactopdrachtArtikelExclusion>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtArtikelExclusion` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtArtikelExclusion` edge in the connection. */
export type FactopdrachtArtikelExclusionsEdge = {
  __typename?: 'FactopdrachtArtikelExclusionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtArtikelExclusion` at the end of the edge. */
  node: FactopdrachtArtikelExclusion;
};

/** Methods to use when ordering `FactopdrachtArtikelExclusion`. */
export enum FactopdrachtArtikelExclusionsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Factopdrachtregel = {
  __typename?: 'Factopdrachtregel';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  aantaldec?: Maybe<Scalars['Int']['output']>;
  aantalgeleverd?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereserv?: Maybe<Scalars['BigFloat']['output']>;
  aantalleveren?: Maybe<Scalars['BigFloat']['output']>;
  aantalnaleveren?: Maybe<Scalars['BigFloat']['output']>;
  bonnummer?: Maybe<Scalars['String']['output']>;
  btwcode?: Maybe<Scalars['Int']['output']>;
  btwperc?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cddeelproject?: Maybe<Scalars['String']['output']>;
  cddossier?: Maybe<Scalars['String']['output']>;
  cdgrbdekking?: Maybe<Scalars['String']['output']>;
  cdgrbkostprijs?: Maybe<Scalars['String']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdgrbrekkort?: Maybe<Scalars['String']['output']>;
  cdgrbrekomzvj?: Maybe<Scalars['String']['output']>;
  cdkostenplaats?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  cdstatus?: Maybe<Scalars['String']['output']>;
  cdtermijn?: Maybe<Scalars['Int']['output']>;
  cduursoort?: Maybe<Scalars['String']['output']>;
  cdwerknemer?: Maybe<Scalars['String']['output']>;
  datum?: Maybe<Scalars['Date']['output']>;
  declarabel?: Maybe<Scalars['String']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  factbedragexcl?: Maybe<Scalars['BigFloat']['output']>;
  factbedragexclvj?: Maybe<Scalars['BigFloat']['output']>;
  factbedragincl?: Maybe<Scalars['BigFloat']['output']>;
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Factureeropdracht` that is related to this `Factopdrachtregel`. */
  factureeropdrachtByFactuuropdracht?: Maybe<Factureeropdracht>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  factuurregel?: Maybe<Scalars['Int']['output']>;
  hoofdregel?: Maybe<Scalars['Int']['output']>;
  koppelMetInkoop?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kostprijs?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  nettoomzet?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  projKosten?: Maybe<Scalars['BigFloat']['output']>;
  projKostprijs?: Maybe<Scalars['BigFloat']['output']>;
  projMutsoort?: Maybe<Scalars['String']['output']>;
  projRegelFactureren?: Maybe<Scalars['String']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  statcode?: Maybe<Scalars['String']['output']>;
  tekstmagb?: Maybe<Scalars['String']['output']>;
  voorschot?: Maybe<Scalars['Int']['output']>;
  vvbestand?: Maybe<Scalars['String']['output']>;
  weeknummer?: Maybe<Scalars['Int']['output']>;
};

export type FactopdrachtregelAmount = {
  __typename?: 'FactopdrachtregelAmount';
  amount?: Maybe<Scalars['BigFloat']['output']>;
  amountAfter?: Maybe<Scalars['BigFloat']['output']>;
  amountBefore?: Maybe<Scalars['BigFloat']['output']>;
  amountDp?: Maybe<Scalars['BigFloat']['output']>;
  amountHold?: Maybe<Scalars['BigFloat']['output']>;
  amountHoldDp?: Maybe<Scalars['BigFloat']['output']>;
  amountOpen?: Maybe<Scalars['BigFloat']['output']>;
  amountScheduled?: Maybe<Scalars['BigFloat']['output']>;
  amountUnscheduled?: Maybe<Scalars['BigFloat']['output']>;
  amountWk0?: Maybe<Scalars['BigFloat']['output']>;
  amountWk1?: Maybe<Scalars['BigFloat']['output']>;
  amountWk2?: Maybe<Scalars['BigFloat']['output']>;
  amountWk3?: Maybe<Scalars['BigFloat']['output']>;
  amountWk4?: Maybe<Scalars['BigFloat']['output']>;
  amountWk5?: Maybe<Scalars['BigFloat']['output']>;
  amountWk6?: Maybe<Scalars['BigFloat']['output']>;
  amountWk7?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  factuurnummer?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelAmount` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelAmountCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountAfter` field. */
  amountAfter?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountBefore` field. */
  amountBefore?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountDp` field. */
  amountDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountHold` field. */
  amountHold?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountHoldDp` field. */
  amountHoldDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountOpen` field. */
  amountOpen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountScheduled` field. */
  amountScheduled?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountUnscheduled` field. */
  amountUnscheduled?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk0` field. */
  amountWk0?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk1` field. */
  amountWk1?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk2` field. */
  amountWk2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk3` field. */
  amountWk3?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk4` field. */
  amountWk4?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk5` field. */
  amountWk5?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk6` field. */
  amountWk6?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk7` field. */
  amountWk7?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `FactopdrachtregelAmount` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelAmountFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountAfter` field. */
  amountAfter?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountBefore` field. */
  amountBefore?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountDp` field. */
  amountDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountHold` field. */
  amountHold?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountHoldDp` field. */
  amountHoldDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountOpen` field. */
  amountOpen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountScheduled` field. */
  amountScheduled?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountUnscheduled` field. */
  amountUnscheduled?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk0` field. */
  amountWk0?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk1` field. */
  amountWk1?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk2` field. */
  amountWk2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk3` field. */
  amountWk3?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk4` field. */
  amountWk4?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk5` field. */
  amountWk5?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk6` field. */
  amountWk6?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk7` field. */
  amountWk7?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelAmountFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelAmountFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelAmountFilter>>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

export type FactopdrachtregelAmounts2 = {
  __typename?: 'FactopdrachtregelAmounts2';
  amount?: Maybe<Scalars['BigFloat']['output']>;
  amountAfter?: Maybe<Scalars['BigFloat']['output']>;
  amountBefore?: Maybe<Scalars['BigFloat']['output']>;
  amountDp?: Maybe<Scalars['BigFloat']['output']>;
  amountHold?: Maybe<Scalars['BigFloat']['output']>;
  amountHoldDp?: Maybe<Scalars['BigFloat']['output']>;
  amountOpen?: Maybe<Scalars['BigFloat']['output']>;
  amountScheduled?: Maybe<Scalars['BigFloat']['output']>;
  amountUnscheduled?: Maybe<Scalars['BigFloat']['output']>;
  amountWk0?: Maybe<Scalars['BigFloat']['output']>;
  amountWk1?: Maybe<Scalars['BigFloat']['output']>;
  amountWk2?: Maybe<Scalars['BigFloat']['output']>;
  amountWk3?: Maybe<Scalars['BigFloat']['output']>;
  amountWk4?: Maybe<Scalars['BigFloat']['output']>;
  amountWk5?: Maybe<Scalars['BigFloat']['output']>;
  amountWk6?: Maybe<Scalars['BigFloat']['output']>;
  amountWk7?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  factuurnummer?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelAmounts2` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelAmounts2Condition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountAfter` field. */
  amountAfter?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountBefore` field. */
  amountBefore?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountDp` field. */
  amountDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountHold` field. */
  amountHold?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountHoldDp` field. */
  amountHoldDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountOpen` field. */
  amountOpen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountScheduled` field. */
  amountScheduled?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountUnscheduled` field. */
  amountUnscheduled?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk0` field. */
  amountWk0?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk1` field. */
  amountWk1?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk2` field. */
  amountWk2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk3` field. */
  amountWk3?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk4` field. */
  amountWk4?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk5` field. */
  amountWk5?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk6` field. */
  amountWk6?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountWk7` field. */
  amountWk7?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `FactopdrachtregelAmounts2` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelAmounts2Filter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountAfter` field. */
  amountAfter?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountBefore` field. */
  amountBefore?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountDp` field. */
  amountDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountHold` field. */
  amountHold?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountHoldDp` field. */
  amountHoldDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountOpen` field. */
  amountOpen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountScheduled` field. */
  amountScheduled?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountUnscheduled` field. */
  amountUnscheduled?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk0` field. */
  amountWk0?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk1` field. */
  amountWk1?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk2` field. */
  amountWk2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk3` field. */
  amountWk3?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk4` field. */
  amountWk4?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk5` field. */
  amountWk5?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk6` field. */
  amountWk6?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountWk7` field. */
  amountWk7?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelAmounts2Filter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelAmounts2Filter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelAmounts2Filter>>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `FactopdrachtregelAmounts2` values. */
export type FactopdrachtregelAmounts2SConnection = {
  __typename?: 'FactopdrachtregelAmounts2SConnection';
  /** A list of edges which contains the `FactopdrachtregelAmounts2` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelAmounts2SEdge>;
  /** A list of `FactopdrachtregelAmounts2` objects. */
  nodes: Array<FactopdrachtregelAmounts2>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelAmounts2` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelAmounts2` edge in the connection. */
export type FactopdrachtregelAmounts2SEdge = {
  __typename?: 'FactopdrachtregelAmounts2SEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelAmounts2` at the end of the edge. */
  node: FactopdrachtregelAmounts2;
};

/** Methods to use when ordering `FactopdrachtregelAmounts2`. */
export enum FactopdrachtregelAmounts2SOrderBy {
  AmountAfterAsc = 'AMOUNT_AFTER_ASC',
  AmountAfterDesc = 'AMOUNT_AFTER_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountBeforeAsc = 'AMOUNT_BEFORE_ASC',
  AmountBeforeDesc = 'AMOUNT_BEFORE_DESC',
  AmountDesc = 'AMOUNT_DESC',
  AmountDpAsc = 'AMOUNT_DP_ASC',
  AmountDpDesc = 'AMOUNT_DP_DESC',
  AmountHoldAsc = 'AMOUNT_HOLD_ASC',
  AmountHoldDesc = 'AMOUNT_HOLD_DESC',
  AmountHoldDpAsc = 'AMOUNT_HOLD_DP_ASC',
  AmountHoldDpDesc = 'AMOUNT_HOLD_DP_DESC',
  AmountOpenAsc = 'AMOUNT_OPEN_ASC',
  AmountOpenDesc = 'AMOUNT_OPEN_DESC',
  AmountScheduledAsc = 'AMOUNT_SCHEDULED_ASC',
  AmountScheduledDesc = 'AMOUNT_SCHEDULED_DESC',
  AmountUnscheduledAsc = 'AMOUNT_UNSCHEDULED_ASC',
  AmountUnscheduledDesc = 'AMOUNT_UNSCHEDULED_DESC',
  AmountWk0Asc = 'AMOUNT_WK0_ASC',
  AmountWk0Desc = 'AMOUNT_WK0_DESC',
  AmountWk1Asc = 'AMOUNT_WK1_ASC',
  AmountWk1Desc = 'AMOUNT_WK1_DESC',
  AmountWk2Asc = 'AMOUNT_WK2_ASC',
  AmountWk2Desc = 'AMOUNT_WK2_DESC',
  AmountWk3Asc = 'AMOUNT_WK3_ASC',
  AmountWk3Desc = 'AMOUNT_WK3_DESC',
  AmountWk4Asc = 'AMOUNT_WK4_ASC',
  AmountWk4Desc = 'AMOUNT_WK4_DESC',
  AmountWk5Asc = 'AMOUNT_WK5_ASC',
  AmountWk5Desc = 'AMOUNT_WK5_DESC',
  AmountWk6Asc = 'AMOUNT_WK6_ASC',
  AmountWk6Desc = 'AMOUNT_WK6_DESC',
  AmountWk7Asc = 'AMOUNT_WK7_ASC',
  AmountWk7Desc = 'AMOUNT_WK7_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  FactuurnummerAsc = 'FACTUURNUMMER_ASC',
  FactuurnummerDesc = 'FACTUURNUMMER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  Natural = 'NATURAL',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A connection to a list of `FactopdrachtregelAmount` values. */
export type FactopdrachtregelAmountsConnection = {
  __typename?: 'FactopdrachtregelAmountsConnection';
  /** A list of edges which contains the `FactopdrachtregelAmount` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelAmountsEdge>;
  /** A list of `FactopdrachtregelAmount` objects. */
  nodes: Array<FactopdrachtregelAmount>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelAmount` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelAmount` edge in the connection. */
export type FactopdrachtregelAmountsEdge = {
  __typename?: 'FactopdrachtregelAmountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelAmount` at the end of the edge. */
  node: FactopdrachtregelAmount;
};

/** Methods to use when ordering `FactopdrachtregelAmount`. */
export enum FactopdrachtregelAmountsOrderBy {
  AmountAfterAsc = 'AMOUNT_AFTER_ASC',
  AmountAfterDesc = 'AMOUNT_AFTER_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountBeforeAsc = 'AMOUNT_BEFORE_ASC',
  AmountBeforeDesc = 'AMOUNT_BEFORE_DESC',
  AmountDesc = 'AMOUNT_DESC',
  AmountDpAsc = 'AMOUNT_DP_ASC',
  AmountDpDesc = 'AMOUNT_DP_DESC',
  AmountHoldAsc = 'AMOUNT_HOLD_ASC',
  AmountHoldDesc = 'AMOUNT_HOLD_DESC',
  AmountHoldDpAsc = 'AMOUNT_HOLD_DP_ASC',
  AmountHoldDpDesc = 'AMOUNT_HOLD_DP_DESC',
  AmountOpenAsc = 'AMOUNT_OPEN_ASC',
  AmountOpenDesc = 'AMOUNT_OPEN_DESC',
  AmountScheduledAsc = 'AMOUNT_SCHEDULED_ASC',
  AmountScheduledDesc = 'AMOUNT_SCHEDULED_DESC',
  AmountUnscheduledAsc = 'AMOUNT_UNSCHEDULED_ASC',
  AmountUnscheduledDesc = 'AMOUNT_UNSCHEDULED_DESC',
  AmountWk0Asc = 'AMOUNT_WK0_ASC',
  AmountWk0Desc = 'AMOUNT_WK0_DESC',
  AmountWk1Asc = 'AMOUNT_WK1_ASC',
  AmountWk1Desc = 'AMOUNT_WK1_DESC',
  AmountWk2Asc = 'AMOUNT_WK2_ASC',
  AmountWk2Desc = 'AMOUNT_WK2_DESC',
  AmountWk3Asc = 'AMOUNT_WK3_ASC',
  AmountWk3Desc = 'AMOUNT_WK3_DESC',
  AmountWk4Asc = 'AMOUNT_WK4_ASC',
  AmountWk4Desc = 'AMOUNT_WK4_DESC',
  AmountWk5Asc = 'AMOUNT_WK5_ASC',
  AmountWk5Desc = 'AMOUNT_WK5_DESC',
  AmountWk6Asc = 'AMOUNT_WK6_ASC',
  AmountWk6Desc = 'AMOUNT_WK6_DESC',
  AmountWk7Asc = 'AMOUNT_WK7_ASC',
  AmountWk7Desc = 'AMOUNT_WK7_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  FactuurnummerAsc = 'FACTUURNUMMER_ASC',
  FactuurnummerDesc = 'FACTUURNUMMER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  Natural = 'NATURAL',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/**
 * A condition to be used against `Factopdrachtregel` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aantalgeleverd` field. */
  aantalgeleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalleveren` field. */
  aantalleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalnaleveren` field. */
  aantalnaleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bonnummer` field. */
  bonnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwcode` field. */
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `btwperc` field. */
  btwperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddossier` field. */
  cddossier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbdekking` field. */
  cdgrbdekking?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbkostprijs` field. */
  cdgrbkostprijs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekomzvj` field. */
  cdgrbrekomzvj?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtermijn` field. */
  cdtermijn?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cduursoort` field. */
  cduursoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdwerknemer` field. */
  cdwerknemer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datum` field. */
  datum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `declarabel` field. */
  declarabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factbedragexcl` field. */
  factbedragexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factbedragexclvj` field. */
  factbedragexclvj?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factbedragincl` field. */
  factbedragincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurregel` field. */
  factuurregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `hoofdregel` field. */
  hoofdregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `koppelMetInkoop` field. */
  koppelMetInkoop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kostprijs` field. */
  kostprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nettoomzet` field. */
  nettoomzet?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projKosten` field. */
  projKosten?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projKostprijs` field. */
  projKostprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projRegelFactureren` field. */
  projRegelFactureren?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `statcode` field. */
  statcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tekstmagb` field. */
  tekstmagb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorschot` field. */
  voorschot?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `weeknummer` field. */
  weeknummer?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Factopdrachtregel` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<IntFilter>;
  /** Filter by the object’s `aantalgeleverd` field. */
  aantalgeleverd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalleveren` field. */
  aantalleveren?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalnaleveren` field. */
  aantalnaleveren?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelFilter>>;
  /** Filter by the object’s `bonnummer` field. */
  bonnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwcode` field. */
  btwcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `btwperc` field. */
  btwperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddossier` field. */
  cddossier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbdekking` field. */
  cdgrbdekking?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbkostprijs` field. */
  cdgrbkostprijs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekomzvj` field. */
  cdgrbrekomzvj?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtermijn` field. */
  cdtermijn?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cduursoort` field. */
  cduursoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdwerknemer` field. */
  cdwerknemer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datum` field. */
  datum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `declarabel` field. */
  declarabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factbedragexcl` field. */
  factbedragexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factbedragexclvj` field. */
  factbedragexclvj?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factbedragincl` field. */
  factbedragincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factureeropdrachtByFactuuropdracht` relation. */
  factureeropdrachtByFactuuropdracht?: InputMaybe<FactureeropdrachtFilter>;
  /** A related `factureeropdrachtByFactuuropdracht` exists. */
  factureeropdrachtByFactuuropdrachtExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurregel` field. */
  factuurregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `hoofdregel` field. */
  hoofdregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `koppelMetInkoop` field. */
  koppelMetInkoop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kostprijs` field. */
  kostprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nettoomzet` field. */
  nettoomzet?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelFilter>>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projKosten` field. */
  projKosten?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projKostprijs` field. */
  projKostprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projRegelFactureren` field. */
  projRegelFactureren?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `statcode` field. */
  statcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tekstmagb` field. */
  tekstmagb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorschot` field. */
  voorschot?: InputMaybe<IntFilter>;
  /** Filter by the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `weeknummer` field. */
  weeknummer?: InputMaybe<IntFilter>;
};

export type FactopdrachtregelFilterView = {
  __typename?: 'FactopdrachtregelFilterView';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  aantalbesteldDp?: Maybe<Scalars['BigFloat']['output']>;
  aantalbesteldHold?: Maybe<Scalars['BigFloat']['output']>;
  attention?: Maybe<Scalars['Boolean']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  factuurnummer?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  open?: Maybe<Scalars['Boolean']['output']>;
  overdue?: Maybe<Scalars['Boolean']['output']>;
  totalAantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  unsaved?: Maybe<Scalars['Boolean']['output']>;
  yearWeek?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelFilterView` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelFilterViewCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalbesteldDp` field. */
  aantalbesteldDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalbesteldHold` field. */
  aantalbesteldHold?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `attention` field. */
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `open` field. */
  open?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `overdue` field. */
  overdue?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `totalAantalbesteld` field. */
  totalAantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `unsaved` field. */
  unsaved?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `yearWeek` field. */
  yearWeek?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtregelFilterView` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelFilterViewFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalbesteldDp` field. */
  aantalbesteldDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalbesteldHold` field. */
  aantalbesteldHold?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelFilterViewFilter>>;
  /** Filter by the object’s `attention` field. */
  attention?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelFilterViewFilter>;
  /** Filter by the object’s `open` field. */
  open?: InputMaybe<BooleanFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelFilterViewFilter>>;
  /** Filter by the object’s `overdue` field. */
  overdue?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `totalAantalbesteld` field. */
  totalAantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `unsaved` field. */
  unsaved?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `yearWeek` field. */
  yearWeek?: InputMaybe<IntFilter>;
};

/** A connection to a list of `FactopdrachtregelFilterView` values. */
export type FactopdrachtregelFilterViewsConnection = {
  __typename?: 'FactopdrachtregelFilterViewsConnection';
  /** A list of edges which contains the `FactopdrachtregelFilterView` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelFilterViewsEdge>;
  /** A list of `FactopdrachtregelFilterView` objects. */
  nodes: Array<FactopdrachtregelFilterView>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelFilterView` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelFilterView` edge in the connection. */
export type FactopdrachtregelFilterViewsEdge = {
  __typename?: 'FactopdrachtregelFilterViewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelFilterView` at the end of the edge. */
  node: FactopdrachtregelFilterView;
};

/** Methods to use when ordering `FactopdrachtregelFilterView`. */
export enum FactopdrachtregelFilterViewsOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  AantalbesteldDpAsc = 'AANTALBESTELD_DP_ASC',
  AantalbesteldDpDesc = 'AANTALBESTELD_DP_DESC',
  AantalbesteldHoldAsc = 'AANTALBESTELD_HOLD_ASC',
  AantalbesteldHoldDesc = 'AANTALBESTELD_HOLD_DESC',
  AttentionAsc = 'ATTENTION_ASC',
  AttentionDesc = 'ATTENTION_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  FactuurnummerAsc = 'FACTUURNUMMER_ASC',
  FactuurnummerDesc = 'FACTUURNUMMER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  Natural = 'NATURAL',
  OpenAsc = 'OPEN_ASC',
  OpenDesc = 'OPEN_DESC',
  OverdueAsc = 'OVERDUE_ASC',
  OverdueDesc = 'OVERDUE_DESC',
  TotalAantalbesteldAsc = 'TOTAL_AANTALBESTELD_ASC',
  TotalAantalbesteldDesc = 'TOTAL_AANTALBESTELD_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UnsavedAsc = 'UNSAVED_ASC',
  UnsavedDesc = 'UNSAVED_DESC',
  YearWeekAsc = 'YEAR_WEEK_ASC',
  YearWeekDesc = 'YEAR_WEEK_DESC'
}

export type FactopdrachtregelIndex = {
  __typename?: 'FactopdrachtregelIndex';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  aantalbesteldDp?: Maybe<Scalars['BigFloat']['output']>;
  aantalbesteldHold?: Maybe<Scalars['BigFloat']['output']>;
  attention?: Maybe<Scalars['Boolean']['output']>;
  calcTargetYearWeek?: Maybe<Scalars['Int']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cddossier?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  deliveryDate?: Maybe<Scalars['String']['output']>;
  factbedragexclInt?: Maybe<Scalars['Int']['output']>;
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  factopdrachtregelLineId?: Maybe<Scalars['Int']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  factuurregel?: Maybe<Scalars['Int']['output']>;
  gereserveerdInt?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inkopenInt?: Maybe<Scalars['Int']['output']>;
  minYearWeek?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  overdue?: Maybe<Scalars['Boolean']['output']>;
  poNumber?: Maybe<Scalars['String']['output']>;
  poWeek?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  stockCdartikel?: Maybe<Scalars['String']['output']>;
  targetYearWeek?: Maybe<Scalars['Int']['output']>;
  totaalAantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldAfter?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldBefore?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldWk0?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldWk1?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldWk2?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldWk3?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldWk4?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldWk5?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldWk6?: Maybe<Scalars['BigFloat']['output']>;
  totaalAantalbesteldWk7?: Maybe<Scalars['BigFloat']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  unsaved?: Maybe<Scalars['Boolean']['output']>;
  voorraadInt?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelIndex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelIndexCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalbesteldDp` field. */
  aantalbesteldDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalbesteldHold` field. */
  aantalbesteldHold?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `attention` field. */
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `calcTargetYearWeek` field. */
  calcTargetYearWeek?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddossier` field. */
  cddossier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factbedragexclInt` field. */
  factbedragexclInt?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factopdrachtregelLineId` field. */
  factopdrachtregelLineId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurregel` field. */
  factuurregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `gereserveerdInt` field. */
  gereserveerdInt?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkopenInt` field. */
  inkopenInt?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `minYearWeek` field. */
  minYearWeek?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `overdue` field. */
  overdue?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `poNumber` field. */
  poNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `poWeek` field. */
  poWeek?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stockCdartikel` field. */
  stockCdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `targetYearWeek` field. */
  targetYearWeek?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteld` field. */
  totaalAantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldAfter` field. */
  totaalAantalbesteldAfter?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldBefore` field. */
  totaalAantalbesteldBefore?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldWk0` field. */
  totaalAantalbesteldWk0?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldWk1` field. */
  totaalAantalbesteldWk1?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldWk2` field. */
  totaalAantalbesteldWk2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldWk3` field. */
  totaalAantalbesteldWk3?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldWk4` field. */
  totaalAantalbesteldWk4?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldWk5` field. */
  totaalAantalbesteldWk5?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldWk6` field. */
  totaalAantalbesteldWk6?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totaalAantalbesteldWk7` field. */
  totaalAantalbesteldWk7?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `unsaved` field. */
  unsaved?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `voorraadInt` field. */
  voorraadInt?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtregelIndex` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelIndexFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalbesteldDp` field. */
  aantalbesteldDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalbesteldHold` field. */
  aantalbesteldHold?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelIndexFilter>>;
  /** Filter by the object’s `attention` field. */
  attention?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `calcTargetYearWeek` field. */
  calcTargetYearWeek?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddossier` field. */
  cddossier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factbedragexclInt` field. */
  factbedragexclInt?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factopdrachtregelLineId` field. */
  factopdrachtregelLineId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurregel` field. */
  factuurregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `gereserveerdInt` field. */
  gereserveerdInt?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkopenInt` field. */
  inkopenInt?: InputMaybe<IntFilter>;
  /** Filter by the object’s `minYearWeek` field. */
  minYearWeek?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelIndexFilter>>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `overdue` field. */
  overdue?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `poNumber` field. */
  poNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `poWeek` field. */
  poWeek?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stockCdartikel` field. */
  stockCdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `targetYearWeek` field. */
  targetYearWeek?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totaalAantalbesteld` field. */
  totaalAantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldAfter` field. */
  totaalAantalbesteldAfter?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldBefore` field. */
  totaalAantalbesteldBefore?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldWk0` field. */
  totaalAantalbesteldWk0?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldWk1` field. */
  totaalAantalbesteldWk1?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldWk2` field. */
  totaalAantalbesteldWk2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldWk3` field. */
  totaalAantalbesteldWk3?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldWk4` field. */
  totaalAantalbesteldWk4?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldWk5` field. */
  totaalAantalbesteldWk5?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldWk6` field. */
  totaalAantalbesteldWk6?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totaalAantalbesteldWk7` field. */
  totaalAantalbesteldWk7?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `unsaved` field. */
  unsaved?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `voorraadInt` field. */
  voorraadInt?: InputMaybe<IntFilter>;
};

/** A connection to a list of `FactopdrachtregelIndex` values. */
export type FactopdrachtregelIndicesConnection = {
  __typename?: 'FactopdrachtregelIndicesConnection';
  /** A list of edges which contains the `FactopdrachtregelIndex` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelIndicesEdge>;
  /** A list of `FactopdrachtregelIndex` objects. */
  nodes: Array<FactopdrachtregelIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelIndex` edge in the connection. */
export type FactopdrachtregelIndicesEdge = {
  __typename?: 'FactopdrachtregelIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelIndex` at the end of the edge. */
  node: FactopdrachtregelIndex;
};

/** Methods to use when ordering `FactopdrachtregelIndex`. */
export enum FactopdrachtregelIndicesOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  AantalbesteldDpAsc = 'AANTALBESTELD_DP_ASC',
  AantalbesteldDpDesc = 'AANTALBESTELD_DP_DESC',
  AantalbesteldHoldAsc = 'AANTALBESTELD_HOLD_ASC',
  AantalbesteldHoldDesc = 'AANTALBESTELD_HOLD_DESC',
  AttentionAsc = 'ATTENTION_ASC',
  AttentionDesc = 'ATTENTION_DESC',
  CalcTargetYearWeekAsc = 'CALC_TARGET_YEAR_WEEK_ASC',
  CalcTargetYearWeekDesc = 'CALC_TARGET_YEAR_WEEK_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CddossierAsc = 'CDDOSSIER_ASC',
  CddossierDesc = 'CDDOSSIER_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  DeliveryDateAsc = 'DELIVERY_DATE_ASC',
  DeliveryDateDesc = 'DELIVERY_DATE_DESC',
  FactbedragexclIntAsc = 'FACTBEDRAGEXCL_INT_ASC',
  FactbedragexclIntDesc = 'FACTBEDRAGEXCL_INT_DESC',
  FactopdrachtregelLineIdAsc = 'FACTOPDRACHTREGEL_LINE_ID_ASC',
  FactopdrachtregelLineIdDesc = 'FACTOPDRACHTREGEL_LINE_ID_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FactuurregelAsc = 'FACTUURREGEL_ASC',
  FactuurregelDesc = 'FACTUURREGEL_DESC',
  GereserveerdIntAsc = 'GERESERVEERD_INT_ASC',
  GereserveerdIntDesc = 'GERESERVEERD_INT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InkopenIntAsc = 'INKOPEN_INT_ASC',
  InkopenIntDesc = 'INKOPEN_INT_DESC',
  MinYearWeekAsc = 'MIN_YEAR_WEEK_ASC',
  MinYearWeekDesc = 'MIN_YEAR_WEEK_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  OverdueAsc = 'OVERDUE_ASC',
  OverdueDesc = 'OVERDUE_DESC',
  PoNumberAsc = 'PO_NUMBER_ASC',
  PoNumberDesc = 'PO_NUMBER_DESC',
  PoWeekAsc = 'PO_WEEK_ASC',
  PoWeekDesc = 'PO_WEEK_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StockCdartikelAsc = 'STOCK_CDARTIKEL_ASC',
  StockCdartikelDesc = 'STOCK_CDARTIKEL_DESC',
  TargetYearWeekAsc = 'TARGET_YEAR_WEEK_ASC',
  TargetYearWeekDesc = 'TARGET_YEAR_WEEK_DESC',
  TotaalAantalbesteldAfterAsc = 'TOTAAL_AANTALBESTELD_AFTER_ASC',
  TotaalAantalbesteldAfterDesc = 'TOTAAL_AANTALBESTELD_AFTER_DESC',
  TotaalAantalbesteldAsc = 'TOTAAL_AANTALBESTELD_ASC',
  TotaalAantalbesteldBeforeAsc = 'TOTAAL_AANTALBESTELD_BEFORE_ASC',
  TotaalAantalbesteldBeforeDesc = 'TOTAAL_AANTALBESTELD_BEFORE_DESC',
  TotaalAantalbesteldDesc = 'TOTAAL_AANTALBESTELD_DESC',
  TotaalAantalbesteldWk0Asc = 'TOTAAL_AANTALBESTELD_WK0_ASC',
  TotaalAantalbesteldWk0Desc = 'TOTAAL_AANTALBESTELD_WK0_DESC',
  TotaalAantalbesteldWk1Asc = 'TOTAAL_AANTALBESTELD_WK1_ASC',
  TotaalAantalbesteldWk1Desc = 'TOTAAL_AANTALBESTELD_WK1_DESC',
  TotaalAantalbesteldWk2Asc = 'TOTAAL_AANTALBESTELD_WK2_ASC',
  TotaalAantalbesteldWk2Desc = 'TOTAAL_AANTALBESTELD_WK2_DESC',
  TotaalAantalbesteldWk3Asc = 'TOTAAL_AANTALBESTELD_WK3_ASC',
  TotaalAantalbesteldWk3Desc = 'TOTAAL_AANTALBESTELD_WK3_DESC',
  TotaalAantalbesteldWk4Asc = 'TOTAAL_AANTALBESTELD_WK4_ASC',
  TotaalAantalbesteldWk4Desc = 'TOTAAL_AANTALBESTELD_WK4_DESC',
  TotaalAantalbesteldWk5Asc = 'TOTAAL_AANTALBESTELD_WK5_ASC',
  TotaalAantalbesteldWk5Desc = 'TOTAAL_AANTALBESTELD_WK5_DESC',
  TotaalAantalbesteldWk6Asc = 'TOTAAL_AANTALBESTELD_WK6_ASC',
  TotaalAantalbesteldWk6Desc = 'TOTAAL_AANTALBESTELD_WK6_DESC',
  TotaalAantalbesteldWk7Asc = 'TOTAAL_AANTALBESTELD_WK7_ASC',
  TotaalAantalbesteldWk7Desc = 'TOTAAL_AANTALBESTELD_WK7_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UnsavedAsc = 'UNSAVED_ASC',
  UnsavedDesc = 'UNSAVED_DESC',
  VoorraadIntAsc = 'VOORRAAD_INT_ASC',
  VoorraadIntDesc = 'VOORRAAD_INT_DESC'
}

export type FactopdrachtregelLine = Node & {
  __typename?: 'FactopdrachtregelLine';
  aantalbesteldDp?: Maybe<Scalars['BigFloat']['output']>;
  aantalbesteldHold?: Maybe<Scalars['BigFloat']['output']>;
  attention?: Maybe<Scalars['Boolean']['output']>;
  factopdrRglGuid: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  poNumber?: Maybe<Scalars['String']['output']>;
  poWeek?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  targetDateOld?: Maybe<Scalars['Date']['output']>;
  targetYearWeek?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelLine` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineCondition = {
  /** Checks for equality with the object’s `aantalbesteldDp` field. */
  aantalbesteldDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalbesteldHold` field. */
  aantalbesteldHold?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `attention` field. */
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `poNumber` field. */
  poNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `poWeek` field. */
  poWeek?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `targetDateOld` field. */
  targetDateOld?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `targetYearWeek` field. */
  targetYearWeek?: InputMaybe<Scalars['Int']['input']>;
};

export type FactopdrachtregelLineDate = Node & {
  __typename?: 'FactopdrachtregelLineDate';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  factopdrRglGuid: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  schedule: Scalars['String']['output'];
};

/**
 * A condition to be used against `FactopdrachtregelLineDate` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineDateCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `schedule` field. */
  schedule?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `FactopdrachtregelLineDate` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineDateFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineDateFilter>>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineDateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineDateFilter>>;
  /** Filter by the object’s `schedule` field. */
  schedule?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `FactopdrachtregelLineDate` */
export type FactopdrachtregelLineDateInput = {
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  factopdrRglGuid: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  schedule: Scalars['String']['input'];
};

/** Represents an update to a `FactopdrachtregelLineDate`. Fields that are set will be updated. */
export type FactopdrachtregelLineDatePatch = {
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  schedule?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `FactopdrachtregelLineDate` values. */
export type FactopdrachtregelLineDatesConnection = {
  __typename?: 'FactopdrachtregelLineDatesConnection';
  /** A list of edges which contains the `FactopdrachtregelLineDate` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLineDatesEdge>;
  /** A list of `FactopdrachtregelLineDate` objects. */
  nodes: Array<FactopdrachtregelLineDate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLineDate` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLineDate` edge in the connection. */
export type FactopdrachtregelLineDatesEdge = {
  __typename?: 'FactopdrachtregelLineDatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLineDate` at the end of the edge. */
  node: FactopdrachtregelLineDate;
};

export type FactopdrachtregelLineDatesIndex = {
  __typename?: 'FactopdrachtregelLineDatesIndex';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  schedule?: Maybe<Scalars['String']['output']>;
  scheduleOverdue?: Maybe<Scalars['String']['output']>;
  scheduleUnderdue?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelLineDatesIndex` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineDatesIndexCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `schedule` field. */
  schedule?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `scheduleOverdue` field. */
  scheduleOverdue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `scheduleUnderdue` field. */
  scheduleUnderdue?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `FactopdrachtregelLineDatesIndex` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineDatesIndexFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineDatesIndexFilter>>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineDatesIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineDatesIndexFilter>>;
  /** Filter by the object’s `schedule` field. */
  schedule?: InputMaybe<StringFilter>;
  /** Filter by the object’s `scheduleOverdue` field. */
  scheduleOverdue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `scheduleUnderdue` field. */
  scheduleUnderdue?: InputMaybe<StringFilter>;
};

/** A connection to a list of `FactopdrachtregelLineDatesIndex` values. */
export type FactopdrachtregelLineDatesIndicesConnection = {
  __typename?: 'FactopdrachtregelLineDatesIndicesConnection';
  /** A list of edges which contains the `FactopdrachtregelLineDatesIndex` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLineDatesIndicesEdge>;
  /** A list of `FactopdrachtregelLineDatesIndex` objects. */
  nodes: Array<FactopdrachtregelLineDatesIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLineDatesIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLineDatesIndex` edge in the connection. */
export type FactopdrachtregelLineDatesIndicesEdge = {
  __typename?: 'FactopdrachtregelLineDatesIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLineDatesIndex` at the end of the edge. */
  node: FactopdrachtregelLineDatesIndex;
};

/** Methods to use when ordering `FactopdrachtregelLineDatesIndex`. */
export enum FactopdrachtregelLineDatesIndicesOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  ScheduleAsc = 'SCHEDULE_ASC',
  ScheduleDesc = 'SCHEDULE_DESC',
  ScheduleOverdueAsc = 'SCHEDULE_OVERDUE_ASC',
  ScheduleOverdueDesc = 'SCHEDULE_OVERDUE_DESC',
  ScheduleUnderdueAsc = 'SCHEDULE_UNDERDUE_ASC',
  ScheduleUnderdueDesc = 'SCHEDULE_UNDERDUE_DESC'
}

/** Methods to use when ordering `FactopdrachtregelLineDate`. */
export enum FactopdrachtregelLineDatesOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScheduleAsc = 'SCHEDULE_ASC',
  ScheduleDesc = 'SCHEDULE_DESC'
}

export type FactopdrachtregelLineDatesTotal = {
  __typename?: 'FactopdrachtregelLineDatesTotal';
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  totalTurnoverDp?: Maybe<Scalars['Int']['output']>;
  totalTurnoverHold?: Maybe<Scalars['Int']['output']>;
  totalTurnoverOverdue?: Maybe<Scalars['Int']['output']>;
  totalTurnoverPo?: Maybe<Scalars['Int']['output']>;
  totalTurnoverSc?: Maybe<Scalars['Int']['output']>;
  totalTurnoverScheduled?: Maybe<Scalars['Int']['output']>;
  totalTurnoverUnderdue?: Maybe<Scalars['Int']['output']>;
  totalTurnoverUnscheduled?: Maybe<Scalars['Int']['output']>;
  totalTurnoverWeek1?: Maybe<Scalars['Int']['output']>;
  totalTurnoverWeek2?: Maybe<Scalars['Int']['output']>;
  totalTurnoverWeek3?: Maybe<Scalars['Int']['output']>;
  totalTurnoverWeek4?: Maybe<Scalars['Int']['output']>;
  totalTurnoverWeek5?: Maybe<Scalars['Int']['output']>;
  totalTurnoverWeek6?: Maybe<Scalars['Int']['output']>;
  totalTurnoverWeek7?: Maybe<Scalars['Int']['output']>;
  totalTurnoverWeek8?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelLineDatesTotal` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineDatesTotalCondition = {
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `totalTurnoverDp` field. */
  totalTurnoverDp?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverHold` field. */
  totalTurnoverHold?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverOverdue` field. */
  totalTurnoverOverdue?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverPo` field. */
  totalTurnoverPo?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverSc` field. */
  totalTurnoverSc?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverScheduled` field. */
  totalTurnoverScheduled?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverUnderdue` field. */
  totalTurnoverUnderdue?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverUnscheduled` field. */
  totalTurnoverUnscheduled?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverWeek1` field. */
  totalTurnoverWeek1?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverWeek2` field. */
  totalTurnoverWeek2?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverWeek3` field. */
  totalTurnoverWeek3?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverWeek4` field. */
  totalTurnoverWeek4?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverWeek5` field. */
  totalTurnoverWeek5?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverWeek6` field. */
  totalTurnoverWeek6?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverWeek7` field. */
  totalTurnoverWeek7?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalTurnoverWeek8` field. */
  totalTurnoverWeek8?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtregelLineDatesTotal` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineDatesTotalFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineDatesTotalFilter>>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineDatesTotalFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineDatesTotalFilter>>;
  /** Filter by the object’s `totalTurnoverDp` field. */
  totalTurnoverDp?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverHold` field. */
  totalTurnoverHold?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverOverdue` field. */
  totalTurnoverOverdue?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverPo` field. */
  totalTurnoverPo?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverSc` field. */
  totalTurnoverSc?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverScheduled` field. */
  totalTurnoverScheduled?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverUnderdue` field. */
  totalTurnoverUnderdue?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverUnscheduled` field. */
  totalTurnoverUnscheduled?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverWeek1` field. */
  totalTurnoverWeek1?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverWeek2` field. */
  totalTurnoverWeek2?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverWeek3` field. */
  totalTurnoverWeek3?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverWeek4` field. */
  totalTurnoverWeek4?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverWeek5` field. */
  totalTurnoverWeek5?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverWeek6` field. */
  totalTurnoverWeek6?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverWeek7` field. */
  totalTurnoverWeek7?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalTurnoverWeek8` field. */
  totalTurnoverWeek8?: InputMaybe<IntFilter>;
};

export type FactopdrachtregelLineDatesTotals2 = {
  __typename?: 'FactopdrachtregelLineDatesTotals2';
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  totalAantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelLineDatesTotals2` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineDatesTotals2Condition = {
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `totalAantalbesteld` field. */
  totalAantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `FactopdrachtregelLineDatesTotals2` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineDatesTotals2Filter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineDatesTotals2Filter>>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineDatesTotals2Filter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineDatesTotals2Filter>>;
  /** Filter by the object’s `totalAantalbesteld` field. */
  totalAantalbesteld?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `FactopdrachtregelLineDatesTotals2` values. */
export type FactopdrachtregelLineDatesTotals2SConnection = {
  __typename?: 'FactopdrachtregelLineDatesTotals2SConnection';
  /** A list of edges which contains the `FactopdrachtregelLineDatesTotals2` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLineDatesTotals2SEdge>;
  /** A list of `FactopdrachtregelLineDatesTotals2` objects. */
  nodes: Array<FactopdrachtregelLineDatesTotals2>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLineDatesTotals2` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLineDatesTotals2` edge in the connection. */
export type FactopdrachtregelLineDatesTotals2SEdge = {
  __typename?: 'FactopdrachtregelLineDatesTotals2SEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLineDatesTotals2` at the end of the edge. */
  node: FactopdrachtregelLineDatesTotals2;
};

/** Methods to use when ordering `FactopdrachtregelLineDatesTotals2`. */
export enum FactopdrachtregelLineDatesTotals2SOrderBy {
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  Natural = 'NATURAL',
  TotalAantalbesteldAsc = 'TOTAL_AANTALBESTELD_ASC',
  TotalAantalbesteldDesc = 'TOTAL_AANTALBESTELD_DESC'
}

/** A connection to a list of `FactopdrachtregelLineDatesTotal` values. */
export type FactopdrachtregelLineDatesTotalsConnection = {
  __typename?: 'FactopdrachtregelLineDatesTotalsConnection';
  /** A list of edges which contains the `FactopdrachtregelLineDatesTotal` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLineDatesTotalsEdge>;
  /** A list of `FactopdrachtregelLineDatesTotal` objects. */
  nodes: Array<FactopdrachtregelLineDatesTotal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLineDatesTotal` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLineDatesTotal` edge in the connection. */
export type FactopdrachtregelLineDatesTotalsEdge = {
  __typename?: 'FactopdrachtregelLineDatesTotalsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLineDatesTotal` at the end of the edge. */
  node: FactopdrachtregelLineDatesTotal;
};

/** Methods to use when ordering `FactopdrachtregelLineDatesTotal`. */
export enum FactopdrachtregelLineDatesTotalsOrderBy {
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  Natural = 'NATURAL',
  TotalTurnoverDpAsc = 'TOTAL_TURNOVER_DP_ASC',
  TotalTurnoverDpDesc = 'TOTAL_TURNOVER_DP_DESC',
  TotalTurnoverHoldAsc = 'TOTAL_TURNOVER_HOLD_ASC',
  TotalTurnoverHoldDesc = 'TOTAL_TURNOVER_HOLD_DESC',
  TotalTurnoverOverdueAsc = 'TOTAL_TURNOVER_OVERDUE_ASC',
  TotalTurnoverOverdueDesc = 'TOTAL_TURNOVER_OVERDUE_DESC',
  TotalTurnoverPoAsc = 'TOTAL_TURNOVER_PO_ASC',
  TotalTurnoverPoDesc = 'TOTAL_TURNOVER_PO_DESC',
  TotalTurnoverScheduledAsc = 'TOTAL_TURNOVER_SCHEDULED_ASC',
  TotalTurnoverScheduledDesc = 'TOTAL_TURNOVER_SCHEDULED_DESC',
  TotalTurnoverScAsc = 'TOTAL_TURNOVER_SC_ASC',
  TotalTurnoverScDesc = 'TOTAL_TURNOVER_SC_DESC',
  TotalTurnoverUnderdueAsc = 'TOTAL_TURNOVER_UNDERDUE_ASC',
  TotalTurnoverUnderdueDesc = 'TOTAL_TURNOVER_UNDERDUE_DESC',
  TotalTurnoverUnscheduledAsc = 'TOTAL_TURNOVER_UNSCHEDULED_ASC',
  TotalTurnoverUnscheduledDesc = 'TOTAL_TURNOVER_UNSCHEDULED_DESC',
  TotalTurnoverWeek_1Asc = 'TOTAL_TURNOVER_WEEK_1_ASC',
  TotalTurnoverWeek_1Desc = 'TOTAL_TURNOVER_WEEK_1_DESC',
  TotalTurnoverWeek_2Asc = 'TOTAL_TURNOVER_WEEK_2_ASC',
  TotalTurnoverWeek_2Desc = 'TOTAL_TURNOVER_WEEK_2_DESC',
  TotalTurnoverWeek_3Asc = 'TOTAL_TURNOVER_WEEK_3_ASC',
  TotalTurnoverWeek_3Desc = 'TOTAL_TURNOVER_WEEK_3_DESC',
  TotalTurnoverWeek_4Asc = 'TOTAL_TURNOVER_WEEK_4_ASC',
  TotalTurnoverWeek_4Desc = 'TOTAL_TURNOVER_WEEK_4_DESC',
  TotalTurnoverWeek_5Asc = 'TOTAL_TURNOVER_WEEK_5_ASC',
  TotalTurnoverWeek_5Desc = 'TOTAL_TURNOVER_WEEK_5_DESC',
  TotalTurnoverWeek_6Asc = 'TOTAL_TURNOVER_WEEK_6_ASC',
  TotalTurnoverWeek_6Desc = 'TOTAL_TURNOVER_WEEK_6_DESC',
  TotalTurnoverWeek_7Asc = 'TOTAL_TURNOVER_WEEK_7_ASC',
  TotalTurnoverWeek_7Desc = 'TOTAL_TURNOVER_WEEK_7_DESC',
  TotalTurnoverWeek_8Asc = 'TOTAL_TURNOVER_WEEK_8_ASC',
  TotalTurnoverWeek_8Desc = 'TOTAL_TURNOVER_WEEK_8_DESC'
}

/** A filter to be used against `FactopdrachtregelLine` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineFilter = {
  /** Filter by the object’s `aantalbesteldDp` field. */
  aantalbesteldDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalbesteldHold` field. */
  aantalbesteldHold?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineFilter>>;
  /** Filter by the object’s `attention` field. */
  attention?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineFilter>>;
  /** Filter by the object’s `poNumber` field. */
  poNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `poWeek` field. */
  poWeek?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `targetDateOld` field. */
  targetDateOld?: InputMaybe<DateFilter>;
  /** Filter by the object’s `targetYearWeek` field. */
  targetYearWeek?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `FactopdrachtregelLine` */
export type FactopdrachtregelLineInput = {
  aantalbesteldDp?: InputMaybe<Scalars['BigFloat']['input']>;
  aantalbesteldHold?: InputMaybe<Scalars['BigFloat']['input']>;
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  factopdrRglGuid: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  poNumber?: InputMaybe<Scalars['String']['input']>;
  poWeek?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  targetDateOld?: InputMaybe<Scalars['Date']['input']>;
  targetYearWeek?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `FactopdrachtregelLine`. Fields that are set will be updated. */
export type FactopdrachtregelLinePatch = {
  aantalbesteldDp?: InputMaybe<Scalars['BigFloat']['input']>;
  aantalbesteldHold?: InputMaybe<Scalars['BigFloat']['input']>;
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  poNumber?: InputMaybe<Scalars['String']['input']>;
  poWeek?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  targetDateOld?: InputMaybe<Scalars['Date']['input']>;
  targetYearWeek?: InputMaybe<Scalars['Int']['input']>;
};

export type FactopdrachtregelLineRemark = Node & {
  __typename?: 'FactopdrachtregelLineRemark';
  attention?: Maybe<Scalars['Boolean']['output']>;
  factopdrachtregelLineId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  remark: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `FactopdrachtregelLineRemark`. */
  userByUserId?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelLineRemark` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineRemarkCondition = {
  /** Checks for equality with the object’s `attention` field. */
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `factopdrachtregelLineId` field. */
  factopdrachtregelLineId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remark` field. */
  remark?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtregelLineRemark` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineRemarkFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineRemarkFilter>>;
  /** Filter by the object’s `attention` field. */
  attention?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `factopdrachtregelLineId` field. */
  factopdrachtregelLineId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineRemarkFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineRemarkFilter>>;
  /** Filter by the object’s `remark` field. */
  remark?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** A related `userByUserId` exists. */
  userByUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `FactopdrachtregelLineRemark` */
export type FactopdrachtregelLineRemarkInput = {
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  factopdrachtregelLineId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  remark: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `FactopdrachtregelLineRemark`. Fields that are set will be updated. */
export type FactopdrachtregelLineRemarkPatch = {
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  factopdrachtregelLineId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  remark?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `FactopdrachtregelLineRemark` values. */
export type FactopdrachtregelLineRemarksConnection = {
  __typename?: 'FactopdrachtregelLineRemarksConnection';
  /** A list of edges which contains the `FactopdrachtregelLineRemark` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLineRemarksEdge>;
  /** A list of `FactopdrachtregelLineRemark` objects. */
  nodes: Array<FactopdrachtregelLineRemark>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLineRemark` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLineRemark` edge in the connection. */
export type FactopdrachtregelLineRemarksEdge = {
  __typename?: 'FactopdrachtregelLineRemarksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLineRemark` at the end of the edge. */
  node: FactopdrachtregelLineRemark;
};

export type FactopdrachtregelLineRemarksIndex = {
  __typename?: 'FactopdrachtregelLineRemarksIndex';
  attention?: Maybe<Scalars['Boolean']['output']>;
  factopdrachtregelId?: Maybe<Scalars['String']['output']>;
  factopdrachtregelLineRemarkId?: Maybe<Scalars['Int']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  remark?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelLineRemarksIndex` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineRemarksIndexCondition = {
  /** Checks for equality with the object’s `attention` field. */
  attention?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `factopdrachtregelId` field. */
  factopdrachtregelId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factopdrachtregelLineRemarkId` field. */
  factopdrachtregelLineRemarkId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `remark` field. */
  remark?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtregelLineRemarksIndex` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineRemarksIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineRemarksIndexFilter>>;
  /** Filter by the object’s `attention` field. */
  attention?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `factopdrachtregelId` field. */
  factopdrachtregelId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factopdrachtregelLineRemarkId` field. */
  factopdrachtregelLineRemarkId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineRemarksIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineRemarksIndexFilter>>;
  /** Filter by the object’s `remark` field. */
  remark?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `FactopdrachtregelLineRemarksIndex` values. */
export type FactopdrachtregelLineRemarksIndicesConnection = {
  __typename?: 'FactopdrachtregelLineRemarksIndicesConnection';
  /** A list of edges which contains the `FactopdrachtregelLineRemarksIndex` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLineRemarksIndicesEdge>;
  /** A list of `FactopdrachtregelLineRemarksIndex` objects. */
  nodes: Array<FactopdrachtregelLineRemarksIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLineRemarksIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLineRemarksIndex` edge in the connection. */
export type FactopdrachtregelLineRemarksIndicesEdge = {
  __typename?: 'FactopdrachtregelLineRemarksIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLineRemarksIndex` at the end of the edge. */
  node: FactopdrachtregelLineRemarksIndex;
};

/** Methods to use when ordering `FactopdrachtregelLineRemarksIndex`. */
export enum FactopdrachtregelLineRemarksIndicesOrderBy {
  AttentionAsc = 'ATTENTION_ASC',
  AttentionDesc = 'ATTENTION_DESC',
  FactopdrachtregelIdAsc = 'FACTOPDRACHTREGEL_ID_ASC',
  FactopdrachtregelIdDesc = 'FACTOPDRACHTREGEL_ID_DESC',
  FactopdrachtregelLineRemarkIdAsc = 'FACTOPDRACHTREGEL_LINE_REMARK_ID_ASC',
  FactopdrachtregelLineRemarkIdDesc = 'FACTOPDRACHTREGEL_LINE_REMARK_ID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  Natural = 'NATURAL',
  RemarkAsc = 'REMARK_ASC',
  RemarkDesc = 'REMARK_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Methods to use when ordering `FactopdrachtregelLineRemark`. */
export enum FactopdrachtregelLineRemarksOrderBy {
  AttentionAsc = 'ATTENTION_ASC',
  AttentionDesc = 'ATTENTION_DESC',
  FactopdrachtregelLineIdAsc = 'FACTOPDRACHTREGEL_LINE_ID_ASC',
  FactopdrachtregelLineIdDesc = 'FACTOPDRACHTREGEL_LINE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarkAsc = 'REMARK_ASC',
  RemarkDesc = 'REMARK_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type FactopdrachtregelLineWeek = {
  __typename?: 'FactopdrachtregelLineWeek';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  factopdrachtregelLineId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  yearWeek: Scalars['Int']['output'];
};

/**
 * A condition to be used against `FactopdrachtregelLineWeek` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineWeekCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factopdrachtregelLineId` field. */
  factopdrachtregelLineId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `yearWeek` field. */
  yearWeek?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtregelLineWeek` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineWeekFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineWeekFilter>>;
  /** Filter by the object’s `factopdrachtregelLineId` field. */
  factopdrachtregelLineId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineWeekFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineWeekFilter>>;
  /** Filter by the object’s `yearWeek` field. */
  yearWeek?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `FactopdrachtregelLineWeek` */
export type FactopdrachtregelLineWeekInput = {
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  factopdrachtregelLineId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  yearWeek: Scalars['Int']['input'];
};

/** A connection to a list of `FactopdrachtregelLineWeek` values. */
export type FactopdrachtregelLineWeeksConnection = {
  __typename?: 'FactopdrachtregelLineWeeksConnection';
  /** A list of edges which contains the `FactopdrachtregelLineWeek` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLineWeeksEdge>;
  /** A list of `FactopdrachtregelLineWeek` objects. */
  nodes: Array<FactopdrachtregelLineWeek>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLineWeek` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLineWeek` edge in the connection. */
export type FactopdrachtregelLineWeeksEdge = {
  __typename?: 'FactopdrachtregelLineWeeksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLineWeek` at the end of the edge. */
  node: FactopdrachtregelLineWeek;
};

export type FactopdrachtregelLineWeeksIndex = {
  __typename?: 'FactopdrachtregelLineWeeksIndex';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  factopdrachtregelId?: Maybe<Scalars['String']['output']>;
  factopdrachtregelLineWeekId?: Maybe<Scalars['Int']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  yearWeek?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelLineWeeksIndex` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelLineWeeksIndexCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factopdrachtregelId` field. */
  factopdrachtregelId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factopdrachtregelLineWeekId` field. */
  factopdrachtregelLineWeekId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `yearWeek` field. */
  yearWeek?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtregelLineWeeksIndex` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelLineWeeksIndexFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelLineWeeksIndexFilter>>;
  /** Filter by the object’s `factopdrachtregelId` field. */
  factopdrachtregelId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factopdrachtregelLineWeekId` field. */
  factopdrachtregelLineWeekId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelLineWeeksIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelLineWeeksIndexFilter>>;
  /** Filter by the object’s `yearWeek` field. */
  yearWeek?: InputMaybe<IntFilter>;
};

/** A connection to a list of `FactopdrachtregelLineWeeksIndex` values. */
export type FactopdrachtregelLineWeeksIndicesConnection = {
  __typename?: 'FactopdrachtregelLineWeeksIndicesConnection';
  /** A list of edges which contains the `FactopdrachtregelLineWeeksIndex` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLineWeeksIndicesEdge>;
  /** A list of `FactopdrachtregelLineWeeksIndex` objects. */
  nodes: Array<FactopdrachtregelLineWeeksIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLineWeeksIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLineWeeksIndex` edge in the connection. */
export type FactopdrachtregelLineWeeksIndicesEdge = {
  __typename?: 'FactopdrachtregelLineWeeksIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLineWeeksIndex` at the end of the edge. */
  node: FactopdrachtregelLineWeeksIndex;
};

/** Methods to use when ordering `FactopdrachtregelLineWeeksIndex`. */
export enum FactopdrachtregelLineWeeksIndicesOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  FactopdrachtregelIdAsc = 'FACTOPDRACHTREGEL_ID_ASC',
  FactopdrachtregelIdDesc = 'FACTOPDRACHTREGEL_ID_DESC',
  FactopdrachtregelLineWeekIdAsc = 'FACTOPDRACHTREGEL_LINE_WEEK_ID_ASC',
  FactopdrachtregelLineWeekIdDesc = 'FACTOPDRACHTREGEL_LINE_WEEK_ID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  Natural = 'NATURAL',
  YearWeekAsc = 'YEAR_WEEK_ASC',
  YearWeekDesc = 'YEAR_WEEK_DESC'
}

/** Methods to use when ordering `FactopdrachtregelLineWeek`. */
export enum FactopdrachtregelLineWeeksOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  FactopdrachtregelLineIdAsc = 'FACTOPDRACHTREGEL_LINE_ID_ASC',
  FactopdrachtregelLineIdDesc = 'FACTOPDRACHTREGEL_LINE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  YearWeekAsc = 'YEAR_WEEK_ASC',
  YearWeekDesc = 'YEAR_WEEK_DESC'
}

/** A connection to a list of `FactopdrachtregelLine` values. */
export type FactopdrachtregelLinesConnection = {
  __typename?: 'FactopdrachtregelLinesConnection';
  /** A list of edges which contains the `FactopdrachtregelLine` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelLinesEdge>;
  /** A list of `FactopdrachtregelLine` objects. */
  nodes: Array<FactopdrachtregelLine>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelLine` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelLine` edge in the connection. */
export type FactopdrachtregelLinesEdge = {
  __typename?: 'FactopdrachtregelLinesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelLine` at the end of the edge. */
  node: FactopdrachtregelLine;
};

/** Methods to use when ordering `FactopdrachtregelLine`. */
export enum FactopdrachtregelLinesOrderBy {
  AantalbesteldDpAsc = 'AANTALBESTELD_DP_ASC',
  AantalbesteldDpDesc = 'AANTALBESTELD_DP_DESC',
  AantalbesteldHoldAsc = 'AANTALBESTELD_HOLD_ASC',
  AantalbesteldHoldDesc = 'AANTALBESTELD_HOLD_DESC',
  AttentionAsc = 'ATTENTION_ASC',
  AttentionDesc = 'ATTENTION_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PoNumberAsc = 'PO_NUMBER_ASC',
  PoNumberDesc = 'PO_NUMBER_DESC',
  PoWeekAsc = 'PO_WEEK_ASC',
  PoWeekDesc = 'PO_WEEK_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TargetDateOldAsc = 'TARGET_DATE_OLD_ASC',
  TargetDateOldDesc = 'TARGET_DATE_OLD_DESC',
  TargetYearWeekAsc = 'TARGET_YEAR_WEEK_ASC',
  TargetYearWeekDesc = 'TARGET_YEAR_WEEK_DESC'
}

export type FactopdrachtregelMv = {
  __typename?: 'FactopdrachtregelMv';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  aantaldec?: Maybe<Scalars['Int']['output']>;
  aantalgeleverd?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereserv?: Maybe<Scalars['BigFloat']['output']>;
  aantalleveren?: Maybe<Scalars['BigFloat']['output']>;
  aantalnaleveren?: Maybe<Scalars['BigFloat']['output']>;
  bonnummer?: Maybe<Scalars['String']['output']>;
  btwcode?: Maybe<Scalars['Int']['output']>;
  btwperc?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cddeelproject?: Maybe<Scalars['String']['output']>;
  cddossier?: Maybe<Scalars['String']['output']>;
  cdgrbdekking?: Maybe<Scalars['String']['output']>;
  cdgrbkostprijs?: Maybe<Scalars['String']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdgrbrekkort?: Maybe<Scalars['String']['output']>;
  cdgrbrekomzvj?: Maybe<Scalars['String']['output']>;
  cdkostenplaats?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  cdstatus?: Maybe<Scalars['String']['output']>;
  cdtermijn?: Maybe<Scalars['Int']['output']>;
  cduursoort?: Maybe<Scalars['String']['output']>;
  cdwerknemer?: Maybe<Scalars['String']['output']>;
  datum?: Maybe<Scalars['Date']['output']>;
  declarabel?: Maybe<Scalars['String']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  factbedragexcl?: Maybe<Scalars['BigFloat']['output']>;
  factbedragexclvj?: Maybe<Scalars['BigFloat']['output']>;
  factbedragincl?: Maybe<Scalars['BigFloat']['output']>;
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  factuurregel?: Maybe<Scalars['Int']['output']>;
  hoofdregel?: Maybe<Scalars['Int']['output']>;
  koppelMetInkoop?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kostprijs?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  nettoomzet?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  projKosten?: Maybe<Scalars['BigFloat']['output']>;
  projKostprijs?: Maybe<Scalars['BigFloat']['output']>;
  projMutsoort?: Maybe<Scalars['String']['output']>;
  projRegelFactureren?: Maybe<Scalars['String']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  statcode?: Maybe<Scalars['String']['output']>;
  tekstmagb?: Maybe<Scalars['String']['output']>;
  voorschot?: Maybe<Scalars['Int']['output']>;
  vvbestand?: Maybe<Scalars['String']['output']>;
  weeknummer?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelMv` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelMvCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aantalgeleverd` field. */
  aantalgeleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalleveren` field. */
  aantalleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalnaleveren` field. */
  aantalnaleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bonnummer` field. */
  bonnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwcode` field. */
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `btwperc` field. */
  btwperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddossier` field. */
  cddossier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbdekking` field. */
  cdgrbdekking?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbkostprijs` field. */
  cdgrbkostprijs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekomzvj` field. */
  cdgrbrekomzvj?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtermijn` field. */
  cdtermijn?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cduursoort` field. */
  cduursoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdwerknemer` field. */
  cdwerknemer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datum` field. */
  datum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `declarabel` field. */
  declarabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factbedragexcl` field. */
  factbedragexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factbedragexclvj` field. */
  factbedragexclvj?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factbedragincl` field. */
  factbedragincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurregel` field. */
  factuurregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `hoofdregel` field. */
  hoofdregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `koppelMetInkoop` field. */
  koppelMetInkoop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kostprijs` field. */
  kostprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nettoomzet` field. */
  nettoomzet?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projKosten` field. */
  projKosten?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projKostprijs` field. */
  projKostprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projRegelFactureren` field. */
  projRegelFactureren?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `statcode` field. */
  statcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tekstmagb` field. */
  tekstmagb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorschot` field. */
  voorschot?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `weeknummer` field. */
  weeknummer?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FactopdrachtregelMv` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelMvFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<IntFilter>;
  /** Filter by the object’s `aantalgeleverd` field. */
  aantalgeleverd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalleveren` field. */
  aantalleveren?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalnaleveren` field. */
  aantalnaleveren?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelMvFilter>>;
  /** Filter by the object’s `bonnummer` field. */
  bonnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwcode` field. */
  btwcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `btwperc` field. */
  btwperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddossier` field. */
  cddossier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbdekking` field. */
  cdgrbdekking?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbkostprijs` field. */
  cdgrbkostprijs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekomzvj` field. */
  cdgrbrekomzvj?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtermijn` field. */
  cdtermijn?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cduursoort` field. */
  cduursoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdwerknemer` field. */
  cdwerknemer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datum` field. */
  datum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `declarabel` field. */
  declarabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factbedragexcl` field. */
  factbedragexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factbedragexclvj` field. */
  factbedragexclvj?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factbedragincl` field. */
  factbedragincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurregel` field. */
  factuurregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `hoofdregel` field. */
  hoofdregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `koppelMetInkoop` field. */
  koppelMetInkoop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kostprijs` field. */
  kostprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nettoomzet` field. */
  nettoomzet?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelMvFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelMvFilter>>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projKosten` field. */
  projKosten?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projKostprijs` field. */
  projKostprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projRegelFactureren` field. */
  projRegelFactureren?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `statcode` field. */
  statcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tekstmagb` field. */
  tekstmagb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorschot` field. */
  voorschot?: InputMaybe<IntFilter>;
  /** Filter by the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `weeknummer` field. */
  weeknummer?: InputMaybe<IntFilter>;
};

/** A connection to a list of `FactopdrachtregelMv` values. */
export type FactopdrachtregelMvsConnection = {
  __typename?: 'FactopdrachtregelMvsConnection';
  /** A list of edges which contains the `FactopdrachtregelMv` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelMvsEdge>;
  /** A list of `FactopdrachtregelMv` objects. */
  nodes: Array<FactopdrachtregelMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelMv` edge in the connection. */
export type FactopdrachtregelMvsEdge = {
  __typename?: 'FactopdrachtregelMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelMv` at the end of the edge. */
  node: FactopdrachtregelMv;
};

/** Methods to use when ordering `FactopdrachtregelMv`. */
export enum FactopdrachtregelMvsOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  AantaldecAsc = 'AANTALDEC_ASC',
  AantaldecDesc = 'AANTALDEC_DESC',
  AantalgeleverdAsc = 'AANTALGELEVERD_ASC',
  AantalgeleverdDesc = 'AANTALGELEVERD_DESC',
  AantalgereservAsc = 'AANTALGERESERV_ASC',
  AantalgereservDesc = 'AANTALGERESERV_DESC',
  AantalleverenAsc = 'AANTALLEVEREN_ASC',
  AantalleverenDesc = 'AANTALLEVEREN_DESC',
  AantalnaleverenAsc = 'AANTALNALEVEREN_ASC',
  AantalnaleverenDesc = 'AANTALNALEVEREN_DESC',
  BonnummerAsc = 'BONNUMMER_ASC',
  BonnummerDesc = 'BONNUMMER_DESC',
  BtwcodeAsc = 'BTWCODE_ASC',
  BtwcodeDesc = 'BTWCODE_DESC',
  BtwpercAsc = 'BTWPERC_ASC',
  BtwpercDesc = 'BTWPERC_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CddeelprojectAsc = 'CDDEELPROJECT_ASC',
  CddeelprojectDesc = 'CDDEELPROJECT_DESC',
  CddossierAsc = 'CDDOSSIER_ASC',
  CddossierDesc = 'CDDOSSIER_DESC',
  CdgrbdekkingAsc = 'CDGRBDEKKING_ASC',
  CdgrbdekkingDesc = 'CDGRBDEKKING_DESC',
  CdgrbkostprijsAsc = 'CDGRBKOSTPRIJS_ASC',
  CdgrbkostprijsDesc = 'CDGRBKOSTPRIJS_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdgrbrekkortAsc = 'CDGRBREKKORT_ASC',
  CdgrbrekkortDesc = 'CDGRBREKKORT_DESC',
  CdgrbrekomzvjAsc = 'CDGRBREKOMZVJ_ASC',
  CdgrbrekomzvjDesc = 'CDGRBREKOMZVJ_DESC',
  CdkostenplaatsAsc = 'CDKOSTENPLAATS_ASC',
  CdkostenplaatsDesc = 'CDKOSTENPLAATS_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  CdstatusAsc = 'CDSTATUS_ASC',
  CdstatusDesc = 'CDSTATUS_DESC',
  CdtermijnAsc = 'CDTERMIJN_ASC',
  CdtermijnDesc = 'CDTERMIJN_DESC',
  CduursoortAsc = 'CDUURSOORT_ASC',
  CduursoortDesc = 'CDUURSOORT_DESC',
  CdwerknemerAsc = 'CDWERKNEMER_ASC',
  CdwerknemerDesc = 'CDWERKNEMER_DESC',
  DatumAsc = 'DATUM_ASC',
  DatumDesc = 'DATUM_DESC',
  DeclarabelAsc = 'DECLARABEL_ASC',
  DeclarabelDesc = 'DECLARABEL_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  FactbedragexclvjAsc = 'FACTBEDRAGEXCLVJ_ASC',
  FactbedragexclvjDesc = 'FACTBEDRAGEXCLVJ_DESC',
  FactbedragexclAsc = 'FACTBEDRAGEXCL_ASC',
  FactbedragexclDesc = 'FACTBEDRAGEXCL_DESC',
  FactbedraginclAsc = 'FACTBEDRAGINCL_ASC',
  FactbedraginclDesc = 'FACTBEDRAGINCL_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FactuurregelAsc = 'FACTUURREGEL_ASC',
  FactuurregelDesc = 'FACTUURREGEL_DESC',
  HoofdregelAsc = 'HOOFDREGEL_ASC',
  HoofdregelDesc = 'HOOFDREGEL_DESC',
  KoppelMetInkoopAsc = 'KOPPEL_MET_INKOOP_ASC',
  KoppelMetInkoopDesc = 'KOPPEL_MET_INKOOP_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KostprijsAsc = 'KOSTPRIJS_ASC',
  KostprijsDesc = 'KOSTPRIJS_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  Natural = 'NATURAL',
  NettoomzetAsc = 'NETTOOMZET_ASC',
  NettoomzetDesc = 'NETTOOMZET_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  ProjKostenAsc = 'PROJ_KOSTEN_ASC',
  ProjKostenDesc = 'PROJ_KOSTEN_DESC',
  ProjKostprijsAsc = 'PROJ_KOSTPRIJS_ASC',
  ProjKostprijsDesc = 'PROJ_KOSTPRIJS_DESC',
  ProjMutsoortAsc = 'PROJ_MUTSOORT_ASC',
  ProjMutsoortDesc = 'PROJ_MUTSOORT_DESC',
  ProjRegelFacturerenAsc = 'PROJ_REGEL_FACTUREREN_ASC',
  ProjRegelFacturerenDesc = 'PROJ_REGEL_FACTUREREN_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  StatcodeAsc = 'STATCODE_ASC',
  StatcodeDesc = 'STATCODE_DESC',
  TekstmagbAsc = 'TEKSTMAGB_ASC',
  TekstmagbDesc = 'TEKSTMAGB_DESC',
  VoorschotAsc = 'VOORSCHOT_ASC',
  VoorschotDesc = 'VOORSCHOT_DESC',
  VvbestandAsc = 'VVBESTAND_ASC',
  VvbestandDesc = 'VVBESTAND_DESC',
  WeeknummerAsc = 'WEEKNUMMER_ASC',
  WeeknummerDesc = 'WEEKNUMMER_DESC'
}

export type FactopdrachtregelTotalAmount = {
  __typename?: 'FactopdrachtregelTotalAmount';
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountAfter?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountBefore?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountDp?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountHold?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountHoldDp?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountOpen?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountScheduled?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountWk0?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountWk1?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountWk2?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountWk3?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountWk4?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountWk5?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountWk6?: Maybe<Scalars['BigFloat']['output']>;
  totalAmountWk7?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `FactopdrachtregelTotalAmount` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FactopdrachtregelTotalAmountCondition = {
  /** Checks for equality with the object’s `totalAmount` field. */
  totalAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountAfter` field. */
  totalAmountAfter?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountBefore` field. */
  totalAmountBefore?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountDp` field. */
  totalAmountDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountHold` field. */
  totalAmountHold?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountHoldDp` field. */
  totalAmountHoldDp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountOpen` field. */
  totalAmountOpen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountScheduled` field. */
  totalAmountScheduled?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountWk0` field. */
  totalAmountWk0?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountWk1` field. */
  totalAmountWk1?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountWk2` field. */
  totalAmountWk2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountWk3` field. */
  totalAmountWk3?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountWk4` field. */
  totalAmountWk4?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountWk5` field. */
  totalAmountWk5?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountWk6` field. */
  totalAmountWk6?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountWk7` field. */
  totalAmountWk7?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `FactopdrachtregelTotalAmount` object types. All fields are combined with a logical ‘and.’ */
export type FactopdrachtregelTotalAmountFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactopdrachtregelTotalAmountFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<FactopdrachtregelTotalAmountFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactopdrachtregelTotalAmountFilter>>;
  /** Filter by the object’s `totalAmount` field. */
  totalAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountAfter` field. */
  totalAmountAfter?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountBefore` field. */
  totalAmountBefore?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountDp` field. */
  totalAmountDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountHold` field. */
  totalAmountHold?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountHoldDp` field. */
  totalAmountHoldDp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountOpen` field. */
  totalAmountOpen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountScheduled` field. */
  totalAmountScheduled?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountWk0` field. */
  totalAmountWk0?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountWk1` field. */
  totalAmountWk1?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountWk2` field. */
  totalAmountWk2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountWk3` field. */
  totalAmountWk3?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountWk4` field. */
  totalAmountWk4?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountWk5` field. */
  totalAmountWk5?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountWk6` field. */
  totalAmountWk6?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountWk7` field. */
  totalAmountWk7?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `FactopdrachtregelTotalAmount` values. */
export type FactopdrachtregelTotalAmountsConnection = {
  __typename?: 'FactopdrachtregelTotalAmountsConnection';
  /** A list of edges which contains the `FactopdrachtregelTotalAmount` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelTotalAmountsEdge>;
  /** A list of `FactopdrachtregelTotalAmount` objects. */
  nodes: Array<FactopdrachtregelTotalAmount>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactopdrachtregelTotalAmount` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactopdrachtregelTotalAmount` edge in the connection. */
export type FactopdrachtregelTotalAmountsEdge = {
  __typename?: 'FactopdrachtregelTotalAmountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactopdrachtregelTotalAmount` at the end of the edge. */
  node: FactopdrachtregelTotalAmount;
};

/** Methods to use when ordering `FactopdrachtregelTotalAmount`. */
export enum FactopdrachtregelTotalAmountsOrderBy {
  Natural = 'NATURAL',
  TotalAmountAfterAsc = 'TOTAL_AMOUNT_AFTER_ASC',
  TotalAmountAfterDesc = 'TOTAL_AMOUNT_AFTER_DESC',
  TotalAmountAsc = 'TOTAL_AMOUNT_ASC',
  TotalAmountBeforeAsc = 'TOTAL_AMOUNT_BEFORE_ASC',
  TotalAmountBeforeDesc = 'TOTAL_AMOUNT_BEFORE_DESC',
  TotalAmountDesc = 'TOTAL_AMOUNT_DESC',
  TotalAmountDpAsc = 'TOTAL_AMOUNT_DP_ASC',
  TotalAmountDpDesc = 'TOTAL_AMOUNT_DP_DESC',
  TotalAmountHoldAsc = 'TOTAL_AMOUNT_HOLD_ASC',
  TotalAmountHoldDesc = 'TOTAL_AMOUNT_HOLD_DESC',
  TotalAmountHoldDpAsc = 'TOTAL_AMOUNT_HOLD_DP_ASC',
  TotalAmountHoldDpDesc = 'TOTAL_AMOUNT_HOLD_DP_DESC',
  TotalAmountOpenAsc = 'TOTAL_AMOUNT_OPEN_ASC',
  TotalAmountOpenDesc = 'TOTAL_AMOUNT_OPEN_DESC',
  TotalAmountScheduledAsc = 'TOTAL_AMOUNT_SCHEDULED_ASC',
  TotalAmountScheduledDesc = 'TOTAL_AMOUNT_SCHEDULED_DESC',
  TotalAmountWk0Asc = 'TOTAL_AMOUNT_WK0_ASC',
  TotalAmountWk0Desc = 'TOTAL_AMOUNT_WK0_DESC',
  TotalAmountWk1Asc = 'TOTAL_AMOUNT_WK1_ASC',
  TotalAmountWk1Desc = 'TOTAL_AMOUNT_WK1_DESC',
  TotalAmountWk2Asc = 'TOTAL_AMOUNT_WK2_ASC',
  TotalAmountWk2Desc = 'TOTAL_AMOUNT_WK2_DESC',
  TotalAmountWk3Asc = 'TOTAL_AMOUNT_WK3_ASC',
  TotalAmountWk3Desc = 'TOTAL_AMOUNT_WK3_DESC',
  TotalAmountWk4Asc = 'TOTAL_AMOUNT_WK4_ASC',
  TotalAmountWk4Desc = 'TOTAL_AMOUNT_WK4_DESC',
  TotalAmountWk5Asc = 'TOTAL_AMOUNT_WK5_ASC',
  TotalAmountWk5Desc = 'TOTAL_AMOUNT_WK5_DESC',
  TotalAmountWk6Asc = 'TOTAL_AMOUNT_WK6_ASC',
  TotalAmountWk6Desc = 'TOTAL_AMOUNT_WK6_DESC',
  TotalAmountWk7Asc = 'TOTAL_AMOUNT_WK7_ASC',
  TotalAmountWk7Desc = 'TOTAL_AMOUNT_WK7_DESC'
}

/** A connection to a list of `Factopdrachtregel` values. */
export type FactopdrachtregelsConnection = {
  __typename?: 'FactopdrachtregelsConnection';
  /** A list of edges which contains the `Factopdrachtregel` and cursor to aid in pagination. */
  edges: Array<FactopdrachtregelsEdge>;
  /** A list of `Factopdrachtregel` objects. */
  nodes: Array<Factopdrachtregel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Factopdrachtregel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Factopdrachtregel` edge in the connection. */
export type FactopdrachtregelsEdge = {
  __typename?: 'FactopdrachtregelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Factopdrachtregel` at the end of the edge. */
  node: Factopdrachtregel;
};

/** Methods to use when ordering `Factopdrachtregel`. */
export enum FactopdrachtregelsOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  AantaldecAsc = 'AANTALDEC_ASC',
  AantaldecDesc = 'AANTALDEC_DESC',
  AantalgeleverdAsc = 'AANTALGELEVERD_ASC',
  AantalgeleverdDesc = 'AANTALGELEVERD_DESC',
  AantalgereservAsc = 'AANTALGERESERV_ASC',
  AantalgereservDesc = 'AANTALGERESERV_DESC',
  AantalleverenAsc = 'AANTALLEVEREN_ASC',
  AantalleverenDesc = 'AANTALLEVEREN_DESC',
  AantalnaleverenAsc = 'AANTALNALEVEREN_ASC',
  AantalnaleverenDesc = 'AANTALNALEVEREN_DESC',
  BonnummerAsc = 'BONNUMMER_ASC',
  BonnummerDesc = 'BONNUMMER_DESC',
  BtwcodeAsc = 'BTWCODE_ASC',
  BtwcodeDesc = 'BTWCODE_DESC',
  BtwpercAsc = 'BTWPERC_ASC',
  BtwpercDesc = 'BTWPERC_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CddeelprojectAsc = 'CDDEELPROJECT_ASC',
  CddeelprojectDesc = 'CDDEELPROJECT_DESC',
  CddossierAsc = 'CDDOSSIER_ASC',
  CddossierDesc = 'CDDOSSIER_DESC',
  CdgrbdekkingAsc = 'CDGRBDEKKING_ASC',
  CdgrbdekkingDesc = 'CDGRBDEKKING_DESC',
  CdgrbkostprijsAsc = 'CDGRBKOSTPRIJS_ASC',
  CdgrbkostprijsDesc = 'CDGRBKOSTPRIJS_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdgrbrekkortAsc = 'CDGRBREKKORT_ASC',
  CdgrbrekkortDesc = 'CDGRBREKKORT_DESC',
  CdgrbrekomzvjAsc = 'CDGRBREKOMZVJ_ASC',
  CdgrbrekomzvjDesc = 'CDGRBREKOMZVJ_DESC',
  CdkostenplaatsAsc = 'CDKOSTENPLAATS_ASC',
  CdkostenplaatsDesc = 'CDKOSTENPLAATS_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  CdstatusAsc = 'CDSTATUS_ASC',
  CdstatusDesc = 'CDSTATUS_DESC',
  CdtermijnAsc = 'CDTERMIJN_ASC',
  CdtermijnDesc = 'CDTERMIJN_DESC',
  CduursoortAsc = 'CDUURSOORT_ASC',
  CduursoortDesc = 'CDUURSOORT_DESC',
  CdwerknemerAsc = 'CDWERKNEMER_ASC',
  CdwerknemerDesc = 'CDWERKNEMER_DESC',
  DatumAsc = 'DATUM_ASC',
  DatumDesc = 'DATUM_DESC',
  DeclarabelAsc = 'DECLARABEL_ASC',
  DeclarabelDesc = 'DECLARABEL_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  FactbedragexclvjAsc = 'FACTBEDRAGEXCLVJ_ASC',
  FactbedragexclvjDesc = 'FACTBEDRAGEXCLVJ_DESC',
  FactbedragexclAsc = 'FACTBEDRAGEXCL_ASC',
  FactbedragexclDesc = 'FACTBEDRAGEXCL_DESC',
  FactbedraginclAsc = 'FACTBEDRAGINCL_ASC',
  FactbedraginclDesc = 'FACTBEDRAGINCL_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  FactureeropdrachtByFactuuropdrachtAantalcolliAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AANTALCOLLI_ASC',
  FactureeropdrachtByFactuuropdrachtAantalcolliDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AANTALCOLLI_DESC',
  FactureeropdrachtByFactuuropdrachtAantalpalletsAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AANTALPALLETS_ASC',
  FactureeropdrachtByFactuuropdrachtAantalpalletsDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AANTALPALLETS_DESC',
  FactureeropdrachtByFactuuropdrachtAbonnementAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ABONNEMENT_ASC',
  FactureeropdrachtByFactuuropdrachtAbonnementDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ABONNEMENT_DESC',
  FactureeropdrachtByFactuuropdrachtAdresAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ADRES_ASC',
  FactureeropdrachtByFactuuropdrachtAdresDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ADRES_DESC',
  FactureeropdrachtByFactuuropdrachtAfdruktellerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AFDRUKTELLER_ASC',
  FactureeropdrachtByFactuuropdrachtAfdruktellerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AFDRUKTELLER_DESC',
  FactureeropdrachtByFactuuropdrachtBehandelddoorAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BEHANDELDDOOR_ASC',
  FactureeropdrachtByFactuuropdrachtBehandelddoorDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BEHANDELDDOOR_DESC',
  FactureeropdrachtByFactuuropdrachtBetaaldbedrag1Asc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETAALDBEDRAG1_ASC',
  FactureeropdrachtByFactuuropdrachtBetaaldbedrag1Desc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETAALDBEDRAG1_DESC',
  FactureeropdrachtByFactuuropdrachtBetaaldbedrag2Asc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETAALDBEDRAG2_ASC',
  FactureeropdrachtByFactuuropdrachtBetaaldbedrag2Desc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETAALDBEDRAG2_DESC',
  FactureeropdrachtByFactuuropdrachtBetkenmerkAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETKENMERK_ASC',
  FactureeropdrachtByFactuuropdrachtBetkenmerkDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETKENMERK_DESC',
  FactureeropdrachtByFactuuropdrachtBetkortpercAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETKORTPERC_ASC',
  FactureeropdrachtByFactuuropdrachtBetkortpercDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETKORTPERC_DESC',
  FactureeropdrachtByFactuuropdrachtBlokkerenAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BLOKKEREN_ASC',
  FactureeropdrachtByFactuuropdrachtBlokkerenDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BLOKKEREN_DESC',
  FactureeropdrachtByFactuuropdrachtBoekjaarAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BOEKJAAR_ASC',
  FactureeropdrachtByFactuuropdrachtBoekjaarDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BOEKJAAR_DESC',
  FactureeropdrachtByFactuuropdrachtBronAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BRON_ASC',
  FactureeropdrachtByFactuuropdrachtBronDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BRON_DESC',
  FactureeropdrachtByFactuuropdrachtBtwopkredbAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BTWOPKREDB_ASC',
  FactureeropdrachtByFactuuropdrachtBtwopkredbDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BTWOPKREDB_DESC',
  FactureeropdrachtByFactuuropdrachtBtwscenarioAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BTWSCENARIO_ASC',
  FactureeropdrachtByFactuuropdrachtBtwscenarioDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BTWSCENARIO_DESC',
  FactureeropdrachtByFactuuropdrachtCdadresAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDADRES_ASC',
  FactureeropdrachtByFactuuropdrachtCdadresDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDADRES_DESC',
  FactureeropdrachtByFactuuropdrachtCdbehandelddoorAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBEHANDELDDOOR_ASC',
  FactureeropdrachtByFactuuropdrachtCdbehandelddoorDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBEHANDELDDOOR_DESC',
  FactureeropdrachtByFactuuropdrachtCdbestlandAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBESTLAND_ASC',
  FactureeropdrachtByFactuuropdrachtCdbestlandDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBESTLAND_DESC',
  FactureeropdrachtByFactuuropdrachtCdbetcondAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETCOND_ASC',
  FactureeropdrachtByFactuuropdrachtCdbetcondDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETCOND_DESC',
  FactureeropdrachtByFactuuropdrachtCdbetwijze1Asc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETWIJZE1_ASC',
  FactureeropdrachtByFactuuropdrachtCdbetwijze1Desc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETWIJZE1_DESC',
  FactureeropdrachtByFactuuropdrachtCdbetwijze2Asc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETWIJZE2_ASC',
  FactureeropdrachtByFactuuropdrachtCdbetwijze2Desc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETWIJZE2_DESC',
  FactureeropdrachtByFactuuropdrachtCdbtwAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBTW_ASC',
  FactureeropdrachtByFactuuropdrachtCdbtwDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBTW_DESC',
  FactureeropdrachtByFactuuropdrachtCddagboekAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDAGBOEK_ASC',
  FactureeropdrachtByFactuuropdrachtCddagboekDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDAGBOEK_DESC',
  FactureeropdrachtByFactuuropdrachtCddebiteurAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDEBITEUR_ASC',
  FactureeropdrachtByFactuuropdrachtCddebiteurDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDEBITEUR_DESC',
  FactureeropdrachtByFactuuropdrachtCddebiteurFactAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDEBITEUR_FACT_ASC',
  FactureeropdrachtByFactuuropdrachtCddebiteurFactDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDEBITEUR_FACT_DESC',
  FactureeropdrachtByFactuuropdrachtCddossierAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDOSSIER_ASC',
  FactureeropdrachtByFactuuropdrachtCddossierDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDOSSIER_DESC',
  FactureeropdrachtByFactuuropdrachtCdexpediteurAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDEXPEDITEUR_ASC',
  FactureeropdrachtByFactuuropdrachtCdexpediteurDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDEXPEDITEUR_DESC',
  FactureeropdrachtByFactuuropdrachtCdfactuurAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDFACTUUR_ASC',
  FactureeropdrachtByFactuuropdrachtCdfactuurDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDFACTUUR_DESC',
  FactureeropdrachtByFactuuropdrachtCdfiatteurAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDFIATTEUR_ASC',
  FactureeropdrachtByFactuuropdrachtCdfiatteurDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDFIATTEUR_DESC',
  FactureeropdrachtByFactuuropdrachtCdkostenplaatsAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDKOSTENPLAATS_ASC',
  FactureeropdrachtByFactuuropdrachtCdkostenplaatsDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDKOSTENPLAATS_DESC',
  FactureeropdrachtByFactuuropdrachtCdlevcondAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDLEVCOND_ASC',
  FactureeropdrachtByFactuuropdrachtCdlevcondDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDLEVCOND_DESC',
  FactureeropdrachtByFactuuropdrachtCdloonwerkAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDLOONWERK_ASC',
  FactureeropdrachtByFactuuropdrachtCdloonwerkDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDLOONWERK_DESC',
  FactureeropdrachtByFactuuropdrachtCdpersoonAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDPERSOON_ASC',
  FactureeropdrachtByFactuuropdrachtCdpersoonDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDPERSOON_DESC',
  FactureeropdrachtByFactuuropdrachtCdprojectAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDPROJECT_ASC',
  FactureeropdrachtByFactuuropdrachtCdprojectDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDPROJECT_DESC',
  FactureeropdrachtByFactuuropdrachtCdsoortAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSOORT_ASC',
  FactureeropdrachtByFactuuropdrachtCdsoortDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSOORT_DESC',
  FactureeropdrachtByFactuuropdrachtCdstelselAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSTELSEL_ASC',
  FactureeropdrachtByFactuuropdrachtCdstelselDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSTELSEL_DESC',
  FactureeropdrachtByFactuuropdrachtCdstroomAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSTROOM_ASC',
  FactureeropdrachtByFactuuropdrachtCdstroomDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSTROOM_DESC',
  FactureeropdrachtByFactuuropdrachtCdtypeAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDTYPE_ASC',
  FactureeropdrachtByFactuuropdrachtCdtypeDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDTYPE_DESC',
  FactureeropdrachtByFactuuropdrachtCdvalutaAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVALUTA_ASC',
  FactureeropdrachtByFactuuropdrachtCdvalutaDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVALUTA_DESC',
  FactureeropdrachtByFactuuropdrachtCdverkeerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERKEER_ASC',
  FactureeropdrachtByFactuuropdrachtCdverkeerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERKEER_DESC',
  FactureeropdrachtByFactuuropdrachtCdvertAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERT_ASC',
  FactureeropdrachtByFactuuropdrachtCdvertDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERT_DESC',
  FactureeropdrachtByFactuuropdrachtCdvervoerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERVOER_ASC',
  FactureeropdrachtByFactuuropdrachtCdvervoerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERVOER_DESC',
  FactureeropdrachtByFactuuropdrachtCdverzamelAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERZAMEL_ASC',
  FactureeropdrachtByFactuuropdrachtCdverzamelDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERZAMEL_DESC',
  FactureeropdrachtByFactuuropdrachtFacturerenAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUREREN_ASC',
  FactureeropdrachtByFactuuropdrachtFacturerenDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUREREN_DESC',
  FactureeropdrachtByFactuuropdrachtFactuurdatumAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUURDATUM_ASC',
  FactureeropdrachtByFactuuropdrachtFactuurdatumDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUURDATUM_DESC',
  FactureeropdrachtByFactuuropdrachtFactuurnummerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUURNUMMER_ASC',
  FactureeropdrachtByFactuuropdrachtFactuurnummerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUURNUMMER_DESC',
  FactureeropdrachtByFactuuropdrachtFactuuropdrachtAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUUROPDRACHT_ASC',
  FactureeropdrachtByFactuuropdrachtFactuuropdrachtDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUUROPDRACHT_DESC',
  FactureeropdrachtByFactuuropdrachtGebruikerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GEBRUIKER_ASC',
  FactureeropdrachtByFactuuropdrachtGebruikerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GEBRUIKER_DESC',
  FactureeropdrachtByFactuuropdrachtGefiatteerdAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GEFIATTEERD_ASC',
  FactureeropdrachtByFactuuropdrachtGefiatteerdDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GEFIATTEERD_DESC',
  FactureeropdrachtByFactuuropdrachtGuidItemAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GUID_ITEM_ASC',
  FactureeropdrachtByFactuuropdrachtGuidItemDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GUID_ITEM_DESC',
  FactureeropdrachtByFactuuropdrachtKortingpercAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KORTINGPERC_ASC',
  FactureeropdrachtByFactuuropdrachtKortingpercDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KORTINGPERC_DESC',
  FactureeropdrachtByFactuuropdrachtKredbeppercAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KREDBEPPERC_ASC',
  FactureeropdrachtByFactuuropdrachtKredbeppercDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KREDBEPPERC_DESC',
  FactureeropdrachtByFactuuropdrachtKvcAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KVC_ASC',
  FactureeropdrachtByFactuuropdrachtKvcDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KVC_DESC',
  FactureeropdrachtByFactuuropdrachtLidnrBijInkorgAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__LIDNR_BIJ_INKORG_ASC',
  FactureeropdrachtByFactuuropdrachtLidnrBijInkorgDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__LIDNR_BIJ_INKORG_DESC',
  FactureeropdrachtByFactuuropdrachtMagazijnbonAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__MAGAZIJNBON_ASC',
  FactureeropdrachtByFactuuropdrachtMagazijnbonDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__MAGAZIJNBON_DESC',
  FactureeropdrachtByFactuuropdrachtMargeblokkadeAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__MARGEBLOKKADE_ASC',
  FactureeropdrachtByFactuuropdrachtMargeblokkadeDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__MARGEBLOKKADE_DESC',
  FactureeropdrachtByFactuuropdrachtOffertenummerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OFFERTENUMMER_ASC',
  FactureeropdrachtByFactuuropdrachtOffertenummerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OFFERTENUMMER_DESC',
  FactureeropdrachtByFactuuropdrachtOffertevolgnrAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OFFERTEVOLGNR_ASC',
  FactureeropdrachtByFactuuropdrachtOffertevolgnrDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OFFERTEVOLGNR_DESC',
  FactureeropdrachtByFactuuropdrachtOpdrachtdatumAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OPDRACHTDATUM_ASC',
  FactureeropdrachtByFactuuropdrachtOpdrachtdatumDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OPDRACHTDATUM_DESC',
  FactureeropdrachtByFactuuropdrachtOrdbevtellerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ORDBEVTELLER_ASC',
  FactureeropdrachtByFactuuropdrachtOrdbevtellerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ORDBEVTELLER_DESC',
  FactureeropdrachtByFactuuropdrachtPakbonAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PAKBON_ASC',
  FactureeropdrachtByFactuuropdrachtPakbonDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PAKBON_DESC',
  FactureeropdrachtByFactuuropdrachtPercgrekAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERCGREK_ASC',
  FactureeropdrachtByFactuuropdrachtPercgrekDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERCGREK_DESC',
  FactureeropdrachtByFactuuropdrachtPeriodeAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERIODE_ASC',
  FactureeropdrachtByFactuuropdrachtPeriodeDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERIODE_DESC',
  FactureeropdrachtByFactuuropdrachtPersoonAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERSOON_ASC',
  FactureeropdrachtByFactuuropdrachtPersoonDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERSOON_DESC',
  FactureeropdrachtByFactuuropdrachtProjFacturerenAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PROJ_FACTUREREN_ASC',
  FactureeropdrachtByFactuuropdrachtProjFacturerenDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PROJ_FACTUREREN_DESC',
  FactureeropdrachtByFactuuropdrachtReferentieAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__REFERENTIE_ASC',
  FactureeropdrachtByFactuuropdrachtReferentieDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__REFERENTIE_DESC',
  FactureeropdrachtByFactuuropdrachtStatusAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__STATUS_ASC',
  FactureeropdrachtByFactuuropdrachtStatusDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__STATUS_DESC',
  FactureeropdrachtByFactuuropdrachtSubadresAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SUBADRES_ASC',
  FactureeropdrachtByFactuuropdrachtSubadresDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SUBADRES_DESC',
  FactureeropdrachtByFactuuropdrachtSysCreateAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SYS_CREATE_ASC',
  FactureeropdrachtByFactuuropdrachtSysCreateDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SYS_CREATE_DESC',
  FactureeropdrachtByFactuuropdrachtSysUpdateAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SYS_UPDATE_ASC',
  FactureeropdrachtByFactuuropdrachtSysUpdateDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SYS_UPDATE_DESC',
  FactureeropdrachtByFactuuropdrachtTransactieAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__TRANSACTIE_ASC',
  FactureeropdrachtByFactuuropdrachtTransactieDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__TRANSACTIE_DESC',
  FactureeropdrachtByFactuuropdrachtVertegenwoordigerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERTEGENWOORDIGER_ASC',
  FactureeropdrachtByFactuuropdrachtVertegenwoordigerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERTEGENWOORDIGER_DESC',
  FactureeropdrachtByFactuuropdrachtVervolgopdrachtvanAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERVOLGOPDRACHTVAN_ASC',
  FactureeropdrachtByFactuuropdrachtVervolgopdrachtvanDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERVOLGOPDRACHTVAN_DESC',
  FactureeropdrachtByFactuuropdrachtVerwerktboAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERWERKTBO_ASC',
  FactureeropdrachtByFactuuropdrachtVerwerktboDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERWERKTBO_DESC',
  FactureeropdrachtByFactuuropdrachtVerwerktvrdAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERWERKTVRD_ASC',
  FactureeropdrachtByFactuuropdrachtVerwerktvrdDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERWERKTVRD_DESC',
  FactureeropdrachtByFactuuropdrachtVrachtgewichtAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VRACHTGEWICHT_ASC',
  FactureeropdrachtByFactuuropdrachtVrachtgewichtDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VRACHTGEWICHT_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FactuurregelAsc = 'FACTUURREGEL_ASC',
  FactuurregelDesc = 'FACTUURREGEL_DESC',
  HoofdregelAsc = 'HOOFDREGEL_ASC',
  HoofdregelDesc = 'HOOFDREGEL_DESC',
  KoppelMetInkoopAsc = 'KOPPEL_MET_INKOOP_ASC',
  KoppelMetInkoopDesc = 'KOPPEL_MET_INKOOP_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KostprijsAsc = 'KOSTPRIJS_ASC',
  KostprijsDesc = 'KOSTPRIJS_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  Natural = 'NATURAL',
  NettoomzetAsc = 'NETTOOMZET_ASC',
  NettoomzetDesc = 'NETTOOMZET_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  ProjKostenAsc = 'PROJ_KOSTEN_ASC',
  ProjKostenDesc = 'PROJ_KOSTEN_DESC',
  ProjKostprijsAsc = 'PROJ_KOSTPRIJS_ASC',
  ProjKostprijsDesc = 'PROJ_KOSTPRIJS_DESC',
  ProjMutsoortAsc = 'PROJ_MUTSOORT_ASC',
  ProjMutsoortDesc = 'PROJ_MUTSOORT_DESC',
  ProjRegelFacturerenAsc = 'PROJ_REGEL_FACTUREREN_ASC',
  ProjRegelFacturerenDesc = 'PROJ_REGEL_FACTUREREN_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  StatcodeAsc = 'STATCODE_ASC',
  StatcodeDesc = 'STATCODE_DESC',
  TekstmagbAsc = 'TEKSTMAGB_ASC',
  TekstmagbDesc = 'TEKSTMAGB_DESC',
  VoorschotAsc = 'VOORSCHOT_ASC',
  VoorschotDesc = 'VOORSCHOT_DESC',
  VvbestandAsc = 'VVBESTAND_ASC',
  VvbestandDesc = 'VVBESTAND_DESC',
  WeeknummerAsc = 'WEEKNUMMER_ASC',
  WeeknummerDesc = 'WEEKNUMMER_DESC'
}

export type Factureeropdracht = Node & {
  __typename?: 'Factureeropdracht';
  aantalcolli?: Maybe<Scalars['Int']['output']>;
  aantalpallets?: Maybe<Scalars['Int']['output']>;
  abonnement?: Maybe<Scalars['String']['output']>;
  adres?: Maybe<Scalars['String']['output']>;
  afdrukteller?: Maybe<Scalars['Int']['output']>;
  behandelddoor?: Maybe<Scalars['String']['output']>;
  betaaldbedrag1?: Maybe<Scalars['BigFloat']['output']>;
  betaaldbedrag2?: Maybe<Scalars['BigFloat']['output']>;
  betkenmerk?: Maybe<Scalars['String']['output']>;
  betkortperc?: Maybe<Scalars['BigFloat']['output']>;
  blokkeren?: Maybe<Scalars['String']['output']>;
  boekjaar?: Maybe<Scalars['Int']['output']>;
  bron?: Maybe<Scalars['String']['output']>;
  btwopkredb?: Maybe<Scalars['String']['output']>;
  btwscenario?: Maybe<Scalars['Int']['output']>;
  cdadres?: Maybe<Scalars['Int']['output']>;
  cdbehandelddoor?: Maybe<Scalars['String']['output']>;
  cdbestland?: Maybe<Scalars['String']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdbetwijze1?: Maybe<Scalars['String']['output']>;
  cdbetwijze2?: Maybe<Scalars['String']['output']>;
  cdbtw?: Maybe<Scalars['String']['output']>;
  cddagboek?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cddebiteurFact?: Maybe<Scalars['String']['output']>;
  cddossier?: Maybe<Scalars['String']['output']>;
  cdexpediteur?: Maybe<Scalars['String']['output']>;
  cdfactuur?: Maybe<Scalars['String']['output']>;
  cdfiatteur?: Maybe<Scalars['String']['output']>;
  cdkostenplaats?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdloonwerk?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdproject?: Maybe<Scalars['String']['output']>;
  cdsoort?: Maybe<Scalars['String']['output']>;
  cdstelsel?: Maybe<Scalars['Int']['output']>;
  cdstroom?: Maybe<Scalars['Int']['output']>;
  cdtype?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  cdverkeer?: Maybe<Scalars['Int']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  cdvervoer?: Maybe<Scalars['Int']['output']>;
  cdverzamel?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Debiteur` that is related to this `Factureeropdracht`. */
  debiteurByCddebiteur?: Maybe<Debiteur>;
  /** Reads and enables pagination through a set of `Factopdrachtregel`. */
  factopdrachtregelsByFactuuropdracht: FactopdrachtregelsConnection;
  factureren?: Maybe<Scalars['String']['output']>;
  factuurdatum?: Maybe<Scalars['Date']['output']>;
  factuurnummer?: Maybe<Scalars['String']['output']>;
  factuuropdracht: Scalars['String']['output'];
  gebruiker?: Maybe<Scalars['String']['output']>;
  gefiatteerd?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kredbepperc?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  lidnrBijInkorg?: Maybe<Scalars['String']['output']>;
  magazijnbon?: Maybe<Scalars['String']['output']>;
  margeblokkade?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  offertenummer?: Maybe<Scalars['String']['output']>;
  offertevolgnr?: Maybe<Scalars['Int']['output']>;
  opdrachtdatum?: Maybe<Scalars['Date']['output']>;
  ordbevteller?: Maybe<Scalars['Int']['output']>;
  pakbon?: Maybe<Scalars['String']['output']>;
  percgrek?: Maybe<Scalars['BigFloat']['output']>;
  periode?: Maybe<Scalars['Int']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  projFactureren?: Maybe<Scalars['String']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SensorOrder`. */
  sensorOrdersByFactuuropdracht: SensorOrdersConnection;
  status?: Maybe<Scalars['String']['output']>;
  subadres?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  transactie?: Maybe<Scalars['Int']['output']>;
  vertegenwoordiger?: Maybe<Scalars['String']['output']>;
  vervolgopdrachtvan?: Maybe<Scalars['String']['output']>;
  verwerktbo?: Maybe<Scalars['String']['output']>;
  verwerktvrd?: Maybe<Scalars['String']['output']>;
  vrachtgewicht?: Maybe<Scalars['BigFloat']['output']>;
};


export type FactureeropdrachtFactopdrachtregelsByFactuuropdrachtArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelCondition>;
  filter?: InputMaybe<FactopdrachtregelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelsOrderBy>>;
};


export type FactureeropdrachtSensorOrdersByFactuuropdrachtArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorOrderCondition>;
  filter?: InputMaybe<SensorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};

/**
 * A condition to be used against `Factureeropdracht` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FactureeropdrachtCondition = {
  /** Checks for equality with the object’s `aantalcolli` field. */
  aantalcolli?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aantalpallets` field. */
  aantalpallets?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `abonnement` field. */
  abonnement?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `adres` field. */
  adres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `betaaldbedrag1` field. */
  betaaldbedrag1?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `betaaldbedrag2` field. */
  betaaldbedrag2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `betkenmerk` field. */
  betkenmerk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `betkortperc` field. */
  betkortperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `blokkeren` field. */
  blokkeren?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `boekjaar` field. */
  boekjaar?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `bron` field. */
  bron?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwopkredb` field. */
  btwopkredb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdadres` field. */
  cdadres?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbestland` field. */
  cdbestland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetwijze1` field. */
  cdbetwijze1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetwijze2` field. */
  cdbetwijze2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbtw` field. */
  cdbtw?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddagboek` field. */
  cddagboek?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteurFact` field. */
  cddebiteurFact?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddossier` field. */
  cddossier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdexpediteur` field. */
  cdexpediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfactuur` field. */
  cdfactuur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdloonwerk` field. */
  cdloonwerk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdproject` field. */
  cdproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtype` field. */
  cdtype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdverzamel` field. */
  cdverzamel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factureren` field. */
  factureren?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurdatum` field. */
  factuurdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gebruiker` field. */
  gebruiker?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kredbepperc` field. */
  kredbepperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lidnrBijInkorg` field. */
  lidnrBijInkorg?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `magazijnbon` field. */
  magazijnbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margeblokkade` field. */
  margeblokkade?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `opdrachtdatum` field. */
  opdrachtdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `ordbevteller` field. */
  ordbevteller?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pakbon` field. */
  pakbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `percgrek` field. */
  percgrek?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `periode` field. */
  periode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projFactureren` field. */
  projFactureren?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `subadres` field. */
  subadres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `transactie` field. */
  transactie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vervolgopdrachtvan` field. */
  vervolgopdrachtvan?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verwerktbo` field. */
  verwerktbo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verwerktvrd` field. */
  verwerktvrd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vrachtgewicht` field. */
  vrachtgewicht?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `Factureeropdracht` object types. All fields are combined with a logical ‘and.’ */
export type FactureeropdrachtFilter = {
  /** Filter by the object’s `aantalcolli` field. */
  aantalcolli?: InputMaybe<IntFilter>;
  /** Filter by the object’s `aantalpallets` field. */
  aantalpallets?: InputMaybe<IntFilter>;
  /** Filter by the object’s `abonnement` field. */
  abonnement?: InputMaybe<StringFilter>;
  /** Filter by the object’s `adres` field. */
  adres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactureeropdrachtFilter>>;
  /** Filter by the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `betaaldbedrag1` field. */
  betaaldbedrag1?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `betaaldbedrag2` field. */
  betaaldbedrag2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `betkenmerk` field. */
  betkenmerk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `betkortperc` field. */
  betkortperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `blokkeren` field. */
  blokkeren?: InputMaybe<StringFilter>;
  /** Filter by the object’s `boekjaar` field. */
  boekjaar?: InputMaybe<IntFilter>;
  /** Filter by the object’s `bron` field. */
  bron?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwopkredb` field. */
  btwopkredb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdadres` field. */
  cdadres?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbestland` field. */
  cdbestland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetwijze1` field. */
  cdbetwijze1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetwijze2` field. */
  cdbetwijze2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbtw` field. */
  cdbtw?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddagboek` field. */
  cddagboek?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteurFact` field. */
  cddebiteurFact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddossier` field. */
  cddossier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdexpediteur` field. */
  cdexpediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfactuur` field. */
  cdfactuur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdloonwerk` field. */
  cdloonwerk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdproject` field. */
  cdproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtype` field. */
  cdtype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdverzamel` field. */
  cdverzamel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `debiteurByCddebiteur` relation. */
  debiteurByCddebiteur?: InputMaybe<DebiteurFilter>;
  /** A related `debiteurByCddebiteur` exists. */
  debiteurByCddebiteurExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `factopdrachtregelsByFactuuropdracht` relation. */
  factopdrachtregelsByFactuuropdracht?: InputMaybe<FactureeropdrachtToManyFactopdrachtregelFilter>;
  /** Some related `factopdrachtregelsByFactuuropdracht` exist. */
  factopdrachtregelsByFactuuropdrachtExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `factureren` field. */
  factureren?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurdatum` field. */
  factuurdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gebruiker` field. */
  gebruiker?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kredbepperc` field. */
  kredbepperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lidnrBijInkorg` field. */
  lidnrBijInkorg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `magazijnbon` field. */
  magazijnbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margeblokkade` field. */
  margeblokkade?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactureeropdrachtFilter>;
  /** Filter by the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `opdrachtdatum` field. */
  opdrachtdatum?: InputMaybe<DateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactureeropdrachtFilter>>;
  /** Filter by the object’s `ordbevteller` field. */
  ordbevteller?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pakbon` field. */
  pakbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `percgrek` field. */
  percgrek?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `periode` field. */
  periode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projFactureren` field. */
  projFactureren?: InputMaybe<StringFilter>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorOrdersByFactuuropdracht` relation. */
  sensorOrdersByFactuuropdracht?: InputMaybe<FactureeropdrachtToManySensorOrderFilter>;
  /** Some related `sensorOrdersByFactuuropdracht` exist. */
  sensorOrdersByFactuuropdrachtExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `subadres` field. */
  subadres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `transactie` field. */
  transactie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vervolgopdrachtvan` field. */
  vervolgopdrachtvan?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verwerktbo` field. */
  verwerktbo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verwerktvrd` field. */
  verwerktvrd?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vrachtgewicht` field. */
  vrachtgewicht?: InputMaybe<BigFloatFilter>;
};

export type FactureeropdrachtIndex = {
  __typename?: 'FactureeropdrachtIndex';
  cdbetcond?: Maybe<Scalars['String']['output']>;
  factuurnummer?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  opdrachtdatum?: Maybe<Scalars['Date']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `FactureeropdrachtIndex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FactureeropdrachtIndexCondition = {
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `opdrachtdatum` field. */
  opdrachtdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `FactureeropdrachtIndex` object types. All fields are combined with a logical ‘and.’ */
export type FactureeropdrachtIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactureeropdrachtIndexFilter>>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactureeropdrachtIndexFilter>;
  /** Filter by the object’s `opdrachtdatum` field. */
  opdrachtdatum?: InputMaybe<DateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactureeropdrachtIndexFilter>>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `FactureeropdrachtIndex` values. */
export type FactureeropdrachtIndicesConnection = {
  __typename?: 'FactureeropdrachtIndicesConnection';
  /** A list of edges which contains the `FactureeropdrachtIndex` and cursor to aid in pagination. */
  edges: Array<FactureeropdrachtIndicesEdge>;
  /** A list of `FactureeropdrachtIndex` objects. */
  nodes: Array<FactureeropdrachtIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactureeropdrachtIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactureeropdrachtIndex` edge in the connection. */
export type FactureeropdrachtIndicesEdge = {
  __typename?: 'FactureeropdrachtIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactureeropdrachtIndex` at the end of the edge. */
  node: FactureeropdrachtIndex;
};

/** Methods to use when ordering `FactureeropdrachtIndex`. */
export enum FactureeropdrachtIndicesOrderBy {
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  FactuurnummerAsc = 'FACTUURNUMMER_ASC',
  FactuurnummerDesc = 'FACTUURNUMMER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  Natural = 'NATURAL',
  OpdrachtdatumAsc = 'OPDRACHTDATUM_ASC',
  OpdrachtdatumDesc = 'OPDRACHTDATUM_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type FactureeropdrachtMv = {
  __typename?: 'FactureeropdrachtMv';
  aantalcolli?: Maybe<Scalars['Int']['output']>;
  aantalpallets?: Maybe<Scalars['Int']['output']>;
  abonnement?: Maybe<Scalars['String']['output']>;
  adres?: Maybe<Scalars['String']['output']>;
  afdrukteller?: Maybe<Scalars['Int']['output']>;
  behandelddoor?: Maybe<Scalars['String']['output']>;
  betaaldbedrag1?: Maybe<Scalars['BigFloat']['output']>;
  betaaldbedrag2?: Maybe<Scalars['BigFloat']['output']>;
  betkenmerk?: Maybe<Scalars['String']['output']>;
  betkortperc?: Maybe<Scalars['BigFloat']['output']>;
  blokkeren?: Maybe<Scalars['String']['output']>;
  boekjaar?: Maybe<Scalars['Int']['output']>;
  bron?: Maybe<Scalars['String']['output']>;
  btwopkredb?: Maybe<Scalars['String']['output']>;
  btwscenario?: Maybe<Scalars['Int']['output']>;
  cdadres?: Maybe<Scalars['Int']['output']>;
  cdbehandelddoor?: Maybe<Scalars['String']['output']>;
  cdbestland?: Maybe<Scalars['String']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdbetwijze1?: Maybe<Scalars['String']['output']>;
  cdbetwijze2?: Maybe<Scalars['String']['output']>;
  cdbtw?: Maybe<Scalars['String']['output']>;
  cddagboek?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cddebiteurFact?: Maybe<Scalars['String']['output']>;
  cddossier?: Maybe<Scalars['String']['output']>;
  cdexpediteur?: Maybe<Scalars['String']['output']>;
  cdfactuur?: Maybe<Scalars['String']['output']>;
  cdfiatteur?: Maybe<Scalars['String']['output']>;
  cdkostenplaats?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdloonwerk?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdproject?: Maybe<Scalars['String']['output']>;
  cdsoort?: Maybe<Scalars['String']['output']>;
  cdstelsel?: Maybe<Scalars['Int']['output']>;
  cdstroom?: Maybe<Scalars['Int']['output']>;
  cdtype?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  cdverkeer?: Maybe<Scalars['Int']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  cdvervoer?: Maybe<Scalars['Int']['output']>;
  cdverzamel?: Maybe<Scalars['Int']['output']>;
  factureren?: Maybe<Scalars['String']['output']>;
  factuurdatum?: Maybe<Scalars['Date']['output']>;
  factuurnummer?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  gebruiker?: Maybe<Scalars['String']['output']>;
  gefiatteerd?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kredbepperc?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  lidnrBijInkorg?: Maybe<Scalars['String']['output']>;
  magazijnbon?: Maybe<Scalars['String']['output']>;
  margeblokkade?: Maybe<Scalars['String']['output']>;
  offertenummer?: Maybe<Scalars['String']['output']>;
  offertevolgnr?: Maybe<Scalars['Int']['output']>;
  opdrachtdatum?: Maybe<Scalars['Date']['output']>;
  ordbevteller?: Maybe<Scalars['Int']['output']>;
  pakbon?: Maybe<Scalars['String']['output']>;
  percgrek?: Maybe<Scalars['BigFloat']['output']>;
  periode?: Maybe<Scalars['Int']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  projFactureren?: Maybe<Scalars['String']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  subadres?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  transactie?: Maybe<Scalars['Int']['output']>;
  vertegenwoordiger?: Maybe<Scalars['String']['output']>;
  vervolgopdrachtvan?: Maybe<Scalars['String']['output']>;
  verwerktbo?: Maybe<Scalars['String']['output']>;
  verwerktvrd?: Maybe<Scalars['String']['output']>;
  vrachtgewicht?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `FactureeropdrachtMv` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type FactureeropdrachtMvCondition = {
  /** Checks for equality with the object’s `aantalcolli` field. */
  aantalcolli?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aantalpallets` field. */
  aantalpallets?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `abonnement` field. */
  abonnement?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `adres` field. */
  adres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `betaaldbedrag1` field. */
  betaaldbedrag1?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `betaaldbedrag2` field. */
  betaaldbedrag2?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `betkenmerk` field. */
  betkenmerk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `betkortperc` field. */
  betkortperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `blokkeren` field. */
  blokkeren?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `boekjaar` field. */
  boekjaar?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `bron` field. */
  bron?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwopkredb` field. */
  btwopkredb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdadres` field. */
  cdadres?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbestland` field. */
  cdbestland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetwijze1` field. */
  cdbetwijze1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetwijze2` field. */
  cdbetwijze2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbtw` field. */
  cdbtw?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddagboek` field. */
  cddagboek?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteurFact` field. */
  cddebiteurFact?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddossier` field. */
  cddossier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdexpediteur` field. */
  cdexpediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfactuur` field. */
  cdfactuur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdloonwerk` field. */
  cdloonwerk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdproject` field. */
  cdproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtype` field. */
  cdtype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdverzamel` field. */
  cdverzamel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factureren` field. */
  factureren?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurdatum` field. */
  factuurdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gebruiker` field. */
  gebruiker?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kredbepperc` field. */
  kredbepperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lidnrBijInkorg` field. */
  lidnrBijInkorg?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `magazijnbon` field. */
  magazijnbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margeblokkade` field. */
  margeblokkade?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `opdrachtdatum` field. */
  opdrachtdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `ordbevteller` field. */
  ordbevteller?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pakbon` field. */
  pakbon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `percgrek` field. */
  percgrek?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `periode` field. */
  periode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projFactureren` field. */
  projFactureren?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `subadres` field. */
  subadres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `transactie` field. */
  transactie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vervolgopdrachtvan` field. */
  vervolgopdrachtvan?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verwerktbo` field. */
  verwerktbo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verwerktvrd` field. */
  verwerktvrd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vrachtgewicht` field. */
  vrachtgewicht?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `FactureeropdrachtMv` object types. All fields are combined with a logical ‘and.’ */
export type FactureeropdrachtMvFilter = {
  /** Filter by the object’s `aantalcolli` field. */
  aantalcolli?: InputMaybe<IntFilter>;
  /** Filter by the object’s `aantalpallets` field. */
  aantalpallets?: InputMaybe<IntFilter>;
  /** Filter by the object’s `abonnement` field. */
  abonnement?: InputMaybe<StringFilter>;
  /** Filter by the object’s `adres` field. */
  adres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactureeropdrachtMvFilter>>;
  /** Filter by the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `betaaldbedrag1` field. */
  betaaldbedrag1?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `betaaldbedrag2` field. */
  betaaldbedrag2?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `betkenmerk` field. */
  betkenmerk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `betkortperc` field. */
  betkortperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `blokkeren` field. */
  blokkeren?: InputMaybe<StringFilter>;
  /** Filter by the object’s `boekjaar` field. */
  boekjaar?: InputMaybe<IntFilter>;
  /** Filter by the object’s `bron` field. */
  bron?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwopkredb` field. */
  btwopkredb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdadres` field. */
  cdadres?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbestland` field. */
  cdbestland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetwijze1` field. */
  cdbetwijze1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetwijze2` field. */
  cdbetwijze2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbtw` field. */
  cdbtw?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddagboek` field. */
  cddagboek?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteurFact` field. */
  cddebiteurFact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddossier` field. */
  cddossier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdexpediteur` field. */
  cdexpediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfactuur` field. */
  cdfactuur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdloonwerk` field. */
  cdloonwerk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdproject` field. */
  cdproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdstelsel` field. */
  cdstelsel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdstroom` field. */
  cdstroom?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtype` field. */
  cdtype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdverkeer` field. */
  cdverkeer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvervoer` field. */
  cdvervoer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdverzamel` field. */
  cdverzamel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factureren` field. */
  factureren?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurdatum` field. */
  factuurdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gebruiker` field. */
  gebruiker?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kredbepperc` field. */
  kredbepperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lidnrBijInkorg` field. */
  lidnrBijInkorg?: InputMaybe<StringFilter>;
  /** Filter by the object’s `magazijnbon` field. */
  magazijnbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margeblokkade` field. */
  margeblokkade?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactureeropdrachtMvFilter>;
  /** Filter by the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `opdrachtdatum` field. */
  opdrachtdatum?: InputMaybe<DateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactureeropdrachtMvFilter>>;
  /** Filter by the object’s `ordbevteller` field. */
  ordbevteller?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pakbon` field. */
  pakbon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `percgrek` field. */
  percgrek?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `periode` field. */
  periode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projFactureren` field. */
  projFactureren?: InputMaybe<StringFilter>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `subadres` field. */
  subadres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `transactie` field. */
  transactie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vervolgopdrachtvan` field. */
  vervolgopdrachtvan?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verwerktbo` field. */
  verwerktbo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verwerktvrd` field. */
  verwerktvrd?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vrachtgewicht` field. */
  vrachtgewicht?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `FactureeropdrachtMv` values. */
export type FactureeropdrachtMvsConnection = {
  __typename?: 'FactureeropdrachtMvsConnection';
  /** A list of edges which contains the `FactureeropdrachtMv` and cursor to aid in pagination. */
  edges: Array<FactureeropdrachtMvsEdge>;
  /** A list of `FactureeropdrachtMv` objects. */
  nodes: Array<FactureeropdrachtMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FactureeropdrachtMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FactureeropdrachtMv` edge in the connection. */
export type FactureeropdrachtMvsEdge = {
  __typename?: 'FactureeropdrachtMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FactureeropdrachtMv` at the end of the edge. */
  node: FactureeropdrachtMv;
};

/** Methods to use when ordering `FactureeropdrachtMv`. */
export enum FactureeropdrachtMvsOrderBy {
  AantalcolliAsc = 'AANTALCOLLI_ASC',
  AantalcolliDesc = 'AANTALCOLLI_DESC',
  AantalpalletsAsc = 'AANTALPALLETS_ASC',
  AantalpalletsDesc = 'AANTALPALLETS_DESC',
  AbonnementAsc = 'ABONNEMENT_ASC',
  AbonnementDesc = 'ABONNEMENT_DESC',
  AdresAsc = 'ADRES_ASC',
  AdresDesc = 'ADRES_DESC',
  AfdruktellerAsc = 'AFDRUKTELLER_ASC',
  AfdruktellerDesc = 'AFDRUKTELLER_DESC',
  BehandelddoorAsc = 'BEHANDELDDOOR_ASC',
  BehandelddoorDesc = 'BEHANDELDDOOR_DESC',
  Betaaldbedrag1Asc = 'BETAALDBEDRAG1_ASC',
  Betaaldbedrag1Desc = 'BETAALDBEDRAG1_DESC',
  Betaaldbedrag2Asc = 'BETAALDBEDRAG2_ASC',
  Betaaldbedrag2Desc = 'BETAALDBEDRAG2_DESC',
  BetkenmerkAsc = 'BETKENMERK_ASC',
  BetkenmerkDesc = 'BETKENMERK_DESC',
  BetkortpercAsc = 'BETKORTPERC_ASC',
  BetkortpercDesc = 'BETKORTPERC_DESC',
  BlokkerenAsc = 'BLOKKEREN_ASC',
  BlokkerenDesc = 'BLOKKEREN_DESC',
  BoekjaarAsc = 'BOEKJAAR_ASC',
  BoekjaarDesc = 'BOEKJAAR_DESC',
  BronAsc = 'BRON_ASC',
  BronDesc = 'BRON_DESC',
  BtwopkredbAsc = 'BTWOPKREDB_ASC',
  BtwopkredbDesc = 'BTWOPKREDB_DESC',
  BtwscenarioAsc = 'BTWSCENARIO_ASC',
  BtwscenarioDesc = 'BTWSCENARIO_DESC',
  CdadresAsc = 'CDADRES_ASC',
  CdadresDesc = 'CDADRES_DESC',
  CdbehandelddoorAsc = 'CDBEHANDELDDOOR_ASC',
  CdbehandelddoorDesc = 'CDBEHANDELDDOOR_DESC',
  CdbestlandAsc = 'CDBESTLAND_ASC',
  CdbestlandDesc = 'CDBESTLAND_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  Cdbetwijze1Asc = 'CDBETWIJZE1_ASC',
  Cdbetwijze1Desc = 'CDBETWIJZE1_DESC',
  Cdbetwijze2Asc = 'CDBETWIJZE2_ASC',
  Cdbetwijze2Desc = 'CDBETWIJZE2_DESC',
  CdbtwAsc = 'CDBTW_ASC',
  CdbtwDesc = 'CDBTW_DESC',
  CddagboekAsc = 'CDDAGBOEK_ASC',
  CddagboekDesc = 'CDDAGBOEK_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CddebiteurFactAsc = 'CDDEBITEUR_FACT_ASC',
  CddebiteurFactDesc = 'CDDEBITEUR_FACT_DESC',
  CddossierAsc = 'CDDOSSIER_ASC',
  CddossierDesc = 'CDDOSSIER_DESC',
  CdexpediteurAsc = 'CDEXPEDITEUR_ASC',
  CdexpediteurDesc = 'CDEXPEDITEUR_DESC',
  CdfactuurAsc = 'CDFACTUUR_ASC',
  CdfactuurDesc = 'CDFACTUUR_DESC',
  CdfiatteurAsc = 'CDFIATTEUR_ASC',
  CdfiatteurDesc = 'CDFIATTEUR_DESC',
  CdkostenplaatsAsc = 'CDKOSTENPLAATS_ASC',
  CdkostenplaatsDesc = 'CDKOSTENPLAATS_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdloonwerkAsc = 'CDLOONWERK_ASC',
  CdloonwerkDesc = 'CDLOONWERK_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdprojectAsc = 'CDPROJECT_ASC',
  CdprojectDesc = 'CDPROJECT_DESC',
  CdsoortAsc = 'CDSOORT_ASC',
  CdsoortDesc = 'CDSOORT_DESC',
  CdstelselAsc = 'CDSTELSEL_ASC',
  CdstelselDesc = 'CDSTELSEL_DESC',
  CdstroomAsc = 'CDSTROOM_ASC',
  CdstroomDesc = 'CDSTROOM_DESC',
  CdtypeAsc = 'CDTYPE_ASC',
  CdtypeDesc = 'CDTYPE_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  CdverkeerAsc = 'CDVERKEER_ASC',
  CdverkeerDesc = 'CDVERKEER_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  CdvervoerAsc = 'CDVERVOER_ASC',
  CdvervoerDesc = 'CDVERVOER_DESC',
  CdverzamelAsc = 'CDVERZAMEL_ASC',
  CdverzamelDesc = 'CDVERZAMEL_DESC',
  FacturerenAsc = 'FACTUREREN_ASC',
  FacturerenDesc = 'FACTUREREN_DESC',
  FactuurdatumAsc = 'FACTUURDATUM_ASC',
  FactuurdatumDesc = 'FACTUURDATUM_DESC',
  FactuurnummerAsc = 'FACTUURNUMMER_ASC',
  FactuurnummerDesc = 'FACTUURNUMMER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  GebruikerAsc = 'GEBRUIKER_ASC',
  GebruikerDesc = 'GEBRUIKER_DESC',
  GefiatteerdAsc = 'GEFIATTEERD_ASC',
  GefiatteerdDesc = 'GEFIATTEERD_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KredbeppercAsc = 'KREDBEPPERC_ASC',
  KredbeppercDesc = 'KREDBEPPERC_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  LidnrBijInkorgAsc = 'LIDNR_BIJ_INKORG_ASC',
  LidnrBijInkorgDesc = 'LIDNR_BIJ_INKORG_DESC',
  MagazijnbonAsc = 'MAGAZIJNBON_ASC',
  MagazijnbonDesc = 'MAGAZIJNBON_DESC',
  MargeblokkadeAsc = 'MARGEBLOKKADE_ASC',
  MargeblokkadeDesc = 'MARGEBLOKKADE_DESC',
  Natural = 'NATURAL',
  OffertenummerAsc = 'OFFERTENUMMER_ASC',
  OffertenummerDesc = 'OFFERTENUMMER_DESC',
  OffertevolgnrAsc = 'OFFERTEVOLGNR_ASC',
  OffertevolgnrDesc = 'OFFERTEVOLGNR_DESC',
  OpdrachtdatumAsc = 'OPDRACHTDATUM_ASC',
  OpdrachtdatumDesc = 'OPDRACHTDATUM_DESC',
  OrdbevtellerAsc = 'ORDBEVTELLER_ASC',
  OrdbevtellerDesc = 'ORDBEVTELLER_DESC',
  PakbonAsc = 'PAKBON_ASC',
  PakbonDesc = 'PAKBON_DESC',
  PercgrekAsc = 'PERCGREK_ASC',
  PercgrekDesc = 'PERCGREK_DESC',
  PeriodeAsc = 'PERIODE_ASC',
  PeriodeDesc = 'PERIODE_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  ProjFacturerenAsc = 'PROJ_FACTUREREN_ASC',
  ProjFacturerenDesc = 'PROJ_FACTUREREN_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SubadresAsc = 'SUBADRES_ASC',
  SubadresDesc = 'SUBADRES_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  TransactieAsc = 'TRANSACTIE_ASC',
  TransactieDesc = 'TRANSACTIE_DESC',
  VertegenwoordigerAsc = 'VERTEGENWOORDIGER_ASC',
  VertegenwoordigerDesc = 'VERTEGENWOORDIGER_DESC',
  VervolgopdrachtvanAsc = 'VERVOLGOPDRACHTVAN_ASC',
  VervolgopdrachtvanDesc = 'VERVOLGOPDRACHTVAN_DESC',
  VerwerktboAsc = 'VERWERKTBO_ASC',
  VerwerktboDesc = 'VERWERKTBO_DESC',
  VerwerktvrdAsc = 'VERWERKTVRD_ASC',
  VerwerktvrdDesc = 'VERWERKTVRD_DESC',
  VrachtgewichtAsc = 'VRACHTGEWICHT_ASC',
  VrachtgewichtDesc = 'VRACHTGEWICHT_DESC'
}

/** A filter to be used against many `Factopdrachtregel` object types. All fields are combined with a logical ‘and.’ */
export type FactureeropdrachtToManyFactopdrachtregelFilter = {
  /** Every related `Factopdrachtregel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FactopdrachtregelFilter>;
  /** No related `Factopdrachtregel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FactopdrachtregelFilter>;
  /** Some related `Factopdrachtregel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FactopdrachtregelFilter>;
};

/** A filter to be used against many `SensorOrder` object types. All fields are combined with a logical ‘and.’ */
export type FactureeropdrachtToManySensorOrderFilter = {
  /** Every related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorOrderFilter>;
  /** No related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorOrderFilter>;
  /** Some related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorOrderFilter>;
};

/** A connection to a list of `Factureeropdracht` values. */
export type FactureeropdrachtsConnection = {
  __typename?: 'FactureeropdrachtsConnection';
  /** A list of edges which contains the `Factureeropdracht` and cursor to aid in pagination. */
  edges: Array<FactureeropdrachtsEdge>;
  /** A list of `Factureeropdracht` objects. */
  nodes: Array<Factureeropdracht>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Factureeropdracht` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Factureeropdracht` edge in the connection. */
export type FactureeropdrachtsEdge = {
  __typename?: 'FactureeropdrachtsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Factureeropdracht` at the end of the edge. */
  node: Factureeropdracht;
};

/** Methods to use when ordering `Factureeropdracht`. */
export enum FactureeropdrachtsOrderBy {
  AantalcolliAsc = 'AANTALCOLLI_ASC',
  AantalcolliDesc = 'AANTALCOLLI_DESC',
  AantalpalletsAsc = 'AANTALPALLETS_ASC',
  AantalpalletsDesc = 'AANTALPALLETS_DESC',
  AbonnementAsc = 'ABONNEMENT_ASC',
  AbonnementDesc = 'ABONNEMENT_DESC',
  AdresAsc = 'ADRES_ASC',
  AdresDesc = 'ADRES_DESC',
  AfdruktellerAsc = 'AFDRUKTELLER_ASC',
  AfdruktellerDesc = 'AFDRUKTELLER_DESC',
  BehandelddoorAsc = 'BEHANDELDDOOR_ASC',
  BehandelddoorDesc = 'BEHANDELDDOOR_DESC',
  Betaaldbedrag1Asc = 'BETAALDBEDRAG1_ASC',
  Betaaldbedrag1Desc = 'BETAALDBEDRAG1_DESC',
  Betaaldbedrag2Asc = 'BETAALDBEDRAG2_ASC',
  Betaaldbedrag2Desc = 'BETAALDBEDRAG2_DESC',
  BetkenmerkAsc = 'BETKENMERK_ASC',
  BetkenmerkDesc = 'BETKENMERK_DESC',
  BetkortpercAsc = 'BETKORTPERC_ASC',
  BetkortpercDesc = 'BETKORTPERC_DESC',
  BlokkerenAsc = 'BLOKKEREN_ASC',
  BlokkerenDesc = 'BLOKKEREN_DESC',
  BoekjaarAsc = 'BOEKJAAR_ASC',
  BoekjaarDesc = 'BOEKJAAR_DESC',
  BronAsc = 'BRON_ASC',
  BronDesc = 'BRON_DESC',
  BtwopkredbAsc = 'BTWOPKREDB_ASC',
  BtwopkredbDesc = 'BTWOPKREDB_DESC',
  BtwscenarioAsc = 'BTWSCENARIO_ASC',
  BtwscenarioDesc = 'BTWSCENARIO_DESC',
  CdadresAsc = 'CDADRES_ASC',
  CdadresDesc = 'CDADRES_DESC',
  CdbehandelddoorAsc = 'CDBEHANDELDDOOR_ASC',
  CdbehandelddoorDesc = 'CDBEHANDELDDOOR_DESC',
  CdbestlandAsc = 'CDBESTLAND_ASC',
  CdbestlandDesc = 'CDBESTLAND_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  Cdbetwijze1Asc = 'CDBETWIJZE1_ASC',
  Cdbetwijze1Desc = 'CDBETWIJZE1_DESC',
  Cdbetwijze2Asc = 'CDBETWIJZE2_ASC',
  Cdbetwijze2Desc = 'CDBETWIJZE2_DESC',
  CdbtwAsc = 'CDBTW_ASC',
  CdbtwDesc = 'CDBTW_DESC',
  CddagboekAsc = 'CDDAGBOEK_ASC',
  CddagboekDesc = 'CDDAGBOEK_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CddebiteurFactAsc = 'CDDEBITEUR_FACT_ASC',
  CddebiteurFactDesc = 'CDDEBITEUR_FACT_DESC',
  CddossierAsc = 'CDDOSSIER_ASC',
  CddossierDesc = 'CDDOSSIER_DESC',
  CdexpediteurAsc = 'CDEXPEDITEUR_ASC',
  CdexpediteurDesc = 'CDEXPEDITEUR_DESC',
  CdfactuurAsc = 'CDFACTUUR_ASC',
  CdfactuurDesc = 'CDFACTUUR_DESC',
  CdfiatteurAsc = 'CDFIATTEUR_ASC',
  CdfiatteurDesc = 'CDFIATTEUR_DESC',
  CdkostenplaatsAsc = 'CDKOSTENPLAATS_ASC',
  CdkostenplaatsDesc = 'CDKOSTENPLAATS_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdloonwerkAsc = 'CDLOONWERK_ASC',
  CdloonwerkDesc = 'CDLOONWERK_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdprojectAsc = 'CDPROJECT_ASC',
  CdprojectDesc = 'CDPROJECT_DESC',
  CdsoortAsc = 'CDSOORT_ASC',
  CdsoortDesc = 'CDSOORT_DESC',
  CdstelselAsc = 'CDSTELSEL_ASC',
  CdstelselDesc = 'CDSTELSEL_DESC',
  CdstroomAsc = 'CDSTROOM_ASC',
  CdstroomDesc = 'CDSTROOM_DESC',
  CdtypeAsc = 'CDTYPE_ASC',
  CdtypeDesc = 'CDTYPE_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  CdverkeerAsc = 'CDVERKEER_ASC',
  CdverkeerDesc = 'CDVERKEER_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  CdvervoerAsc = 'CDVERVOER_ASC',
  CdvervoerDesc = 'CDVERVOER_DESC',
  CdverzamelAsc = 'CDVERZAMEL_ASC',
  CdverzamelDesc = 'CDVERZAMEL_DESC',
  DebiteurByCddebiteurAanmaakdatumAsc = 'DEBITEUR_BY_CDDEBITEUR__AANMAAKDATUM_ASC',
  DebiteurByCddebiteurAanmaakdatumDesc = 'DEBITEUR_BY_CDDEBITEUR__AANMAAKDATUM_DESC',
  DebiteurByCddebiteurBerekenordkostAsc = 'DEBITEUR_BY_CDDEBITEUR__BEREKENORDKOST_ASC',
  DebiteurByCddebiteurBerekenordkostDesc = 'DEBITEUR_BY_CDDEBITEUR__BEREKENORDKOST_DESC',
  DebiteurByCddebiteurBtwnummerAsc = 'DEBITEUR_BY_CDDEBITEUR__BTWNUMMER_ASC',
  DebiteurByCddebiteurBtwnummerDesc = 'DEBITEUR_BY_CDDEBITEUR__BTWNUMMER_DESC',
  DebiteurByCddebiteurBtwscenarioAsc = 'DEBITEUR_BY_CDDEBITEUR__BTWSCENARIO_ASC',
  DebiteurByCddebiteurBtwscenarioDesc = 'DEBITEUR_BY_CDDEBITEUR__BTWSCENARIO_DESC',
  DebiteurByCddebiteurBtwExInclAsc = 'DEBITEUR_BY_CDDEBITEUR__BTW_EX_INCL_ASC',
  DebiteurByCddebiteurBtwExInclDesc = 'DEBITEUR_BY_CDDEBITEUR__BTW_EX_INCL_DESC',
  DebiteurByCddebiteurCdaanmanenAsc = 'DEBITEUR_BY_CDDEBITEUR__CDAANMANEN_ASC',
  DebiteurByCddebiteurCdaanmanenDesc = 'DEBITEUR_BY_CDDEBITEUR__CDAANMANEN_DESC',
  DebiteurByCddebiteurCdbetcondAsc = 'DEBITEUR_BY_CDDEBITEUR__CDBETCOND_ASC',
  DebiteurByCddebiteurCdbetcondDesc = 'DEBITEUR_BY_CDDEBITEUR__CDBETCOND_DESC',
  DebiteurByCddebiteurCdbtwberekenenAsc = 'DEBITEUR_BY_CDDEBITEUR__CDBTWBEREKENEN_ASC',
  DebiteurByCddebiteurCdbtwberekenenDesc = 'DEBITEUR_BY_CDDEBITEUR__CDBTWBEREKENEN_DESC',
  DebiteurByCddebiteurCddebiteurAsc = 'DEBITEUR_BY_CDDEBITEUR__CDDEBITEUR_ASC',
  DebiteurByCddebiteurCddebiteurDesc = 'DEBITEUR_BY_CDDEBITEUR__CDDEBITEUR_DESC',
  DebiteurByCddebiteurCddebiteurInkorgAsc = 'DEBITEUR_BY_CDDEBITEUR__CDDEBITEUR_INKORG_ASC',
  DebiteurByCddebiteurCddebiteurInkorgDesc = 'DEBITEUR_BY_CDDEBITEUR__CDDEBITEUR_INKORG_DESC',
  DebiteurByCddebiteurCdgoedcodeAsc = 'DEBITEUR_BY_CDDEBITEUR__CDGOEDCODE_ASC',
  DebiteurByCddebiteurCdgoedcodeDesc = 'DEBITEUR_BY_CDDEBITEUR__CDGOEDCODE_DESC',
  DebiteurByCddebiteurCdgrbrekeningAsc = 'DEBITEUR_BY_CDDEBITEUR__CDGRBREKENING_ASC',
  DebiteurByCddebiteurCdgrbrekeningDesc = 'DEBITEUR_BY_CDDEBITEUR__CDGRBREKENING_DESC',
  DebiteurByCddebiteurCdjournaalAsc = 'DEBITEUR_BY_CDDEBITEUR__CDJOURNAAL_ASC',
  DebiteurByCddebiteurCdjournaalDesc = 'DEBITEUR_BY_CDDEBITEUR__CDJOURNAAL_DESC',
  DebiteurByCddebiteurCdkredbepAsc = 'DEBITEUR_BY_CDDEBITEUR__CDKREDBEP_ASC',
  DebiteurByCddebiteurCdkredbepDesc = 'DEBITEUR_BY_CDDEBITEUR__CDKREDBEP_DESC',
  DebiteurByCddebiteurCdlandAsc = 'DEBITEUR_BY_CDDEBITEUR__CDLAND_ASC',
  DebiteurByCddebiteurCdlandDesc = 'DEBITEUR_BY_CDDEBITEUR__CDLAND_DESC',
  DebiteurByCddebiteurCdlevcondAsc = 'DEBITEUR_BY_CDDEBITEUR__CDLEVCOND_ASC',
  DebiteurByCddebiteurCdlevcondDesc = 'DEBITEUR_BY_CDDEBITEUR__CDLEVCOND_DESC',
  DebiteurByCddebiteurCdprijslijstAsc = 'DEBITEUR_BY_CDDEBITEUR__CDPRIJSLIJST_ASC',
  DebiteurByCddebiteurCdprijslijstDesc = 'DEBITEUR_BY_CDDEBITEUR__CDPRIJSLIJST_DESC',
  DebiteurByCddebiteurCdrelatieAsc = 'DEBITEUR_BY_CDDEBITEUR__CDRELATIE_ASC',
  DebiteurByCddebiteurCdrelatieDesc = 'DEBITEUR_BY_CDDEBITEUR__CDRELATIE_DESC',
  DebiteurByCddebiteurCdstelselAsc = 'DEBITEUR_BY_CDDEBITEUR__CDSTELSEL_ASC',
  DebiteurByCddebiteurCdstelselDesc = 'DEBITEUR_BY_CDDEBITEUR__CDSTELSEL_DESC',
  DebiteurByCddebiteurCdstroomAsc = 'DEBITEUR_BY_CDDEBITEUR__CDSTROOM_ASC',
  DebiteurByCddebiteurCdstroomDesc = 'DEBITEUR_BY_CDDEBITEUR__CDSTROOM_DESC',
  DebiteurByCddebiteurCdtaalAsc = 'DEBITEUR_BY_CDDEBITEUR__CDTAAL_ASC',
  DebiteurByCddebiteurCdtaalDesc = 'DEBITEUR_BY_CDDEBITEUR__CDTAAL_DESC',
  DebiteurByCddebiteurCdtypeAsc = 'DEBITEUR_BY_CDDEBITEUR__CDTYPE_ASC',
  DebiteurByCddebiteurCdtypeDesc = 'DEBITEUR_BY_CDDEBITEUR__CDTYPE_DESC',
  DebiteurByCddebiteurCdvalutaAsc = 'DEBITEUR_BY_CDDEBITEUR__CDVALUTA_ASC',
  DebiteurByCddebiteurCdvalutaDesc = 'DEBITEUR_BY_CDDEBITEUR__CDVALUTA_DESC',
  DebiteurByCddebiteurCdverkeerAsc = 'DEBITEUR_BY_CDDEBITEUR__CDVERKEER_ASC',
  DebiteurByCddebiteurCdverkeerDesc = 'DEBITEUR_BY_CDDEBITEUR__CDVERKEER_DESC',
  DebiteurByCddebiteurCdvertAsc = 'DEBITEUR_BY_CDDEBITEUR__CDVERT_ASC',
  DebiteurByCddebiteurCdvertDesc = 'DEBITEUR_BY_CDDEBITEUR__CDVERT_DESC',
  DebiteurByCddebiteurCdvervoerAsc = 'DEBITEUR_BY_CDDEBITEUR__CDVERVOER_ASC',
  DebiteurByCddebiteurCdvervoerDesc = 'DEBITEUR_BY_CDDEBITEUR__CDVERVOER_DESC',
  DebiteurByCddebiteurCdverzamelAsc = 'DEBITEUR_BY_CDDEBITEUR__CDVERZAMEL_ASC',
  DebiteurByCddebiteurCdverzamelDesc = 'DEBITEUR_BY_CDDEBITEUR__CDVERZAMEL_DESC',
  DebiteurByCddebiteurControleBetkenmerkAsc = 'DEBITEUR_BY_CDDEBITEUR__CONTROLE_BETKENMERK_ASC',
  DebiteurByCddebiteurControleBetkenmerkDesc = 'DEBITEUR_BY_CDDEBITEUR__CONTROLE_BETKENMERK_DESC',
  DebiteurByCddebiteurDatumkvkAsc = 'DEBITEUR_BY_CDDEBITEUR__DATUMKVK_ASC',
  DebiteurByCddebiteurDatumkvkDesc = 'DEBITEUR_BY_CDDEBITEUR__DATUMKVK_DESC',
  DebiteurByCddebiteurDatumltstewijzAsc = 'DEBITEUR_BY_CDDEBITEUR__DATUMLTSTEWIJZ_ASC',
  DebiteurByCddebiteurDatumltstewijzDesc = 'DEBITEUR_BY_CDDEBITEUR__DATUMLTSTEWIJZ_DESC',
  DebiteurByCddebiteurDatumverifAsc = 'DEBITEUR_BY_CDDEBITEUR__DATUMVERIF_ASC',
  DebiteurByCddebiteurDatumverifDesc = 'DEBITEUR_BY_CDDEBITEUR__DATUMVERIF_DESC',
  DebiteurByCddebiteurEmailAsc = 'DEBITEUR_BY_CDDEBITEUR__EMAIL_ASC',
  DebiteurByCddebiteurEmailDesc = 'DEBITEUR_BY_CDDEBITEUR__EMAIL_DESC',
  DebiteurByCddebiteurGuidItemAsc = 'DEBITEUR_BY_CDDEBITEUR__GUID_ITEM_ASC',
  DebiteurByCddebiteurGuidItemDesc = 'DEBITEUR_BY_CDDEBITEUR__GUID_ITEM_DESC',
  DebiteurByCddebiteurHomepageAsc = 'DEBITEUR_BY_CDDEBITEUR__HOMEPAGE_ASC',
  DebiteurByCddebiteurHomepageDesc = 'DEBITEUR_BY_CDDEBITEUR__HOMEPAGE_DESC',
  DebiteurByCddebiteurInFactoringAsc = 'DEBITEUR_BY_CDDEBITEUR__IN_FACTORING_ASC',
  DebiteurByCddebiteurInFactoringDesc = 'DEBITEUR_BY_CDDEBITEUR__IN_FACTORING_DESC',
  DebiteurByCddebiteurIsinkooporgAsc = 'DEBITEUR_BY_CDDEBITEUR__ISINKOOPORG_ASC',
  DebiteurByCddebiteurIsinkooporgDesc = 'DEBITEUR_BY_CDDEBITEUR__ISINKOOPORG_DESC',
  DebiteurByCddebiteurKortpercAsc = 'DEBITEUR_BY_CDDEBITEUR__KORTPERC_ASC',
  DebiteurByCddebiteurKortpercDesc = 'DEBITEUR_BY_CDDEBITEUR__KORTPERC_DESC',
  DebiteurByCddebiteurKredietlimietAsc = 'DEBITEUR_BY_CDDEBITEUR__KREDIETLIMIET_ASC',
  DebiteurByCddebiteurKredietlimietDesc = 'DEBITEUR_BY_CDDEBITEUR__KREDIETLIMIET_DESC',
  DebiteurByCddebiteurLidnrBijInkorgAsc = 'DEBITEUR_BY_CDDEBITEUR__LIDNR_BIJ_INKORG_ASC',
  DebiteurByCddebiteurLidnrBijInkorgDesc = 'DEBITEUR_BY_CDDEBITEUR__LIDNR_BIJ_INKORG_DESC',
  DebiteurByCddebiteurNaamstraatAsc = 'DEBITEUR_BY_CDDEBITEUR__NAAMSTRAAT_ASC',
  DebiteurByCddebiteurNaamstraatDesc = 'DEBITEUR_BY_CDDEBITEUR__NAAMSTRAAT_DESC',
  DebiteurByCddebiteurNaamAsc = 'DEBITEUR_BY_CDDEBITEUR__NAAM_ASC',
  DebiteurByCddebiteurNaamDesc = 'DEBITEUR_BY_CDDEBITEUR__NAAM_DESC',
  DebiteurByCddebiteurNummerkvkAsc = 'DEBITEUR_BY_CDDEBITEUR__NUMMERKVK_ASC',
  DebiteurByCddebiteurNummerkvkDesc = 'DEBITEUR_BY_CDDEBITEUR__NUMMERKVK_DESC',
  DebiteurByCddebiteurOndernemersnrAsc = 'DEBITEUR_BY_CDDEBITEUR__ONDERNEMERSNR_ASC',
  DebiteurByCddebiteurOndernemersnrDesc = 'DEBITEUR_BY_CDDEBITEUR__ONDERNEMERSNR_DESC',
  DebiteurByCddebiteurOntvBorderelAsc = 'DEBITEUR_BY_CDDEBITEUR__ONTV_BORDEREL_ASC',
  DebiteurByCddebiteurOntvBorderelDesc = 'DEBITEUR_BY_CDDEBITEUR__ONTV_BORDEREL_DESC',
  DebiteurByCddebiteurOntvFactIpvLidAsc = 'DEBITEUR_BY_CDDEBITEUR__ONTV_FACT_IPV_LID_ASC',
  DebiteurByCddebiteurOntvFactIpvLidDesc = 'DEBITEUR_BY_CDDEBITEUR__ONTV_FACT_IPV_LID_DESC',
  DebiteurByCddebiteurOverhIdNrAsc = 'DEBITEUR_BY_CDDEBITEUR__OVERH_ID_NR_ASC',
  DebiteurByCddebiteurOverhIdNrDesc = 'DEBITEUR_BY_CDDEBITEUR__OVERH_ID_NR_DESC',
  DebiteurByCddebiteurPersoonAsc = 'DEBITEUR_BY_CDDEBITEUR__PERSOON_ASC',
  DebiteurByCddebiteurPersoonDesc = 'DEBITEUR_BY_CDDEBITEUR__PERSOON_DESC',
  DebiteurByCddebiteurPlaatskvkAsc = 'DEBITEUR_BY_CDDEBITEUR__PLAATSKVK_ASC',
  DebiteurByCddebiteurPlaatskvkDesc = 'DEBITEUR_BY_CDDEBITEUR__PLAATSKVK_DESC',
  DebiteurByCddebiteurPostcodeAsc = 'DEBITEUR_BY_CDDEBITEUR__POSTCODE_ASC',
  DebiteurByCddebiteurPostcodeDesc = 'DEBITEUR_BY_CDDEBITEUR__POSTCODE_DESC',
  DebiteurByCddebiteurStatusAsc = 'DEBITEUR_BY_CDDEBITEUR__STATUS_ASC',
  DebiteurByCddebiteurStatusDesc = 'DEBITEUR_BY_CDDEBITEUR__STATUS_DESC',
  DebiteurByCddebiteurStraatAsc = 'DEBITEUR_BY_CDDEBITEUR__STRAAT_ASC',
  DebiteurByCddebiteurStraatDesc = 'DEBITEUR_BY_CDDEBITEUR__STRAAT_DESC',
  DebiteurByCddebiteurSysCreateAsc = 'DEBITEUR_BY_CDDEBITEUR__SYS_CREATE_ASC',
  DebiteurByCddebiteurSysCreateDesc = 'DEBITEUR_BY_CDDEBITEUR__SYS_CREATE_DESC',
  DebiteurByCddebiteurSysUpdateAsc = 'DEBITEUR_BY_CDDEBITEUR__SYS_UPDATE_ASC',
  DebiteurByCddebiteurSysUpdateDesc = 'DEBITEUR_BY_CDDEBITEUR__SYS_UPDATE_DESC',
  DebiteurByCddebiteurTelebankfactAsc = 'DEBITEUR_BY_CDDEBITEUR__TELEBANKFACT_ASC',
  DebiteurByCddebiteurTelebankfactDesc = 'DEBITEUR_BY_CDDEBITEUR__TELEBANKFACT_DESC',
  DebiteurByCddebiteurTelefaxAsc = 'DEBITEUR_BY_CDDEBITEUR__TELEFAX_ASC',
  DebiteurByCddebiteurTelefaxDesc = 'DEBITEUR_BY_CDDEBITEUR__TELEFAX_DESC',
  DebiteurByCddebiteurTelefoonmobielAsc = 'DEBITEUR_BY_CDDEBITEUR__TELEFOONMOBIEL_ASC',
  DebiteurByCddebiteurTelefoonmobielDesc = 'DEBITEUR_BY_CDDEBITEUR__TELEFOONMOBIEL_DESC',
  DebiteurByCddebiteurTelefoonAsc = 'DEBITEUR_BY_CDDEBITEUR__TELEFOON_ASC',
  DebiteurByCddebiteurTelefoonDesc = 'DEBITEUR_BY_CDDEBITEUR__TELEFOON_DESC',
  DebiteurByCddebiteurVertegenwoordigerAsc = 'DEBITEUR_BY_CDDEBITEUR__VERTEGENWOORDIGER_ASC',
  DebiteurByCddebiteurVertegenwoordigerDesc = 'DEBITEUR_BY_CDDEBITEUR__VERTEGENWOORDIGER_DESC',
  DebiteurByCddebiteurWoonplaatsAsc = 'DEBITEUR_BY_CDDEBITEUR__WOONPLAATS_ASC',
  DebiteurByCddebiteurWoonplaatsDesc = 'DEBITEUR_BY_CDDEBITEUR__WOONPLAATS_DESC',
  DebiteurByCddebiteurZoeknaamAsc = 'DEBITEUR_BY_CDDEBITEUR__ZOEKNAAM_ASC',
  DebiteurByCddebiteurZoeknaamDesc = 'DEBITEUR_BY_CDDEBITEUR__ZOEKNAAM_DESC',
  FactopdrachtregelsByFactuuropdrachtCountAsc = 'FACTOPDRACHTREGELS_BY_FACTUUROPDRACHT__COUNT_ASC',
  FactopdrachtregelsByFactuuropdrachtCountDesc = 'FACTOPDRACHTREGELS_BY_FACTUUROPDRACHT__COUNT_DESC',
  FacturerenAsc = 'FACTUREREN_ASC',
  FacturerenDesc = 'FACTUREREN_DESC',
  FactuurdatumAsc = 'FACTUURDATUM_ASC',
  FactuurdatumDesc = 'FACTUURDATUM_DESC',
  FactuurnummerAsc = 'FACTUURNUMMER_ASC',
  FactuurnummerDesc = 'FACTUURNUMMER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  GebruikerAsc = 'GEBRUIKER_ASC',
  GebruikerDesc = 'GEBRUIKER_DESC',
  GefiatteerdAsc = 'GEFIATTEERD_ASC',
  GefiatteerdDesc = 'GEFIATTEERD_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KredbeppercAsc = 'KREDBEPPERC_ASC',
  KredbeppercDesc = 'KREDBEPPERC_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  LidnrBijInkorgAsc = 'LIDNR_BIJ_INKORG_ASC',
  LidnrBijInkorgDesc = 'LIDNR_BIJ_INKORG_DESC',
  MagazijnbonAsc = 'MAGAZIJNBON_ASC',
  MagazijnbonDesc = 'MAGAZIJNBON_DESC',
  MargeblokkadeAsc = 'MARGEBLOKKADE_ASC',
  MargeblokkadeDesc = 'MARGEBLOKKADE_DESC',
  Natural = 'NATURAL',
  OffertenummerAsc = 'OFFERTENUMMER_ASC',
  OffertenummerDesc = 'OFFERTENUMMER_DESC',
  OffertevolgnrAsc = 'OFFERTEVOLGNR_ASC',
  OffertevolgnrDesc = 'OFFERTEVOLGNR_DESC',
  OpdrachtdatumAsc = 'OPDRACHTDATUM_ASC',
  OpdrachtdatumDesc = 'OPDRACHTDATUM_DESC',
  OrdbevtellerAsc = 'ORDBEVTELLER_ASC',
  OrdbevtellerDesc = 'ORDBEVTELLER_DESC',
  PakbonAsc = 'PAKBON_ASC',
  PakbonDesc = 'PAKBON_DESC',
  PercgrekAsc = 'PERCGREK_ASC',
  PercgrekDesc = 'PERCGREK_DESC',
  PeriodeAsc = 'PERIODE_ASC',
  PeriodeDesc = 'PERIODE_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProjFacturerenAsc = 'PROJ_FACTUREREN_ASC',
  ProjFacturerenDesc = 'PROJ_FACTUREREN_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  SensorOrdersByFactuuropdrachtCountAsc = 'SENSOR_ORDERS_BY_FACTUUROPDRACHT__COUNT_ASC',
  SensorOrdersByFactuuropdrachtCountDesc = 'SENSOR_ORDERS_BY_FACTUUROPDRACHT__COUNT_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SubadresAsc = 'SUBADRES_ASC',
  SubadresDesc = 'SUBADRES_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  TransactieAsc = 'TRANSACTIE_ASC',
  TransactieDesc = 'TRANSACTIE_DESC',
  VertegenwoordigerAsc = 'VERTEGENWOORDIGER_ASC',
  VertegenwoordigerDesc = 'VERTEGENWOORDIGER_DESC',
  VervolgopdrachtvanAsc = 'VERVOLGOPDRACHTVAN_ASC',
  VervolgopdrachtvanDesc = 'VERVOLGOPDRACHTVAN_DESC',
  VerwerktboAsc = 'VERWERKTBO_ASC',
  VerwerktboDesc = 'VERWERKTBO_DESC',
  VerwerktvrdAsc = 'VERWERKTVRD_ASC',
  VerwerktvrdDesc = 'VERWERKTVRD_DESC',
  VrachtgewichtAsc = 'VRACHTGEWICHT_ASC',
  VrachtgewichtDesc = 'VRACHTGEWICHT_DESC'
}

export type Factuur = Node & {
  __typename?: 'Factuur';
  checked: Scalars['Boolean']['output'];
  checkedId?: Maybe<Scalars['Int']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  factuuropdracht: Scalars['String']['output'];
  filename?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  sent: Scalars['Boolean']['output'];
  sentId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userByCheckedId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userBySentId?: Maybe<User>;
};

/** A condition to be used against `Factuur` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FactuurCondition = {
  /** Checks for equality with the object’s `checked` field. */
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `checkedId` field. */
  checkedId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filename` field. */
  filename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sent` field. */
  sent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `sentId` field. */
  sentId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Factuur` object types. All fields are combined with a logical ‘and.’ */
export type FactuurFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FactuurFilter>>;
  /** Filter by the object’s `checked` field. */
  checked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `checkedId` field. */
  checkedId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filename` field. */
  filename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FactuurFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FactuurFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sent` field. */
  sent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `sentId` field. */
  sentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByCheckedId` relation. */
  userByCheckedId?: InputMaybe<UserFilter>;
  /** A related `userByCheckedId` exists. */
  userByCheckedIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userBySentId` relation. */
  userBySentId?: InputMaybe<UserFilter>;
  /** A related `userBySentId` exists. */
  userBySentIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Factuur` */
export type FactuurInput = {
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  checkedId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  factuuropdracht: Scalars['String']['input'];
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  sent?: InputMaybe<Scalars['Boolean']['input']>;
  sentId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Factuur`. Fields that are set will be updated. */
export type FactuurPatch = {
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  checkedId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sent?: InputMaybe<Scalars['Boolean']['input']>;
  sentId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Factuur` values. */
export type FactuursConnection = {
  __typename?: 'FactuursConnection';
  /** A list of edges which contains the `Factuur` and cursor to aid in pagination. */
  edges: Array<FactuursEdge>;
  /** A list of `Factuur` objects. */
  nodes: Array<Factuur>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Factuur` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Factuur` edge in the connection. */
export type FactuursEdge = {
  __typename?: 'FactuursEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Factuur` at the end of the edge. */
  node: Factuur;
};

/** Methods to use when ordering `Factuur`. */
export enum FactuursOrderBy {
  CheckedAsc = 'CHECKED_ASC',
  CheckedDesc = 'CHECKED_DESC',
  CheckedIdAsc = 'CHECKED_ID_ASC',
  CheckedIdDesc = 'CHECKED_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FilenameAsc = 'FILENAME_ASC',
  FilenameDesc = 'FILENAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SentAsc = 'SENT_ASC',
  SentDesc = 'SENT_DESC',
  SentIdAsc = 'SENT_ID_ASC',
  SentIdDesc = 'SENT_ID_DESC',
  UserByCheckedIdCreatedAsc = 'USER_BY_CHECKED_ID__CREATED_ASC',
  UserByCheckedIdCreatedDesc = 'USER_BY_CHECKED_ID__CREATED_DESC',
  UserByCheckedIdFullnameAsc = 'USER_BY_CHECKED_ID__FULLNAME_ASC',
  UserByCheckedIdFullnameDesc = 'USER_BY_CHECKED_ID__FULLNAME_DESC',
  UserByCheckedIdGroupIdAsc = 'USER_BY_CHECKED_ID__GROUP_ID_ASC',
  UserByCheckedIdGroupIdDesc = 'USER_BY_CHECKED_ID__GROUP_ID_DESC',
  UserByCheckedIdHolidayStartBalanceAsc = 'USER_BY_CHECKED_ID__HOLIDAY_START_BALANCE_ASC',
  UserByCheckedIdHolidayStartBalanceDesc = 'USER_BY_CHECKED_ID__HOLIDAY_START_BALANCE_DESC',
  UserByCheckedIdIdAsc = 'USER_BY_CHECKED_ID__ID_ASC',
  UserByCheckedIdIdDesc = 'USER_BY_CHECKED_ID__ID_DESC',
  UserByCheckedIdInitialsAsc = 'USER_BY_CHECKED_ID__INITIALS_ASC',
  UserByCheckedIdInitialsDesc = 'USER_BY_CHECKED_ID__INITIALS_DESC',
  UserByCheckedIdModifiedAsc = 'USER_BY_CHECKED_ID__MODIFIED_ASC',
  UserByCheckedIdModifiedDesc = 'USER_BY_CHECKED_ID__MODIFIED_DESC',
  UserByCheckedIdOvertimeStartBalanceAsc = 'USER_BY_CHECKED_ID__OVERTIME_START_BALANCE_ASC',
  UserByCheckedIdOvertimeStartBalanceDesc = 'USER_BY_CHECKED_ID__OVERTIME_START_BALANCE_DESC',
  UserByCheckedIdPasswordAsc = 'USER_BY_CHECKED_ID__PASSWORD_ASC',
  UserByCheckedIdPasswordDesc = 'USER_BY_CHECKED_ID__PASSWORD_DESC',
  UserByCheckedIdUrlAsc = 'USER_BY_CHECKED_ID__URL_ASC',
  UserByCheckedIdUrlDesc = 'USER_BY_CHECKED_ID__URL_DESC',
  UserByCheckedIdUsernameAsc = 'USER_BY_CHECKED_ID__USERNAME_ASC',
  UserByCheckedIdUsernameDesc = 'USER_BY_CHECKED_ID__USERNAME_DESC',
  UserByCheckedIdWeeklyHoursFullAccessAsc = 'USER_BY_CHECKED_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByCheckedIdWeeklyHoursFullAccessDesc = 'USER_BY_CHECKED_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserBySentIdCreatedAsc = 'USER_BY_SENT_ID__CREATED_ASC',
  UserBySentIdCreatedDesc = 'USER_BY_SENT_ID__CREATED_DESC',
  UserBySentIdFullnameAsc = 'USER_BY_SENT_ID__FULLNAME_ASC',
  UserBySentIdFullnameDesc = 'USER_BY_SENT_ID__FULLNAME_DESC',
  UserBySentIdGroupIdAsc = 'USER_BY_SENT_ID__GROUP_ID_ASC',
  UserBySentIdGroupIdDesc = 'USER_BY_SENT_ID__GROUP_ID_DESC',
  UserBySentIdHolidayStartBalanceAsc = 'USER_BY_SENT_ID__HOLIDAY_START_BALANCE_ASC',
  UserBySentIdHolidayStartBalanceDesc = 'USER_BY_SENT_ID__HOLIDAY_START_BALANCE_DESC',
  UserBySentIdIdAsc = 'USER_BY_SENT_ID__ID_ASC',
  UserBySentIdIdDesc = 'USER_BY_SENT_ID__ID_DESC',
  UserBySentIdInitialsAsc = 'USER_BY_SENT_ID__INITIALS_ASC',
  UserBySentIdInitialsDesc = 'USER_BY_SENT_ID__INITIALS_DESC',
  UserBySentIdModifiedAsc = 'USER_BY_SENT_ID__MODIFIED_ASC',
  UserBySentIdModifiedDesc = 'USER_BY_SENT_ID__MODIFIED_DESC',
  UserBySentIdOvertimeStartBalanceAsc = 'USER_BY_SENT_ID__OVERTIME_START_BALANCE_ASC',
  UserBySentIdOvertimeStartBalanceDesc = 'USER_BY_SENT_ID__OVERTIME_START_BALANCE_DESC',
  UserBySentIdPasswordAsc = 'USER_BY_SENT_ID__PASSWORD_ASC',
  UserBySentIdPasswordDesc = 'USER_BY_SENT_ID__PASSWORD_DESC',
  UserBySentIdUrlAsc = 'USER_BY_SENT_ID__URL_ASC',
  UserBySentIdUrlDesc = 'USER_BY_SENT_ID__URL_DESC',
  UserBySentIdUsernameAsc = 'USER_BY_SENT_ID__USERNAME_ASC',
  UserBySentIdUsernameDesc = 'USER_BY_SENT_ID__USERNAME_DESC',
  UserBySentIdWeeklyHoursFullAccessAsc = 'USER_BY_SENT_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserBySentIdWeeklyHoursFullAccessDesc = 'USER_BY_SENT_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Filter = Node & {
  __typename?: 'Filter';
  cdartikel: Scalars['String']['output'];
  consumable?: Maybe<Scalars['Boolean']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DetectorSensor`. */
  detectorSensorsByFilterId: DetectorSensorsConnection;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  maintenanceVisitLinesByFilterId: MaintenanceVisitLinesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByFilterId: SensorTypesConnection;
  /** Reads a single `User` that is related to this `Filter`. */
  userByOwnerId?: Maybe<User>;
};


export type FilterDetectorSensorsByFilterIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorCondition>;
  filter?: InputMaybe<DetectorSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};


export type FilterMaintenanceVisitLinesByFilterIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};


export type FilterSensorTypesByFilterIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/** A condition to be used against `Filter` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FilterCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `consumable` field. */
  consumable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `FilterEntity` values. */
export type FilterEntitiesConnection = {
  __typename?: 'FilterEntitiesConnection';
  /** A list of edges which contains the `FilterEntity` and cursor to aid in pagination. */
  edges: Array<FilterEntitiesEdge>;
  /** A list of `FilterEntity` objects. */
  nodes: Array<FilterEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FilterEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FilterEntity` edge in the connection. */
export type FilterEntitiesEdge = {
  __typename?: 'FilterEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FilterEntity` at the end of the edge. */
  node: FilterEntity;
};

/** Methods to use when ordering `FilterEntity`. */
export enum FilterEntitiesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  ConsumableAsc = 'CONSUMABLE_ASC',
  ConsumableDesc = 'CONSUMABLE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC'
}

export type FilterEntity = {
  __typename?: 'FilterEntity';
  cdartikel?: Maybe<Scalars['String']['output']>;
  consumable?: Maybe<Scalars['Boolean']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FilterEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FilterEntityCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `consumable` field. */
  consumable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FilterEntity` object types. All fields are combined with a logical ‘and.’ */
export type FilterEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FilterEntityFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `consumable` field. */
  consumable?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FilterEntityFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FilterEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
};

/** A filter to be used against `Filter` object types. All fields are combined with a logical ‘and.’ */
export type FilterFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FilterFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `consumable` field. */
  consumable?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorSensorsByFilterId` relation. */
  detectorSensorsByFilterId?: InputMaybe<FilterToManyDetectorSensorFilter>;
  /** Some related `detectorSensorsByFilterId` exist. */
  detectorSensorsByFilterIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitLinesByFilterId` relation. */
  maintenanceVisitLinesByFilterId?: InputMaybe<FilterToManyMaintenanceVisitLineFilter>;
  /** Some related `maintenanceVisitLinesByFilterId` exist. */
  maintenanceVisitLinesByFilterIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FilterFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FilterFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypesByFilterId` relation. */
  sensorTypesByFilterId?: InputMaybe<FilterToManySensorTypeFilter>;
  /** Some related `sensorTypesByFilterId` exist. */
  sensorTypesByFilterIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Filter` */
export type FilterInput = {
  cdartikel: Scalars['String']['input'];
  consumable?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Filter`. Fields that are set will be updated. */
export type FilterPatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  consumable?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `DetectorSensor` object types. All fields are combined with a logical ‘and.’ */
export type FilterToManyDetectorSensorFilter = {
  /** Every related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorFilter>;
  /** No related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorFilter>;
  /** Some related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorFilter>;
};

/** A filter to be used against many `MaintenanceVisitLine` object types. All fields are combined with a logical ‘and.’ */
export type FilterToManyMaintenanceVisitLineFilter = {
  /** Every related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitLineFilter>;
  /** No related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitLineFilter>;
  /** Some related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitLineFilter>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type FilterToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `Filter` values. */
export type FiltersConnection = {
  __typename?: 'FiltersConnection';
  /** A list of edges which contains the `Filter` and cursor to aid in pagination. */
  edges: Array<FiltersEdge>;
  /** A list of `Filter` objects. */
  nodes: Array<Filter>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Filter` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Filter` edge in the connection. */
export type FiltersEdge = {
  __typename?: 'FiltersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Filter` at the end of the edge. */
  node: Filter;
};

/** Methods to use when ordering `Filter`. */
export enum FiltersOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  ConsumableAsc = 'CONSUMABLE_ASC',
  ConsumableDesc = 'CONSUMABLE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorSensorsByFilterIdCountAsc = 'DETECTOR_SENSORS_BY_FILTER_ID__COUNT_ASC',
  DetectorSensorsByFilterIdCountDesc = 'DETECTOR_SENSORS_BY_FILTER_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceVisitLinesByFilterIdCountAsc = 'MAINTENANCE_VISIT_LINES_BY_FILTER_ID__COUNT_ASC',
  MaintenanceVisitLinesByFilterIdCountDesc = 'MAINTENANCE_VISIT_LINES_BY_FILTER_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorTypesByFilterIdCountAsc = 'SENSOR_TYPES_BY_FILTER_ID__COUNT_ASC',
  SensorTypesByFilterIdCountDesc = 'SENSOR_TYPES_BY_FILTER_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Float']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Float']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Float']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Float']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Float']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type Floor = Node & {
  __typename?: 'Floor';
  /** Reads and enables pagination through a set of `Area`. */
  areasByFloorId: AreasConnection;
  /** Reads a single `Building` that is related to this `Floor`. */
  buildingByBuildingId?: Maybe<Building>;
  buildingId: Scalars['Int']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `Floor`. */
  userByOwnerId?: Maybe<User>;
};


export type FloorAreasByFloorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AreaCondition>;
  filter?: InputMaybe<AreaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AreasOrderBy>>;
};

/** A condition to be used against `Floor` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FloorCondition = {
  /** Checks for equality with the object’s `buildingId` field. */
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `FloorEntity` values. */
export type FloorEntitiesConnection = {
  __typename?: 'FloorEntitiesConnection';
  /** A list of edges which contains the `FloorEntity` and cursor to aid in pagination. */
  edges: Array<FloorEntitiesEdge>;
  /** A list of `FloorEntity` objects. */
  nodes: Array<FloorEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FloorEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FloorEntity` edge in the connection. */
export type FloorEntitiesEdge = {
  __typename?: 'FloorEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FloorEntity` at the end of the edge. */
  node: FloorEntity;
};

/** Methods to use when ordering `FloorEntity`. */
export enum FloorEntitiesOrderBy {
  BuildingIdAsc = 'BUILDING_ID_ASC',
  BuildingIdDesc = 'BUILDING_ID_DESC',
  BuildingNameAsc = 'BUILDING_NAME_ASC',
  BuildingNameDesc = 'BUILDING_NAME_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  EndUserNameAsc = 'END_USER_NAME_ASC',
  EndUserNameDesc = 'END_USER_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC'
}

export type FloorEntity = {
  __typename?: 'FloorEntity';
  buildingId?: Maybe<Scalars['Int']['output']>;
  buildingName?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  endUserName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `FloorEntity` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type FloorEntityCondition = {
  /** Checks for equality with the object’s `buildingId` field. */
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `buildingName` field. */
  buildingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserName` field. */
  endUserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FloorEntity` object types. All fields are combined with a logical ‘and.’ */
export type FloorEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FloorEntityFilter>>;
  /** Filter by the object’s `buildingId` field. */
  buildingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `buildingName` field. */
  buildingName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserName` field. */
  endUserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FloorEntityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FloorEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
};

/** A filter to be used against `Floor` object types. All fields are combined with a logical ‘and.’ */
export type FloorFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FloorFilter>>;
  /** Filter by the object’s `areasByFloorId` relation. */
  areasByFloorId?: InputMaybe<FloorToManyAreaFilter>;
  /** Some related `areasByFloorId` exist. */
  areasByFloorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `buildingByBuildingId` relation. */
  buildingByBuildingId?: InputMaybe<BuildingFilter>;
  /** Filter by the object’s `buildingId` field. */
  buildingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FloorFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FloorFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `Floor` */
export type FloorInput = {
  buildingId: Scalars['Int']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Floor`. Fields that are set will be updated. */
export type FloorPatch = {
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `Area` object types. All fields are combined with a logical ‘and.’ */
export type FloorToManyAreaFilter = {
  /** Every related `Area` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AreaFilter>;
  /** No related `Area` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AreaFilter>;
  /** Some related `Area` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AreaFilter>;
};

/** A connection to a list of `Floor` values. */
export type FloorsConnection = {
  __typename?: 'FloorsConnection';
  /** A list of edges which contains the `Floor` and cursor to aid in pagination. */
  edges: Array<FloorsEdge>;
  /** A list of `Floor` objects. */
  nodes: Array<Floor>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Floor` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Floor` edge in the connection. */
export type FloorsEdge = {
  __typename?: 'FloorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Floor` at the end of the edge. */
  node: Floor;
};

/** Methods to use when ordering `Floor`. */
export enum FloorsOrderBy {
  AreasByFloorIdCountAsc = 'AREAS_BY_FLOOR_ID__COUNT_ASC',
  AreasByFloorIdCountDesc = 'AREAS_BY_FLOOR_ID__COUNT_DESC',
  BuildingByBuildingIdCreatedAsc = 'BUILDING_BY_BUILDING_ID__CREATED_ASC',
  BuildingByBuildingIdCreatedDesc = 'BUILDING_BY_BUILDING_ID__CREATED_DESC',
  BuildingByBuildingIdEndUserIdAsc = 'BUILDING_BY_BUILDING_ID__END_USER_ID_ASC',
  BuildingByBuildingIdEndUserIdDesc = 'BUILDING_BY_BUILDING_ID__END_USER_ID_DESC',
  BuildingByBuildingIdIdAsc = 'BUILDING_BY_BUILDING_ID__ID_ASC',
  BuildingByBuildingIdIdDesc = 'BUILDING_BY_BUILDING_ID__ID_DESC',
  BuildingByBuildingIdModifiedAsc = 'BUILDING_BY_BUILDING_ID__MODIFIED_ASC',
  BuildingByBuildingIdModifiedDesc = 'BUILDING_BY_BUILDING_ID__MODIFIED_DESC',
  BuildingByBuildingIdNameAsc = 'BUILDING_BY_BUILDING_ID__NAME_ASC',
  BuildingByBuildingIdNameDesc = 'BUILDING_BY_BUILDING_ID__NAME_DESC',
  BuildingByBuildingIdOwnerIdAsc = 'BUILDING_BY_BUILDING_ID__OWNER_ID_ASC',
  BuildingByBuildingIdOwnerIdDesc = 'BUILDING_BY_BUILDING_ID__OWNER_ID_DESC',
  BuildingIdAsc = 'BUILDING_ID_ASC',
  BuildingIdDesc = 'BUILDING_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Gas = Node & {
  __typename?: 'Gas';
  /** Reads and enables pagination through a set of `CalGas`. */
  calGasesByGasId: CalGasesConnection;
  /** Reads a single `ChemicalCompound` that is related to this `Gas`. */
  chemicalCompoundByChemicalCompoundId?: Maybe<ChemicalCompound>;
  chemicalCompoundId?: Maybe<Scalars['Int']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  formula?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Range`. */
  rangesByGasId: RangesConnection;
  /** Reads a single `User` that is related to this `Gas`. */
  userByOwnerId?: Maybe<User>;
};


export type GasCalGasesByGasIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CalGasCondition>;
  filter?: InputMaybe<CalGasFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CalGasesOrderBy>>;
};


export type GasRangesByGasIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RangeCondition>;
  filter?: InputMaybe<RangeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RangesOrderBy>>;
};

/** A condition to be used against `Gas` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GasCondition = {
  /** Checks for equality with the object’s `chemicalCompoundId` field. */
  chemicalCompoundId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `formula` field. */
  formula?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Gas` object types. All fields are combined with a logical ‘and.’ */
export type GasFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GasFilter>>;
  /** Filter by the object’s `calGasesByGasId` relation. */
  calGasesByGasId?: InputMaybe<GasToManyCalGasFilter>;
  /** Some related `calGasesByGasId` exist. */
  calGasesByGasIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `chemicalCompoundByChemicalCompoundId` relation. */
  chemicalCompoundByChemicalCompoundId?: InputMaybe<ChemicalCompoundFilter>;
  /** A related `chemicalCompoundByChemicalCompoundId` exists. */
  chemicalCompoundByChemicalCompoundIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `chemicalCompoundId` field. */
  chemicalCompoundId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `formula` field. */
  formula?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GasFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GasFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `rangesByGasId` relation. */
  rangesByGasId?: InputMaybe<GasToManyRangeFilter>;
  /** Some related `rangesByGasId` exist. */
  rangesByGasIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Gas` */
export type GasInput = {
  chemicalCompoundId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  formula?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Gas`. Fields that are set will be updated. */
export type GasPatch = {
  chemicalCompoundId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  formula?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `CalGas` object types. All fields are combined with a logical ‘and.’ */
export type GasToManyCalGasFilter = {
  /** Every related `CalGas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CalGasFilter>;
  /** No related `CalGas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CalGasFilter>;
  /** Some related `CalGas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CalGasFilter>;
};

/** A filter to be used against many `Range` object types. All fields are combined with a logical ‘and.’ */
export type GasToManyRangeFilter = {
  /** Every related `Range` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RangeFilter>;
  /** No related `Range` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RangeFilter>;
  /** Some related `Range` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RangeFilter>;
};

/** A connection to a list of `Gas` values. */
export type GasesConnection = {
  __typename?: 'GasesConnection';
  /** A list of edges which contains the `Gas` and cursor to aid in pagination. */
  edges: Array<GasesEdge>;
  /** A list of `Gas` objects. */
  nodes: Array<Gas>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Gas` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Gas` edge in the connection. */
export type GasesEdge = {
  __typename?: 'GasesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Gas` at the end of the edge. */
  node: Gas;
};

/** Methods to use when ordering `Gas`. */
export enum GasesOrderBy {
  CalGasesByGasIdCountAsc = 'CAL_GASES_BY_GAS_ID__COUNT_ASC',
  CalGasesByGasIdCountDesc = 'CAL_GASES_BY_GAS_ID__COUNT_DESC',
  ChemicalCompoundByChemicalCompoundIdCasAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__CAS_ASC',
  ChemicalCompoundByChemicalCompoundIdCasDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__CAS_DESC',
  ChemicalCompoundByChemicalCompoundIdCreatedAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__CREATED_ASC',
  ChemicalCompoundByChemicalCompoundIdCreatedDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__CREATED_DESC',
  ChemicalCompoundByChemicalCompoundIdDensityAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__DENSITY_ASC',
  ChemicalCompoundByChemicalCompoundIdDensityDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__DENSITY_DESC',
  ChemicalCompoundByChemicalCompoundIdFormulaAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__FORMULA_ASC',
  ChemicalCompoundByChemicalCompoundIdFormulaDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__FORMULA_DESC',
  ChemicalCompoundByChemicalCompoundIdIcscAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__ICSC_ASC',
  ChemicalCompoundByChemicalCompoundIdIcscDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__ICSC_DESC',
  ChemicalCompoundByChemicalCompoundIdIdAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__ID_ASC',
  ChemicalCompoundByChemicalCompoundIdIdDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__ID_DESC',
  ChemicalCompoundByChemicalCompoundIdModifiedAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__MODIFIED_ASC',
  ChemicalCompoundByChemicalCompoundIdModifiedDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__MODIFIED_DESC',
  ChemicalCompoundByChemicalCompoundIdMolarMassAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__MOLAR_MASS_ASC',
  ChemicalCompoundByChemicalCompoundIdMolarMassDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__MOLAR_MASS_DESC',
  ChemicalCompoundByChemicalCompoundIdNameAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__NAME_ASC',
  ChemicalCompoundByChemicalCompoundIdNameDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__NAME_DESC',
  ChemicalCompoundByChemicalCompoundIdOtherNameAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__OTHER_NAME_ASC',
  ChemicalCompoundByChemicalCompoundIdOtherNameDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__OTHER_NAME_DESC',
  ChemicalCompoundByChemicalCompoundIdOwnerIdAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__OWNER_ID_ASC',
  ChemicalCompoundByChemicalCompoundIdOwnerIdDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__OWNER_ID_DESC',
  ChemicalCompoundByChemicalCompoundIdUrlAsc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__URL_ASC',
  ChemicalCompoundByChemicalCompoundIdUrlDesc = 'CHEMICAL_COMPOUND_BY_CHEMICAL_COMPOUND_ID__URL_DESC',
  ChemicalCompoundIdAsc = 'CHEMICAL_COMPOUND_ID_ASC',
  ChemicalCompoundIdDesc = 'CHEMICAL_COMPOUND_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  FormulaAsc = 'FORMULA_ASC',
  FormulaDesc = 'FORMULA_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RangesByGasIdCountAsc = 'RANGES_BY_GAS_ID__COUNT_ASC',
  RangesByGasIdCountDesc = 'RANGES_BY_GAS_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Group = Node & {
  __typename?: 'Group';
  /** Reads and enables pagination through a set of `Action`. */
  actionsByGroupId: ActionsConnection;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `GroupPermission` that is related to this `Group`. */
  groupPermissionByGroupId?: Maybe<GroupPermission>;
  /**
   * Reads and enables pagination through a set of `GroupPermission`.
   * @deprecated Please use groupPermissionByGroupId instead
   */
  groupPermissionsByGroupId: GroupPermissionsConnection;
  /** Reads and enables pagination through a set of `GroupRight`. */
  groupRightsByGroupId: GroupRightsConnection;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `Group`. */
  userByOwnerId?: Maybe<User>;
  /** Reads and enables pagination through a set of `User`. */
  usersByGroupId: UsersConnection;
  /** Reads and enables pagination through a set of `UsersGroup`. */
  usersGroupsByGroupId: UsersGroupsConnection;
};


export type GroupActionsByGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionCondition>;
  filter?: InputMaybe<ActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionsOrderBy>>;
};


export type GroupGroupPermissionsByGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupPermissionCondition>;
  filter?: InputMaybe<GroupPermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupPermissionsOrderBy>>;
};


export type GroupGroupRightsByGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupRightCondition>;
  filter?: InputMaybe<GroupRightFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupRightsOrderBy>>;
};


export type GroupUsersByGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


export type GroupUsersGroupsByGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UsersGroupCondition>;
  filter?: InputMaybe<UsersGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersGroupsOrderBy>>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Group` object types. All fields are combined with a logical ‘and.’ */
export type GroupFilter = {
  /** Filter by the object’s `actionsByGroupId` relation. */
  actionsByGroupId?: InputMaybe<GroupToManyActionFilter>;
  /** Some related `actionsByGroupId` exist. */
  actionsByGroupIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GroupFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `groupPermissionByGroupId` relation. */
  groupPermissionByGroupId?: InputMaybe<GroupPermissionFilter>;
  /** A related `groupPermissionByGroupId` exists. */
  groupPermissionByGroupIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `groupRightsByGroupId` relation. */
  groupRightsByGroupId?: InputMaybe<GroupToManyGroupRightFilter>;
  /** Some related `groupRightsByGroupId` exist. */
  groupRightsByGroupIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GroupFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `usersByGroupId` relation. */
  usersByGroupId?: InputMaybe<GroupToManyUserFilter>;
  /** Some related `usersByGroupId` exist. */
  usersByGroupIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `usersGroupsByGroupId` relation. */
  usersGroupsByGroupId?: InputMaybe<GroupToManyUsersGroupFilter>;
  /** Some related `usersGroupsByGroupId` exist. */
  usersGroupsByGroupIdExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

export type GroupPermission = Node & {
  __typename?: 'GroupPermission';
  /** Reads a single `Group` that is related to this `GroupPermission`. */
  groupByGroupId?: Maybe<Group>;
  groupId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  readIds: Array<Maybe<Scalars['Int']['output']>>;
  writeIds: Array<Maybe<Scalars['Int']['output']>>;
};

/**
 * A condition to be used against `GroupPermission` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GroupPermissionCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `readIds` field. */
  readIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Checks for equality with the object’s `writeIds` field. */
  writeIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** A filter to be used against `GroupPermission` object types. All fields are combined with a logical ‘and.’ */
export type GroupPermissionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GroupPermissionFilter>>;
  /** Filter by the object’s `groupByGroupId` relation. */
  groupByGroupId?: InputMaybe<GroupFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GroupPermissionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GroupPermissionFilter>>;
  /** Filter by the object’s `readIds` field. */
  readIds?: InputMaybe<IntListFilter>;
  /** Filter by the object’s `writeIds` field. */
  writeIds?: InputMaybe<IntListFilter>;
};

/** An input for mutations affecting `GroupPermission` */
export type GroupPermissionInput = {
  groupId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  readIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  writeIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** Represents an update to a `GroupPermission`. Fields that are set will be updated. */
export type GroupPermissionPatch = {
  groupId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  readIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  writeIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** A connection to a list of `GroupPermission` values. */
export type GroupPermissionsConnection = {
  __typename?: 'GroupPermissionsConnection';
  /** A list of edges which contains the `GroupPermission` and cursor to aid in pagination. */
  edges: Array<GroupPermissionsEdge>;
  /** A list of `GroupPermission` objects. */
  nodes: Array<GroupPermission>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GroupPermission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `GroupPermission` edge in the connection. */
export type GroupPermissionsEdge = {
  __typename?: 'GroupPermissionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `GroupPermission` at the end of the edge. */
  node: GroupPermission;
};

/** Methods to use when ordering `GroupPermission`. */
export enum GroupPermissionsOrderBy {
  GroupByGroupIdCreatedAsc = 'GROUP_BY_GROUP_ID__CREATED_ASC',
  GroupByGroupIdCreatedDesc = 'GROUP_BY_GROUP_ID__CREATED_DESC',
  GroupByGroupIdIdAsc = 'GROUP_BY_GROUP_ID__ID_ASC',
  GroupByGroupIdIdDesc = 'GROUP_BY_GROUP_ID__ID_DESC',
  GroupByGroupIdModifiedAsc = 'GROUP_BY_GROUP_ID__MODIFIED_ASC',
  GroupByGroupIdModifiedDesc = 'GROUP_BY_GROUP_ID__MODIFIED_DESC',
  GroupByGroupIdNameAsc = 'GROUP_BY_GROUP_ID__NAME_ASC',
  GroupByGroupIdNameDesc = 'GROUP_BY_GROUP_ID__NAME_DESC',
  GroupByGroupIdOwnerIdAsc = 'GROUP_BY_GROUP_ID__OWNER_ID_ASC',
  GroupByGroupIdOwnerIdDesc = 'GROUP_BY_GROUP_ID__OWNER_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReadIdsAsc = 'READ_IDS_ASC',
  ReadIdsDesc = 'READ_IDS_DESC',
  WriteIdsAsc = 'WRITE_IDS_ASC',
  WriteIdsDesc = 'WRITE_IDS_DESC'
}

export type GroupRight = Node & {
  __typename?: 'GroupRight';
  authorized: Scalars['Boolean']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Group` that is related to this `GroupRight`. */
  groupByGroupId?: Maybe<Group>;
  groupId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  path?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `GroupRight` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GroupRightCondition = {
  /** Checks for equality with the object’s `authorized` field. */
  authorized?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `path` field. */
  path?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `GroupRight` object types. All fields are combined with a logical ‘and.’ */
export type GroupRightFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GroupRightFilter>>;
  /** Filter by the object’s `authorized` field. */
  authorized?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `groupByGroupId` relation. */
  groupByGroupId?: InputMaybe<GroupFilter>;
  /** A related `groupByGroupId` exists. */
  groupByGroupIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GroupRightFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GroupRightFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `path` field. */
  path?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `GroupRight` */
export type GroupRightInput = {
  authorized: Scalars['Boolean']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  groupId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `GroupRight`. Fields that are set will be updated. */
export type GroupRightPatch = {
  authorized?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  groupId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `GroupRight` values. */
export type GroupRightsConnection = {
  __typename?: 'GroupRightsConnection';
  /** A list of edges which contains the `GroupRight` and cursor to aid in pagination. */
  edges: Array<GroupRightsEdge>;
  /** A list of `GroupRight` objects. */
  nodes: Array<GroupRight>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GroupRight` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `GroupRight` edge in the connection. */
export type GroupRightsEdge = {
  __typename?: 'GroupRightsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `GroupRight` at the end of the edge. */
  node: GroupRight;
};

/** Methods to use when ordering `GroupRight`. */
export enum GroupRightsOrderBy {
  AuthorizedAsc = 'AUTHORIZED_ASC',
  AuthorizedDesc = 'AUTHORIZED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GroupByGroupIdCreatedAsc = 'GROUP_BY_GROUP_ID__CREATED_ASC',
  GroupByGroupIdCreatedDesc = 'GROUP_BY_GROUP_ID__CREATED_DESC',
  GroupByGroupIdIdAsc = 'GROUP_BY_GROUP_ID__ID_ASC',
  GroupByGroupIdIdDesc = 'GROUP_BY_GROUP_ID__ID_DESC',
  GroupByGroupIdModifiedAsc = 'GROUP_BY_GROUP_ID__MODIFIED_ASC',
  GroupByGroupIdModifiedDesc = 'GROUP_BY_GROUP_ID__MODIFIED_DESC',
  GroupByGroupIdNameAsc = 'GROUP_BY_GROUP_ID__NAME_ASC',
  GroupByGroupIdNameDesc = 'GROUP_BY_GROUP_ID__NAME_DESC',
  GroupByGroupIdOwnerIdAsc = 'GROUP_BY_GROUP_ID__OWNER_ID_ASC',
  GroupByGroupIdOwnerIdDesc = 'GROUP_BY_GROUP_ID__OWNER_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against many `Action` object types. All fields are combined with a logical ‘and.’ */
export type GroupToManyActionFilter = {
  /** Every related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionFilter>;
  /** No related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionFilter>;
  /** Some related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionFilter>;
};

/** A filter to be used against many `GroupRight` object types. All fields are combined with a logical ‘and.’ */
export type GroupToManyGroupRightFilter = {
  /** Every related `GroupRight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<GroupRightFilter>;
  /** No related `GroupRight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<GroupRightFilter>;
  /** Some related `GroupRight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<GroupRightFilter>;
};

/** A filter to be used against many `User` object types. All fields are combined with a logical ‘and.’ */
export type GroupToManyUserFilter = {
  /** Every related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserFilter>;
  /** No related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserFilter>;
  /** Some related `User` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserFilter>;
};

/** A filter to be used against many `UsersGroup` object types. All fields are combined with a logical ‘and.’ */
export type GroupToManyUsersGroupFilter = {
  /** Every related `UsersGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UsersGroupFilter>;
  /** No related `UsersGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UsersGroupFilter>;
  /** Some related `UsersGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UsersGroupFilter>;
};

/** A connection to a list of `Group` values. */
export type GroupsConnection = {
  __typename?: 'GroupsConnection';
  /** A list of edges which contains the `Group` and cursor to aid in pagination. */
  edges: Array<GroupsEdge>;
  /** A list of `Group` objects. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Group` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Group` edge in the connection. */
export type GroupsEdge = {
  __typename?: 'GroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Group` at the end of the edge. */
  node: Group;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  ActionsByGroupIdCountAsc = 'ACTIONS_BY_GROUP_ID__COUNT_ASC',
  ActionsByGroupIdCountDesc = 'ACTIONS_BY_GROUP_ID__COUNT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GroupPermissionByGroupIdGroupIdAsc = 'GROUP_PERMISSION_BY_GROUP_ID__GROUP_ID_ASC',
  GroupPermissionByGroupIdGroupIdDesc = 'GROUP_PERMISSION_BY_GROUP_ID__GROUP_ID_DESC',
  GroupPermissionByGroupIdIdAsc = 'GROUP_PERMISSION_BY_GROUP_ID__ID_ASC',
  GroupPermissionByGroupIdIdDesc = 'GROUP_PERMISSION_BY_GROUP_ID__ID_DESC',
  GroupPermissionByGroupIdReadIdsAsc = 'GROUP_PERMISSION_BY_GROUP_ID__READ_IDS_ASC',
  GroupPermissionByGroupIdReadIdsDesc = 'GROUP_PERMISSION_BY_GROUP_ID__READ_IDS_DESC',
  GroupPermissionByGroupIdWriteIdsAsc = 'GROUP_PERMISSION_BY_GROUP_ID__WRITE_IDS_ASC',
  GroupPermissionByGroupIdWriteIdsDesc = 'GROUP_PERMISSION_BY_GROUP_ID__WRITE_IDS_DESC',
  GroupRightsByGroupIdCountAsc = 'GROUP_RIGHTS_BY_GROUP_ID__COUNT_ASC',
  GroupRightsByGroupIdCountDesc = 'GROUP_RIGHTS_BY_GROUP_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UsersByGroupIdCountAsc = 'USERS_BY_GROUP_ID__COUNT_ASC',
  UsersByGroupIdCountDesc = 'USERS_BY_GROUP_ID__COUNT_DESC',
  UsersGroupsByGroupIdCountAsc = 'USERS_GROUPS_BY_GROUP_ID__COUNT_ASC',
  UsersGroupsByGroupIdCountDesc = 'USERS_GROUPS_BY_GROUP_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Hardware = Node & {
  __typename?: 'Hardware';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  ipAddress?: Maybe<Scalars['String']['output']>;
  macAddress?: Maybe<Scalars['String']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  operatingSystem?: Maybe<Scalars['String']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  purchaseDate?: Maybe<Scalars['Date']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Software`. */
  softwaresByHardwareId: SoftwaresConnection;
  specs?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `Hardware`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Hardware`. */
  userByUserId?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};


export type HardwareSoftwaresByHardwareIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SoftwareCondition>;
  filter?: InputMaybe<SoftwareFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SoftwaresOrderBy>>;
};

/**
 * A condition to be used against `Hardware` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type HardwareCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `macAddress` field. */
  macAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `model` field. */
  model?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `operatingSystem` field. */
  operatingSystem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `purchaseDate` field. */
  purchaseDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `specs` field. */
  specs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Hardware` object types. All fields are combined with a logical ‘and.’ */
export type HardwareFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<HardwareFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `macAddress` field. */
  macAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `model` field. */
  model?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<HardwareFilter>;
  /** Filter by the object’s `operatingSystem` field. */
  operatingSystem?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<HardwareFilter>>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `purchaseDate` field. */
  purchaseDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `softwaresByHardwareId` relation. */
  softwaresByHardwareId?: InputMaybe<HardwareToManySoftwareFilter>;
  /** Some related `softwaresByHardwareId` exist. */
  softwaresByHardwareIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `specs` field. */
  specs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** A related `userByUserId` exists. */
  userByUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Hardware` */
export type HardwareInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  macAddress?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  operatingSystem?: InputMaybe<Scalars['String']['input']>;
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  purchaseDate?: InputMaybe<Scalars['Date']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  specs?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Hardware`. Fields that are set will be updated. */
export type HardwarePatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  macAddress?: InputMaybe<Scalars['String']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  operatingSystem?: InputMaybe<Scalars['String']['input']>;
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  purchaseDate?: InputMaybe<Scalars['Date']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  specs?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `Software` object types. All fields are combined with a logical ‘and.’ */
export type HardwareToManySoftwareFilter = {
  /** Every related `Software` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SoftwareFilter>;
  /** No related `Software` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SoftwareFilter>;
  /** Some related `Software` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SoftwareFilter>;
};

/** A connection to a list of `Hardware` values. */
export type HardwaresConnection = {
  __typename?: 'HardwaresConnection';
  /** A list of edges which contains the `Hardware` and cursor to aid in pagination. */
  edges: Array<HardwaresEdge>;
  /** A list of `Hardware` objects. */
  nodes: Array<Hardware>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Hardware` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Hardware` edge in the connection. */
export type HardwaresEdge = {
  __typename?: 'HardwaresEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Hardware` at the end of the edge. */
  node: Hardware;
};

/** Methods to use when ordering `Hardware`. */
export enum HardwaresOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IpAddressAsc = 'IP_ADDRESS_ASC',
  IpAddressDesc = 'IP_ADDRESS_DESC',
  MacAddressAsc = 'MAC_ADDRESS_ASC',
  MacAddressDesc = 'MAC_ADDRESS_DESC',
  ModelAsc = 'MODEL_ASC',
  ModelDesc = 'MODEL_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OperatingSystemAsc = 'OPERATING_SYSTEM_ASC',
  OperatingSystemDesc = 'OPERATING_SYSTEM_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PurchaseDateAsc = 'PURCHASE_DATE_ASC',
  PurchaseDateDesc = 'PURCHASE_DATE_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  SoftwaresByHardwareIdCountAsc = 'SOFTWARES_BY_HARDWARE_ID__COUNT_ASC',
  SoftwaresByHardwareIdCountDesc = 'SOFTWARES_BY_HARDWARE_ID__COUNT_DESC',
  SpecsAsc = 'SPECS_ASC',
  SpecsDesc = 'SPECS_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type IncomingDocument = Node & {
  __typename?: 'IncomingDocument';
  amount?: Maybe<Scalars['Float']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  date?: Maybe<Scalars['Date']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isovaluta?: Maybe<Scalars['String']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  type?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `IncomingDocument`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `IncomingDocument`. */
  userByUserId?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/**
 * A condition to be used against `IncomingDocument` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type IncomingDocumentCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `IncomingDocument` object types. All fields are combined with a logical ‘and.’ */
export type IncomingDocumentFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<FloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<IncomingDocumentFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<IncomingDocumentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<IncomingDocumentFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `IncomingDocument` */
export type IncomingDocumentInput = {
  amount?: InputMaybe<Scalars['Float']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  type?: InputMaybe<Scalars['String']['input']>;
  userId: Scalars['Int']['input'];
};

/** Represents an update to a `IncomingDocument`. Fields that are set will be updated. */
export type IncomingDocumentPatch = {
  amount?: InputMaybe<Scalars['Float']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `IncomingDocument` values. */
export type IncomingDocumentsConnection = {
  __typename?: 'IncomingDocumentsConnection';
  /** A list of edges which contains the `IncomingDocument` and cursor to aid in pagination. */
  edges: Array<IncomingDocumentsEdge>;
  /** A list of `IncomingDocument` objects. */
  nodes: Array<IncomingDocument>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `IncomingDocument` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `IncomingDocument` edge in the connection. */
export type IncomingDocumentsEdge = {
  __typename?: 'IncomingDocumentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `IncomingDocument` at the end of the edge. */
  node: IncomingDocument;
};

/** Methods to use when ordering `IncomingDocument`. */
export enum IncomingDocumentsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsovalutaAsc = 'ISOVALUTA_ASC',
  IsovalutaDesc = 'ISOVALUTA_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Inkoopgegeven = Node & {
  __typename?: 'Inkoopgegeven';
  bestcode?: Maybe<Scalars['String']['output']>;
  besthoeveelheid?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel: Scalars['String']['output'];
  cdcrediteur: Scalars['String']['output'];
  cdvaluta?: Maybe<Scalars['String']['output']>;
  inkoopprijs?: Maybe<Scalars['BigFloat']['output']>;
  inkvolgnr: Scalars['Int']['output'];
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  opslpercinkoop?: Maybe<Scalars['BigFloat']['output']>;
  voorkeur: Scalars['String']['output'];
};

/**
 * A condition to be used against `Inkoopgegeven` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InkoopgegevenCondition = {
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `opslpercinkoop` field. */
  opslpercinkoop?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Inkoopgegeven` object types. All fields are combined with a logical ‘and.’ */
export type InkoopgegevenFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkoopgegevenFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkoopgegevenFilter>;
  /** Filter by the object’s `opslpercinkoop` field. */
  opslpercinkoop?: InputMaybe<BigFloatFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkoopgegevenFilter>>;
  /** Filter by the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Inkoopgegeven` */
export type InkoopgegevenInput = {
  bestcode?: InputMaybe<Scalars['String']['input']>;
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  cdartikel: Scalars['String']['input'];
  cdcrediteur: Scalars['String']['input'];
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  inkvolgnr: Scalars['Int']['input'];
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  opslpercinkoop?: InputMaybe<Scalars['BigFloat']['input']>;
  voorkeur: Scalars['String']['input'];
};

/** Represents an update to a `Inkoopgegeven`. Fields that are set will be updated. */
export type InkoopgegevenPatch = {
  bestcode?: InputMaybe<Scalars['String']['input']>;
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  opslpercinkoop?: InputMaybe<Scalars['BigFloat']['input']>;
  voorkeur?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Inkoopgegeven` values. */
export type InkoopgegevensConnection = {
  __typename?: 'InkoopgegevensConnection';
  /** A list of edges which contains the `Inkoopgegeven` and cursor to aid in pagination. */
  edges: Array<InkoopgegevensEdge>;
  /** A list of `Inkoopgegeven` objects. */
  nodes: Array<Inkoopgegeven>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Inkoopgegeven` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Inkoopgegeven` edge in the connection. */
export type InkoopgegevensEdge = {
  __typename?: 'InkoopgegevensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Inkoopgegeven` at the end of the edge. */
  node: Inkoopgegeven;
};

export type InkoopgegevensFactopdrachtregel = {
  __typename?: 'InkoopgegevensFactopdrachtregel';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  voorkeur?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkoopgegevensFactopdrachtregel` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type InkoopgegevensFactopdrachtregelCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkoopgegevensFactopdrachtregel` object types. All fields are combined with a logical ‘and.’ */
export type InkoopgegevensFactopdrachtregelFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkoopgegevensFactopdrachtregelFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkoopgegevensFactopdrachtregelFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkoopgegevensFactopdrachtregelFilter>>;
  /** Filter by the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkoopgegevensFactopdrachtregel` values. */
export type InkoopgegevensFactopdrachtregelsConnection = {
  __typename?: 'InkoopgegevensFactopdrachtregelsConnection';
  /** A list of edges which contains the `InkoopgegevensFactopdrachtregel` and cursor to aid in pagination. */
  edges: Array<InkoopgegevensFactopdrachtregelsEdge>;
  /** A list of `InkoopgegevensFactopdrachtregel` objects. */
  nodes: Array<InkoopgegevensFactopdrachtregel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkoopgegevensFactopdrachtregel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkoopgegevensFactopdrachtregel` edge in the connection. */
export type InkoopgegevensFactopdrachtregelsEdge = {
  __typename?: 'InkoopgegevensFactopdrachtregelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkoopgegevensFactopdrachtregel` at the end of the edge. */
  node: InkoopgegevensFactopdrachtregel;
};

/** Methods to use when ordering `InkoopgegevensFactopdrachtregel`. */
export enum InkoopgegevensFactopdrachtregelsOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  VoorkeurAsc = 'VOORKEUR_ASC',
  VoorkeurDesc = 'VOORKEUR_DESC'
}

export type InkoopgegevensIndex = {
  __typename?: 'InkoopgegevensIndex';
  advice?: Maybe<Scalars['BigFloat']['output']>;
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  besthoeveelheid?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkoopprijs?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  isovaluta?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  voorkeur?: Maybe<Scalars['String']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vrij?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkoopgegevensIndex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type InkoopgegevensIndexCondition = {
  /** Checks for equality with the object’s `advice` field. */
  advice?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vrij` field. */
  vrij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkoopgegevensIndex` object types. All fields are combined with a logical ‘and.’ */
export type InkoopgegevensIndexFilter = {
  /** Filter by the object’s `advice` field. */
  advice?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkoopgegevensIndexFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkoopgegevensIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkoopgegevensIndexFilter>>;
  /** Filter by the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vrij` field. */
  vrij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkoopgegevensIndex` values. */
export type InkoopgegevensIndicesConnection = {
  __typename?: 'InkoopgegevensIndicesConnection';
  /** A list of edges which contains the `InkoopgegevensIndex` and cursor to aid in pagination. */
  edges: Array<InkoopgegevensIndicesEdge>;
  /** A list of `InkoopgegevensIndex` objects. */
  nodes: Array<InkoopgegevensIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkoopgegevensIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkoopgegevensIndex` edge in the connection. */
export type InkoopgegevensIndicesEdge = {
  __typename?: 'InkoopgegevensIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkoopgegevensIndex` at the end of the edge. */
  node: InkoopgegevensIndex;
};

/** Methods to use when ordering `InkoopgegevensIndex`. */
export enum InkoopgegevensIndicesOrderBy {
  AdviceAsc = 'ADVICE_ASC',
  AdviceDesc = 'ADVICE_DESC',
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  BesthoeveelheidAsc = 'BESTHOEVEELHEID_ASC',
  BesthoeveelheidDesc = 'BESTHOEVEELHEID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkoopprijsAsc = 'INKOOPPRIJS_ASC',
  InkoopprijsDesc = 'INKOOPPRIJS_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  IsovalutaAsc = 'ISOVALUTA_ASC',
  IsovalutaDesc = 'ISOVALUTA_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  VoorkeurAsc = 'VOORKEUR_ASC',
  VoorkeurDesc = 'VOORKEUR_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VrijAsc = 'VRIJ_ASC',
  VrijDesc = 'VRIJ_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type InkoopgegevensLog = Node & {
  __typename?: 'InkoopgegevensLog';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  new?: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  old?: Maybe<Scalars['JSON']['output']>;
  operation?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkoopgegevensLog` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InkoopgegevensLogCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `new` field. */
  new?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `old` field. */
  old?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `operation` field. */
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkoopgegevensLog` object types. All fields are combined with a logical ‘and.’ */
export type InkoopgegevensLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkoopgegevensLogFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `new` field. */
  new?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkoopgegevensLogFilter>;
  /** Filter by the object’s `old` field. */
  old?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `operation` field. */
  operation?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkoopgegevensLogFilter>>;
};

/** An input for mutations affecting `InkoopgegevensLog` */
export type InkoopgegevensLogInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  new?: InputMaybe<Scalars['JSON']['input']>;
  old?: InputMaybe<Scalars['JSON']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `InkoopgegevensLog`. Fields that are set will be updated. */
export type InkoopgegevensLogPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  new?: InputMaybe<Scalars['JSON']['input']>;
  old?: InputMaybe<Scalars['JSON']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `InkoopgegevensLog` values. */
export type InkoopgegevensLogsConnection = {
  __typename?: 'InkoopgegevensLogsConnection';
  /** A list of edges which contains the `InkoopgegevensLog` and cursor to aid in pagination. */
  edges: Array<InkoopgegevensLogsEdge>;
  /** A list of `InkoopgegevensLog` objects. */
  nodes: Array<InkoopgegevensLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkoopgegevensLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkoopgegevensLog` edge in the connection. */
export type InkoopgegevensLogsEdge = {
  __typename?: 'InkoopgegevensLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkoopgegevensLog` at the end of the edge. */
  node: InkoopgegevensLog;
};

export type InkoopgegevensLogsIndex = {
  __typename?: 'InkoopgegevensLogsIndex';
  calculatedVerrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Date']['output']>;
  deltaVerrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  margin?: Maybe<Scalars['BigFloat']['output']>;
  new?: Maybe<Scalars['String']['output']>;
  old?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkoopgegevensLogsIndex` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type InkoopgegevensLogsIndexCondition = {
  /** Checks for equality with the object’s `calculatedVerrekenprijs` field. */
  calculatedVerrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `deltaVerrekenprijs` field. */
  deltaVerrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `new` field. */
  new?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `old` field. */
  old?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkoopgegevensLogsIndex` object types. All fields are combined with a logical ‘and.’ */
export type InkoopgegevensLogsIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkoopgegevensLogsIndexFilter>>;
  /** Filter by the object’s `calculatedVerrekenprijs` field. */
  calculatedVerrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DateFilter>;
  /** Filter by the object’s `deltaVerrekenprijs` field. */
  deltaVerrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `new` field. */
  new?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkoopgegevensLogsIndexFilter>;
  /** Filter by the object’s `old` field. */
  old?: InputMaybe<StringFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkoopgegevensLogsIndexFilter>>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkoopgegevensLogsIndex` values. */
export type InkoopgegevensLogsIndicesConnection = {
  __typename?: 'InkoopgegevensLogsIndicesConnection';
  /** A list of edges which contains the `InkoopgegevensLogsIndex` and cursor to aid in pagination. */
  edges: Array<InkoopgegevensLogsIndicesEdge>;
  /** A list of `InkoopgegevensLogsIndex` objects. */
  nodes: Array<InkoopgegevensLogsIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkoopgegevensLogsIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkoopgegevensLogsIndex` edge in the connection. */
export type InkoopgegevensLogsIndicesEdge = {
  __typename?: 'InkoopgegevensLogsIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkoopgegevensLogsIndex` at the end of the edge. */
  node: InkoopgegevensLogsIndex;
};

/** Methods to use when ordering `InkoopgegevensLogsIndex`. */
export enum InkoopgegevensLogsIndicesOrderBy {
  CalculatedVerrekenprijsAsc = 'CALCULATED_VERREKENPRIJS_ASC',
  CalculatedVerrekenprijsDesc = 'CALCULATED_VERREKENPRIJS_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DeltaVerrekenprijsAsc = 'DELTA_VERREKENPRIJS_ASC',
  DeltaVerrekenprijsDesc = 'DELTA_VERREKENPRIJS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginDesc = 'MARGIN_DESC',
  Natural = 'NATURAL',
  NewAsc = 'NEW_ASC',
  NewDesc = 'NEW_DESC',
  OldAsc = 'OLD_ASC',
  OldDesc = 'OLD_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** Methods to use when ordering `InkoopgegevensLog`. */
export enum InkoopgegevensLogsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NewAsc = 'NEW_ASC',
  NewDesc = 'NEW_DESC',
  OldAsc = 'OLD_ASC',
  OldDesc = 'OLD_DESC',
  OperationAsc = 'OPERATION_ASC',
  OperationDesc = 'OPERATION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type InkoopgegevensMv = {
  __typename?: 'InkoopgegevensMv';
  bestcode?: Maybe<Scalars['String']['output']>;
  besthoeveelheid?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  inkoopprijs?: Maybe<Scalars['BigFloat']['output']>;
  inkvolgnr?: Maybe<Scalars['Int']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  opslpercinkoop?: Maybe<Scalars['BigFloat']['output']>;
  voorkeur?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkoopgegevensMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InkoopgegevensMvCondition = {
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `opslpercinkoop` field. */
  opslpercinkoop?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkoopgegevensMv` object types. All fields are combined with a logical ‘and.’ */
export type InkoopgegevensMvFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkoopgegevensMvFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkoopgegevensMvFilter>;
  /** Filter by the object’s `opslpercinkoop` field. */
  opslpercinkoop?: InputMaybe<BigFloatFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkoopgegevensMvFilter>>;
  /** Filter by the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkoopgegevensMv` values. */
export type InkoopgegevensMvsConnection = {
  __typename?: 'InkoopgegevensMvsConnection';
  /** A list of edges which contains the `InkoopgegevensMv` and cursor to aid in pagination. */
  edges: Array<InkoopgegevensMvsEdge>;
  /** A list of `InkoopgegevensMv` objects. */
  nodes: Array<InkoopgegevensMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkoopgegevensMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkoopgegevensMv` edge in the connection. */
export type InkoopgegevensMvsEdge = {
  __typename?: 'InkoopgegevensMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkoopgegevensMv` at the end of the edge. */
  node: InkoopgegevensMv;
};

/** Methods to use when ordering `InkoopgegevensMv`. */
export enum InkoopgegevensMvsOrderBy {
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  BesthoeveelheidAsc = 'BESTHOEVEELHEID_ASC',
  BesthoeveelheidDesc = 'BESTHOEVEELHEID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  InkoopprijsAsc = 'INKOOPPRIJS_ASC',
  InkoopprijsDesc = 'INKOOPPRIJS_DESC',
  InkvolgnrAsc = 'INKVOLGNR_ASC',
  InkvolgnrDesc = 'INKVOLGNR_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  Natural = 'NATURAL',
  OpslpercinkoopAsc = 'OPSLPERCINKOOP_ASC',
  OpslpercinkoopDesc = 'OPSLPERCINKOOP_DESC',
  VoorkeurAsc = 'VOORKEUR_ASC',
  VoorkeurDesc = 'VOORKEUR_DESC'
}

/** Methods to use when ordering `Inkoopgegeven`. */
export enum InkoopgegevensOrderBy {
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  BesthoeveelheidAsc = 'BESTHOEVEELHEID_ASC',
  BesthoeveelheidDesc = 'BESTHOEVEELHEID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  InkoopprijsAsc = 'INKOOPPRIJS_ASC',
  InkoopprijsDesc = 'INKOOPPRIJS_DESC',
  InkvolgnrAsc = 'INKVOLGNR_ASC',
  InkvolgnrDesc = 'INKVOLGNR_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  Natural = 'NATURAL',
  OpslpercinkoopAsc = 'OPSLPERCINKOOP_ASC',
  OpslpercinkoopDesc = 'OPSLPERCINKOOP_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VoorkeurAsc = 'VOORKEUR_ASC',
  VoorkeurDesc = 'VOORKEUR_DESC'
}

export type Inkooporder = {
  __typename?: 'Inkooporder';
  adres?: Maybe<Scalars['String']['output']>;
  afdrukteller?: Maybe<Scalars['Int']['output']>;
  behandelddoor?: Maybe<Scalars['String']['output']>;
  cdbehandelddoor?: Maybe<Scalars['String']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cdfiatteur?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdproject?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  gefiatteerd?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  openstaand?: Maybe<Scalars['String']['output']>;
  orderdatum?: Maybe<Scalars['Date']['output']>;
  orderkortbedrag?: Maybe<Scalars['BigFloat']['output']>;
  orderkortperc?: Maybe<Scalars['BigFloat']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  toelichting?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Inkooporder` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type InkooporderCondition = {
  /** Checks for equality with the object’s `adres` field. */
  adres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdproject` field. */
  cdproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `openstaand` field. */
  openstaand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `orderkortbedrag` field. */
  orderkortbedrag?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `orderkortperc` field. */
  orderkortperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `toelichting` field. */
  toelichting?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Inkooporder` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderFilter = {
  /** Filter by the object’s `adres` field. */
  adres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderFilter>>;
  /** Filter by the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdproject` field. */
  cdproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderFilter>;
  /** Filter by the object’s `openstaand` field. */
  openstaand?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderFilter>>;
  /** Filter by the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `orderkortbedrag` field. */
  orderkortbedrag?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `orderkortperc` field. */
  orderkortperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `toelichting` field. */
  toelichting?: InputMaybe<StringFilter>;
};

export type InkooporderIndex = {
  __typename?: 'InkooporderIndex';
  cdvaluta?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  orderdatum?: Maybe<Scalars['Date']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  persoonnaam?: Maybe<Scalars['String']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  shipmentDay?: Maybe<Scalars['Int']['output']>;
  shipmentDays?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `InkooporderIndex` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InkooporderIndexCondition = {
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoonnaam` field. */
  persoonnaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shipmentDay` field. */
  shipmentDay?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `shipmentDays` field. */
  shipmentDays?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `InkooporderIndex` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderIndexFilter>>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderIndexFilter>>;
  /** Filter by the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `persoonnaam` field. */
  persoonnaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shipmentDay` field. */
  shipmentDay?: InputMaybe<IntFilter>;
  /** Filter by the object’s `shipmentDays` field. */
  shipmentDays?: InputMaybe<IntFilter>;
};

/** A connection to a list of `InkooporderIndex` values. */
export type InkooporderIndicesConnection = {
  __typename?: 'InkooporderIndicesConnection';
  /** A list of edges which contains the `InkooporderIndex` and cursor to aid in pagination. */
  edges: Array<InkooporderIndicesEdge>;
  /** A list of `InkooporderIndex` objects. */
  nodes: Array<InkooporderIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkooporderIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkooporderIndex` edge in the connection. */
export type InkooporderIndicesEdge = {
  __typename?: 'InkooporderIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkooporderIndex` at the end of the edge. */
  node: InkooporderIndex;
};

/** Methods to use when ordering `InkooporderIndex`. */
export enum InkooporderIndicesOrderBy {
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  OrderdatumAsc = 'ORDERDATUM_ASC',
  OrderdatumDesc = 'ORDERDATUM_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  PersoonnaamAsc = 'PERSOONNAAM_ASC',
  PersoonnaamDesc = 'PERSOONNAAM_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  ShipmentDaysAsc = 'SHIPMENT_DAYS_ASC',
  ShipmentDaysDesc = 'SHIPMENT_DAYS_DESC',
  ShipmentDayAsc = 'SHIPMENT_DAY_ASC',
  ShipmentDayDesc = 'SHIPMENT_DAY_DESC'
}

export type InkooporderMv = {
  __typename?: 'InkooporderMv';
  adres?: Maybe<Scalars['String']['output']>;
  afdrukteller?: Maybe<Scalars['Int']['output']>;
  behandelddoor?: Maybe<Scalars['String']['output']>;
  cdbehandelddoor?: Maybe<Scalars['String']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cdfiatteur?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdproject?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  gefiatteerd?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  openstaand?: Maybe<Scalars['String']['output']>;
  orderdatum?: Maybe<Scalars['Date']['output']>;
  orderkortbedrag?: Maybe<Scalars['BigFloat']['output']>;
  orderkortperc?: Maybe<Scalars['BigFloat']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  toelichting?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkooporderMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InkooporderMvCondition = {
  /** Checks for equality with the object’s `adres` field. */
  adres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdproject` field. */
  cdproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `openstaand` field. */
  openstaand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `orderkortbedrag` field. */
  orderkortbedrag?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `orderkortperc` field. */
  orderkortperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `toelichting` field. */
  toelichting?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkooporderMv` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderMvFilter = {
  /** Filter by the object’s `adres` field. */
  adres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderMvFilter>>;
  /** Filter by the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdproject` field. */
  cdproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderMvFilter>;
  /** Filter by the object’s `openstaand` field. */
  openstaand?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderMvFilter>>;
  /** Filter by the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `orderkortbedrag` field. */
  orderkortbedrag?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `orderkortperc` field. */
  orderkortperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `toelichting` field. */
  toelichting?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkooporderMv` values. */
export type InkooporderMvsConnection = {
  __typename?: 'InkooporderMvsConnection';
  /** A list of edges which contains the `InkooporderMv` and cursor to aid in pagination. */
  edges: Array<InkooporderMvsEdge>;
  /** A list of `InkooporderMv` objects. */
  nodes: Array<InkooporderMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkooporderMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkooporderMv` edge in the connection. */
export type InkooporderMvsEdge = {
  __typename?: 'InkooporderMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkooporderMv` at the end of the edge. */
  node: InkooporderMv;
};

/** Methods to use when ordering `InkooporderMv`. */
export enum InkooporderMvsOrderBy {
  AdresAsc = 'ADRES_ASC',
  AdresDesc = 'ADRES_DESC',
  AfdruktellerAsc = 'AFDRUKTELLER_ASC',
  AfdruktellerDesc = 'AFDRUKTELLER_DESC',
  BehandelddoorAsc = 'BEHANDELDDOOR_ASC',
  BehandelddoorDesc = 'BEHANDELDDOOR_DESC',
  CdbehandelddoorAsc = 'CDBEHANDELDDOOR_ASC',
  CdbehandelddoorDesc = 'CDBEHANDELDDOOR_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CdfiatteurAsc = 'CDFIATTEUR_ASC',
  CdfiatteurDesc = 'CDFIATTEUR_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdprojectAsc = 'CDPROJECT_ASC',
  CdprojectDesc = 'CDPROJECT_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  GefiatteerdAsc = 'GEFIATTEERD_ASC',
  GefiatteerdDesc = 'GEFIATTEERD_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  Natural = 'NATURAL',
  OpenstaandAsc = 'OPENSTAAND_ASC',
  OpenstaandDesc = 'OPENSTAAND_DESC',
  OrderdatumAsc = 'ORDERDATUM_ASC',
  OrderdatumDesc = 'ORDERDATUM_DESC',
  OrderkortbedragAsc = 'ORDERKORTBEDRAG_ASC',
  OrderkortbedragDesc = 'ORDERKORTBEDRAG_DESC',
  OrderkortpercAsc = 'ORDERKORTPERC_ASC',
  OrderkortpercDesc = 'ORDERKORTPERC_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  ToelichtingAsc = 'TOELICHTING_ASC',
  ToelichtingDesc = 'TOELICHTING_DESC'
}

export type Inkooporderregel = {
  __typename?: 'Inkooporderregel';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereserv?: Maybe<Scalars['BigFloat']['output']>;
  aantalopenstaand?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cddeelproject?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inkopdrRglGuid?: Maybe<Scalars['String']['output']>;
  inkvolgnr?: Maybe<Scalars['Int']['output']>;
  leverdatum?: Maybe<Scalars['Date']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  orderregel?: Maybe<Scalars['Int']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  regelkortingperc?: Maybe<Scalars['BigFloat']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Inkooporderregel` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InkooporderregelCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalopenstaand` field. */
  aantalopenstaand?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `leverdatum` field. */
  leverdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderregel` field. */
  orderregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `regelkortingperc` field. */
  regelkortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Inkooporderregel` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderregelFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalopenstaand` field. */
  aantalopenstaand?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderregelFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `leverdatum` field. */
  leverdatum?: InputMaybe<DateFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderregelFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderregelFilter>>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `orderregel` field. */
  orderregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `regelkortingperc` field. */
  regelkortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
};

export type InkooporderregelFilterView = {
  __typename?: 'InkooporderregelFilterView';
  ordernummer?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkooporderregelFilterView` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type InkooporderregelFilterViewCondition = {
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkooporderregelFilterView` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderregelFilterViewFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderregelFilterViewFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderregelFilterViewFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderregelFilterViewFilter>>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkooporderregelFilterView` values. */
export type InkooporderregelFilterViewsConnection = {
  __typename?: 'InkooporderregelFilterViewsConnection';
  /** A list of edges which contains the `InkooporderregelFilterView` and cursor to aid in pagination. */
  edges: Array<InkooporderregelFilterViewsEdge>;
  /** A list of `InkooporderregelFilterView` objects. */
  nodes: Array<InkooporderregelFilterView>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkooporderregelFilterView` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkooporderregelFilterView` edge in the connection. */
export type InkooporderregelFilterViewsEdge = {
  __typename?: 'InkooporderregelFilterViewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkooporderregelFilterView` at the end of the edge. */
  node: InkooporderregelFilterView;
};

/** Methods to use when ordering `InkooporderregelFilterView`. */
export enum InkooporderregelFilterViewsOrderBy {
  Natural = 'NATURAL',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC'
}

export type InkooporderregelLevertijden = {
  __typename?: 'InkooporderregelLevertijden';
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  deliveryDate?: Maybe<Scalars['Date']['output']>;
  levertijd?: Maybe<Scalars['Int']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  orderdatum?: Maybe<Scalars['Date']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  orderregel?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `InkooporderregelLevertijden` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type InkooporderregelLevertijdenCondition = {
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `levertijd` field. */
  levertijd?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderregel` field. */
  orderregel?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `InkooporderregelLevertijden` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderregelLevertijdenFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderregelLevertijdenFilter>>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `levertijd` field. */
  levertijd?: InputMaybe<IntFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderregelLevertijdenFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderregelLevertijdenFilter>>;
  /** Filter by the object’s `orderdatum` field. */
  orderdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `orderregel` field. */
  orderregel?: InputMaybe<IntFilter>;
};

/** A connection to a list of `InkooporderregelLevertijden` values. */
export type InkooporderregelLevertijdensConnection = {
  __typename?: 'InkooporderregelLevertijdensConnection';
  /** A list of edges which contains the `InkooporderregelLevertijden` and cursor to aid in pagination. */
  edges: Array<InkooporderregelLevertijdensEdge>;
  /** A list of `InkooporderregelLevertijden` objects. */
  nodes: Array<InkooporderregelLevertijden>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkooporderregelLevertijden` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkooporderregelLevertijden` edge in the connection. */
export type InkooporderregelLevertijdensEdge = {
  __typename?: 'InkooporderregelLevertijdensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkooporderregelLevertijden` at the end of the edge. */
  node: InkooporderregelLevertijden;
};

/** Methods to use when ordering `InkooporderregelLevertijden`. */
export enum InkooporderregelLevertijdensOrderBy {
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  DeliveryDateAsc = 'DELIVERY_DATE_ASC',
  DeliveryDateDesc = 'DELIVERY_DATE_DESC',
  LevertijdAsc = 'LEVERTIJD_ASC',
  LevertijdDesc = 'LEVERTIJD_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  OrderdatumAsc = 'ORDERDATUM_ASC',
  OrderdatumDesc = 'ORDERDATUM_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  OrderregelAsc = 'ORDERREGEL_ASC',
  OrderregelDesc = 'ORDERREGEL_DESC'
}

export type InkooporderregelLine = Node & {
  __typename?: 'InkooporderregelLine';
  _aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  _aantalopenstaand?: Maybe<Scalars['BigFloat']['output']>;
  _cdartikel?: Maybe<Scalars['String']['output']>;
  deliveryDate?: Maybe<Scalars['Date']['output']>;
  deliveryDateConfirmed?: Maybe<Scalars['Boolean']['output']>;
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  inkopdrRglGuid?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  remarks?: Maybe<Scalars['String']['output']>;
  shipmentDate?: Maybe<Scalars['Date']['output']>;
  status?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkooporderregelLine` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type InkooporderregelLineCondition = {
  /** Checks for equality with the object’s `_aantalbesteld` field. */
  _aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `_aantalopenstaand` field. */
  _aantalopenstaand?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `_cdartikel` field. */
  _cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `deliveryDateConfirmed` field. */
  deliveryDateConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shipmentDate` field. */
  shipmentDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkooporderregelLine` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderregelLineFilter = {
  /** Filter by the object’s `_aantalbesteld` field. */
  _aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `_aantalopenstaand` field. */
  _aantalopenstaand?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `_cdartikel` field. */
  _cdartikel?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderregelLineFilter>>;
  /** Filter by the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `deliveryDateConfirmed` field. */
  deliveryDateConfirmed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderregelLineFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderregelLineFilter>>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shipmentDate` field. */
  shipmentDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `InkooporderregelLine` */
export type InkooporderregelLineInput = {
  _aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  _aantalopenstaand?: InputMaybe<Scalars['BigFloat']['input']>;
  _cdartikel?: InputMaybe<Scalars['String']['input']>;
  deliveryDate?: InputMaybe<Scalars['Date']['input']>;
  deliveryDateConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  inkopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  shipmentDate?: InputMaybe<Scalars['Date']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `InkooporderregelLine`. Fields that are set will be updated. */
export type InkooporderregelLinePatch = {
  _aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  _aantalopenstaand?: InputMaybe<Scalars['BigFloat']['input']>;
  _cdartikel?: InputMaybe<Scalars['String']['input']>;
  deliveryDate?: InputMaybe<Scalars['Date']['input']>;
  deliveryDateConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  inkopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  shipmentDate?: InputMaybe<Scalars['Date']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `InkooporderregelLine` values. */
export type InkooporderregelLinesConnection = {
  __typename?: 'InkooporderregelLinesConnection';
  /** A list of edges which contains the `InkooporderregelLine` and cursor to aid in pagination. */
  edges: Array<InkooporderregelLinesEdge>;
  /** A list of `InkooporderregelLine` objects. */
  nodes: Array<InkooporderregelLine>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkooporderregelLine` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkooporderregelLine` edge in the connection. */
export type InkooporderregelLinesEdge = {
  __typename?: 'InkooporderregelLinesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkooporderregelLine` at the end of the edge. */
  node: InkooporderregelLine;
};

/** Methods to use when ordering `InkooporderregelLine`. */
export enum InkooporderregelLinesOrderBy {
  DeliveryDateAsc = 'DELIVERY_DATE_ASC',
  DeliveryDateConfirmedAsc = 'DELIVERY_DATE_CONFIRMED_ASC',
  DeliveryDateConfirmedDesc = 'DELIVERY_DATE_CONFIRMED_DESC',
  DeliveryDateDesc = 'DELIVERY_DATE_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InkopdrRglGuidAsc = 'INKOPDR_RGL_GUID_ASC',
  InkopdrRglGuidDesc = 'INKOPDR_RGL_GUID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  ShipmentDateAsc = 'SHIPMENT_DATE_ASC',
  ShipmentDateDesc = 'SHIPMENT_DATE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  AantalbesteldAsc = '_AANTALBESTELD_ASC',
  AantalbesteldDesc = '_AANTALBESTELD_DESC',
  AantalopenstaandAsc = '_AANTALOPENSTAAND_ASC',
  AantalopenstaandDesc = '_AANTALOPENSTAAND_DESC',
  CdartikelAsc = '_CDARTIKEL_ASC',
  CdartikelDesc = '_CDARTIKEL_DESC'
}

export type InkooporderregelMv = {
  __typename?: 'InkooporderregelMv';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereserv?: Maybe<Scalars['BigFloat']['output']>;
  aantalopenstaand?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cddeelproject?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  endUser?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inkopdrRglGuid?: Maybe<Scalars['String']['output']>;
  inkvolgnr?: Maybe<Scalars['Int']['output']>;
  leverdatum?: Maybe<Scalars['Date']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  orderregel?: Maybe<Scalars['Int']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  regelkortingperc?: Maybe<Scalars['BigFloat']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkooporderregelMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InkooporderregelMvCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalopenstaand` field. */
  aantalopenstaand?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `endUser` field. */
  endUser?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `leverdatum` field. */
  leverdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderregel` field. */
  orderregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `regelkortingperc` field. */
  regelkortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkooporderregelMv` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderregelMvFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalopenstaand` field. */
  aantalopenstaand?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderregelMvFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `endUser` field. */
  endUser?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkvolgnr` field. */
  inkvolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `leverdatum` field. */
  leverdatum?: InputMaybe<DateFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderregelMvFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderregelMvFilter>>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `orderregel` field. */
  orderregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `regelkortingperc` field. */
  regelkortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkooporderregelMv` values. */
export type InkooporderregelMvsConnection = {
  __typename?: 'InkooporderregelMvsConnection';
  /** A list of edges which contains the `InkooporderregelMv` and cursor to aid in pagination. */
  edges: Array<InkooporderregelMvsEdge>;
  /** A list of `InkooporderregelMv` objects. */
  nodes: Array<InkooporderregelMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkooporderregelMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkooporderregelMv` edge in the connection. */
export type InkooporderregelMvsEdge = {
  __typename?: 'InkooporderregelMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkooporderregelMv` at the end of the edge. */
  node: InkooporderregelMv;
};

/** Methods to use when ordering `InkooporderregelMv`. */
export enum InkooporderregelMvsOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  AantalgereservAsc = 'AANTALGERESERV_ASC',
  AantalgereservDesc = 'AANTALGERESERV_DESC',
  AantalopenstaandAsc = 'AANTALOPENSTAAND_ASC',
  AantalopenstaandDesc = 'AANTALOPENSTAAND_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CddeelprojectAsc = 'CDDEELPROJECT_ASC',
  CddeelprojectDesc = 'CDDEELPROJECT_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  EndUserAsc = 'END_USER_ASC',
  EndUserDesc = 'END_USER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InkopdrRglGuidAsc = 'INKOPDR_RGL_GUID_ASC',
  InkopdrRglGuidDesc = 'INKOPDR_RGL_GUID_DESC',
  InkvolgnrAsc = 'INKVOLGNR_ASC',
  InkvolgnrDesc = 'INKVOLGNR_DESC',
  LeverdatumAsc = 'LEVERDATUM_ASC',
  LeverdatumDesc = 'LEVERDATUM_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  OrderregelAsc = 'ORDERREGEL_ASC',
  OrderregelDesc = 'ORDERREGEL_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  RegelkortingpercAsc = 'REGELKORTINGPERC_ASC',
  RegelkortingpercDesc = 'REGELKORTINGPERC_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC'
}

/** A connection to a list of `Inkooporderregel` values. */
export type InkooporderregelsConnection = {
  __typename?: 'InkooporderregelsConnection';
  /** A list of edges which contains the `Inkooporderregel` and cursor to aid in pagination. */
  edges: Array<InkooporderregelsEdge>;
  /** A list of `Inkooporderregel` objects. */
  nodes: Array<Inkooporderregel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Inkooporderregel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Inkooporderregel` edge in the connection. */
export type InkooporderregelsEdge = {
  __typename?: 'InkooporderregelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Inkooporderregel` at the end of the edge. */
  node: Inkooporderregel;
};

export type InkooporderregelsFactopdrachtregel = {
  __typename?: 'InkooporderregelsFactopdrachtregel';
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  inkooporderregelId?: Maybe<Scalars['String']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  orderregel?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `InkooporderregelsFactopdrachtregel` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type InkooporderregelsFactopdrachtregelCondition = {
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkooporderregelId` field. */
  inkooporderregelId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderregel` field. */
  orderregel?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `InkooporderregelsFactopdrachtregel` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderregelsFactopdrachtregelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderregelsFactopdrachtregelFilter>>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkooporderregelId` field. */
  inkooporderregelId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderregelsFactopdrachtregelFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderregelsFactopdrachtregelFilter>>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `orderregel` field. */
  orderregel?: InputMaybe<IntFilter>;
};

/** A connection to a list of `InkooporderregelsFactopdrachtregel` values. */
export type InkooporderregelsFactopdrachtregelsConnection = {
  __typename?: 'InkooporderregelsFactopdrachtregelsConnection';
  /** A list of edges which contains the `InkooporderregelsFactopdrachtregel` and cursor to aid in pagination. */
  edges: Array<InkooporderregelsFactopdrachtregelsEdge>;
  /** A list of `InkooporderregelsFactopdrachtregel` objects. */
  nodes: Array<InkooporderregelsFactopdrachtregel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkooporderregelsFactopdrachtregel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkooporderregelsFactopdrachtregel` edge in the connection. */
export type InkooporderregelsFactopdrachtregelsEdge = {
  __typename?: 'InkooporderregelsFactopdrachtregelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkooporderregelsFactopdrachtregel` at the end of the edge. */
  node: InkooporderregelsFactopdrachtregel;
};

/** Methods to use when ordering `InkooporderregelsFactopdrachtregel`. */
export enum InkooporderregelsFactopdrachtregelsOrderBy {
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  InkooporderregelIdAsc = 'INKOOPORDERREGEL_ID_ASC',
  InkooporderregelIdDesc = 'INKOOPORDERREGEL_ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  Natural = 'NATURAL',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  OrderregelAsc = 'ORDERREGEL_ASC',
  OrderregelDesc = 'ORDERREGEL_DESC'
}

export type InkooporderregelsIndex = {
  __typename?: 'InkooporderregelsIndex';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  aantalopenstaand?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  deliveryDate?: Maybe<Scalars['Date']['output']>;
  deliveryDateConfirmed?: Maybe<Scalars['Boolean']['output']>;
  deliveryWeek?: Maybe<Scalars['String']['output']>;
  deliveryYearWeek?: Maybe<Scalars['Int']['output']>;
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inkooporderregelLineId?: Maybe<Scalars['Int']['output']>;
  inkopdrRglGuid?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ordernummer?: Maybe<Scalars['String']['output']>;
  orderregel?: Maybe<Scalars['Int']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  shipmentDate?: Maybe<Scalars['Date']['output']>;
  status?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkooporderregelsIndex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type InkooporderregelsIndexCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalopenstaand` field. */
  aantalopenstaand?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `deliveryDateConfirmed` field. */
  deliveryDateConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `deliveryWeek` field. */
  deliveryWeek?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deliveryYearWeek` field. */
  deliveryYearWeek?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkooporderregelLineId` field. */
  inkooporderregelLineId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orderregel` field. */
  orderregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shipmentDate` field. */
  shipmentDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkooporderregelsIndex` object types. All fields are combined with a logical ‘and.’ */
export type InkooporderregelsIndexFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalopenstaand` field. */
  aantalopenstaand?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkooporderregelsIndexFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deliveryDate` field. */
  deliveryDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `deliveryDateConfirmed` field. */
  deliveryDateConfirmed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `deliveryWeek` field. */
  deliveryWeek?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deliveryYearWeek` field. */
  deliveryYearWeek?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkooporderregelLineId` field. */
  inkooporderregelLineId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkooporderregelsIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkooporderregelsIndexFilter>>;
  /** Filter by the object’s `ordernummer` field. */
  ordernummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `orderregel` field. */
  orderregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shipmentDate` field. */
  shipmentDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkooporderregelsIndex` values. */
export type InkooporderregelsIndicesConnection = {
  __typename?: 'InkooporderregelsIndicesConnection';
  /** A list of edges which contains the `InkooporderregelsIndex` and cursor to aid in pagination. */
  edges: Array<InkooporderregelsIndicesEdge>;
  /** A list of `InkooporderregelsIndex` objects. */
  nodes: Array<InkooporderregelsIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkooporderregelsIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkooporderregelsIndex` edge in the connection. */
export type InkooporderregelsIndicesEdge = {
  __typename?: 'InkooporderregelsIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkooporderregelsIndex` at the end of the edge. */
  node: InkooporderregelsIndex;
};

/** Methods to use when ordering `InkooporderregelsIndex`. */
export enum InkooporderregelsIndicesOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  AantalopenstaandAsc = 'AANTALOPENSTAAND_ASC',
  AantalopenstaandDesc = 'AANTALOPENSTAAND_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  DeliveryDateAsc = 'DELIVERY_DATE_ASC',
  DeliveryDateConfirmedAsc = 'DELIVERY_DATE_CONFIRMED_ASC',
  DeliveryDateConfirmedDesc = 'DELIVERY_DATE_CONFIRMED_DESC',
  DeliveryDateDesc = 'DELIVERY_DATE_DESC',
  DeliveryWeekAsc = 'DELIVERY_WEEK_ASC',
  DeliveryWeekDesc = 'DELIVERY_WEEK_DESC',
  DeliveryYearWeekAsc = 'DELIVERY_YEAR_WEEK_ASC',
  DeliveryYearWeekDesc = 'DELIVERY_YEAR_WEEK_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InkooporderregelLineIdAsc = 'INKOOPORDERREGEL_LINE_ID_ASC',
  InkooporderregelLineIdDesc = 'INKOOPORDERREGEL_LINE_ID_DESC',
  InkopdrRglGuidAsc = 'INKOPDR_RGL_GUID_ASC',
  InkopdrRglGuidDesc = 'INKOPDR_RGL_GUID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  OrderregelAsc = 'ORDERREGEL_ASC',
  OrderregelDesc = 'ORDERREGEL_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  ShipmentDateAsc = 'SHIPMENT_DATE_ASC',
  ShipmentDateDesc = 'SHIPMENT_DATE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC'
}

/** Methods to use when ordering `Inkooporderregel`. */
export enum InkooporderregelsOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  AantalgereservAsc = 'AANTALGERESERV_ASC',
  AantalgereservDesc = 'AANTALGERESERV_DESC',
  AantalopenstaandAsc = 'AANTALOPENSTAAND_ASC',
  AantalopenstaandDesc = 'AANTALOPENSTAAND_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CddeelprojectAsc = 'CDDEELPROJECT_ASC',
  CddeelprojectDesc = 'CDDEELPROJECT_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InkopdrRglGuidAsc = 'INKOPDR_RGL_GUID_ASC',
  InkopdrRglGuidDesc = 'INKOPDR_RGL_GUID_DESC',
  InkvolgnrAsc = 'INKVOLGNR_ASC',
  InkvolgnrDesc = 'INKVOLGNR_DESC',
  LeverdatumAsc = 'LEVERDATUM_ASC',
  LeverdatumDesc = 'LEVERDATUM_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  OrderregelAsc = 'ORDERREGEL_ASC',
  OrderregelDesc = 'ORDERREGEL_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  RegelkortingpercAsc = 'REGELKORTINGPERC_ASC',
  RegelkortingpercDesc = 'REGELKORTINGPERC_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC'
}

/** A connection to a list of `Inkooporder` values. */
export type InkoopordersConnection = {
  __typename?: 'InkoopordersConnection';
  /** A list of edges which contains the `Inkooporder` and cursor to aid in pagination. */
  edges: Array<InkoopordersEdge>;
  /** A list of `Inkooporder` objects. */
  nodes: Array<Inkooporder>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Inkooporder` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Inkooporder` edge in the connection. */
export type InkoopordersEdge = {
  __typename?: 'InkoopordersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Inkooporder` at the end of the edge. */
  node: Inkooporder;
};

/** Methods to use when ordering `Inkooporder`. */
export enum InkoopordersOrderBy {
  AdresAsc = 'ADRES_ASC',
  AdresDesc = 'ADRES_DESC',
  AfdruktellerAsc = 'AFDRUKTELLER_ASC',
  AfdruktellerDesc = 'AFDRUKTELLER_DESC',
  BehandelddoorAsc = 'BEHANDELDDOOR_ASC',
  BehandelddoorDesc = 'BEHANDELDDOOR_DESC',
  CdbehandelddoorAsc = 'CDBEHANDELDDOOR_ASC',
  CdbehandelddoorDesc = 'CDBEHANDELDDOOR_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CdfiatteurAsc = 'CDFIATTEUR_ASC',
  CdfiatteurDesc = 'CDFIATTEUR_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdprojectAsc = 'CDPROJECT_ASC',
  CdprojectDesc = 'CDPROJECT_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  GefiatteerdAsc = 'GEFIATTEERD_ASC',
  GefiatteerdDesc = 'GEFIATTEERD_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  Natural = 'NATURAL',
  OpenstaandAsc = 'OPENSTAAND_ASC',
  OpenstaandDesc = 'OPENSTAAND_DESC',
  OrderdatumAsc = 'ORDERDATUM_ASC',
  OrderdatumDesc = 'ORDERDATUM_DESC',
  OrderkortbedragAsc = 'ORDERKORTBEDRAG_ASC',
  OrderkortbedragDesc = 'ORDERKORTBEDRAG_DESC',
  OrderkortpercAsc = 'ORDERKORTPERC_ASC',
  OrderkortpercDesc = 'ORDERKORTPERC_DESC',
  OrdernummerAsc = 'ORDERNUMMER_ASC',
  OrdernummerDesc = 'ORDERNUMMER_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  ToelichtingAsc = 'TOELICHTING_ASC',
  ToelichtingDesc = 'TOELICHTING_DESC'
}

export type InkoopprijsChangesIndex = {
  __typename?: 'InkoopprijsChangesIndex';
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  crediteurZoeknaam?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  inkoopprijsNew?: Maybe<Scalars['BigFloat']['output']>;
  inkoopprijsOld?: Maybe<Scalars['BigFloat']['output']>;
  marginCalculated?: Maybe<Scalars['BigFloat']['output']>;
  marginCurrent?: Maybe<Scalars['BigFloat']['output']>;
  marginDiff?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  uitloop?: Maybe<Scalars['String']['output']>;
  verrekenprijsCalculated?: Maybe<Scalars['BigFloat']['output']>;
  verrekenprijsCurrent?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `InkoopprijsChangesIndex` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type InkoopprijsChangesIndexCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `crediteurZoeknaam` field. */
  crediteurZoeknaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `inkoopprijsNew` field. */
  inkoopprijsNew?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkoopprijsOld` field. */
  inkoopprijsOld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginCalculated` field. */
  marginCalculated?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginCurrent` field. */
  marginCurrent?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginDiff` field. */
  marginDiff?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uitloop` field. */
  uitloop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijsCalculated` field. */
  verrekenprijsCalculated?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `verrekenprijsCurrent` field. */
  verrekenprijsCurrent?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `InkoopprijsChangesIndex` object types. All fields are combined with a logical ‘and.’ */
export type InkoopprijsChangesIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InkoopprijsChangesIndexFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `crediteurZoeknaam` field. */
  crediteurZoeknaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `inkoopprijsNew` field. */
  inkoopprijsNew?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkoopprijsOld` field. */
  inkoopprijsOld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `marginCalculated` field. */
  marginCalculated?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `marginCurrent` field. */
  marginCurrent?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `marginDiff` field. */
  marginDiff?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InkoopprijsChangesIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InkoopprijsChangesIndexFilter>>;
  /** Filter by the object’s `uitloop` field. */
  uitloop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verrekenprijsCalculated` field. */
  verrekenprijsCalculated?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `verrekenprijsCurrent` field. */
  verrekenprijsCurrent?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `InkoopprijsChangesIndex` values. */
export type InkoopprijsChangesIndicesConnection = {
  __typename?: 'InkoopprijsChangesIndicesConnection';
  /** A list of edges which contains the `InkoopprijsChangesIndex` and cursor to aid in pagination. */
  edges: Array<InkoopprijsChangesIndicesEdge>;
  /** A list of `InkoopprijsChangesIndex` objects. */
  nodes: Array<InkoopprijsChangesIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InkoopprijsChangesIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InkoopprijsChangesIndex` edge in the connection. */
export type InkoopprijsChangesIndicesEdge = {
  __typename?: 'InkoopprijsChangesIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InkoopprijsChangesIndex` at the end of the edge. */
  node: InkoopprijsChangesIndex;
};

/** Methods to use when ordering `InkoopprijsChangesIndex`. */
export enum InkoopprijsChangesIndicesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CrediteurZoeknaamAsc = 'CREDITEUR_ZOEKNAAM_ASC',
  CrediteurZoeknaamDesc = 'CREDITEUR_ZOEKNAAM_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InkoopprijsNewAsc = 'INKOOPPRIJS_NEW_ASC',
  InkoopprijsNewDesc = 'INKOOPPRIJS_NEW_DESC',
  InkoopprijsOldAsc = 'INKOOPPRIJS_OLD_ASC',
  InkoopprijsOldDesc = 'INKOOPPRIJS_OLD_DESC',
  MarginCalculatedAsc = 'MARGIN_CALCULATED_ASC',
  MarginCalculatedDesc = 'MARGIN_CALCULATED_DESC',
  MarginCurrentAsc = 'MARGIN_CURRENT_ASC',
  MarginCurrentDesc = 'MARGIN_CURRENT_DESC',
  MarginDiffAsc = 'MARGIN_DIFF_ASC',
  MarginDiffDesc = 'MARGIN_DIFF_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  UitloopAsc = 'UITLOOP_ASC',
  UitloopDesc = 'UITLOOP_DESC',
  VerrekenprijsCalculatedAsc = 'VERREKENPRIJS_CALCULATED_ASC',
  VerrekenprijsCalculatedDesc = 'VERREKENPRIJS_CALCULATED_DESC',
  VerrekenprijsCurrentAsc = 'VERREKENPRIJS_CURRENT_ASC',
  VerrekenprijsCurrentDesc = 'VERREKENPRIJS_CURRENT_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A filter to be used against Int List fields. All fields are combined with a logical ‘and.’ */
export type IntListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
};

/** An interval of time that has passed where the smallest distinct unit is a second. */
export type Interval = {
  __typename?: 'Interval';
  /** A quantity of days. */
  days?: Maybe<Scalars['Int']['output']>;
  /** A quantity of hours. */
  hours?: Maybe<Scalars['Int']['output']>;
  /** A quantity of minutes. */
  minutes?: Maybe<Scalars['Int']['output']>;
  /** A quantity of months. */
  months?: Maybe<Scalars['Int']['output']>;
  /**
   * A quantity of seconds. This is the only non-integer field, as all the other
   * fields will dump their overflow into a smaller unit of time. Intervals don’t
   * have a smaller unit than seconds.
   */
  seconds?: Maybe<Scalars['Float']['output']>;
  /** A quantity of years. */
  years?: Maybe<Scalars['Int']['output']>;
};

/** A filter to be used against Interval fields. All fields are combined with a logical ‘and.’ */
export type IntervalFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<IntervalInput>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<IntervalInput>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<IntervalInput>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<IntervalInput>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<IntervalInput>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<IntervalInput>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<IntervalInput>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<IntervalInput>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<IntervalInput>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<IntervalInput>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<IntervalInput>>;
};

/** An interval of time that has passed where the smallest distinct unit is a second. */
export type IntervalInput = {
  /** A quantity of days. */
  days?: InputMaybe<Scalars['Int']['input']>;
  /** A quantity of hours. */
  hours?: InputMaybe<Scalars['Int']['input']>;
  /** A quantity of minutes. */
  minutes?: InputMaybe<Scalars['Int']['input']>;
  /** A quantity of months. */
  months?: InputMaybe<Scalars['Int']['input']>;
  /**
   * A quantity of seconds. This is the only non-integer field, as all the other
   * fields will dump their overflow into a smaller unit of time. Intervals don’t
   * have a smaller unit than seconds.
   */
  seconds?: InputMaybe<Scalars['Float']['input']>;
  /** A quantity of years. */
  years?: InputMaybe<Scalars['Int']['input']>;
};

export type Item = Node & {
  __typename?: 'Item';
  cdartikel: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `EndUser` that is related to this `Item`. */
  endUserByEndUserId?: Maybe<EndUser>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  labelDate?: Maybe<Scalars['Date']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ReportItem`. */
  reportItemsByItemId: ReportItemsConnection;
  serialNumber: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `Item`. */
  userByOwnerId?: Maybe<User>;
};


export type ItemReportItemsByItemIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportItemCondition>;
  filter?: InputMaybe<ReportItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportItemsOrderBy>>;
};

/** A condition to be used against `Item` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ItemCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `labelDate` field. */
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Item` object types. All fields are combined with a logical ‘and.’ */
export type ItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ItemFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `endUserByEndUserId` relation. */
  endUserByEndUserId?: InputMaybe<EndUserFilter>;
  /** A related `endUserByEndUserId` exists. */
  endUserByEndUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `labelDate` field. */
  labelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ItemFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reportItemsByItemId` relation. */
  reportItemsByItemId?: InputMaybe<ItemToManyReportItemFilter>;
  /** Some related `reportItemsByItemId` exist. */
  reportItemsByItemIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `Item` */
export type ItemInput = {
  cdartikel: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber: Scalars['String']['input'];
};

/** Represents an update to a `Item`. Fields that are set will be updated. */
export type ItemPatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `ReportItem` object types. All fields are combined with a logical ‘and.’ */
export type ItemToManyReportItemFilter = {
  /** Every related `ReportItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReportItemFilter>;
  /** No related `ReportItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReportItemFilter>;
  /** Some related `ReportItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReportItemFilter>;
};

/** A connection to a list of `Item` values. */
export type ItemsConnection = {
  __typename?: 'ItemsConnection';
  /** A list of edges which contains the `Item` and cursor to aid in pagination. */
  edges: Array<ItemsEdge>;
  /** A list of `Item` objects. */
  nodes: Array<Item>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Item` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Item` edge in the connection. */
export type ItemsEdge = {
  __typename?: 'ItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Item` at the end of the edge. */
  node: Item;
};

/** Methods to use when ordering `Item`. */
export enum ItemsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EndUserByEndUserIdAddress1Asc = 'END_USER_BY_END_USER_ID__ADDRESS1_ASC',
  EndUserByEndUserIdAddress1Desc = 'END_USER_BY_END_USER_ID__ADDRESS1_DESC',
  EndUserByEndUserIdAddress2Asc = 'END_USER_BY_END_USER_ID__ADDRESS2_ASC',
  EndUserByEndUserIdAddress2Desc = 'END_USER_BY_END_USER_ID__ADDRESS2_DESC',
  EndUserByEndUserIdCityAsc = 'END_USER_BY_END_USER_ID__CITY_ASC',
  EndUserByEndUserIdCityDesc = 'END_USER_BY_END_USER_ID__CITY_DESC',
  EndUserByEndUserIdContactEmailAsc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_ASC',
  EndUserByEndUserIdContactEmailDesc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_DESC',
  EndUserByEndUserIdContactNameAsc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_ASC',
  EndUserByEndUserIdContactNameDesc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_DESC',
  EndUserByEndUserIdContactPhoneAsc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_ASC',
  EndUserByEndUserIdContactPhoneDesc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_DESC',
  EndUserByEndUserIdCountryAsc = 'END_USER_BY_END_USER_ID__COUNTRY_ASC',
  EndUserByEndUserIdCountryDesc = 'END_USER_BY_END_USER_ID__COUNTRY_DESC',
  EndUserByEndUserIdCreatedAsc = 'END_USER_BY_END_USER_ID__CREATED_ASC',
  EndUserByEndUserIdCreatedDesc = 'END_USER_BY_END_USER_ID__CREATED_DESC',
  EndUserByEndUserIdFormerName1Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_ASC',
  EndUserByEndUserIdFormerName1Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_DESC',
  EndUserByEndUserIdFormerName2Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_ASC',
  EndUserByEndUserIdFormerName2Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_DESC',
  EndUserByEndUserIdIdAsc = 'END_USER_BY_END_USER_ID__ID_ASC',
  EndUserByEndUserIdIdDesc = 'END_USER_BY_END_USER_ID__ID_DESC',
  EndUserByEndUserIdLocationAsc = 'END_USER_BY_END_USER_ID__LOCATION_ASC',
  EndUserByEndUserIdLocationDesc = 'END_USER_BY_END_USER_ID__LOCATION_DESC',
  EndUserByEndUserIdModifiedAsc = 'END_USER_BY_END_USER_ID__MODIFIED_ASC',
  EndUserByEndUserIdModifiedDesc = 'END_USER_BY_END_USER_ID__MODIFIED_DESC',
  EndUserByEndUserIdNameAsc = 'END_USER_BY_END_USER_ID__NAME_ASC',
  EndUserByEndUserIdNameDesc = 'END_USER_BY_END_USER_ID__NAME_DESC',
  EndUserByEndUserIdOwnerIdAsc = 'END_USER_BY_END_USER_ID__OWNER_ID_ASC',
  EndUserByEndUserIdOwnerIdDesc = 'END_USER_BY_END_USER_ID__OWNER_ID_DESC',
  EndUserByEndUserIdRegionAsc = 'END_USER_BY_END_USER_ID__REGION_ASC',
  EndUserByEndUserIdRegionDesc = 'END_USER_BY_END_USER_ID__REGION_DESC',
  EndUserByEndUserIdSubLocationAsc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_ASC',
  EndUserByEndUserIdSubLocationDesc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_DESC',
  EndUserByEndUserIdZipCodeAsc = 'END_USER_BY_END_USER_ID__ZIP_CODE_ASC',
  EndUserByEndUserIdZipCodeDesc = 'END_USER_BY_END_USER_ID__ZIP_CODE_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelDateAsc = 'LABEL_DATE_ASC',
  LabelDateDesc = 'LABEL_DATE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  ReportItemsByItemIdCountAsc = 'REPORT_ITEMS_BY_ITEM_ID__COUNT_ASC',
  ReportItemsByItemIdCountDesc = 'REPORT_ITEMS_BY_ITEM_ID__COUNT_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']['input']>>;
};

export type Job = Node & {
  __typename?: 'Job';
  confirmed?: Maybe<Scalars['Boolean']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Reads a single `EndUser` that is related to this `Job`. */
  endUserByEndUserId?: Maybe<EndUser>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  factuuropdracht: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  startDate?: Maybe<Scalars['Date']['output']>;
  /** Reads a single `User` that is related to this `Job`. */
  userByOwnerId?: Maybe<User>;
};

/** A condition to be used against `Job` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type JobCondition = {
  /** Checks for equality with the object’s `confirmed` field. */
  confirmed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `endDate` field. */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `startDate` field. */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** A filter to be used against `Job` object types. All fields are combined with a logical ‘and.’ */
export type JobFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JobFilter>>;
  /** Filter by the object’s `confirmed` field. */
  confirmed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `endDate` field. */
  endDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `endUserByEndUserId` relation. */
  endUserByEndUserId?: InputMaybe<EndUserFilter>;
  /** A related `endUserByEndUserId` exists. */
  endUserByEndUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JobFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JobFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `startDate` field. */
  startDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Job` */
export type JobInput = {
  confirmed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  factuuropdracht: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Represents an update to a `Job`. Fields that are set will be updated. */
export type JobPatch = {
  confirmed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** A connection to a list of `Job` values. */
export type JobsConnection = {
  __typename?: 'JobsConnection';
  /** A list of edges which contains the `Job` and cursor to aid in pagination. */
  edges: Array<JobsEdge>;
  /** A list of `Job` objects. */
  nodes: Array<Job>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Job` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Job` edge in the connection. */
export type JobsEdge = {
  __typename?: 'JobsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Job` at the end of the edge. */
  node: Job;
};

/** Methods to use when ordering `Job`. */
export enum JobsOrderBy {
  ConfirmedAsc = 'CONFIRMED_ASC',
  ConfirmedDesc = 'CONFIRMED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EndDateAsc = 'END_DATE_ASC',
  EndDateDesc = 'END_DATE_DESC',
  EndUserByEndUserIdAddress1Asc = 'END_USER_BY_END_USER_ID__ADDRESS1_ASC',
  EndUserByEndUserIdAddress1Desc = 'END_USER_BY_END_USER_ID__ADDRESS1_DESC',
  EndUserByEndUserIdAddress2Asc = 'END_USER_BY_END_USER_ID__ADDRESS2_ASC',
  EndUserByEndUserIdAddress2Desc = 'END_USER_BY_END_USER_ID__ADDRESS2_DESC',
  EndUserByEndUserIdCityAsc = 'END_USER_BY_END_USER_ID__CITY_ASC',
  EndUserByEndUserIdCityDesc = 'END_USER_BY_END_USER_ID__CITY_DESC',
  EndUserByEndUserIdContactEmailAsc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_ASC',
  EndUserByEndUserIdContactEmailDesc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_DESC',
  EndUserByEndUserIdContactNameAsc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_ASC',
  EndUserByEndUserIdContactNameDesc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_DESC',
  EndUserByEndUserIdContactPhoneAsc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_ASC',
  EndUserByEndUserIdContactPhoneDesc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_DESC',
  EndUserByEndUserIdCountryAsc = 'END_USER_BY_END_USER_ID__COUNTRY_ASC',
  EndUserByEndUserIdCountryDesc = 'END_USER_BY_END_USER_ID__COUNTRY_DESC',
  EndUserByEndUserIdCreatedAsc = 'END_USER_BY_END_USER_ID__CREATED_ASC',
  EndUserByEndUserIdCreatedDesc = 'END_USER_BY_END_USER_ID__CREATED_DESC',
  EndUserByEndUserIdFormerName1Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_ASC',
  EndUserByEndUserIdFormerName1Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_DESC',
  EndUserByEndUserIdFormerName2Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_ASC',
  EndUserByEndUserIdFormerName2Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_DESC',
  EndUserByEndUserIdIdAsc = 'END_USER_BY_END_USER_ID__ID_ASC',
  EndUserByEndUserIdIdDesc = 'END_USER_BY_END_USER_ID__ID_DESC',
  EndUserByEndUserIdLocationAsc = 'END_USER_BY_END_USER_ID__LOCATION_ASC',
  EndUserByEndUserIdLocationDesc = 'END_USER_BY_END_USER_ID__LOCATION_DESC',
  EndUserByEndUserIdModifiedAsc = 'END_USER_BY_END_USER_ID__MODIFIED_ASC',
  EndUserByEndUserIdModifiedDesc = 'END_USER_BY_END_USER_ID__MODIFIED_DESC',
  EndUserByEndUserIdNameAsc = 'END_USER_BY_END_USER_ID__NAME_ASC',
  EndUserByEndUserIdNameDesc = 'END_USER_BY_END_USER_ID__NAME_DESC',
  EndUserByEndUserIdOwnerIdAsc = 'END_USER_BY_END_USER_ID__OWNER_ID_ASC',
  EndUserByEndUserIdOwnerIdDesc = 'END_USER_BY_END_USER_ID__OWNER_ID_DESC',
  EndUserByEndUserIdRegionAsc = 'END_USER_BY_END_USER_ID__REGION_ASC',
  EndUserByEndUserIdRegionDesc = 'END_USER_BY_END_USER_ID__REGION_DESC',
  EndUserByEndUserIdSubLocationAsc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_ASC',
  EndUserByEndUserIdSubLocationDesc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_DESC',
  EndUserByEndUserIdZipCodeAsc = 'END_USER_BY_END_USER_ID__ZIP_CODE_ASC',
  EndUserByEndUserIdZipCodeDesc = 'END_USER_BY_END_USER_ID__ZIP_CODE_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StartDateAsc = 'START_DATE_ASC',
  StartDateDesc = 'START_DATE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type JunctionBox = Node & {
  __typename?: 'JunctionBox';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `JunctionBox`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `JunctionBox` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type JunctionBoxCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `JunctionBox` object types. All fields are combined with a logical ‘and.’ */
export type JunctionBoxFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<JunctionBoxFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<JunctionBoxFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<JunctionBoxFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `JunctionBox` */
export type JunctionBoxInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `JunctionBox`. Fields that are set will be updated. */
export type JunctionBoxPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `JunctionBox` values. */
export type JunctionBoxesConnection = {
  __typename?: 'JunctionBoxesConnection';
  /** A list of edges which contains the `JunctionBox` and cursor to aid in pagination. */
  edges: Array<JunctionBoxesEdge>;
  /** A list of `JunctionBox` objects. */
  nodes: Array<JunctionBox>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `JunctionBox` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `JunctionBox` edge in the connection. */
export type JunctionBoxesEdge = {
  __typename?: 'JunctionBoxesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `JunctionBox` at the end of the edge. */
  node: JunctionBox;
};

/** Methods to use when ordering `JunctionBox`. */
export enum JunctionBoxesOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Land = {
  __typename?: 'Land';
  cbsland?: Maybe<Scalars['String']['output']>;
  cdeglid?: Maybe<Scalars['String']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  isoland?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  rszland?: Maybe<Scalars['Int']['output']>;
  sepa?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Land` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LandCondition = {
  /** Checks for equality with the object’s `cbsland` field. */
  cbsland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdeglid` field. */
  cdeglid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isoland` field. */
  isoland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rszland` field. */
  rszland?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sepa` field. */
  sepa?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Land` object types. All fields are combined with a logical ‘and.’ */
export type LandFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LandFilter>>;
  /** Filter by the object’s `cbsland` field. */
  cbsland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdeglid` field. */
  cdeglid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isoland` field. */
  isoland?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LandFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LandFilter>>;
  /** Filter by the object’s `rszland` field. */
  rszland?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sepa` field. */
  sepa?: InputMaybe<StringFilter>;
};

export type LandMv = {
  __typename?: 'LandMv';
  cbsland?: Maybe<Scalars['String']['output']>;
  cdeglid?: Maybe<Scalars['String']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  isoland?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  rszland?: Maybe<Scalars['Int']['output']>;
  sepa?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `LandMv` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LandMvCondition = {
  /** Checks for equality with the object’s `cbsland` field. */
  cbsland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdeglid` field. */
  cdeglid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isoland` field. */
  isoland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rszland` field. */
  rszland?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sepa` field. */
  sepa?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `LandMv` object types. All fields are combined with a logical ‘and.’ */
export type LandMvFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LandMvFilter>>;
  /** Filter by the object’s `cbsland` field. */
  cbsland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdeglid` field. */
  cdeglid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isoland` field. */
  isoland?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LandMvFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LandMvFilter>>;
  /** Filter by the object’s `rszland` field. */
  rszland?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sepa` field. */
  sepa?: InputMaybe<StringFilter>;
};

/** A connection to a list of `LandMv` values. */
export type LandMvsConnection = {
  __typename?: 'LandMvsConnection';
  /** A list of edges which contains the `LandMv` and cursor to aid in pagination. */
  edges: Array<LandMvsEdge>;
  /** A list of `LandMv` objects. */
  nodes: Array<LandMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LandMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LandMv` edge in the connection. */
export type LandMvsEdge = {
  __typename?: 'LandMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LandMv` at the end of the edge. */
  node: LandMv;
};

/** Methods to use when ordering `LandMv`. */
export enum LandMvsOrderBy {
  CbslandAsc = 'CBSLAND_ASC',
  CbslandDesc = 'CBSLAND_DESC',
  CdeglidAsc = 'CDEGLID_ASC',
  CdeglidDesc = 'CDEGLID_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  IsolandAsc = 'ISOLAND_ASC',
  IsolandDesc = 'ISOLAND_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  RszlandAsc = 'RSZLAND_ASC',
  RszlandDesc = 'RSZLAND_DESC',
  SepaAsc = 'SEPA_ASC',
  SepaDesc = 'SEPA_DESC'
}

/** A connection to a list of `Land` values. */
export type LandsConnection = {
  __typename?: 'LandsConnection';
  /** A list of edges which contains the `Land` and cursor to aid in pagination. */
  edges: Array<LandsEdge>;
  /** A list of `Land` objects. */
  nodes: Array<Land>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Land` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Land` edge in the connection. */
export type LandsEdge = {
  __typename?: 'LandsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Land` at the end of the edge. */
  node: Land;
};

/** Methods to use when ordering `Land`. */
export enum LandsOrderBy {
  CbslandAsc = 'CBSLAND_ASC',
  CbslandDesc = 'CBSLAND_DESC',
  CdeglidAsc = 'CDEGLID_ASC',
  CdeglidDesc = 'CDEGLID_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  IsolandAsc = 'ISOLAND_ASC',
  IsolandDesc = 'ISOLAND_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  RszlandAsc = 'RSZLAND_ASC',
  RszlandDesc = 'RSZLAND_DESC',
  SepaAsc = 'SEPA_ASC',
  SepaDesc = 'SEPA_DESC'
}

export type Lead = Node & {
  __typename?: 'Lead';
  address?: Maybe<Scalars['String']['output']>;
  businessSector?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  clickThroughsToYourSite?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  dateOfLastRequest?: Maybe<Scalars['Date']['output']>;
  dateOfLastVisit?: Maybe<Scalars['Date']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  noOfEmployees?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  requests?: Maybe<Scalars['String']['output']>;
  telephone?: Maybe<Scalars['String']['output']>;
  typeOfCompany?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Lead`. */
  userByOwnerId?: Maybe<User>;
  viewedElements?: Maybe<Scalars['String']['output']>;
  webSite?: Maybe<Scalars['String']['output']>;
  zipCode?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Lead` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LeadCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `businessSector` field. */
  businessSector?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `clickThroughsToYourSite` field. */
  clickThroughsToYourSite?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `company` field. */
  company?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `dateOfLastRequest` field. */
  dateOfLastRequest?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `dateOfLastVisit` field. */
  dateOfLastVisit?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `noOfEmployees` field. */
  noOfEmployees?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `requests` field. */
  requests?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telephone` field. */
  telephone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `typeOfCompany` field. */
  typeOfCompany?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `viewedElements` field. */
  viewedElements?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `webSite` field. */
  webSite?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zipCode` field. */
  zipCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Lead` object types. All fields are combined with a logical ‘and.’ */
export type LeadFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LeadFilter>>;
  /** Filter by the object’s `businessSector` field. */
  businessSector?: InputMaybe<StringFilter>;
  /** Filter by the object’s `city` field. */
  city?: InputMaybe<StringFilter>;
  /** Filter by the object’s `clickThroughsToYourSite` field. */
  clickThroughsToYourSite?: InputMaybe<StringFilter>;
  /** Filter by the object’s `company` field. */
  company?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `dateOfLastRequest` field. */
  dateOfLastRequest?: InputMaybe<DateFilter>;
  /** Filter by the object’s `dateOfLastVisit` field. */
  dateOfLastVisit?: InputMaybe<DateFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `noOfEmployees` field. */
  noOfEmployees?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LeadFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LeadFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `requests` field. */
  requests?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telephone` field. */
  telephone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `typeOfCompany` field. */
  typeOfCompany?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `viewedElements` field. */
  viewedElements?: InputMaybe<StringFilter>;
  /** Filter by the object’s `webSite` field. */
  webSite?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zipCode` field. */
  zipCode?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Lead` */
export type LeadInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  businessSector?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  clickThroughsToYourSite?: InputMaybe<Scalars['String']['input']>;
  company?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  dateOfLastRequest?: InputMaybe<Scalars['Date']['input']>;
  dateOfLastVisit?: InputMaybe<Scalars['Date']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  noOfEmployees?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  requests?: InputMaybe<Scalars['String']['input']>;
  telephone?: InputMaybe<Scalars['String']['input']>;
  typeOfCompany?: InputMaybe<Scalars['String']['input']>;
  viewedElements?: InputMaybe<Scalars['String']['input']>;
  webSite?: InputMaybe<Scalars['String']['input']>;
  zipCode?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Lead`. Fields that are set will be updated. */
export type LeadPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  businessSector?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  clickThroughsToYourSite?: InputMaybe<Scalars['String']['input']>;
  company?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  dateOfLastRequest?: InputMaybe<Scalars['Date']['input']>;
  dateOfLastVisit?: InputMaybe<Scalars['Date']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  noOfEmployees?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  requests?: InputMaybe<Scalars['String']['input']>;
  telephone?: InputMaybe<Scalars['String']['input']>;
  typeOfCompany?: InputMaybe<Scalars['String']['input']>;
  viewedElements?: InputMaybe<Scalars['String']['input']>;
  webSite?: InputMaybe<Scalars['String']['input']>;
  zipCode?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Lead` values. */
export type LeadsConnection = {
  __typename?: 'LeadsConnection';
  /** A list of edges which contains the `Lead` and cursor to aid in pagination. */
  edges: Array<LeadsEdge>;
  /** A list of `Lead` objects. */
  nodes: Array<Lead>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Lead` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Lead` edge in the connection. */
export type LeadsEdge = {
  __typename?: 'LeadsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Lead` at the end of the edge. */
  node: Lead;
};

/** Methods to use when ordering `Lead`. */
export enum LeadsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  BusinessSectorAsc = 'BUSINESS_SECTOR_ASC',
  BusinessSectorDesc = 'BUSINESS_SECTOR_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  ClickThroughsToYourSiteAsc = 'CLICK_THROUGHS_TO_YOUR_SITE_ASC',
  ClickThroughsToYourSiteDesc = 'CLICK_THROUGHS_TO_YOUR_SITE_DESC',
  CompanyAsc = 'COMPANY_ASC',
  CompanyDesc = 'COMPANY_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateOfLastRequestAsc = 'DATE_OF_LAST_REQUEST_ASC',
  DateOfLastRequestDesc = 'DATE_OF_LAST_REQUEST_DESC',
  DateOfLastVisitAsc = 'DATE_OF_LAST_VISIT_ASC',
  DateOfLastVisitDesc = 'DATE_OF_LAST_VISIT_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  NoOfEmployeesAsc = 'NO_OF_EMPLOYEES_ASC',
  NoOfEmployeesDesc = 'NO_OF_EMPLOYEES_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequestsAsc = 'REQUESTS_ASC',
  RequestsDesc = 'REQUESTS_DESC',
  TelephoneAsc = 'TELEPHONE_ASC',
  TelephoneDesc = 'TELEPHONE_DESC',
  TypeOfCompanyAsc = 'TYPE_OF_COMPANY_ASC',
  TypeOfCompanyDesc = 'TYPE_OF_COMPANY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  ViewedElementsAsc = 'VIEWED_ELEMENTS_ASC',
  ViewedElementsDesc = 'VIEWED_ELEMENTS_DESC',
  WebSiteAsc = 'WEB_SITE_ASC',
  WebSiteDesc = 'WEB_SITE_DESC',
  ZipCodeAsc = 'ZIP_CODE_ASC',
  ZipCodeDesc = 'ZIP_CODE_DESC'
}

export type Levertijden = {
  __typename?: 'Levertijden';
  aantalgeleverd?: Maybe<Scalars['BigFloat']['output']>;
  cdartgroep?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cwaQty?: Maybe<Scalars['BigFloat']['output']>;
  cwaWgt?: Maybe<Scalars['BigFloat']['output']>;
  factuurdatum?: Maybe<Scalars['Date']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  invoiceOrderDays?: Maybe<Scalars['Int']['output']>;
  invoiceOrderWeeks?: Maybe<Scalars['BigFloat']['output']>;
  invoiceTargetDays?: Maybe<Scalars['Int']['output']>;
  invoiceTargetWeeks?: Maybe<Scalars['BigFloat']['output']>;
  isoland?: Maybe<Scalars['String']['output']>;
  kfpQty?: Maybe<Scalars['BigFloat']['output']>;
  kfpWgt?: Maybe<Scalars['BigFloat']['output']>;
  materials?: Maybe<Scalars['Boolean']['output']>;
  nettoomzet?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  opdrachtdatum?: Maybe<Scalars['Date']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  targetDate?: Maybe<Scalars['Date']['output']>;
  wad1Qty?: Maybe<Scalars['BigFloat']['output']>;
  wad1Wgt?: Maybe<Scalars['BigFloat']['output']>;
  wad2Qty?: Maybe<Scalars['BigFloat']['output']>;
  wad2Wgt?: Maybe<Scalars['BigFloat']['output']>;
  wad4Qty?: Maybe<Scalars['BigFloat']['output']>;
  wad4Wgt?: Maybe<Scalars['BigFloat']['output']>;
  wadBoxQty?: Maybe<Scalars['BigFloat']['output']>;
  wadBoxWgt?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Levertijden` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LevertijdenCondition = {
  /** Checks for equality with the object’s `aantalgeleverd` field. */
  aantalgeleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartgroep` field. */
  cdartgroep?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cwaQty` field. */
  cwaQty?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cwaWgt` field. */
  cwaWgt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factuurdatum` field. */
  factuurdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `invoiceOrderDays` field. */
  invoiceOrderDays?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `invoiceOrderWeeks` field. */
  invoiceOrderWeeks?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `invoiceTargetDays` field. */
  invoiceTargetDays?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `invoiceTargetWeeks` field. */
  invoiceTargetWeeks?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `isoland` field. */
  isoland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kfpQty` field. */
  kfpQty?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kfpWgt` field. */
  kfpWgt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `materials` field. */
  materials?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `nettoomzet` field. */
  nettoomzet?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `opdrachtdatum` field. */
  opdrachtdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `targetDate` field. */
  targetDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `wad1Qty` field. */
  wad1Qty?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `wad1Wgt` field. */
  wad1Wgt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `wad2Qty` field. */
  wad2Qty?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `wad2Wgt` field. */
  wad2Wgt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `wad4Qty` field. */
  wad4Qty?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `wad4Wgt` field. */
  wad4Wgt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `wadBoxQty` field. */
  wadBoxQty?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `wadBoxWgt` field. */
  wadBoxWgt?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

export type LevertijdenExcel = {
  __typename?: 'LevertijdenExcel';
  inkopdrRglGuid?: Maybe<Scalars['String']['output']>;
  ncPart?: Maybe<Scalars['String']['output']>;
  ncbieDescription?: Maybe<Scalars['String']['output']>;
  ncbieEndUser?: Maybe<Scalars['String']['output']>;
  ncbiePart?: Maybe<Scalars['String']['output']>;
  ncbiePo?: Maybe<Scalars['String']['output']>;
  ncbiePoDate?: Maybe<Scalars['Date']['output']>;
  ncbieSo?: Maybe<Scalars['String']['output']>;
  open?: Maybe<Scalars['BigFloat']['output']>;
  orderregel?: Maybe<Scalars['Int']['output']>;
  originalRemarks?: Maybe<Scalars['String']['output']>;
  originalShipmentDate?: Maybe<Scalars['Date']['output']>;
  price?: Maybe<Scalars['BigFloat']['output']>;
  qty?: Maybe<Scalars['BigFloat']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  shipmentDate?: Maybe<Scalars['Date']['output']>;
  total?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LevertijdenExcel` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LevertijdenExcelCondition = {
  /** Checks for equality with the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ncPart` field. */
  ncPart?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ncbieDescription` field. */
  ncbieDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ncbieEndUser` field. */
  ncbieEndUser?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ncbiePart` field. */
  ncbiePart?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ncbiePo` field. */
  ncbiePo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ncbiePoDate` field. */
  ncbiePoDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `ncbieSo` field. */
  ncbieSo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `open` field. */
  open?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `orderregel` field. */
  orderregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `originalRemarks` field. */
  originalRemarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `originalShipmentDate` field. */
  originalShipmentDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `price` field. */
  price?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `qty` field. */
  qty?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shipmentDate` field. */
  shipmentDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `total` field. */
  total?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `LevertijdenExcel` object types. All fields are combined with a logical ‘and.’ */
export type LevertijdenExcelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LevertijdenExcelFilter>>;
  /** Filter by the object’s `inkopdrRglGuid` field. */
  inkopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ncPart` field. */
  ncPart?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ncbieDescription` field. */
  ncbieDescription?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ncbieEndUser` field. */
  ncbieEndUser?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ncbiePart` field. */
  ncbiePart?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ncbiePo` field. */
  ncbiePo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ncbiePoDate` field. */
  ncbiePoDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `ncbieSo` field. */
  ncbieSo?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LevertijdenExcelFilter>;
  /** Filter by the object’s `open` field. */
  open?: InputMaybe<BigFloatFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LevertijdenExcelFilter>>;
  /** Filter by the object’s `orderregel` field. */
  orderregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `originalRemarks` field. */
  originalRemarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `originalShipmentDate` field. */
  originalShipmentDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `price` field. */
  price?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `qty` field. */
  qty?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shipmentDate` field. */
  shipmentDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `total` field. */
  total?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `LevertijdenExcel` values. */
export type LevertijdenExcelsConnection = {
  __typename?: 'LevertijdenExcelsConnection';
  /** A list of edges which contains the `LevertijdenExcel` and cursor to aid in pagination. */
  edges: Array<LevertijdenExcelsEdge>;
  /** A list of `LevertijdenExcel` objects. */
  nodes: Array<LevertijdenExcel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LevertijdenExcel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LevertijdenExcel` edge in the connection. */
export type LevertijdenExcelsEdge = {
  __typename?: 'LevertijdenExcelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LevertijdenExcel` at the end of the edge. */
  node: LevertijdenExcel;
};

/** Methods to use when ordering `LevertijdenExcel`. */
export enum LevertijdenExcelsOrderBy {
  InkopdrRglGuidAsc = 'INKOPDR_RGL_GUID_ASC',
  InkopdrRglGuidDesc = 'INKOPDR_RGL_GUID_DESC',
  Natural = 'NATURAL',
  NcbieDescriptionAsc = 'NCBIE_DESCRIPTION_ASC',
  NcbieDescriptionDesc = 'NCBIE_DESCRIPTION_DESC',
  NcbieEndUserAsc = 'NCBIE_END_USER_ASC',
  NcbieEndUserDesc = 'NCBIE_END_USER_DESC',
  NcbiePartAsc = 'NCBIE_PART_ASC',
  NcbiePartDesc = 'NCBIE_PART_DESC',
  NcbiePoAsc = 'NCBIE_PO_ASC',
  NcbiePoDateAsc = 'NCBIE_PO_DATE_ASC',
  NcbiePoDateDesc = 'NCBIE_PO_DATE_DESC',
  NcbiePoDesc = 'NCBIE_PO_DESC',
  NcbieSoAsc = 'NCBIE_SO_ASC',
  NcbieSoDesc = 'NCBIE_SO_DESC',
  NcPartAsc = 'NC_PART_ASC',
  NcPartDesc = 'NC_PART_DESC',
  OpenAsc = 'OPEN_ASC',
  OpenDesc = 'OPEN_DESC',
  OrderregelAsc = 'ORDERREGEL_ASC',
  OrderregelDesc = 'ORDERREGEL_DESC',
  OriginalRemarksAsc = 'ORIGINAL_REMARKS_ASC',
  OriginalRemarksDesc = 'ORIGINAL_REMARKS_DESC',
  OriginalShipmentDateAsc = 'ORIGINAL_SHIPMENT_DATE_ASC',
  OriginalShipmentDateDesc = 'ORIGINAL_SHIPMENT_DATE_DESC',
  PriceAsc = 'PRICE_ASC',
  PriceDesc = 'PRICE_DESC',
  QtyAsc = 'QTY_ASC',
  QtyDesc = 'QTY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  ShipmentDateAsc = 'SHIPMENT_DATE_ASC',
  ShipmentDateDesc = 'SHIPMENT_DATE_DESC',
  TotalAsc = 'TOTAL_ASC',
  TotalDesc = 'TOTAL_DESC'
}

/** A filter to be used against `Levertijden` object types. All fields are combined with a logical ‘and.’ */
export type LevertijdenFilter = {
  /** Filter by the object’s `aantalgeleverd` field. */
  aantalgeleverd?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LevertijdenFilter>>;
  /** Filter by the object’s `cdartgroep` field. */
  cdartgroep?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cwaQty` field. */
  cwaQty?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cwaWgt` field. */
  cwaWgt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factuurdatum` field. */
  factuurdatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `invoiceOrderDays` field. */
  invoiceOrderDays?: InputMaybe<IntFilter>;
  /** Filter by the object’s `invoiceOrderWeeks` field. */
  invoiceOrderWeeks?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `invoiceTargetDays` field. */
  invoiceTargetDays?: InputMaybe<IntFilter>;
  /** Filter by the object’s `invoiceTargetWeeks` field. */
  invoiceTargetWeeks?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `isoland` field. */
  isoland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kfpQty` field. */
  kfpQty?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kfpWgt` field. */
  kfpWgt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `materials` field. */
  materials?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `nettoomzet` field. */
  nettoomzet?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LevertijdenFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `opdrachtdatum` field. */
  opdrachtdatum?: InputMaybe<DateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LevertijdenFilter>>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `targetDate` field. */
  targetDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `wad1Qty` field. */
  wad1Qty?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `wad1Wgt` field. */
  wad1Wgt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `wad2Qty` field. */
  wad2Qty?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `wad2Wgt` field. */
  wad2Wgt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `wad4Qty` field. */
  wad4Qty?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `wad4Wgt` field. */
  wad4Wgt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `wadBoxQty` field. */
  wadBoxQty?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `wadBoxWgt` field. */
  wadBoxWgt?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Levertijden` values. */
export type LevertijdensConnection = {
  __typename?: 'LevertijdensConnection';
  /** A list of edges which contains the `Levertijden` and cursor to aid in pagination. */
  edges: Array<LevertijdensEdge>;
  /** A list of `Levertijden` objects. */
  nodes: Array<Levertijden>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Levertijden` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Levertijden` edge in the connection. */
export type LevertijdensEdge = {
  __typename?: 'LevertijdensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Levertijden` at the end of the edge. */
  node: Levertijden;
};

/** Methods to use when ordering `Levertijden`. */
export enum LevertijdensOrderBy {
  AantalgeleverdAsc = 'AANTALGELEVERD_ASC',
  AantalgeleverdDesc = 'AANTALGELEVERD_DESC',
  CdartgroepAsc = 'CDARTGROEP_ASC',
  CdartgroepDesc = 'CDARTGROEP_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CwaQtyAsc = 'CWA_QTY_ASC',
  CwaQtyDesc = 'CWA_QTY_DESC',
  CwaWgtAsc = 'CWA_WGT_ASC',
  CwaWgtDesc = 'CWA_WGT_DESC',
  FactuurdatumAsc = 'FACTUURDATUM_ASC',
  FactuurdatumDesc = 'FACTUURDATUM_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  InvoiceOrderDaysAsc = 'INVOICE_ORDER_DAYS_ASC',
  InvoiceOrderDaysDesc = 'INVOICE_ORDER_DAYS_DESC',
  InvoiceOrderWeeksAsc = 'INVOICE_ORDER_WEEKS_ASC',
  InvoiceOrderWeeksDesc = 'INVOICE_ORDER_WEEKS_DESC',
  InvoiceTargetDaysAsc = 'INVOICE_TARGET_DAYS_ASC',
  InvoiceTargetDaysDesc = 'INVOICE_TARGET_DAYS_DESC',
  InvoiceTargetWeeksAsc = 'INVOICE_TARGET_WEEKS_ASC',
  InvoiceTargetWeeksDesc = 'INVOICE_TARGET_WEEKS_DESC',
  IsolandAsc = 'ISOLAND_ASC',
  IsolandDesc = 'ISOLAND_DESC',
  KfpQtyAsc = 'KFP_QTY_ASC',
  KfpQtyDesc = 'KFP_QTY_DESC',
  KfpWgtAsc = 'KFP_WGT_ASC',
  KfpWgtDesc = 'KFP_WGT_DESC',
  MaterialsAsc = 'MATERIALS_ASC',
  MaterialsDesc = 'MATERIALS_DESC',
  Natural = 'NATURAL',
  NettoomzetAsc = 'NETTOOMZET_ASC',
  NettoomzetDesc = 'NETTOOMZET_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OpdrachtdatumAsc = 'OPDRACHTDATUM_ASC',
  OpdrachtdatumDesc = 'OPDRACHTDATUM_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  TargetDateAsc = 'TARGET_DATE_ASC',
  TargetDateDesc = 'TARGET_DATE_DESC',
  Wad_1QtyAsc = 'WAD_1_QTY_ASC',
  Wad_1QtyDesc = 'WAD_1_QTY_DESC',
  Wad_1WgtAsc = 'WAD_1_WGT_ASC',
  Wad_1WgtDesc = 'WAD_1_WGT_DESC',
  Wad_2QtyAsc = 'WAD_2_QTY_ASC',
  Wad_2QtyDesc = 'WAD_2_QTY_DESC',
  Wad_2WgtAsc = 'WAD_2_WGT_ASC',
  Wad_2WgtDesc = 'WAD_2_WGT_DESC',
  Wad_4QtyAsc = 'WAD_4_QTY_ASC',
  Wad_4QtyDesc = 'WAD_4_QTY_DESC',
  Wad_4WgtAsc = 'WAD_4_WGT_ASC',
  Wad_4WgtDesc = 'WAD_4_WGT_DESC',
  WadBoxQtyAsc = 'WAD_BOX_QTY_ASC',
  WadBoxQtyDesc = 'WAD_BOX_QTY_DESC',
  WadBoxWgtAsc = 'WAD_BOX_WGT_ASC',
  WadBoxWgtDesc = 'WAD_BOX_WGT_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type License = Node & {
  __typename?: 'License';
  activate: Scalars['Boolean']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DetectorSensorLocation`. */
  detectorSensorLocationsByLicenseId: DetectorSensorLocationsConnection;
  durationDays: Scalars['Int']['output'];
  durationMonths: Scalars['Int']['output'];
  /** Reads a single `EndUser` that is related to this `License`. */
  endUserByEndUserId?: Maybe<EndUser>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  licenseCode?: Maybe<Scalars['String']['output']>;
  /** Reads a single `LicenseCustomer` that is related to this `License`. */
  licenseCustomerByLicenseCustomerId?: Maybe<LicenseCustomer>;
  licenseCustomerId?: Maybe<Scalars['Int']['output']>;
  licenseId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `LicenseModule` that is related to this `License`. */
  licenseModuleByLicenseModuleId?: Maybe<LicenseModule>;
  licenseModuleId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `LicenseOrder`. */
  licenseOrdersByLicenseId: LicenseOrdersConnection;
  /** Reads and enables pagination through a set of `LicenseRegistration`. */
  licenseRegistrationsByLicenseId: LicenseRegistrationsConnection;
  moduleData?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `License`. */
  userByOwnerId?: Maybe<User>;
};


export type LicenseDetectorSensorLocationsByLicenseIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationCondition>;
  filter?: InputMaybe<DetectorSensorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};


export type LicenseLicenseOrdersByLicenseIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseOrderCondition>;
  filter?: InputMaybe<LicenseOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseOrdersOrderBy>>;
};


export type LicenseLicenseRegistrationsByLicenseIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseRegistrationCondition>;
  filter?: InputMaybe<LicenseRegistrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseRegistrationsOrderBy>>;
};

/** A condition to be used against `License` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LicenseCondition = {
  /** Checks for equality with the object’s `activate` field. */
  activate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `durationDays` field. */
  durationDays?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `durationMonths` field. */
  durationMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `licenseCode` field. */
  licenseCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `licenseCustomerId` field. */
  licenseCustomerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `licenseId` field. */
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `licenseModuleId` field. */
  licenseModuleId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `moduleData` field. */
  moduleData?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
};

export type LicenseCustomer = Node & {
  __typename?: 'LicenseCustomer';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `License`. */
  licensesByLicenseCustomerId: LicensesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `LicenseCustomer`. */
  userByOwnerId?: Maybe<User>;
};


export type LicenseCustomerLicensesByLicenseCustomerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseCondition>;
  filter?: InputMaybe<LicenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicensesOrderBy>>;
};

/**
 * A condition to be used against `LicenseCustomer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LicenseCustomerCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `LicenseCustomer` object types. All fields are combined with a logical ‘and.’ */
export type LicenseCustomerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LicenseCustomerFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licensesByLicenseCustomerId` relation. */
  licensesByLicenseCustomerId?: InputMaybe<LicenseCustomerToManyLicenseFilter>;
  /** Some related `licensesByLicenseCustomerId` exist. */
  licensesByLicenseCustomerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LicenseCustomerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LicenseCustomerFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `LicenseCustomer` */
export type LicenseCustomerInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `LicenseCustomer`. Fields that are set will be updated. */
export type LicenseCustomerPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `License` object types. All fields are combined with a logical ‘and.’ */
export type LicenseCustomerToManyLicenseFilter = {
  /** Every related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseFilter>;
  /** No related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseFilter>;
  /** Some related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseFilter>;
};

/** A connection to a list of `LicenseCustomer` values. */
export type LicenseCustomersConnection = {
  __typename?: 'LicenseCustomersConnection';
  /** A list of edges which contains the `LicenseCustomer` and cursor to aid in pagination. */
  edges: Array<LicenseCustomersEdge>;
  /** A list of `LicenseCustomer` objects. */
  nodes: Array<LicenseCustomer>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LicenseCustomer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LicenseCustomer` edge in the connection. */
export type LicenseCustomersEdge = {
  __typename?: 'LicenseCustomersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LicenseCustomer` at the end of the edge. */
  node: LicenseCustomer;
};

/** Methods to use when ordering `LicenseCustomer`. */
export enum LicenseCustomersOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LicensesByLicenseCustomerIdCountAsc = 'LICENSES_BY_LICENSE_CUSTOMER_ID__COUNT_ASC',
  LicensesByLicenseCustomerIdCountDesc = 'LICENSES_BY_LICENSE_CUSTOMER_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A filter to be used against `License` object types. All fields are combined with a logical ‘and.’ */
export type LicenseFilter = {
  /** Filter by the object’s `activate` field. */
  activate?: InputMaybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LicenseFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorSensorLocationsByLicenseId` relation. */
  detectorSensorLocationsByLicenseId?: InputMaybe<LicenseToManyDetectorSensorLocationFilter>;
  /** Some related `detectorSensorLocationsByLicenseId` exist. */
  detectorSensorLocationsByLicenseIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `durationDays` field. */
  durationDays?: InputMaybe<IntFilter>;
  /** Filter by the object’s `durationMonths` field. */
  durationMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserByEndUserId` relation. */
  endUserByEndUserId?: InputMaybe<EndUserFilter>;
  /** A related `endUserByEndUserId` exists. */
  endUserByEndUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licenseCode` field. */
  licenseCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `licenseCustomerByLicenseCustomerId` relation. */
  licenseCustomerByLicenseCustomerId?: InputMaybe<LicenseCustomerFilter>;
  /** A related `licenseCustomerByLicenseCustomerId` exists. */
  licenseCustomerByLicenseCustomerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseCustomerId` field. */
  licenseCustomerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licenseId` field. */
  licenseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licenseModuleByLicenseModuleId` relation. */
  licenseModuleByLicenseModuleId?: InputMaybe<LicenseModuleFilter>;
  /** A related `licenseModuleByLicenseModuleId` exists. */
  licenseModuleByLicenseModuleIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseModuleId` field. */
  licenseModuleId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licenseOrdersByLicenseId` relation. */
  licenseOrdersByLicenseId?: InputMaybe<LicenseToManyLicenseOrderFilter>;
  /** Some related `licenseOrdersByLicenseId` exist. */
  licenseOrdersByLicenseIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseRegistrationsByLicenseId` relation. */
  licenseRegistrationsByLicenseId?: InputMaybe<LicenseToManyLicenseRegistrationFilter>;
  /** Some related `licenseRegistrationsByLicenseId` exist. */
  licenseRegistrationsByLicenseIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `moduleData` field. */
  moduleData?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LicenseFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LicenseFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `License` */
export type LicenseInput = {
  activate?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  durationDays?: InputMaybe<Scalars['Int']['input']>;
  durationMonths?: InputMaybe<Scalars['Int']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  licenseCode?: InputMaybe<Scalars['String']['input']>;
  licenseCustomerId?: InputMaybe<Scalars['Int']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  licenseModuleId?: InputMaybe<Scalars['Int']['input']>;
  moduleData?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

export type LicenseModule = Node & {
  __typename?: 'LicenseModule';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  latestVersion?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `License`. */
  licensesByLicenseModuleId: LicensesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `LicenseModule`. */
  userByOwnerId?: Maybe<User>;
};


export type LicenseModuleLicensesByLicenseModuleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseCondition>;
  filter?: InputMaybe<LicenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicensesOrderBy>>;
};

/**
 * A condition to be used against `LicenseModule` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LicenseModuleCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `latestVersion` field. */
  latestVersion?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `LicenseModule` object types. All fields are combined with a logical ‘and.’ */
export type LicenseModuleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LicenseModuleFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `latestVersion` field. */
  latestVersion?: InputMaybe<StringFilter>;
  /** Filter by the object’s `licensesByLicenseModuleId` relation. */
  licensesByLicenseModuleId?: InputMaybe<LicenseModuleToManyLicenseFilter>;
  /** Some related `licensesByLicenseModuleId` exist. */
  licensesByLicenseModuleIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LicenseModuleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LicenseModuleFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `LicenseModule` */
export type LicenseModuleInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  latestVersion?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `LicenseModule`. Fields that are set will be updated. */
export type LicenseModulePatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  latestVersion?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `License` object types. All fields are combined with a logical ‘and.’ */
export type LicenseModuleToManyLicenseFilter = {
  /** Every related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseFilter>;
  /** No related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseFilter>;
  /** Some related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseFilter>;
};

/** A connection to a list of `LicenseModule` values. */
export type LicenseModulesConnection = {
  __typename?: 'LicenseModulesConnection';
  /** A list of edges which contains the `LicenseModule` and cursor to aid in pagination. */
  edges: Array<LicenseModulesEdge>;
  /** A list of `LicenseModule` objects. */
  nodes: Array<LicenseModule>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LicenseModule` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LicenseModule` edge in the connection. */
export type LicenseModulesEdge = {
  __typename?: 'LicenseModulesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LicenseModule` at the end of the edge. */
  node: LicenseModule;
};

/** Methods to use when ordering `LicenseModule`. */
export enum LicenseModulesOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatestVersionAsc = 'LATEST_VERSION_ASC',
  LatestVersionDesc = 'LATEST_VERSION_DESC',
  LicensesByLicenseModuleIdCountAsc = 'LICENSES_BY_LICENSE_MODULE_ID__COUNT_ASC',
  LicensesByLicenseModuleIdCountDesc = 'LICENSES_BY_LICENSE_MODULE_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type LicenseOrder = Node & {
  __typename?: 'LicenseOrder';
  cdSerialNumber?: Maybe<Scalars['Int']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  factuuropdracht: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** Reads a single `License` that is related to this `LicenseOrder`. */
  licenseByLicenseId?: Maybe<License>;
  licenseId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `LicenseRegistration` that is related to this `LicenseOrder`. */
  licenseRegistrationByLicenseRegistrationId?: Maybe<LicenseRegistration>;
  licenseRegistrationId?: Maybe<Scalars['Int']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  offertenummer?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `LicenseOrder`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `LicenseOrder` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LicenseOrderCondition = {
  /** Checks for equality with the object’s `cdSerialNumber` field. */
  cdSerialNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `licenseId` field. */
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `licenseRegistrationId` field. */
  licenseRegistrationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `LicenseOrder` object types. All fields are combined with a logical ‘and.’ */
export type LicenseOrderFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LicenseOrderFilter>>;
  /** Filter by the object’s `cdSerialNumber` field. */
  cdSerialNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licenseByLicenseId` relation. */
  licenseByLicenseId?: InputMaybe<LicenseFilter>;
  /** A related `licenseByLicenseId` exists. */
  licenseByLicenseIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseId` field. */
  licenseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licenseRegistrationByLicenseRegistrationId` relation. */
  licenseRegistrationByLicenseRegistrationId?: InputMaybe<LicenseRegistrationFilter>;
  /** A related `licenseRegistrationByLicenseRegistrationId` exists. */
  licenseRegistrationByLicenseRegistrationIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseRegistrationId` field. */
  licenseRegistrationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LicenseOrderFilter>;
  /** Filter by the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LicenseOrderFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `LicenseOrder` */
export type LicenseOrderInput = {
  cdSerialNumber?: InputMaybe<Scalars['Int']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  factuuropdracht: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  licenseRegistrationId?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `LicenseOrder`. Fields that are set will be updated. */
export type LicenseOrderPatch = {
  cdSerialNumber?: InputMaybe<Scalars['Int']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  licenseRegistrationId?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `LicenseOrder` values. */
export type LicenseOrdersConnection = {
  __typename?: 'LicenseOrdersConnection';
  /** A list of edges which contains the `LicenseOrder` and cursor to aid in pagination. */
  edges: Array<LicenseOrdersEdge>;
  /** A list of `LicenseOrder` objects. */
  nodes: Array<LicenseOrder>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LicenseOrder` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LicenseOrder` edge in the connection. */
export type LicenseOrdersEdge = {
  __typename?: 'LicenseOrdersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LicenseOrder` at the end of the edge. */
  node: LicenseOrder;
};

/** Methods to use when ordering `LicenseOrder`. */
export enum LicenseOrdersOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdSerialNumberAsc = 'CD_SERIAL_NUMBER_ASC',
  CdSerialNumberDesc = 'CD_SERIAL_NUMBER_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LicenseByLicenseIdActivateAsc = 'LICENSE_BY_LICENSE_ID__ACTIVATE_ASC',
  LicenseByLicenseIdActivateDesc = 'LICENSE_BY_LICENSE_ID__ACTIVATE_DESC',
  LicenseByLicenseIdCreatedAsc = 'LICENSE_BY_LICENSE_ID__CREATED_ASC',
  LicenseByLicenseIdCreatedDesc = 'LICENSE_BY_LICENSE_ID__CREATED_DESC',
  LicenseByLicenseIdDurationDaysAsc = 'LICENSE_BY_LICENSE_ID__DURATION_DAYS_ASC',
  LicenseByLicenseIdDurationDaysDesc = 'LICENSE_BY_LICENSE_ID__DURATION_DAYS_DESC',
  LicenseByLicenseIdDurationMonthsAsc = 'LICENSE_BY_LICENSE_ID__DURATION_MONTHS_ASC',
  LicenseByLicenseIdDurationMonthsDesc = 'LICENSE_BY_LICENSE_ID__DURATION_MONTHS_DESC',
  LicenseByLicenseIdEndUserIdAsc = 'LICENSE_BY_LICENSE_ID__END_USER_ID_ASC',
  LicenseByLicenseIdEndUserIdDesc = 'LICENSE_BY_LICENSE_ID__END_USER_ID_DESC',
  LicenseByLicenseIdIdAsc = 'LICENSE_BY_LICENSE_ID__ID_ASC',
  LicenseByLicenseIdIdDesc = 'LICENSE_BY_LICENSE_ID__ID_DESC',
  LicenseByLicenseIdLicenseCodeAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_CODE_ASC',
  LicenseByLicenseIdLicenseCodeDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_CODE_DESC',
  LicenseByLicenseIdLicenseCustomerIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_CUSTOMER_ID_ASC',
  LicenseByLicenseIdLicenseCustomerIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_CUSTOMER_ID_DESC',
  LicenseByLicenseIdLicenseIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_ID_ASC',
  LicenseByLicenseIdLicenseIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_ID_DESC',
  LicenseByLicenseIdLicenseModuleIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_MODULE_ID_ASC',
  LicenseByLicenseIdLicenseModuleIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_MODULE_ID_DESC',
  LicenseByLicenseIdModuleDataAsc = 'LICENSE_BY_LICENSE_ID__MODULE_DATA_ASC',
  LicenseByLicenseIdModuleDataDesc = 'LICENSE_BY_LICENSE_ID__MODULE_DATA_DESC',
  LicenseByLicenseIdOwnerIdAsc = 'LICENSE_BY_LICENSE_ID__OWNER_ID_ASC',
  LicenseByLicenseIdOwnerIdDesc = 'LICENSE_BY_LICENSE_ID__OWNER_ID_DESC',
  LicenseByLicenseIdRemarksAsc = 'LICENSE_BY_LICENSE_ID__REMARKS_ASC',
  LicenseByLicenseIdRemarksDesc = 'LICENSE_BY_LICENSE_ID__REMARKS_DESC',
  LicenseIdAsc = 'LICENSE_ID_ASC',
  LicenseIdDesc = 'LICENSE_ID_DESC',
  LicenseRegistrationByLicenseRegistrationIdActivationCodeAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__ACTIVATION_CODE_ASC',
  LicenseRegistrationByLicenseRegistrationIdActivationCodeDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__ACTIVATION_CODE_DESC',
  LicenseRegistrationByLicenseRegistrationIdComputerNameAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__COMPUTER_NAME_ASC',
  LicenseRegistrationByLicenseRegistrationIdComputerNameDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__COMPUTER_NAME_DESC',
  LicenseRegistrationByLicenseRegistrationIdCreatedAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__CREATED_ASC',
  LicenseRegistrationByLicenseRegistrationIdCreatedDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__CREATED_DESC',
  LicenseRegistrationByLicenseRegistrationIdExpirationDateAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__EXPIRATION_DATE_ASC',
  LicenseRegistrationByLicenseRegistrationIdExpirationDateDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__EXPIRATION_DATE_DESC',
  LicenseRegistrationByLicenseRegistrationIdHwCodeAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__HW_CODE_ASC',
  LicenseRegistrationByLicenseRegistrationIdHwCodeDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__HW_CODE_DESC',
  LicenseRegistrationByLicenseRegistrationIdHwTypeAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__HW_TYPE_ASC',
  LicenseRegistrationByLicenseRegistrationIdHwTypeDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__HW_TYPE_DESC',
  LicenseRegistrationByLicenseRegistrationIdIdAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__ID_ASC',
  LicenseRegistrationByLicenseRegistrationIdIdDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__ID_DESC',
  LicenseRegistrationByLicenseRegistrationIdIpAddressAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__IP_ADDRESS_ASC',
  LicenseRegistrationByLicenseRegistrationIdIpAddressDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__IP_ADDRESS_DESC',
  LicenseRegistrationByLicenseRegistrationIdLicenseIdAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__LICENSE_ID_ASC',
  LicenseRegistrationByLicenseRegistrationIdLicenseIdDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__LICENSE_ID_DESC',
  LicenseRegistrationByLicenseRegistrationIdOwnerIdAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__OWNER_ID_ASC',
  LicenseRegistrationByLicenseRegistrationIdOwnerIdDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__OWNER_ID_DESC',
  LicenseRegistrationByLicenseRegistrationIdRegistrationCodeAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__REGISTRATION_CODE_ASC',
  LicenseRegistrationByLicenseRegistrationIdRegistrationCodeDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__REGISTRATION_CODE_DESC',
  LicenseRegistrationByLicenseRegistrationIdRemarksAsc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__REMARKS_ASC',
  LicenseRegistrationByLicenseRegistrationIdRemarksDesc = 'LICENSE_REGISTRATION_BY_LICENSE_REGISTRATION_ID__REMARKS_DESC',
  LicenseRegistrationIdAsc = 'LICENSE_REGISTRATION_ID_ASC',
  LicenseRegistrationIdDesc = 'LICENSE_REGISTRATION_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OffertenummerAsc = 'OFFERTENUMMER_ASC',
  OffertenummerDesc = 'OFFERTENUMMER_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** Represents an update to a `License`. Fields that are set will be updated. */
export type LicensePatch = {
  activate?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  durationDays?: InputMaybe<Scalars['Int']['input']>;
  durationMonths?: InputMaybe<Scalars['Int']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  licenseCode?: InputMaybe<Scalars['String']['input']>;
  licenseCustomerId?: InputMaybe<Scalars['Int']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  licenseModuleId?: InputMaybe<Scalars['Int']['input']>;
  moduleData?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

export type LicenseRegistration = Node & {
  __typename?: 'LicenseRegistration';
  activationCode?: Maybe<Scalars['String']['output']>;
  computerName?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  expirationDate?: Maybe<Scalars['Date']['output']>;
  hwCode?: Maybe<Scalars['String']['output']>;
  hwType?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  ipAddress?: Maybe<Scalars['String']['output']>;
  /** Reads a single `License` that is related to this `LicenseRegistration`. */
  licenseByLicenseId?: Maybe<License>;
  licenseId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `LicenseOrder`. */
  licenseOrdersByLicenseRegistrationId: LicenseOrdersConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  registrationCode?: Maybe<Scalars['String']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `LicenseRegistration`. */
  userByOwnerId?: Maybe<User>;
};


export type LicenseRegistrationLicenseOrdersByLicenseRegistrationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseOrderCondition>;
  filter?: InputMaybe<LicenseOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseOrdersOrderBy>>;
};

/**
 * A condition to be used against `LicenseRegistration` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type LicenseRegistrationCondition = {
  /** Checks for equality with the object’s `activationCode` field. */
  activationCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `computerName` field. */
  computerName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `hwCode` field. */
  hwCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `hwType` field. */
  hwType?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `licenseId` field. */
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `registrationCode` field. */
  registrationCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `LicenseRegistration` object types. All fields are combined with a logical ‘and.’ */
export type LicenseRegistrationFilter = {
  /** Filter by the object’s `activationCode` field. */
  activationCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LicenseRegistrationFilter>>;
  /** Filter by the object’s `computerName` field. */
  computerName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `hwCode` field. */
  hwCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `hwType` field. */
  hwType?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `licenseByLicenseId` relation. */
  licenseByLicenseId?: InputMaybe<LicenseFilter>;
  /** A related `licenseByLicenseId` exists. */
  licenseByLicenseIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseId` field. */
  licenseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licenseOrdersByLicenseRegistrationId` relation. */
  licenseOrdersByLicenseRegistrationId?: InputMaybe<LicenseRegistrationToManyLicenseOrderFilter>;
  /** Some related `licenseOrdersByLicenseRegistrationId` exist. */
  licenseOrdersByLicenseRegistrationIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<LicenseRegistrationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LicenseRegistrationFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `registrationCode` field. */
  registrationCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `LicenseRegistration` */
export type LicenseRegistrationInput = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  computerName?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  hwCode?: InputMaybe<Scalars['String']['input']>;
  hwType?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  registrationCode?: InputMaybe<Scalars['String']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `LicenseRegistration`. Fields that are set will be updated. */
export type LicenseRegistrationPatch = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  computerName?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  hwCode?: InputMaybe<Scalars['String']['input']>;
  hwType?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  registrationCode?: InputMaybe<Scalars['String']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `LicenseOrder` object types. All fields are combined with a logical ‘and.’ */
export type LicenseRegistrationToManyLicenseOrderFilter = {
  /** Every related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseOrderFilter>;
  /** No related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseOrderFilter>;
  /** Some related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseOrderFilter>;
};

/** A connection to a list of `LicenseRegistration` values. */
export type LicenseRegistrationsConnection = {
  __typename?: 'LicenseRegistrationsConnection';
  /** A list of edges which contains the `LicenseRegistration` and cursor to aid in pagination. */
  edges: Array<LicenseRegistrationsEdge>;
  /** A list of `LicenseRegistration` objects. */
  nodes: Array<LicenseRegistration>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LicenseRegistration` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LicenseRegistration` edge in the connection. */
export type LicenseRegistrationsEdge = {
  __typename?: 'LicenseRegistrationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LicenseRegistration` at the end of the edge. */
  node: LicenseRegistration;
};

/** Methods to use when ordering `LicenseRegistration`. */
export enum LicenseRegistrationsOrderBy {
  ActivationCodeAsc = 'ACTIVATION_CODE_ASC',
  ActivationCodeDesc = 'ACTIVATION_CODE_DESC',
  ComputerNameAsc = 'COMPUTER_NAME_ASC',
  ComputerNameDesc = 'COMPUTER_NAME_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ExpirationDateAsc = 'EXPIRATION_DATE_ASC',
  ExpirationDateDesc = 'EXPIRATION_DATE_DESC',
  HwCodeAsc = 'HW_CODE_ASC',
  HwCodeDesc = 'HW_CODE_DESC',
  HwTypeAsc = 'HW_TYPE_ASC',
  HwTypeDesc = 'HW_TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IpAddressAsc = 'IP_ADDRESS_ASC',
  IpAddressDesc = 'IP_ADDRESS_DESC',
  LicenseByLicenseIdActivateAsc = 'LICENSE_BY_LICENSE_ID__ACTIVATE_ASC',
  LicenseByLicenseIdActivateDesc = 'LICENSE_BY_LICENSE_ID__ACTIVATE_DESC',
  LicenseByLicenseIdCreatedAsc = 'LICENSE_BY_LICENSE_ID__CREATED_ASC',
  LicenseByLicenseIdCreatedDesc = 'LICENSE_BY_LICENSE_ID__CREATED_DESC',
  LicenseByLicenseIdDurationDaysAsc = 'LICENSE_BY_LICENSE_ID__DURATION_DAYS_ASC',
  LicenseByLicenseIdDurationDaysDesc = 'LICENSE_BY_LICENSE_ID__DURATION_DAYS_DESC',
  LicenseByLicenseIdDurationMonthsAsc = 'LICENSE_BY_LICENSE_ID__DURATION_MONTHS_ASC',
  LicenseByLicenseIdDurationMonthsDesc = 'LICENSE_BY_LICENSE_ID__DURATION_MONTHS_DESC',
  LicenseByLicenseIdEndUserIdAsc = 'LICENSE_BY_LICENSE_ID__END_USER_ID_ASC',
  LicenseByLicenseIdEndUserIdDesc = 'LICENSE_BY_LICENSE_ID__END_USER_ID_DESC',
  LicenseByLicenseIdIdAsc = 'LICENSE_BY_LICENSE_ID__ID_ASC',
  LicenseByLicenseIdIdDesc = 'LICENSE_BY_LICENSE_ID__ID_DESC',
  LicenseByLicenseIdLicenseCodeAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_CODE_ASC',
  LicenseByLicenseIdLicenseCodeDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_CODE_DESC',
  LicenseByLicenseIdLicenseCustomerIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_CUSTOMER_ID_ASC',
  LicenseByLicenseIdLicenseCustomerIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_CUSTOMER_ID_DESC',
  LicenseByLicenseIdLicenseIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_ID_ASC',
  LicenseByLicenseIdLicenseIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_ID_DESC',
  LicenseByLicenseIdLicenseModuleIdAsc = 'LICENSE_BY_LICENSE_ID__LICENSE_MODULE_ID_ASC',
  LicenseByLicenseIdLicenseModuleIdDesc = 'LICENSE_BY_LICENSE_ID__LICENSE_MODULE_ID_DESC',
  LicenseByLicenseIdModuleDataAsc = 'LICENSE_BY_LICENSE_ID__MODULE_DATA_ASC',
  LicenseByLicenseIdModuleDataDesc = 'LICENSE_BY_LICENSE_ID__MODULE_DATA_DESC',
  LicenseByLicenseIdOwnerIdAsc = 'LICENSE_BY_LICENSE_ID__OWNER_ID_ASC',
  LicenseByLicenseIdOwnerIdDesc = 'LICENSE_BY_LICENSE_ID__OWNER_ID_DESC',
  LicenseByLicenseIdRemarksAsc = 'LICENSE_BY_LICENSE_ID__REMARKS_ASC',
  LicenseByLicenseIdRemarksDesc = 'LICENSE_BY_LICENSE_ID__REMARKS_DESC',
  LicenseIdAsc = 'LICENSE_ID_ASC',
  LicenseIdDesc = 'LICENSE_ID_DESC',
  LicenseOrdersByLicenseRegistrationIdCountAsc = 'LICENSE_ORDERS_BY_LICENSE_REGISTRATION_ID__COUNT_ASC',
  LicenseOrdersByLicenseRegistrationIdCountDesc = 'LICENSE_ORDERS_BY_LICENSE_REGISTRATION_ID__COUNT_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RegistrationCodeAsc = 'REGISTRATION_CODE_ASC',
  RegistrationCodeDesc = 'REGISTRATION_CODE_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A filter to be used against many `DetectorSensorLocation` object types. All fields are combined with a logical ‘and.’ */
export type LicenseToManyDetectorSensorLocationFilter = {
  /** Every related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorLocationFilter>;
  /** No related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorLocationFilter>;
  /** Some related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorLocationFilter>;
};

/** A filter to be used against many `LicenseOrder` object types. All fields are combined with a logical ‘and.’ */
export type LicenseToManyLicenseOrderFilter = {
  /** Every related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseOrderFilter>;
  /** No related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseOrderFilter>;
  /** Some related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseOrderFilter>;
};

/** A filter to be used against many `LicenseRegistration` object types. All fields are combined with a logical ‘and.’ */
export type LicenseToManyLicenseRegistrationFilter = {
  /** Every related `LicenseRegistration` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseRegistrationFilter>;
  /** No related `LicenseRegistration` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseRegistrationFilter>;
  /** Some related `LicenseRegistration` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseRegistrationFilter>;
};

/** A connection to a list of `License` values. */
export type LicensesConnection = {
  __typename?: 'LicensesConnection';
  /** A list of edges which contains the `License` and cursor to aid in pagination. */
  edges: Array<LicensesEdge>;
  /** A list of `License` objects. */
  nodes: Array<License>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `License` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `License` edge in the connection. */
export type LicensesEdge = {
  __typename?: 'LicensesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `License` at the end of the edge. */
  node: License;
};

/** Methods to use when ordering `License`. */
export enum LicensesOrderBy {
  ActivateAsc = 'ACTIVATE_ASC',
  ActivateDesc = 'ACTIVATE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorSensorLocationsByLicenseIdCountAsc = 'DETECTOR_SENSOR_LOCATIONS_BY_LICENSE_ID__COUNT_ASC',
  DetectorSensorLocationsByLicenseIdCountDesc = 'DETECTOR_SENSOR_LOCATIONS_BY_LICENSE_ID__COUNT_DESC',
  DurationDaysAsc = 'DURATION_DAYS_ASC',
  DurationDaysDesc = 'DURATION_DAYS_DESC',
  DurationMonthsAsc = 'DURATION_MONTHS_ASC',
  DurationMonthsDesc = 'DURATION_MONTHS_DESC',
  EndUserByEndUserIdAddress1Asc = 'END_USER_BY_END_USER_ID__ADDRESS1_ASC',
  EndUserByEndUserIdAddress1Desc = 'END_USER_BY_END_USER_ID__ADDRESS1_DESC',
  EndUserByEndUserIdAddress2Asc = 'END_USER_BY_END_USER_ID__ADDRESS2_ASC',
  EndUserByEndUserIdAddress2Desc = 'END_USER_BY_END_USER_ID__ADDRESS2_DESC',
  EndUserByEndUserIdCityAsc = 'END_USER_BY_END_USER_ID__CITY_ASC',
  EndUserByEndUserIdCityDesc = 'END_USER_BY_END_USER_ID__CITY_DESC',
  EndUserByEndUserIdContactEmailAsc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_ASC',
  EndUserByEndUserIdContactEmailDesc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_DESC',
  EndUserByEndUserIdContactNameAsc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_ASC',
  EndUserByEndUserIdContactNameDesc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_DESC',
  EndUserByEndUserIdContactPhoneAsc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_ASC',
  EndUserByEndUserIdContactPhoneDesc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_DESC',
  EndUserByEndUserIdCountryAsc = 'END_USER_BY_END_USER_ID__COUNTRY_ASC',
  EndUserByEndUserIdCountryDesc = 'END_USER_BY_END_USER_ID__COUNTRY_DESC',
  EndUserByEndUserIdCreatedAsc = 'END_USER_BY_END_USER_ID__CREATED_ASC',
  EndUserByEndUserIdCreatedDesc = 'END_USER_BY_END_USER_ID__CREATED_DESC',
  EndUserByEndUserIdFormerName1Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_ASC',
  EndUserByEndUserIdFormerName1Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_DESC',
  EndUserByEndUserIdFormerName2Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_ASC',
  EndUserByEndUserIdFormerName2Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_DESC',
  EndUserByEndUserIdIdAsc = 'END_USER_BY_END_USER_ID__ID_ASC',
  EndUserByEndUserIdIdDesc = 'END_USER_BY_END_USER_ID__ID_DESC',
  EndUserByEndUserIdLocationAsc = 'END_USER_BY_END_USER_ID__LOCATION_ASC',
  EndUserByEndUserIdLocationDesc = 'END_USER_BY_END_USER_ID__LOCATION_DESC',
  EndUserByEndUserIdModifiedAsc = 'END_USER_BY_END_USER_ID__MODIFIED_ASC',
  EndUserByEndUserIdModifiedDesc = 'END_USER_BY_END_USER_ID__MODIFIED_DESC',
  EndUserByEndUserIdNameAsc = 'END_USER_BY_END_USER_ID__NAME_ASC',
  EndUserByEndUserIdNameDesc = 'END_USER_BY_END_USER_ID__NAME_DESC',
  EndUserByEndUserIdOwnerIdAsc = 'END_USER_BY_END_USER_ID__OWNER_ID_ASC',
  EndUserByEndUserIdOwnerIdDesc = 'END_USER_BY_END_USER_ID__OWNER_ID_DESC',
  EndUserByEndUserIdRegionAsc = 'END_USER_BY_END_USER_ID__REGION_ASC',
  EndUserByEndUserIdRegionDesc = 'END_USER_BY_END_USER_ID__REGION_DESC',
  EndUserByEndUserIdSubLocationAsc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_ASC',
  EndUserByEndUserIdSubLocationDesc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_DESC',
  EndUserByEndUserIdZipCodeAsc = 'END_USER_BY_END_USER_ID__ZIP_CODE_ASC',
  EndUserByEndUserIdZipCodeDesc = 'END_USER_BY_END_USER_ID__ZIP_CODE_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LicenseCodeAsc = 'LICENSE_CODE_ASC',
  LicenseCodeDesc = 'LICENSE_CODE_DESC',
  LicenseCustomerByLicenseCustomerIdCreatedAsc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__CREATED_ASC',
  LicenseCustomerByLicenseCustomerIdCreatedDesc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__CREATED_DESC',
  LicenseCustomerByLicenseCustomerIdIdAsc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__ID_ASC',
  LicenseCustomerByLicenseCustomerIdIdDesc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__ID_DESC',
  LicenseCustomerByLicenseCustomerIdModifiedAsc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__MODIFIED_ASC',
  LicenseCustomerByLicenseCustomerIdModifiedDesc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__MODIFIED_DESC',
  LicenseCustomerByLicenseCustomerIdNameAsc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__NAME_ASC',
  LicenseCustomerByLicenseCustomerIdNameDesc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__NAME_DESC',
  LicenseCustomerByLicenseCustomerIdOwnerIdAsc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__OWNER_ID_ASC',
  LicenseCustomerByLicenseCustomerIdOwnerIdDesc = 'LICENSE_CUSTOMER_BY_LICENSE_CUSTOMER_ID__OWNER_ID_DESC',
  LicenseCustomerIdAsc = 'LICENSE_CUSTOMER_ID_ASC',
  LicenseCustomerIdDesc = 'LICENSE_CUSTOMER_ID_DESC',
  LicenseIdAsc = 'LICENSE_ID_ASC',
  LicenseIdDesc = 'LICENSE_ID_DESC',
  LicenseModuleByLicenseModuleIdCreatedAsc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__CREATED_ASC',
  LicenseModuleByLicenseModuleIdCreatedDesc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__CREATED_DESC',
  LicenseModuleByLicenseModuleIdIdAsc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__ID_ASC',
  LicenseModuleByLicenseModuleIdIdDesc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__ID_DESC',
  LicenseModuleByLicenseModuleIdLatestVersionAsc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__LATEST_VERSION_ASC',
  LicenseModuleByLicenseModuleIdLatestVersionDesc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__LATEST_VERSION_DESC',
  LicenseModuleByLicenseModuleIdModifiedAsc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__MODIFIED_ASC',
  LicenseModuleByLicenseModuleIdModifiedDesc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__MODIFIED_DESC',
  LicenseModuleByLicenseModuleIdNameAsc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__NAME_ASC',
  LicenseModuleByLicenseModuleIdNameDesc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__NAME_DESC',
  LicenseModuleByLicenseModuleIdOwnerIdAsc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__OWNER_ID_ASC',
  LicenseModuleByLicenseModuleIdOwnerIdDesc = 'LICENSE_MODULE_BY_LICENSE_MODULE_ID__OWNER_ID_DESC',
  LicenseModuleIdAsc = 'LICENSE_MODULE_ID_ASC',
  LicenseModuleIdDesc = 'LICENSE_MODULE_ID_DESC',
  LicenseOrdersByLicenseIdCountAsc = 'LICENSE_ORDERS_BY_LICENSE_ID__COUNT_ASC',
  LicenseOrdersByLicenseIdCountDesc = 'LICENSE_ORDERS_BY_LICENSE_ID__COUNT_DESC',
  LicenseRegistrationsByLicenseIdCountAsc = 'LICENSE_REGISTRATIONS_BY_LICENSE_ID__COUNT_ASC',
  LicenseRegistrationsByLicenseIdCountDesc = 'LICENSE_REGISTRATIONS_BY_LICENSE_ID__COUNT_DESC',
  ModuleDataAsc = 'MODULE_DATA_ASC',
  ModuleDataDesc = 'MODULE_DATA_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Magazijn = {
  __typename?: 'Magazijn';
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  voorkeur?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Magazijn` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MagazijnCondition = {
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Magazijn` object types. All fields are combined with a logical ‘and.’ */
export type MagazijnFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MagazijnFilter>>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MagazijnFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MagazijnFilter>>;
  /** Filter by the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<StringFilter>;
};

export type MagazijnMv = {
  __typename?: 'MagazijnMv';
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  voorkeur?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MagazijnMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MagazijnMvCondition = {
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MagazijnMv` object types. All fields are combined with a logical ‘and.’ */
export type MagazijnMvFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MagazijnMvFilter>>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MagazijnMvFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MagazijnMvFilter>>;
  /** Filter by the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<StringFilter>;
};

/** A connection to a list of `MagazijnMv` values. */
export type MagazijnMvsConnection = {
  __typename?: 'MagazijnMvsConnection';
  /** A list of edges which contains the `MagazijnMv` and cursor to aid in pagination. */
  edges: Array<MagazijnMvsEdge>;
  /** A list of `MagazijnMv` objects. */
  nodes: Array<MagazijnMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MagazijnMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MagazijnMv` edge in the connection. */
export type MagazijnMvsEdge = {
  __typename?: 'MagazijnMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MagazijnMv` at the end of the edge. */
  node: MagazijnMv;
};

/** Methods to use when ordering `MagazijnMv`. */
export enum MagazijnMvsOrderBy {
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  VoorkeurAsc = 'VOORKEUR_ASC',
  VoorkeurDesc = 'VOORKEUR_DESC'
}

/** A connection to a list of `Magazijn` values. */
export type MagazijnsConnection = {
  __typename?: 'MagazijnsConnection';
  /** A list of edges which contains the `Magazijn` and cursor to aid in pagination. */
  edges: Array<MagazijnsEdge>;
  /** A list of `Magazijn` objects. */
  nodes: Array<Magazijn>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Magazijn` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Magazijn` edge in the connection. */
export type MagazijnsEdge = {
  __typename?: 'MagazijnsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Magazijn` at the end of the edge. */
  node: Magazijn;
};

/** Methods to use when ordering `Magazijn`. */
export enum MagazijnsOrderBy {
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  VoorkeurAsc = 'VOORKEUR_ASC',
  VoorkeurDesc = 'VOORKEUR_DESC'
}

export type MaintenanceVisit = Node & {
  __typename?: 'MaintenanceVisit';
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  checked?: Maybe<Scalars['Boolean']['output']>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  contactName?: Maybe<Scalars['String']['output']>;
  contactPhone?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  date: Scalars['Date']['output'];
  duration: Scalars['Int']['output'];
  /** Reads a single `EndUser` that is related to this `MaintenanceVisit`. */
  endUserByEndUserId?: Maybe<EndUser>;
  endUserId: Scalars['Int']['output'];
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  labourHours?: Maybe<Scalars['BigFloat']['output']>;
  locked: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  maintenanceVisitLinesByMaintenanceVisitId: MaintenanceVisitLinesConnection;
  /** Reads and enables pagination through a set of `MaintenanceVisitRemark`. */
  maintenanceVisitRemarksByMaintenanceVisitId: MaintenanceVisitRemarksConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `MaintenanceVisit`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `MaintenanceVisit`. */
  userByUserId?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};


export type MaintenanceVisitMaintenanceVisitLinesByMaintenanceVisitIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};


export type MaintenanceVisitMaintenanceVisitRemarksByMaintenanceVisitIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitRemarkCondition>;
  filter?: InputMaybe<MaintenanceVisitRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitRemarksOrderBy>>;
};

export type MaintenanceVisitArea = {
  __typename?: 'MaintenanceVisitArea';
  areaName?: Maybe<Scalars['String']['output']>;
  areaRemarks?: Maybe<Scalars['String']['output']>;
  buildingId?: Maybe<Scalars['Int']['output']>;
  buildingName?: Maybe<Scalars['String']['output']>;
  floorName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  maintenanceVisitId?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitArea` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitAreaCondition = {
  /** Checks for equality with the object’s `areaName` field. */
  areaName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `areaRemarks` field. */
  areaRemarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `buildingId` field. */
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `buildingName` field. */
  buildingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `floorName` field. */
  floorName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MaintenanceVisitArea` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitAreaFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitAreaFilter>>;
  /** Filter by the object’s `areaName` field. */
  areaName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `areaRemarks` field. */
  areaRemarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `buildingId` field. */
  buildingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `buildingName` field. */
  buildingName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `floorName` field. */
  floorName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitAreaFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitAreaFilter>>;
};

/** A connection to a list of `MaintenanceVisitArea` values. */
export type MaintenanceVisitAreasConnection = {
  __typename?: 'MaintenanceVisitAreasConnection';
  /** A list of edges which contains the `MaintenanceVisitArea` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitAreasEdge>;
  /** A list of `MaintenanceVisitArea` objects. */
  nodes: Array<MaintenanceVisitArea>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitArea` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitArea` edge in the connection. */
export type MaintenanceVisitAreasEdge = {
  __typename?: 'MaintenanceVisitAreasEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitArea` at the end of the edge. */
  node: MaintenanceVisitArea;
};

/** Methods to use when ordering `MaintenanceVisitArea`. */
export enum MaintenanceVisitAreasOrderBy {
  AreaNameAsc = 'AREA_NAME_ASC',
  AreaNameDesc = 'AREA_NAME_DESC',
  AreaRemarksAsc = 'AREA_REMARKS_ASC',
  AreaRemarksDesc = 'AREA_REMARKS_DESC',
  BuildingIdAsc = 'BUILDING_ID_ASC',
  BuildingIdDesc = 'BUILDING_ID_DESC',
  BuildingNameAsc = 'BUILDING_NAME_ASC',
  BuildingNameDesc = 'BUILDING_NAME_DESC',
  FloorNameAsc = 'FLOOR_NAME_ASC',
  FloorNameDesc = 'FLOOR_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceVisitIdAsc = 'MAINTENANCE_VISIT_ID_ASC',
  MaintenanceVisitIdDesc = 'MAINTENANCE_VISIT_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL'
}

/**
 * A condition to be used against `MaintenanceVisit` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitCondition = {
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `checked` field. */
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactName` field. */
  contactName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactPhone` field. */
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `labourHours` field. */
  labourHours?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `locked` field. */
  locked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `MaintenanceVisit` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitFilter>>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `checked` field. */
  checked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactName` field. */
  contactName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactPhone` field. */
  contactPhone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserByEndUserId` relation. */
  endUserByEndUserId?: InputMaybe<EndUserFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `labourHours` field. */
  labourHours?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `locked` field. */
  locked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `maintenanceVisitLinesByMaintenanceVisitId` relation. */
  maintenanceVisitLinesByMaintenanceVisitId?: InputMaybe<MaintenanceVisitToManyMaintenanceVisitLineFilter>;
  /** Some related `maintenanceVisitLinesByMaintenanceVisitId` exist. */
  maintenanceVisitLinesByMaintenanceVisitIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `maintenanceVisitRemarksByMaintenanceVisitId` relation. */
  maintenanceVisitRemarksByMaintenanceVisitId?: InputMaybe<MaintenanceVisitToManyMaintenanceVisitRemarkFilter>;
  /** Some related `maintenanceVisitRemarksByMaintenanceVisitId` exist. */
  maintenanceVisitRemarksByMaintenanceVisitIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** A related `userByUserId` exists. */
  userByUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `MaintenanceVisit` */
export type MaintenanceVisitInput = {
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactName?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date: Scalars['Date']['input'];
  duration: Scalars['Int']['input'];
  endUserId: Scalars['Int']['input'];
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  labourHours?: InputMaybe<Scalars['BigFloat']['input']>;
  locked?: InputMaybe<Scalars['Boolean']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
};

export type MaintenanceVisitLine = Node & {
  __typename?: 'MaintenanceVisitLine';
  /** Reads a single `CalGas` that is related to this `MaintenanceVisitLine`. */
  calGasByCalGasId?: Maybe<CalGas>;
  calGasId?: Maybe<Scalars['Int']['output']>;
  concentration?: Maybe<Scalars['Float']['output']>;
  dateOld?: Maybe<Scalars['Date']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `DetectorSensor` that is related to this `MaintenanceVisitLine`. */
  detectorSensorByDetectorSensorId?: Maybe<DetectorSensor>;
  detectorSensorId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `DetectorSensorLocation` that is related to this `MaintenanceVisitLine`. */
  detectorSensorLocationByDetectorSensorLocationId?: Maybe<DetectorSensorLocation>;
  detectorSensorLocationId: Scalars['Int']['output'];
  /** Reads a single `Filter` that is related to this `MaintenanceVisitLine`. */
  filterByFilterId?: Maybe<Filter>;
  filterId?: Maybe<Scalars['Int']['output']>;
  filterInstallDueDate?: Maybe<Scalars['Date']['output']>;
  id: Scalars['Int']['output'];
  /** Reads a single `MaintenanceVisit` that is related to this `MaintenanceVisitLine`. */
  maintenanceVisitByMaintenanceVisitId?: Maybe<MaintenanceVisit>;
  maintenanceVisitId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  originalSensorId?: Maybe<Scalars['Int']['output']>;
  preResponse?: Maybe<Scalars['Float']['output']>;
  /** Reads a single `Pyrolyser` that is related to this `MaintenanceVisitLine`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  pyrolyserId?: Maybe<Scalars['Int']['output']>;
  pyrolyserInstallDueDate?: Maybe<Scalars['Date']['output']>;
  remarkLine?: Maybe<Scalars['Int']['output']>;
  response?: Maybe<Scalars['Float']['output']>;
  /** Reads a single `Sensor` that is related to this `MaintenanceVisitLine`. */
  sensorByOriginalSensorId?: Maybe<Sensor>;
  /** Reads a single `Sensor` that is related to this `MaintenanceVisitLine`. */
  sensorBySensorId?: Maybe<Sensor>;
  sensorId?: Maybe<Scalars['Int']['output']>;
  sensorInstallDueDate?: Maybe<Scalars['Date']['output']>;
  sensorMaintenanceDueDate?: Maybe<Scalars['Date']['output']>;
  spanSuccess?: Maybe<Scalars['Boolean']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
  zeroSuccess?: Maybe<Scalars['Boolean']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitLine` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitLineCondition = {
  /** Checks for equality with the object’s `calGasId` field. */
  calGasId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `concentration` field. */
  concentration?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `dateOld` field. */
  dateOld?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `day` field. */
  day?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `filterId` field. */
  filterId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `filterInstallDueDate` field. */
  filterInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `originalSensorId` field. */
  originalSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `preResponse` field. */
  preResponse?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueDate` field. */
  pyrolyserInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `remarkLine` field. */
  remarkLine?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `response` field. */
  response?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueDate` field. */
  sensorInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `spanSuccess` field. */
  spanSuccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `success` field. */
  success?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `zeroSuccess` field. */
  zeroSuccess?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A filter to be used against `MaintenanceVisitLine` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitLineFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitLineFilter>>;
  /** Filter by the object’s `calGasByCalGasId` relation. */
  calGasByCalGasId?: InputMaybe<CalGasFilter>;
  /** A related `calGasByCalGasId` exists. */
  calGasByCalGasIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `calGasId` field. */
  calGasId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `concentration` field. */
  concentration?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `dateOld` field. */
  dateOld?: InputMaybe<DateFilter>;
  /** Filter by the object’s `day` field. */
  day?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorByDetectorSensorId` relation. */
  detectorSensorByDetectorSensorId?: InputMaybe<DetectorSensorFilter>;
  /** A related `detectorSensorByDetectorSensorId` exists. */
  detectorSensorByDetectorSensorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationByDetectorSensorLocationId` relation. */
  detectorSensorLocationByDetectorSensorLocationId?: InputMaybe<DetectorSensorLocationFilter>;
  /** Filter by the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `filterByFilterId` relation. */
  filterByFilterId?: InputMaybe<FilterFilter>;
  /** A related `filterByFilterId` exists. */
  filterByFilterIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `filterId` field. */
  filterId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `filterInstallDueDate` field. */
  filterInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitByMaintenanceVisitId` relation. */
  maintenanceVisitByMaintenanceVisitId?: InputMaybe<MaintenanceVisitFilter>;
  /** Filter by the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitLineFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitLineFilter>>;
  /** Filter by the object’s `originalSensorId` field. */
  originalSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `preResponse` field. */
  preResponse?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `pyrolyserByPyrolyserId` relation. */
  pyrolyserByPyrolyserId?: InputMaybe<PyrolyserFilter>;
  /** A related `pyrolyserByPyrolyserId` exists. */
  pyrolyserByPyrolyserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pyrolyserInstallDueDate` field. */
  pyrolyserInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `remarkLine` field. */
  remarkLine?: InputMaybe<IntFilter>;
  /** Filter by the object’s `response` field. */
  response?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `sensorByOriginalSensorId` relation. */
  sensorByOriginalSensorId?: InputMaybe<SensorFilter>;
  /** A related `sensorByOriginalSensorId` exists. */
  sensorByOriginalSensorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorBySensorId` relation. */
  sensorBySensorId?: InputMaybe<SensorFilter>;
  /** A related `sensorBySensorId` exists. */
  sensorBySensorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorInstallDueDate` field. */
  sensorInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `spanSuccess` field. */
  spanSuccess?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `success` field. */
  success?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `zeroSuccess` field. */
  zeroSuccess?: InputMaybe<BooleanFilter>;
};

/** An input for mutations affecting `MaintenanceVisitLine` */
export type MaintenanceVisitLineInput = {
  calGasId?: InputMaybe<Scalars['Int']['input']>;
  concentration?: InputMaybe<Scalars['Float']['input']>;
  dateOld?: InputMaybe<Scalars['Date']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  detectorSensorLocationId: Scalars['Int']['input'];
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  maintenanceVisitId: Scalars['Int']['input'];
  originalSensorId?: InputMaybe<Scalars['Int']['input']>;
  preResponse?: InputMaybe<Scalars['Float']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  remarkLine?: InputMaybe<Scalars['Int']['input']>;
  response?: InputMaybe<Scalars['Float']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  sensorInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  sensorMaintenanceDueDate?: InputMaybe<Scalars['Date']['input']>;
  spanSuccess?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  zeroSuccess?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents an update to a `MaintenanceVisitLine`. Fields that are set will be updated. */
export type MaintenanceVisitLinePatch = {
  calGasId?: InputMaybe<Scalars['Int']['input']>;
  concentration?: InputMaybe<Scalars['Float']['input']>;
  dateOld?: InputMaybe<Scalars['Date']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  maintenanceVisitId?: InputMaybe<Scalars['Int']['input']>;
  originalSensorId?: InputMaybe<Scalars['Int']['input']>;
  preResponse?: InputMaybe<Scalars['Float']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  remarkLine?: InputMaybe<Scalars['Int']['input']>;
  response?: InputMaybe<Scalars['Float']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  sensorInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  sensorMaintenanceDueDate?: InputMaybe<Scalars['Date']['input']>;
  spanSuccess?: InputMaybe<Scalars['Boolean']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  zeroSuccess?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A connection to a list of `MaintenanceVisitLine` values. */
export type MaintenanceVisitLinesConnection = {
  __typename?: 'MaintenanceVisitLinesConnection';
  /** A list of edges which contains the `MaintenanceVisitLine` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitLinesEdge>;
  /** A list of `MaintenanceVisitLine` objects. */
  nodes: Array<MaintenanceVisitLine>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitLine` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitLine` edge in the connection. */
export type MaintenanceVisitLinesEdge = {
  __typename?: 'MaintenanceVisitLinesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitLine` at the end of the edge. */
  node: MaintenanceVisitLine;
};

export type MaintenanceVisitLinesMaintain = {
  __typename?: 'MaintenanceVisitLinesMaintain';
  applicationName?: Maybe<Scalars['String']['output']>;
  areaId?: Maybe<Scalars['Int']['output']>;
  calDeviation?: Maybe<Scalars['Float']['output']>;
  calGasConcentration?: Maybe<Scalars['Float']['output']>;
  calGasEngineeringUnits?: Maybe<Scalars['String']['output']>;
  calGasGasName?: Maybe<Scalars['String']['output']>;
  calGasId?: Maybe<Scalars['Int']['output']>;
  calResponse?: Maybe<Scalars['Float']['output']>;
  concentration?: Maybe<Scalars['Float']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  detectorFirstSensorSn?: Maybe<Scalars['Int']['output']>;
  detectorId?: Maybe<Scalars['Int']['output']>;
  detectorLabelDate?: Maybe<Scalars['String']['output']>;
  detectorModel?: Maybe<Scalars['String']['output']>;
  detectorPosition?: Maybe<Scalars['Int']['output']>;
  detectorSensorId?: Maybe<Scalars['Int']['output']>;
  detectorSensorLocationId?: Maybe<Scalars['Int']['output']>;
  detectorSensorLocationRemarks?: Maybe<Scalars['String']['output']>;
  detectorSensorSensorId?: Maybe<Scalars['Int']['output']>;
  detectorSerialNumber?: Maybe<Scalars['String']['output']>;
  detectorTypeId?: Maybe<Scalars['Int']['output']>;
  electrolyteName?: Maybe<Scalars['String']['output']>;
  engineeringUnits?: Maybe<Scalars['String']['output']>;
  filterId?: Maybe<Scalars['Int']['output']>;
  filterInstallDueClass?: Maybe<Scalars['String']['output']>;
  filterInstallDueDate?: Maybe<Scalars['Date']['output']>;
  filterName?: Maybe<Scalars['String']['output']>;
  highEu?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  installedFilterId?: Maybe<Scalars['Int']['output']>;
  installedPyrolyserId?: Maybe<Scalars['Int']['output']>;
  maintenanceVisitId?: Maybe<Scalars['Int']['output']>;
  membraneName?: Maybe<Scalars['String']['output']>;
  nextSensorMaintenanceDueDateLabel?: Maybe<Scalars['String']['output']>;
  oRingName?: Maybe<Scalars['String']['output']>;
  originalSensorId?: Maybe<Scalars['Int']['output']>;
  preResponse?: Maybe<Scalars['Float']['output']>;
  pyrolyserId?: Maybe<Scalars['Int']['output']>;
  pyrolyserInstallDueClass?: Maybe<Scalars['String']['output']>;
  pyrolyserInstallDueDate?: Maybe<Scalars['Date']['output']>;
  pyrolyserName?: Maybe<Scalars['String']['output']>;
  range?: Maybe<Scalars['String']['output']>;
  rangeId?: Maybe<Scalars['Int']['output']>;
  remarkLine?: Maybe<Scalars['Int']['output']>;
  response?: Maybe<Scalars['Float']['output']>;
  samplePointName?: Maybe<Scalars['String']['output']>;
  sensorCount?: Maybe<Scalars['BigInt']['output']>;
  sensorId?: Maybe<Scalars['Int']['output']>;
  sensorInstallDueClass?: Maybe<Scalars['String']['output']>;
  sensorInstallDueDate?: Maybe<Scalars['Date']['output']>;
  sensorLabelDate?: Maybe<Scalars['Date']['output']>;
  sensorMaintenanceDueClass?: Maybe<Scalars['String']['output']>;
  sensorMaintenanceDueDate?: Maybe<Scalars['Date']['output']>;
  sensorModel?: Maybe<Scalars['String']['output']>;
  sensorSerialNumber?: Maybe<Scalars['String']['output']>;
  sensorTypeId?: Maybe<Scalars['Int']['output']>;
  siliconeSheet?: Maybe<Scalars['Boolean']['output']>;
  simsChannel?: Maybe<Scalars['Int']['output']>;
  simsTag?: Maybe<Scalars['String']['output']>;
  spanSuccess?: Maybe<Scalars['Boolean']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
  target?: Maybe<Scalars['String']['output']>;
  zeroSuccess?: Maybe<Scalars['Boolean']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitLinesMaintain` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitLinesMaintainCondition = {
  /** Checks for equality with the object’s `applicationName` field. */
  applicationName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `areaId` field. */
  areaId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `calDeviation` field. */
  calDeviation?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `calGasConcentration` field. */
  calGasConcentration?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `calGasEngineeringUnits` field. */
  calGasEngineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calGasGasName` field. */
  calGasGasName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calGasId` field. */
  calGasId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `calResponse` field. */
  calResponse?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `concentration` field. */
  concentration?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `day` field. */
  day?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorFirstSensorSn` field. */
  detectorFirstSensorSn?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorId` field. */
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorLabelDate` field. */
  detectorLabelDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorModel` field. */
  detectorModel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationRemarks` field. */
  detectorSensorLocationRemarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorSensorSensorId` field. */
  detectorSensorSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSerialNumber` field. */
  detectorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterId` field. */
  filterId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `filterInstallDueClass` field. */
  filterInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterInstallDueDate` field. */
  filterInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `filterName` field. */
  filterName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `highEu` field. */
  highEu?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `installedFilterId` field. */
  installedFilterId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `installedPyrolyserId` field. */
  installedPyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `membraneName` field. */
  membraneName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nextSensorMaintenanceDueDateLabel` field. */
  nextSensorMaintenanceDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `oRingName` field. */
  oRingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `originalSensorId` field. */
  originalSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `preResponse` field. */
  preResponse?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueClass` field. */
  pyrolyserInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueDate` field. */
  pyrolyserInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `pyrolyserName` field. */
  pyrolyserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `range` field. */
  range?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rangeId` field. */
  rangeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarkLine` field. */
  remarkLine?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `response` field. */
  response?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `samplePointName` field. */
  samplePointName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorCount` field. */
  sensorCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueClass` field. */
  sensorInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueDate` field. */
  sensorInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorLabelDate` field. */
  sensorLabelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueClass` field. */
  sensorMaintenanceDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorModel` field. */
  sensorModel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `siliconeSheet` field. */
  siliconeSheet?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `simsChannel` field. */
  simsChannel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `simsTag` field. */
  simsTag?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `spanSuccess` field. */
  spanSuccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `success` field. */
  success?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `target` field. */
  target?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zeroSuccess` field. */
  zeroSuccess?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A filter to be used against `MaintenanceVisitLinesMaintain` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitLinesMaintainFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitLinesMaintainFilter>>;
  /** Filter by the object’s `applicationName` field. */
  applicationName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `areaId` field. */
  areaId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `calDeviation` field. */
  calDeviation?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `calGasConcentration` field. */
  calGasConcentration?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `calGasEngineeringUnits` field. */
  calGasEngineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calGasGasName` field. */
  calGasGasName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calGasId` field. */
  calGasId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `calResponse` field. */
  calResponse?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `concentration` field. */
  concentration?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `day` field. */
  day?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorFirstSensorSn` field. */
  detectorFirstSensorSn?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorId` field. */
  detectorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorLabelDate` field. */
  detectorLabelDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorModel` field. */
  detectorModel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationRemarks` field. */
  detectorSensorLocationRemarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorSensorSensorId` field. */
  detectorSensorSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSerialNumber` field. */
  detectorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorTypeId` field. */
  detectorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterId` field. */
  filterId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `filterInstallDueClass` field. */
  filterInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterInstallDueDate` field. */
  filterInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `filterName` field. */
  filterName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `highEu` field. */
  highEu?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `installedFilterId` field. */
  installedFilterId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `installedPyrolyserId` field. */
  installedPyrolyserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `membraneName` field. */
  membraneName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nextSensorMaintenanceDueDateLabel` field. */
  nextSensorMaintenanceDueDateLabel?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitLinesMaintainFilter>;
  /** Filter by the object’s `oRingName` field. */
  oRingName?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitLinesMaintainFilter>>;
  /** Filter by the object’s `originalSensorId` field. */
  originalSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `preResponse` field. */
  preResponse?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pyrolyserInstallDueClass` field. */
  pyrolyserInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pyrolyserInstallDueDate` field. */
  pyrolyserInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `pyrolyserName` field. */
  pyrolyserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `range` field. */
  range?: InputMaybe<StringFilter>;
  /** Filter by the object’s `rangeId` field. */
  rangeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarkLine` field. */
  remarkLine?: InputMaybe<IntFilter>;
  /** Filter by the object’s `response` field. */
  response?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `samplePointName` field. */
  samplePointName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorCount` field. */
  sensorCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorInstallDueClass` field. */
  sensorInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorInstallDueDate` field. */
  sensorInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorLabelDate` field. */
  sensorLabelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorMaintenanceDueClass` field. */
  sensorMaintenanceDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorModel` field. */
  sensorModel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `siliconeSheet` field. */
  siliconeSheet?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `simsChannel` field. */
  simsChannel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `simsTag` field. */
  simsTag?: InputMaybe<StringFilter>;
  /** Filter by the object’s `spanSuccess` field. */
  spanSuccess?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `success` field. */
  success?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `target` field. */
  target?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zeroSuccess` field. */
  zeroSuccess?: InputMaybe<BooleanFilter>;
};

/** A connection to a list of `MaintenanceVisitLinesMaintain` values. */
export type MaintenanceVisitLinesMaintainsConnection = {
  __typename?: 'MaintenanceVisitLinesMaintainsConnection';
  /** A list of edges which contains the `MaintenanceVisitLinesMaintain` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitLinesMaintainsEdge>;
  /** A list of `MaintenanceVisitLinesMaintain` objects. */
  nodes: Array<MaintenanceVisitLinesMaintain>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitLinesMaintain` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitLinesMaintain` edge in the connection. */
export type MaintenanceVisitLinesMaintainsEdge = {
  __typename?: 'MaintenanceVisitLinesMaintainsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitLinesMaintain` at the end of the edge. */
  node: MaintenanceVisitLinesMaintain;
};

/** Methods to use when ordering `MaintenanceVisitLinesMaintain`. */
export enum MaintenanceVisitLinesMaintainsOrderBy {
  ApplicationNameAsc = 'APPLICATION_NAME_ASC',
  ApplicationNameDesc = 'APPLICATION_NAME_DESC',
  AreaIdAsc = 'AREA_ID_ASC',
  AreaIdDesc = 'AREA_ID_DESC',
  CalDeviationAsc = 'CAL_DEVIATION_ASC',
  CalDeviationDesc = 'CAL_DEVIATION_DESC',
  CalGasConcentrationAsc = 'CAL_GAS_CONCENTRATION_ASC',
  CalGasConcentrationDesc = 'CAL_GAS_CONCENTRATION_DESC',
  CalGasEngineeringUnitsAsc = 'CAL_GAS_ENGINEERING_UNITS_ASC',
  CalGasEngineeringUnitsDesc = 'CAL_GAS_ENGINEERING_UNITS_DESC',
  CalGasGasNameAsc = 'CAL_GAS_GAS_NAME_ASC',
  CalGasGasNameDesc = 'CAL_GAS_GAS_NAME_DESC',
  CalGasIdAsc = 'CAL_GAS_ID_ASC',
  CalGasIdDesc = 'CAL_GAS_ID_DESC',
  CalResponseAsc = 'CAL_RESPONSE_ASC',
  CalResponseDesc = 'CAL_RESPONSE_DESC',
  ConcentrationAsc = 'CONCENTRATION_ASC',
  ConcentrationDesc = 'CONCENTRATION_DESC',
  DayAsc = 'DAY_ASC',
  DayDesc = 'DAY_DESC',
  DetectorFirstSensorSnAsc = 'DETECTOR_FIRST_SENSOR_SN_ASC',
  DetectorFirstSensorSnDesc = 'DETECTOR_FIRST_SENSOR_SN_DESC',
  DetectorIdAsc = 'DETECTOR_ID_ASC',
  DetectorIdDesc = 'DETECTOR_ID_DESC',
  DetectorLabelDateAsc = 'DETECTOR_LABEL_DATE_ASC',
  DetectorLabelDateDesc = 'DETECTOR_LABEL_DATE_DESC',
  DetectorModelAsc = 'DETECTOR_MODEL_ASC',
  DetectorModelDesc = 'DETECTOR_MODEL_DESC',
  DetectorPositionAsc = 'DETECTOR_POSITION_ASC',
  DetectorPositionDesc = 'DETECTOR_POSITION_DESC',
  DetectorSensorIdAsc = 'DETECTOR_SENSOR_ID_ASC',
  DetectorSensorIdDesc = 'DETECTOR_SENSOR_ID_DESC',
  DetectorSensorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_ID_ASC',
  DetectorSensorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_ID_DESC',
  DetectorSensorLocationRemarksAsc = 'DETECTOR_SENSOR_LOCATION_REMARKS_ASC',
  DetectorSensorLocationRemarksDesc = 'DETECTOR_SENSOR_LOCATION_REMARKS_DESC',
  DetectorSensorSensorIdAsc = 'DETECTOR_SENSOR_SENSOR_ID_ASC',
  DetectorSensorSensorIdDesc = 'DETECTOR_SENSOR_SENSOR_ID_DESC',
  DetectorSerialNumberAsc = 'DETECTOR_SERIAL_NUMBER_ASC',
  DetectorSerialNumberDesc = 'DETECTOR_SERIAL_NUMBER_DESC',
  DetectorTypeIdAsc = 'DETECTOR_TYPE_ID_ASC',
  DetectorTypeIdDesc = 'DETECTOR_TYPE_ID_DESC',
  ElectrolyteNameAsc = 'ELECTROLYTE_NAME_ASC',
  ElectrolyteNameDesc = 'ELECTROLYTE_NAME_DESC',
  EngineeringUnitsAsc = 'ENGINEERING_UNITS_ASC',
  EngineeringUnitsDesc = 'ENGINEERING_UNITS_DESC',
  FilterIdAsc = 'FILTER_ID_ASC',
  FilterIdDesc = 'FILTER_ID_DESC',
  FilterInstallDueClassAsc = 'FILTER_INSTALL_DUE_CLASS_ASC',
  FilterInstallDueClassDesc = 'FILTER_INSTALL_DUE_CLASS_DESC',
  FilterInstallDueDateAsc = 'FILTER_INSTALL_DUE_DATE_ASC',
  FilterInstallDueDateDesc = 'FILTER_INSTALL_DUE_DATE_DESC',
  FilterNameAsc = 'FILTER_NAME_ASC',
  FilterNameDesc = 'FILTER_NAME_DESC',
  HighEuAsc = 'HIGH_EU_ASC',
  HighEuDesc = 'HIGH_EU_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InstalledFilterIdAsc = 'INSTALLED_FILTER_ID_ASC',
  InstalledFilterIdDesc = 'INSTALLED_FILTER_ID_DESC',
  InstalledPyrolyserIdAsc = 'INSTALLED_PYROLYSER_ID_ASC',
  InstalledPyrolyserIdDesc = 'INSTALLED_PYROLYSER_ID_DESC',
  MaintenanceVisitIdAsc = 'MAINTENANCE_VISIT_ID_ASC',
  MaintenanceVisitIdDesc = 'MAINTENANCE_VISIT_ID_DESC',
  MembraneNameAsc = 'MEMBRANE_NAME_ASC',
  MembraneNameDesc = 'MEMBRANE_NAME_DESC',
  Natural = 'NATURAL',
  NextSensorMaintenanceDueDateLabelAsc = 'NEXT_SENSOR_MAINTENANCE_DUE_DATE_LABEL_ASC',
  NextSensorMaintenanceDueDateLabelDesc = 'NEXT_SENSOR_MAINTENANCE_DUE_DATE_LABEL_DESC',
  OriginalSensorIdAsc = 'ORIGINAL_SENSOR_ID_ASC',
  OriginalSensorIdDesc = 'ORIGINAL_SENSOR_ID_DESC',
  ORingNameAsc = 'O_RING_NAME_ASC',
  ORingNameDesc = 'O_RING_NAME_DESC',
  PreResponseAsc = 'PRE_RESPONSE_ASC',
  PreResponseDesc = 'PRE_RESPONSE_DESC',
  PyrolyserIdAsc = 'PYROLYSER_ID_ASC',
  PyrolyserIdDesc = 'PYROLYSER_ID_DESC',
  PyrolyserInstallDueClassAsc = 'PYROLYSER_INSTALL_DUE_CLASS_ASC',
  PyrolyserInstallDueClassDesc = 'PYROLYSER_INSTALL_DUE_CLASS_DESC',
  PyrolyserInstallDueDateAsc = 'PYROLYSER_INSTALL_DUE_DATE_ASC',
  PyrolyserInstallDueDateDesc = 'PYROLYSER_INSTALL_DUE_DATE_DESC',
  PyrolyserNameAsc = 'PYROLYSER_NAME_ASC',
  PyrolyserNameDesc = 'PYROLYSER_NAME_DESC',
  RangeAsc = 'RANGE_ASC',
  RangeDesc = 'RANGE_DESC',
  RangeIdAsc = 'RANGE_ID_ASC',
  RangeIdDesc = 'RANGE_ID_DESC',
  RemarkLineAsc = 'REMARK_LINE_ASC',
  RemarkLineDesc = 'REMARK_LINE_DESC',
  ResponseAsc = 'RESPONSE_ASC',
  ResponseDesc = 'RESPONSE_DESC',
  SamplePointNameAsc = 'SAMPLE_POINT_NAME_ASC',
  SamplePointNameDesc = 'SAMPLE_POINT_NAME_DESC',
  SensorCountAsc = 'SENSOR_COUNT_ASC',
  SensorCountDesc = 'SENSOR_COUNT_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  SensorInstallDueClassAsc = 'SENSOR_INSTALL_DUE_CLASS_ASC',
  SensorInstallDueClassDesc = 'SENSOR_INSTALL_DUE_CLASS_DESC',
  SensorInstallDueDateAsc = 'SENSOR_INSTALL_DUE_DATE_ASC',
  SensorInstallDueDateDesc = 'SENSOR_INSTALL_DUE_DATE_DESC',
  SensorLabelDateAsc = 'SENSOR_LABEL_DATE_ASC',
  SensorLabelDateDesc = 'SENSOR_LABEL_DATE_DESC',
  SensorMaintenanceDueClassAsc = 'SENSOR_MAINTENANCE_DUE_CLASS_ASC',
  SensorMaintenanceDueClassDesc = 'SENSOR_MAINTENANCE_DUE_CLASS_DESC',
  SensorMaintenanceDueDateAsc = 'SENSOR_MAINTENANCE_DUE_DATE_ASC',
  SensorMaintenanceDueDateDesc = 'SENSOR_MAINTENANCE_DUE_DATE_DESC',
  SensorModelAsc = 'SENSOR_MODEL_ASC',
  SensorModelDesc = 'SENSOR_MODEL_DESC',
  SensorSerialNumberAsc = 'SENSOR_SERIAL_NUMBER_ASC',
  SensorSerialNumberDesc = 'SENSOR_SERIAL_NUMBER_DESC',
  SensorTypeIdAsc = 'SENSOR_TYPE_ID_ASC',
  SensorTypeIdDesc = 'SENSOR_TYPE_ID_DESC',
  SiliconeSheetAsc = 'SILICONE_SHEET_ASC',
  SiliconeSheetDesc = 'SILICONE_SHEET_DESC',
  SimsChannelAsc = 'SIMS_CHANNEL_ASC',
  SimsChannelDesc = 'SIMS_CHANNEL_DESC',
  SimsTagAsc = 'SIMS_TAG_ASC',
  SimsTagDesc = 'SIMS_TAG_DESC',
  SpanSuccessAsc = 'SPAN_SUCCESS_ASC',
  SpanSuccessDesc = 'SPAN_SUCCESS_DESC',
  SuccessAsc = 'SUCCESS_ASC',
  SuccessDesc = 'SUCCESS_DESC',
  TargetAsc = 'TARGET_ASC',
  TargetDesc = 'TARGET_DESC',
  ZeroSuccessAsc = 'ZERO_SUCCESS_ASC',
  ZeroSuccessDesc = 'ZERO_SUCCESS_DESC'
}

/** Methods to use when ordering `MaintenanceVisitLine`. */
export enum MaintenanceVisitLinesOrderBy {
  CalGasByCalGasIdCdartikelAsc = 'CAL_GAS_BY_CAL_GAS_ID__CDARTIKEL_ASC',
  CalGasByCalGasIdCdartikelDesc = 'CAL_GAS_BY_CAL_GAS_ID__CDARTIKEL_DESC',
  CalGasByCalGasIdConcentrationAsc = 'CAL_GAS_BY_CAL_GAS_ID__CONCENTRATION_ASC',
  CalGasByCalGasIdConcentrationDesc = 'CAL_GAS_BY_CAL_GAS_ID__CONCENTRATION_DESC',
  CalGasByCalGasIdCreatedAsc = 'CAL_GAS_BY_CAL_GAS_ID__CREATED_ASC',
  CalGasByCalGasIdCreatedDesc = 'CAL_GAS_BY_CAL_GAS_ID__CREATED_DESC',
  CalGasByCalGasIdEngineeringUnitsAsc = 'CAL_GAS_BY_CAL_GAS_ID__ENGINEERING_UNITS_ASC',
  CalGasByCalGasIdEngineeringUnitsDesc = 'CAL_GAS_BY_CAL_GAS_ID__ENGINEERING_UNITS_DESC',
  CalGasByCalGasIdGasIdAsc = 'CAL_GAS_BY_CAL_GAS_ID__GAS_ID_ASC',
  CalGasByCalGasIdGasIdDesc = 'CAL_GAS_BY_CAL_GAS_ID__GAS_ID_DESC',
  CalGasByCalGasIdIdAsc = 'CAL_GAS_BY_CAL_GAS_ID__ID_ASC',
  CalGasByCalGasIdIdDesc = 'CAL_GAS_BY_CAL_GAS_ID__ID_DESC',
  CalGasByCalGasIdModifiedAsc = 'CAL_GAS_BY_CAL_GAS_ID__MODIFIED_ASC',
  CalGasByCalGasIdModifiedDesc = 'CAL_GAS_BY_CAL_GAS_ID__MODIFIED_DESC',
  CalGasByCalGasIdOwnerIdAsc = 'CAL_GAS_BY_CAL_GAS_ID__OWNER_ID_ASC',
  CalGasByCalGasIdOwnerIdDesc = 'CAL_GAS_BY_CAL_GAS_ID__OWNER_ID_DESC',
  CalGasIdAsc = 'CAL_GAS_ID_ASC',
  CalGasIdDesc = 'CAL_GAS_ID_DESC',
  ConcentrationAsc = 'CONCENTRATION_ASC',
  ConcentrationDesc = 'CONCENTRATION_DESC',
  DateOldAsc = 'DATE_OLD_ASC',
  DateOldDesc = 'DATE_OLD_DESC',
  DayAsc = 'DAY_ASC',
  DayDesc = 'DAY_DESC',
  DetectorSensorByDetectorSensorIdCreatedAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__CREATED_ASC',
  DetectorSensorByDetectorSensorIdCreatedDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__CREATED_DESC',
  DetectorSensorByDetectorSensorIdDetectorIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__DETECTOR_ID_ASC',
  DetectorSensorByDetectorSensorIdDetectorIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__DETECTOR_ID_DESC',
  DetectorSensorByDetectorSensorIdDetectorPositionAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__DETECTOR_POSITION_ASC',
  DetectorSensorByDetectorSensorIdDetectorPositionDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__DETECTOR_POSITION_DESC',
  DetectorSensorByDetectorSensorIdFilterIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__FILTER_ID_ASC',
  DetectorSensorByDetectorSensorIdFilterIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__FILTER_ID_DESC',
  DetectorSensorByDetectorSensorIdIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__ID_ASC',
  DetectorSensorByDetectorSensorIdIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__ID_DESC',
  DetectorSensorByDetectorSensorIdModifiedAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__MODIFIED_ASC',
  DetectorSensorByDetectorSensorIdModifiedDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__MODIFIED_DESC',
  DetectorSensorByDetectorSensorIdOwnerIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__OWNER_ID_ASC',
  DetectorSensorByDetectorSensorIdOwnerIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__OWNER_ID_DESC',
  DetectorSensorByDetectorSensorIdPyrolyserIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__PYROLYSER_ID_ASC',
  DetectorSensorByDetectorSensorIdPyrolyserIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__PYROLYSER_ID_DESC',
  DetectorSensorByDetectorSensorIdSensorIdAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__SENSOR_ID_ASC',
  DetectorSensorByDetectorSensorIdSensorIdDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID__SENSOR_ID_DESC',
  DetectorSensorByDetectorSensorIdFilterLabelDateAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID___FILTER_LABEL_DATE_ASC',
  DetectorSensorByDetectorSensorIdFilterLabelDateDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID___FILTER_LABEL_DATE_DESC',
  DetectorSensorByDetectorSensorIdPyrolyserLabelDateAsc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID___PYROLYSER_LABEL_DATE_ASC',
  DetectorSensorByDetectorSensorIdPyrolyserLabelDateDesc = 'DETECTOR_SENSOR_BY_DETECTOR_SENSOR_ID___PYROLYSER_LABEL_DATE_DESC',
  DetectorSensorIdAsc = 'DETECTOR_SENSOR_ID_ASC',
  DetectorSensorIdDesc = 'DETECTOR_SENSOR_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdApplicationIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__APPLICATION_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdApplicationIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__APPLICATION_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdCreatedAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__CREATED_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdCreatedDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__CREATED_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdDetectorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__DETECTOR_LOCATION_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdDetectorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__DETECTOR_LOCATION_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdDetectorSensorIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__DETECTOR_SENSOR_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdDetectorSensorIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__DETECTOR_SENSOR_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdFilterReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__FILTER_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdFilterReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__FILTER_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdLicenseIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__LICENSE_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdLicenseIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__LICENSE_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdModifiedAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__MODIFIED_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdModifiedDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__MODIFIED_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdOwnerIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__OWNER_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdOwnerIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__OWNER_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdPyrolyserReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__PYROLYSER_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdPyrolyserReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__PYROLYSER_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdRemarksAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__REMARKS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdRemarksDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__REMARKS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSamplePointIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SAMPLE_POINT_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSamplePointIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SAMPLE_POINT_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSensorMaintenanceIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SENSOR_MAINTENANCE_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSensorMaintenanceIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SENSOR_MAINTENANCE_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSensorReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SENSOR_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSensorReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SENSOR_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSimsChannelAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SIMS_CHANNEL_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSimsChannelDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SIMS_CHANNEL_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSimsTagAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SIMS_TAG_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSimsTagDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SIMS_TAG_DESC',
  DetectorSensorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_ID_ASC',
  DetectorSensorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_ID_DESC',
  FilterByFilterIdCdartikelAsc = 'FILTER_BY_FILTER_ID__CDARTIKEL_ASC',
  FilterByFilterIdCdartikelDesc = 'FILTER_BY_FILTER_ID__CDARTIKEL_DESC',
  FilterByFilterIdConsumableAsc = 'FILTER_BY_FILTER_ID__CONSUMABLE_ASC',
  FilterByFilterIdConsumableDesc = 'FILTER_BY_FILTER_ID__CONSUMABLE_DESC',
  FilterByFilterIdCreatedAsc = 'FILTER_BY_FILTER_ID__CREATED_ASC',
  FilterByFilterIdCreatedDesc = 'FILTER_BY_FILTER_ID__CREATED_DESC',
  FilterByFilterIdIdAsc = 'FILTER_BY_FILTER_ID__ID_ASC',
  FilterByFilterIdIdDesc = 'FILTER_BY_FILTER_ID__ID_DESC',
  FilterByFilterIdModifiedAsc = 'FILTER_BY_FILTER_ID__MODIFIED_ASC',
  FilterByFilterIdModifiedDesc = 'FILTER_BY_FILTER_ID__MODIFIED_DESC',
  FilterByFilterIdNameAsc = 'FILTER_BY_FILTER_ID__NAME_ASC',
  FilterByFilterIdNameDesc = 'FILTER_BY_FILTER_ID__NAME_DESC',
  FilterByFilterIdOwnerIdAsc = 'FILTER_BY_FILTER_ID__OWNER_ID_ASC',
  FilterByFilterIdOwnerIdDesc = 'FILTER_BY_FILTER_ID__OWNER_ID_DESC',
  FilterByFilterIdReplacementIntervalMonthsAsc = 'FILTER_BY_FILTER_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  FilterByFilterIdReplacementIntervalMonthsDesc = 'FILTER_BY_FILTER_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  FilterIdAsc = 'FILTER_ID_ASC',
  FilterIdDesc = 'FILTER_ID_DESC',
  FilterInstallDueDateAsc = 'FILTER_INSTALL_DUE_DATE_ASC',
  FilterInstallDueDateDesc = 'FILTER_INSTALL_DUE_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceVisitByMaintenanceVisitIdCdmagazijnAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CDMAGAZIJN_ASC',
  MaintenanceVisitByMaintenanceVisitIdCdmagazijnDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CDMAGAZIJN_DESC',
  MaintenanceVisitByMaintenanceVisitIdCheckedAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CHECKED_ASC',
  MaintenanceVisitByMaintenanceVisitIdCheckedDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CHECKED_DESC',
  MaintenanceVisitByMaintenanceVisitIdContactEmailAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_EMAIL_ASC',
  MaintenanceVisitByMaintenanceVisitIdContactEmailDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_EMAIL_DESC',
  MaintenanceVisitByMaintenanceVisitIdContactNameAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_NAME_ASC',
  MaintenanceVisitByMaintenanceVisitIdContactNameDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_NAME_DESC',
  MaintenanceVisitByMaintenanceVisitIdContactPhoneAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_PHONE_ASC',
  MaintenanceVisitByMaintenanceVisitIdContactPhoneDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_PHONE_DESC',
  MaintenanceVisitByMaintenanceVisitIdCreatedAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CREATED_ASC',
  MaintenanceVisitByMaintenanceVisitIdCreatedDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CREATED_DESC',
  MaintenanceVisitByMaintenanceVisitIdDateAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__DATE_ASC',
  MaintenanceVisitByMaintenanceVisitIdDateDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__DATE_DESC',
  MaintenanceVisitByMaintenanceVisitIdDurationAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__DURATION_ASC',
  MaintenanceVisitByMaintenanceVisitIdDurationDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__DURATION_DESC',
  MaintenanceVisitByMaintenanceVisitIdEndUserIdAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__END_USER_ID_ASC',
  MaintenanceVisitByMaintenanceVisitIdEndUserIdDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__END_USER_ID_DESC',
  MaintenanceVisitByMaintenanceVisitIdFactuuropdrachtAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__FACTUUROPDRACHT_ASC',
  MaintenanceVisitByMaintenanceVisitIdFactuuropdrachtDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__FACTUUROPDRACHT_DESC',
  MaintenanceVisitByMaintenanceVisitIdIdAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__ID_ASC',
  MaintenanceVisitByMaintenanceVisitIdIdDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__ID_DESC',
  MaintenanceVisitByMaintenanceVisitIdLabourHoursAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__LABOUR_HOURS_ASC',
  MaintenanceVisitByMaintenanceVisitIdLabourHoursDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__LABOUR_HOURS_DESC',
  MaintenanceVisitByMaintenanceVisitIdLockedAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__LOCKED_ASC',
  MaintenanceVisitByMaintenanceVisitIdLockedDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__LOCKED_DESC',
  MaintenanceVisitByMaintenanceVisitIdModifiedAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__MODIFIED_ASC',
  MaintenanceVisitByMaintenanceVisitIdModifiedDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__MODIFIED_DESC',
  MaintenanceVisitByMaintenanceVisitIdOwnerIdAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__OWNER_ID_ASC',
  MaintenanceVisitByMaintenanceVisitIdOwnerIdDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__OWNER_ID_DESC',
  MaintenanceVisitByMaintenanceVisitIdUserIdAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__USER_ID_ASC',
  MaintenanceVisitByMaintenanceVisitIdUserIdDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__USER_ID_DESC',
  MaintenanceVisitIdAsc = 'MAINTENANCE_VISIT_ID_ASC',
  MaintenanceVisitIdDesc = 'MAINTENANCE_VISIT_ID_DESC',
  Natural = 'NATURAL',
  OriginalSensorIdAsc = 'ORIGINAL_SENSOR_ID_ASC',
  OriginalSensorIdDesc = 'ORIGINAL_SENSOR_ID_DESC',
  PreResponseAsc = 'PRE_RESPONSE_ASC',
  PreResponseDesc = 'PRE_RESPONSE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PyrolyserByPyrolyserIdCdartikelAsc = 'PYROLYSER_BY_PYROLYSER_ID__CDARTIKEL_ASC',
  PyrolyserByPyrolyserIdCdartikelDesc = 'PYROLYSER_BY_PYROLYSER_ID__CDARTIKEL_DESC',
  PyrolyserByPyrolyserIdCreatedAsc = 'PYROLYSER_BY_PYROLYSER_ID__CREATED_ASC',
  PyrolyserByPyrolyserIdCreatedDesc = 'PYROLYSER_BY_PYROLYSER_ID__CREATED_DESC',
  PyrolyserByPyrolyserIdIdAsc = 'PYROLYSER_BY_PYROLYSER_ID__ID_ASC',
  PyrolyserByPyrolyserIdIdDesc = 'PYROLYSER_BY_PYROLYSER_ID__ID_DESC',
  PyrolyserByPyrolyserIdModifiedAsc = 'PYROLYSER_BY_PYROLYSER_ID__MODIFIED_ASC',
  PyrolyserByPyrolyserIdModifiedDesc = 'PYROLYSER_BY_PYROLYSER_ID__MODIFIED_DESC',
  PyrolyserByPyrolyserIdNameAsc = 'PYROLYSER_BY_PYROLYSER_ID__NAME_ASC',
  PyrolyserByPyrolyserIdNameDesc = 'PYROLYSER_BY_PYROLYSER_ID__NAME_DESC',
  PyrolyserByPyrolyserIdOwnerIdAsc = 'PYROLYSER_BY_PYROLYSER_ID__OWNER_ID_ASC',
  PyrolyserByPyrolyserIdOwnerIdDesc = 'PYROLYSER_BY_PYROLYSER_ID__OWNER_ID_DESC',
  PyrolyserByPyrolyserIdReplacementIntervalMonthsAsc = 'PYROLYSER_BY_PYROLYSER_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  PyrolyserByPyrolyserIdReplacementIntervalMonthsDesc = 'PYROLYSER_BY_PYROLYSER_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  PyrolyserIdAsc = 'PYROLYSER_ID_ASC',
  PyrolyserIdDesc = 'PYROLYSER_ID_DESC',
  PyrolyserInstallDueDateAsc = 'PYROLYSER_INSTALL_DUE_DATE_ASC',
  PyrolyserInstallDueDateDesc = 'PYROLYSER_INSTALL_DUE_DATE_DESC',
  RemarkLineAsc = 'REMARK_LINE_ASC',
  RemarkLineDesc = 'REMARK_LINE_DESC',
  ResponseAsc = 'RESPONSE_ASC',
  ResponseDesc = 'RESPONSE_DESC',
  SensorByOriginalSensorIdCreatedAsc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__CREATED_ASC',
  SensorByOriginalSensorIdCreatedDesc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__CREATED_DESC',
  SensorByOriginalSensorIdIdAsc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__ID_ASC',
  SensorByOriginalSensorIdIdDesc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__ID_DESC',
  SensorByOriginalSensorIdLabelDateAsc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__LABEL_DATE_ASC',
  SensorByOriginalSensorIdLabelDateDesc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__LABEL_DATE_DESC',
  SensorByOriginalSensorIdModifiedAsc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__MODIFIED_ASC',
  SensorByOriginalSensorIdModifiedDesc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__MODIFIED_DESC',
  SensorByOriginalSensorIdOwnerIdAsc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__OWNER_ID_ASC',
  SensorByOriginalSensorIdOwnerIdDesc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__OWNER_ID_DESC',
  SensorByOriginalSensorIdRemarksAsc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__REMARKS_ASC',
  SensorByOriginalSensorIdRemarksDesc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__REMARKS_DESC',
  SensorByOriginalSensorIdSensorTypeIdAsc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__SENSOR_TYPE_ID_ASC',
  SensorByOriginalSensorIdSensorTypeIdDesc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__SENSOR_TYPE_ID_DESC',
  SensorByOriginalSensorIdSerialNumberAsc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__SERIAL_NUMBER_ASC',
  SensorByOriginalSensorIdSerialNumberDesc = 'SENSOR_BY_ORIGINAL_SENSOR_ID__SERIAL_NUMBER_DESC',
  SensorBySensorIdCreatedAsc = 'SENSOR_BY_SENSOR_ID__CREATED_ASC',
  SensorBySensorIdCreatedDesc = 'SENSOR_BY_SENSOR_ID__CREATED_DESC',
  SensorBySensorIdIdAsc = 'SENSOR_BY_SENSOR_ID__ID_ASC',
  SensorBySensorIdIdDesc = 'SENSOR_BY_SENSOR_ID__ID_DESC',
  SensorBySensorIdLabelDateAsc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_ASC',
  SensorBySensorIdLabelDateDesc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_DESC',
  SensorBySensorIdModifiedAsc = 'SENSOR_BY_SENSOR_ID__MODIFIED_ASC',
  SensorBySensorIdModifiedDesc = 'SENSOR_BY_SENSOR_ID__MODIFIED_DESC',
  SensorBySensorIdOwnerIdAsc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_ASC',
  SensorBySensorIdOwnerIdDesc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_DESC',
  SensorBySensorIdRemarksAsc = 'SENSOR_BY_SENSOR_ID__REMARKS_ASC',
  SensorBySensorIdRemarksDesc = 'SENSOR_BY_SENSOR_ID__REMARKS_DESC',
  SensorBySensorIdSensorTypeIdAsc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_ASC',
  SensorBySensorIdSensorTypeIdDesc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_DESC',
  SensorBySensorIdSerialNumberAsc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_ASC',
  SensorBySensorIdSerialNumberDesc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  SensorInstallDueDateAsc = 'SENSOR_INSTALL_DUE_DATE_ASC',
  SensorInstallDueDateDesc = 'SENSOR_INSTALL_DUE_DATE_DESC',
  SensorMaintenanceDueDateAsc = 'SENSOR_MAINTENANCE_DUE_DATE_ASC',
  SensorMaintenanceDueDateDesc = 'SENSOR_MAINTENANCE_DUE_DATE_DESC',
  SpanSuccessAsc = 'SPAN_SUCCESS_ASC',
  SpanSuccessDesc = 'SPAN_SUCCESS_DESC',
  SuccessAsc = 'SUCCESS_ASC',
  SuccessDesc = 'SUCCESS_DESC',
  ZeroSuccessAsc = 'ZERO_SUCCESS_ASC',
  ZeroSuccessDesc = 'ZERO_SUCCESS_DESC'
}

/** Represents an update to a `MaintenanceVisit`. Fields that are set will be updated. */
export type MaintenanceVisitPatch = {
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactName?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  labourHours?: InputMaybe<Scalars['BigFloat']['input']>;
  locked?: InputMaybe<Scalars['Boolean']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

export type MaintenanceVisitRemark = Node & {
  __typename?: 'MaintenanceVisitRemark';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  followUp?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  line?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `MaintenanceVisit` that is related to this `MaintenanceVisitRemark`. */
  maintenanceVisitByMaintenanceVisitId?: Maybe<MaintenanceVisit>;
  maintenanceVisitId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  remarks?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitRemark` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitRemarkCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `followUp` field. */
  followUp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `line` field. */
  line?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MaintenanceVisitRemark` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitRemarkFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitRemarkFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `followUp` field. */
  followUp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `line` field. */
  line?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitByMaintenanceVisitId` relation. */
  maintenanceVisitByMaintenanceVisitId?: InputMaybe<MaintenanceVisitFilter>;
  /** Filter by the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitRemarkFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitRemarkFilter>>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `MaintenanceVisitRemark` */
export type MaintenanceVisitRemarkInput = {
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  followUp?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  line?: InputMaybe<Scalars['Int']['input']>;
  maintenanceVisitId: Scalars['Int']['input'];
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `MaintenanceVisitRemark`. Fields that are set will be updated. */
export type MaintenanceVisitRemarkPatch = {
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  followUp?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  line?: InputMaybe<Scalars['Int']['input']>;
  maintenanceVisitId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `MaintenanceVisitRemark` values. */
export type MaintenanceVisitRemarksConnection = {
  __typename?: 'MaintenanceVisitRemarksConnection';
  /** A list of edges which contains the `MaintenanceVisitRemark` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitRemarksEdge>;
  /** A list of `MaintenanceVisitRemark` objects. */
  nodes: Array<MaintenanceVisitRemark>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitRemark` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitRemark` edge in the connection. */
export type MaintenanceVisitRemarksEdge = {
  __typename?: 'MaintenanceVisitRemarksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitRemark` at the end of the edge. */
  node: MaintenanceVisitRemark;
};

export type MaintenanceVisitRemarksIndex = {
  __typename?: 'MaintenanceVisitRemarksIndex';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  followUp?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  line?: Maybe<Scalars['Int']['output']>;
  maintenanceVisitId?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitRemarksIndex` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitRemarksIndexCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `followUp` field. */
  followUp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `line` field. */
  line?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MaintenanceVisitRemarksIndex` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitRemarksIndexFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitRemarksIndexFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `followUp` field. */
  followUp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `line` field. */
  line?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitRemarksIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitRemarksIndexFilter>>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
};

/** A connection to a list of `MaintenanceVisitRemarksIndex` values. */
export type MaintenanceVisitRemarksIndicesConnection = {
  __typename?: 'MaintenanceVisitRemarksIndicesConnection';
  /** A list of edges which contains the `MaintenanceVisitRemarksIndex` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitRemarksIndicesEdge>;
  /** A list of `MaintenanceVisitRemarksIndex` objects. */
  nodes: Array<MaintenanceVisitRemarksIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitRemarksIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitRemarksIndex` edge in the connection. */
export type MaintenanceVisitRemarksIndicesEdge = {
  __typename?: 'MaintenanceVisitRemarksIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitRemarksIndex` at the end of the edge. */
  node: MaintenanceVisitRemarksIndex;
};

/** Methods to use when ordering `MaintenanceVisitRemarksIndex`. */
export enum MaintenanceVisitRemarksIndicesOrderBy {
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  FollowUpAsc = 'FOLLOW_UP_ASC',
  FollowUpDesc = 'FOLLOW_UP_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LineAsc = 'LINE_ASC',
  LineDesc = 'LINE_DESC',
  MaintenanceVisitIdAsc = 'MAINTENANCE_VISIT_ID_ASC',
  MaintenanceVisitIdDesc = 'MAINTENANCE_VISIT_ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC'
}

/** Methods to use when ordering `MaintenanceVisitRemark`. */
export enum MaintenanceVisitRemarksOrderBy {
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  FollowUpAsc = 'FOLLOW_UP_ASC',
  FollowUpDesc = 'FOLLOW_UP_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LineAsc = 'LINE_ASC',
  LineDesc = 'LINE_DESC',
  MaintenanceVisitByMaintenanceVisitIdCdmagazijnAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CDMAGAZIJN_ASC',
  MaintenanceVisitByMaintenanceVisitIdCdmagazijnDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CDMAGAZIJN_DESC',
  MaintenanceVisitByMaintenanceVisitIdCheckedAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CHECKED_ASC',
  MaintenanceVisitByMaintenanceVisitIdCheckedDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CHECKED_DESC',
  MaintenanceVisitByMaintenanceVisitIdContactEmailAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_EMAIL_ASC',
  MaintenanceVisitByMaintenanceVisitIdContactEmailDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_EMAIL_DESC',
  MaintenanceVisitByMaintenanceVisitIdContactNameAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_NAME_ASC',
  MaintenanceVisitByMaintenanceVisitIdContactNameDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_NAME_DESC',
  MaintenanceVisitByMaintenanceVisitIdContactPhoneAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_PHONE_ASC',
  MaintenanceVisitByMaintenanceVisitIdContactPhoneDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CONTACT_PHONE_DESC',
  MaintenanceVisitByMaintenanceVisitIdCreatedAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CREATED_ASC',
  MaintenanceVisitByMaintenanceVisitIdCreatedDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__CREATED_DESC',
  MaintenanceVisitByMaintenanceVisitIdDateAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__DATE_ASC',
  MaintenanceVisitByMaintenanceVisitIdDateDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__DATE_DESC',
  MaintenanceVisitByMaintenanceVisitIdDurationAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__DURATION_ASC',
  MaintenanceVisitByMaintenanceVisitIdDurationDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__DURATION_DESC',
  MaintenanceVisitByMaintenanceVisitIdEndUserIdAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__END_USER_ID_ASC',
  MaintenanceVisitByMaintenanceVisitIdEndUserIdDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__END_USER_ID_DESC',
  MaintenanceVisitByMaintenanceVisitIdFactuuropdrachtAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__FACTUUROPDRACHT_ASC',
  MaintenanceVisitByMaintenanceVisitIdFactuuropdrachtDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__FACTUUROPDRACHT_DESC',
  MaintenanceVisitByMaintenanceVisitIdIdAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__ID_ASC',
  MaintenanceVisitByMaintenanceVisitIdIdDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__ID_DESC',
  MaintenanceVisitByMaintenanceVisitIdLabourHoursAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__LABOUR_HOURS_ASC',
  MaintenanceVisitByMaintenanceVisitIdLabourHoursDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__LABOUR_HOURS_DESC',
  MaintenanceVisitByMaintenanceVisitIdLockedAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__LOCKED_ASC',
  MaintenanceVisitByMaintenanceVisitIdLockedDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__LOCKED_DESC',
  MaintenanceVisitByMaintenanceVisitIdModifiedAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__MODIFIED_ASC',
  MaintenanceVisitByMaintenanceVisitIdModifiedDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__MODIFIED_DESC',
  MaintenanceVisitByMaintenanceVisitIdOwnerIdAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__OWNER_ID_ASC',
  MaintenanceVisitByMaintenanceVisitIdOwnerIdDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__OWNER_ID_DESC',
  MaintenanceVisitByMaintenanceVisitIdUserIdAsc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__USER_ID_ASC',
  MaintenanceVisitByMaintenanceVisitIdUserIdDesc = 'MAINTENANCE_VISIT_BY_MAINTENANCE_VISIT_ID__USER_ID_DESC',
  MaintenanceVisitIdAsc = 'MAINTENANCE_VISIT_ID_ASC',
  MaintenanceVisitIdDesc = 'MAINTENANCE_VISIT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC'
}

/** A filter to be used against many `MaintenanceVisitLine` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitToManyMaintenanceVisitLineFilter = {
  /** Every related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitLineFilter>;
  /** No related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitLineFilter>;
  /** Some related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitLineFilter>;
};

/** A filter to be used against many `MaintenanceVisitRemark` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitToManyMaintenanceVisitRemarkFilter = {
  /** Every related `MaintenanceVisitRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitRemarkFilter>;
  /** No related `MaintenanceVisitRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitRemarkFilter>;
  /** Some related `MaintenanceVisitRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitRemarkFilter>;
};

export type MaintenanceVisitsCalGasMaterial = {
  __typename?: 'MaintenanceVisitsCalGasMaterial';
  cdartikel?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  points?: Maybe<Scalars['BigInt']['output']>;
  quantity?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsCalGasMaterial` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsCalGasMaterialCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `points` field. */
  points?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MaintenanceVisitsCalGasMaterial` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsCalGasMaterialFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsCalGasMaterialFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsCalGasMaterialFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsCalGasMaterialFilter>>;
  /** Filter by the object’s `points` field. */
  points?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<StringFilter>;
};

/** A connection to a list of `MaintenanceVisitsCalGasMaterial` values. */
export type MaintenanceVisitsCalGasMaterialsConnection = {
  __typename?: 'MaintenanceVisitsCalGasMaterialsConnection';
  /** A list of edges which contains the `MaintenanceVisitsCalGasMaterial` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsCalGasMaterialsEdge>;
  /** A list of `MaintenanceVisitsCalGasMaterial` objects. */
  nodes: Array<MaintenanceVisitsCalGasMaterial>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsCalGasMaterial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsCalGasMaterial` edge in the connection. */
export type MaintenanceVisitsCalGasMaterialsEdge = {
  __typename?: 'MaintenanceVisitsCalGasMaterialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsCalGasMaterial` at the end of the edge. */
  node: MaintenanceVisitsCalGasMaterial;
};

/** Methods to use when ordering `MaintenanceVisitsCalGasMaterial`. */
export enum MaintenanceVisitsCalGasMaterialsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PointsAsc = 'POINTS_ASC',
  PointsDesc = 'POINTS_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC'
}

/** A connection to a list of `MaintenanceVisit` values. */
export type MaintenanceVisitsConnection = {
  __typename?: 'MaintenanceVisitsConnection';
  /** A list of edges which contains the `MaintenanceVisit` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsEdge>;
  /** A list of `MaintenanceVisit` objects. */
  nodes: Array<MaintenanceVisit>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisit` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisit` edge in the connection. */
export type MaintenanceVisitsEdge = {
  __typename?: 'MaintenanceVisitsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisit` at the end of the edge. */
  node: MaintenanceVisit;
};

export type MaintenanceVisitsEdit = {
  __typename?: 'MaintenanceVisitsEdit';
  applicationName?: Maybe<Scalars['String']['output']>;
  areaName?: Maybe<Scalars['String']['output']>;
  buildingId?: Maybe<Scalars['Int']['output']>;
  buildingName?: Maybe<Scalars['String']['output']>;
  detectorModel?: Maybe<Scalars['String']['output']>;
  detectorPosition?: Maybe<Scalars['Int']['output']>;
  detectorSensorLocationId?: Maybe<Scalars['Int']['output']>;
  detectorSerialNumber?: Maybe<Scalars['String']['output']>;
  filterInstallDueClass?: Maybe<Scalars['String']['output']>;
  filterInstallDueDate?: Maybe<Scalars['Date']['output']>;
  filterInstallDueDateLabel?: Maybe<Scalars['String']['output']>;
  floorName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  lastSensorMaintenanceDate?: Maybe<Scalars['String']['output']>;
  maintenanceVisitLineId?: Maybe<Scalars['Int']['output']>;
  pyrolyserInstallDueClass?: Maybe<Scalars['String']['output']>;
  pyrolyserInstallDueDate?: Maybe<Scalars['Date']['output']>;
  pyrolyserInstallDueDateLabel?: Maybe<Scalars['String']['output']>;
  range?: Maybe<Scalars['String']['output']>;
  samplePointName?: Maybe<Scalars['String']['output']>;
  sensorInstallDueClass?: Maybe<Scalars['String']['output']>;
  sensorInstallDueDate?: Maybe<Scalars['Date']['output']>;
  sensorInstallDueDateLabel?: Maybe<Scalars['String']['output']>;
  sensorMaintenanceDueClass?: Maybe<Scalars['String']['output']>;
  sensorMaintenanceDueDate?: Maybe<Scalars['Date']['output']>;
  sensorMaintenanceDueDateLabel?: Maybe<Scalars['String']['output']>;
  sensorModel?: Maybe<Scalars['String']['output']>;
  sensorSerialNumber?: Maybe<Scalars['String']['output']>;
  simsChannel?: Maybe<Scalars['Int']['output']>;
  simsTag?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsEdit` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsEditCondition = {
  /** Checks for equality with the object’s `applicationName` field. */
  applicationName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `areaName` field. */
  areaName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `buildingId` field. */
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `buildingName` field. */
  buildingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorModel` field. */
  detectorModel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSerialNumber` field. */
  detectorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterInstallDueClass` field. */
  filterInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterInstallDueDate` field. */
  filterInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `filterInstallDueDateLabel` field. */
  filterInstallDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `floorName` field. */
  floorName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lastSensorMaintenanceDate` field. */
  lastSensorMaintenanceDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maintenanceVisitLineId` field. */
  maintenanceVisitLineId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueClass` field. */
  pyrolyserInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueDate` field. */
  pyrolyserInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueDateLabel` field. */
  pyrolyserInstallDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `range` field. */
  range?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samplePointName` field. */
  samplePointName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueClass` field. */
  sensorInstallDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueDate` field. */
  sensorInstallDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueDateLabel` field. */
  sensorInstallDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueClass` field. */
  sensorMaintenanceDueClass?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueDateLabel` field. */
  sensorMaintenanceDueDateLabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorModel` field. */
  sensorModel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `simsChannel` field. */
  simsChannel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `simsTag` field. */
  simsTag?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MaintenanceVisitsEdit` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsEditFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsEditFilter>>;
  /** Filter by the object’s `applicationName` field. */
  applicationName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `areaName` field. */
  areaName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `buildingId` field. */
  buildingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `buildingName` field. */
  buildingName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorModel` field. */
  detectorModel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorPosition` field. */
  detectorPosition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSerialNumber` field. */
  detectorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterInstallDueClass` field. */
  filterInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterInstallDueDate` field. */
  filterInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `filterInstallDueDateLabel` field. */
  filterInstallDueDateLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `floorName` field. */
  floorName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lastSensorMaintenanceDate` field. */
  lastSensorMaintenanceDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maintenanceVisitLineId` field. */
  maintenanceVisitLineId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsEditFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsEditFilter>>;
  /** Filter by the object’s `pyrolyserInstallDueClass` field. */
  pyrolyserInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pyrolyserInstallDueDate` field. */
  pyrolyserInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `pyrolyserInstallDueDateLabel` field. */
  pyrolyserInstallDueDateLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `range` field. */
  range?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samplePointName` field. */
  samplePointName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorInstallDueClass` field. */
  sensorInstallDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorInstallDueDate` field. */
  sensorInstallDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorInstallDueDateLabel` field. */
  sensorInstallDueDateLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorMaintenanceDueClass` field. */
  sensorMaintenanceDueClass?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorMaintenanceDueDate` field. */
  sensorMaintenanceDueDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `sensorMaintenanceDueDateLabel` field. */
  sensorMaintenanceDueDateLabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorModel` field. */
  sensorModel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `simsChannel` field. */
  simsChannel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `simsTag` field. */
  simsTag?: InputMaybe<StringFilter>;
};

/** A connection to a list of `MaintenanceVisitsEdit` values. */
export type MaintenanceVisitsEditsConnection = {
  __typename?: 'MaintenanceVisitsEditsConnection';
  /** A list of edges which contains the `MaintenanceVisitsEdit` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsEditsEdge>;
  /** A list of `MaintenanceVisitsEdit` objects. */
  nodes: Array<MaintenanceVisitsEdit>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsEdit` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsEdit` edge in the connection. */
export type MaintenanceVisitsEditsEdge = {
  __typename?: 'MaintenanceVisitsEditsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsEdit` at the end of the edge. */
  node: MaintenanceVisitsEdit;
};

/** Methods to use when ordering `MaintenanceVisitsEdit`. */
export enum MaintenanceVisitsEditsOrderBy {
  ApplicationNameAsc = 'APPLICATION_NAME_ASC',
  ApplicationNameDesc = 'APPLICATION_NAME_DESC',
  AreaNameAsc = 'AREA_NAME_ASC',
  AreaNameDesc = 'AREA_NAME_DESC',
  BuildingIdAsc = 'BUILDING_ID_ASC',
  BuildingIdDesc = 'BUILDING_ID_DESC',
  BuildingNameAsc = 'BUILDING_NAME_ASC',
  BuildingNameDesc = 'BUILDING_NAME_DESC',
  DetectorModelAsc = 'DETECTOR_MODEL_ASC',
  DetectorModelDesc = 'DETECTOR_MODEL_DESC',
  DetectorPositionAsc = 'DETECTOR_POSITION_ASC',
  DetectorPositionDesc = 'DETECTOR_POSITION_DESC',
  DetectorSensorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_ID_ASC',
  DetectorSensorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_ID_DESC',
  DetectorSerialNumberAsc = 'DETECTOR_SERIAL_NUMBER_ASC',
  DetectorSerialNumberDesc = 'DETECTOR_SERIAL_NUMBER_DESC',
  FilterInstallDueClassAsc = 'FILTER_INSTALL_DUE_CLASS_ASC',
  FilterInstallDueClassDesc = 'FILTER_INSTALL_DUE_CLASS_DESC',
  FilterInstallDueDateAsc = 'FILTER_INSTALL_DUE_DATE_ASC',
  FilterInstallDueDateDesc = 'FILTER_INSTALL_DUE_DATE_DESC',
  FilterInstallDueDateLabelAsc = 'FILTER_INSTALL_DUE_DATE_LABEL_ASC',
  FilterInstallDueDateLabelDesc = 'FILTER_INSTALL_DUE_DATE_LABEL_DESC',
  FloorNameAsc = 'FLOOR_NAME_ASC',
  FloorNameDesc = 'FLOOR_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastSensorMaintenanceDateAsc = 'LAST_SENSOR_MAINTENANCE_DATE_ASC',
  LastSensorMaintenanceDateDesc = 'LAST_SENSOR_MAINTENANCE_DATE_DESC',
  MaintenanceVisitLineIdAsc = 'MAINTENANCE_VISIT_LINE_ID_ASC',
  MaintenanceVisitLineIdDesc = 'MAINTENANCE_VISIT_LINE_ID_DESC',
  Natural = 'NATURAL',
  PyrolyserInstallDueClassAsc = 'PYROLYSER_INSTALL_DUE_CLASS_ASC',
  PyrolyserInstallDueClassDesc = 'PYROLYSER_INSTALL_DUE_CLASS_DESC',
  PyrolyserInstallDueDateAsc = 'PYROLYSER_INSTALL_DUE_DATE_ASC',
  PyrolyserInstallDueDateDesc = 'PYROLYSER_INSTALL_DUE_DATE_DESC',
  PyrolyserInstallDueDateLabelAsc = 'PYROLYSER_INSTALL_DUE_DATE_LABEL_ASC',
  PyrolyserInstallDueDateLabelDesc = 'PYROLYSER_INSTALL_DUE_DATE_LABEL_DESC',
  RangeAsc = 'RANGE_ASC',
  RangeDesc = 'RANGE_DESC',
  SamplePointNameAsc = 'SAMPLE_POINT_NAME_ASC',
  SamplePointNameDesc = 'SAMPLE_POINT_NAME_DESC',
  SensorInstallDueClassAsc = 'SENSOR_INSTALL_DUE_CLASS_ASC',
  SensorInstallDueClassDesc = 'SENSOR_INSTALL_DUE_CLASS_DESC',
  SensorInstallDueDateAsc = 'SENSOR_INSTALL_DUE_DATE_ASC',
  SensorInstallDueDateDesc = 'SENSOR_INSTALL_DUE_DATE_DESC',
  SensorInstallDueDateLabelAsc = 'SENSOR_INSTALL_DUE_DATE_LABEL_ASC',
  SensorInstallDueDateLabelDesc = 'SENSOR_INSTALL_DUE_DATE_LABEL_DESC',
  SensorMaintenanceDueClassAsc = 'SENSOR_MAINTENANCE_DUE_CLASS_ASC',
  SensorMaintenanceDueClassDesc = 'SENSOR_MAINTENANCE_DUE_CLASS_DESC',
  SensorMaintenanceDueDateAsc = 'SENSOR_MAINTENANCE_DUE_DATE_ASC',
  SensorMaintenanceDueDateDesc = 'SENSOR_MAINTENANCE_DUE_DATE_DESC',
  SensorMaintenanceDueDateLabelAsc = 'SENSOR_MAINTENANCE_DUE_DATE_LABEL_ASC',
  SensorMaintenanceDueDateLabelDesc = 'SENSOR_MAINTENANCE_DUE_DATE_LABEL_DESC',
  SensorModelAsc = 'SENSOR_MODEL_ASC',
  SensorModelDesc = 'SENSOR_MODEL_DESC',
  SensorSerialNumberAsc = 'SENSOR_SERIAL_NUMBER_ASC',
  SensorSerialNumberDesc = 'SENSOR_SERIAL_NUMBER_DESC',
  SimsChannelAsc = 'SIMS_CHANNEL_ASC',
  SimsChannelDesc = 'SIMS_CHANNEL_DESC',
  SimsTagAsc = 'SIMS_TAG_ASC',
  SimsTagDesc = 'SIMS_TAG_DESC'
}

export type MaintenanceVisitsElectrolyteMaterial = {
  __typename?: 'MaintenanceVisitsElectrolyteMaterial';
  cdartikel?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  points?: Maybe<Scalars['BigInt']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsElectrolyteMaterial` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsElectrolyteMaterialCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `points` field. */
  points?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Float']['input']>;
};

/** A filter to be used against `MaintenanceVisitsElectrolyteMaterial` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsElectrolyteMaterialFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsElectrolyteMaterialFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsElectrolyteMaterialFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsElectrolyteMaterialFilter>>;
  /** Filter by the object’s `points` field. */
  points?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<FloatFilter>;
};

/** A connection to a list of `MaintenanceVisitsElectrolyteMaterial` values. */
export type MaintenanceVisitsElectrolyteMaterialsConnection = {
  __typename?: 'MaintenanceVisitsElectrolyteMaterialsConnection';
  /** A list of edges which contains the `MaintenanceVisitsElectrolyteMaterial` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsElectrolyteMaterialsEdge>;
  /** A list of `MaintenanceVisitsElectrolyteMaterial` objects. */
  nodes: Array<MaintenanceVisitsElectrolyteMaterial>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsElectrolyteMaterial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsElectrolyteMaterial` edge in the connection. */
export type MaintenanceVisitsElectrolyteMaterialsEdge = {
  __typename?: 'MaintenanceVisitsElectrolyteMaterialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsElectrolyteMaterial` at the end of the edge. */
  node: MaintenanceVisitsElectrolyteMaterial;
};

/** Methods to use when ordering `MaintenanceVisitsElectrolyteMaterial`. */
export enum MaintenanceVisitsElectrolyteMaterialsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PointsAsc = 'POINTS_ASC',
  PointsDesc = 'POINTS_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC'
}

export type MaintenanceVisitsFilterMaterial = {
  __typename?: 'MaintenanceVisitsFilterMaterial';
  cdartikel?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  points?: Maybe<Scalars['BigInt']['output']>;
  quantity?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsFilterMaterial` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsFilterMaterialCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `points` field. */
  points?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `MaintenanceVisitsFilterMaterial` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsFilterMaterialFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsFilterMaterialFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsFilterMaterialFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsFilterMaterialFilter>>;
  /** Filter by the object’s `points` field. */
  points?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<BigIntFilter>;
};

/** A connection to a list of `MaintenanceVisitsFilterMaterial` values. */
export type MaintenanceVisitsFilterMaterialsConnection = {
  __typename?: 'MaintenanceVisitsFilterMaterialsConnection';
  /** A list of edges which contains the `MaintenanceVisitsFilterMaterial` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsFilterMaterialsEdge>;
  /** A list of `MaintenanceVisitsFilterMaterial` objects. */
  nodes: Array<MaintenanceVisitsFilterMaterial>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsFilterMaterial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsFilterMaterial` edge in the connection. */
export type MaintenanceVisitsFilterMaterialsEdge = {
  __typename?: 'MaintenanceVisitsFilterMaterialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsFilterMaterial` at the end of the edge. */
  node: MaintenanceVisitsFilterMaterial;
};

/** Methods to use when ordering `MaintenanceVisitsFilterMaterial`. */
export enum MaintenanceVisitsFilterMaterialsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PointsAsc = 'POINTS_ASC',
  PointsDesc = 'POINTS_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC'
}

export type MaintenanceVisitsIndex = {
  __typename?: 'MaintenanceVisitsIndex';
  address?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cddossier?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  checked?: Maybe<Scalars['Boolean']['output']>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  contactName?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['Date']['output']>;
  debiteurNaam?: Maybe<Scalars['String']['output']>;
  duration?: Maybe<Scalars['Int']['output']>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  endUserName?: Maybe<Scalars['String']['output']>;
  factuurnummer?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  filterInstallCount?: Maybe<Scalars['BigInt']['output']>;
  filterInstallDueCount?: Maybe<Scalars['BigInt']['output']>;
  fullname?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  labourHours?: Maybe<Scalars['BigFloat']['output']>;
  lineCount?: Maybe<Scalars['BigInt']['output']>;
  linesPerDay?: Maybe<Scalars['BigInt']['output']>;
  location?: Maybe<Scalars['String']['output']>;
  locked?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pyrolyserInstallCount?: Maybe<Scalars['BigInt']['output']>;
  pyrolyserInstallDueCount?: Maybe<Scalars['BigInt']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  remarkCount?: Maybe<Scalars['BigInt']['output']>;
  sensorInstallCount?: Maybe<Scalars['BigInt']['output']>;
  sensorInstallDueCount?: Maybe<Scalars['BigInt']['output']>;
  sensorMaintenanceCount?: Maybe<Scalars['BigInt']['output']>;
  sensorMaintenanceDueCount?: Maybe<Scalars['BigInt']['output']>;
  userFullname?: Maybe<Scalars['String']['output']>;
  userInitials?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsIndex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsIndexCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddossier` field. */
  cddossier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `checked` field. */
  checked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactName` field. */
  contactName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `debiteurNaam` field. */
  debiteurNaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserName` field. */
  endUserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterInstallCount` field. */
  filterInstallCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `filterInstallDueCount` field. */
  filterInstallDueCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `fullname` field. */
  fullname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `labourHours` field. */
  labourHours?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `lineCount` field. */
  lineCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `linesPerDay` field. */
  linesPerDay?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `location` field. */
  location?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `locked` field. */
  locked?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallCount` field. */
  pyrolyserInstallCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `pyrolyserInstallDueCount` field. */
  pyrolyserInstallDueCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `remarkCount` field. */
  remarkCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sensorInstallCount` field. */
  sensorInstallCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sensorInstallDueCount` field. */
  sensorInstallDueCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceCount` field. */
  sensorMaintenanceCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `sensorMaintenanceDueCount` field. */
  sensorMaintenanceDueCount?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `userFullname` field. */
  userFullname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userInitials` field. */
  userInitials?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MaintenanceVisitsIndex` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsIndexFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsIndexFilter>>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddossier` field. */
  cddossier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `checked` field. */
  checked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactName` field. */
  contactName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Filter by the object’s `debiteurNaam` field. */
  debiteurNaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserName` field. */
  endUserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurnummer` field. */
  factuurnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterInstallCount` field. */
  filterInstallCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `filterInstallDueCount` field. */
  filterInstallDueCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `fullname` field. */
  fullname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `labourHours` field. */
  labourHours?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `lineCount` field. */
  lineCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `linesPerDay` field. */
  linesPerDay?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `location` field. */
  location?: InputMaybe<StringFilter>;
  /** Filter by the object’s `locked` field. */
  locked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsIndexFilter>>;
  /** Filter by the object’s `pyrolyserInstallCount` field. */
  pyrolyserInstallCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `pyrolyserInstallDueCount` field. */
  pyrolyserInstallDueCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `remarkCount` field. */
  remarkCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `sensorInstallCount` field. */
  sensorInstallCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `sensorInstallDueCount` field. */
  sensorInstallDueCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `sensorMaintenanceCount` field. */
  sensorMaintenanceCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `sensorMaintenanceDueCount` field. */
  sensorMaintenanceDueCount?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `userFullname` field. */
  userFullname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userInitials` field. */
  userInitials?: InputMaybe<StringFilter>;
};

/** A connection to a list of `MaintenanceVisitsIndex` values. */
export type MaintenanceVisitsIndicesConnection = {
  __typename?: 'MaintenanceVisitsIndicesConnection';
  /** A list of edges which contains the `MaintenanceVisitsIndex` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsIndicesEdge>;
  /** A list of `MaintenanceVisitsIndex` objects. */
  nodes: Array<MaintenanceVisitsIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsIndex` edge in the connection. */
export type MaintenanceVisitsIndicesEdge = {
  __typename?: 'MaintenanceVisitsIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsIndex` at the end of the edge. */
  node: MaintenanceVisitsIndex;
};

/** Methods to use when ordering `MaintenanceVisitsIndex`. */
export enum MaintenanceVisitsIndicesOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CddossierAsc = 'CDDOSSIER_ASC',
  CddossierDesc = 'CDDOSSIER_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  CheckedAsc = 'CHECKED_ASC',
  CheckedDesc = 'CHECKED_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactNameAsc = 'CONTACT_NAME_ASC',
  ContactNameDesc = 'CONTACT_NAME_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DebiteurNaamAsc = 'DEBITEUR_NAAM_ASC',
  DebiteurNaamDesc = 'DEBITEUR_NAAM_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  EndUserNameAsc = 'END_USER_NAME_ASC',
  EndUserNameDesc = 'END_USER_NAME_DESC',
  FactuurnummerAsc = 'FACTUURNUMMER_ASC',
  FactuurnummerDesc = 'FACTUURNUMMER_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FilterInstallCountAsc = 'FILTER_INSTALL_COUNT_ASC',
  FilterInstallCountDesc = 'FILTER_INSTALL_COUNT_DESC',
  FilterInstallDueCountAsc = 'FILTER_INSTALL_DUE_COUNT_ASC',
  FilterInstallDueCountDesc = 'FILTER_INSTALL_DUE_COUNT_DESC',
  FullnameAsc = 'FULLNAME_ASC',
  FullnameDesc = 'FULLNAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabourHoursAsc = 'LABOUR_HOURS_ASC',
  LabourHoursDesc = 'LABOUR_HOURS_DESC',
  LinesPerDayAsc = 'LINES_PER_DAY_ASC',
  LinesPerDayDesc = 'LINES_PER_DAY_DESC',
  LineCountAsc = 'LINE_COUNT_ASC',
  LineCountDesc = 'LINE_COUNT_DESC',
  LocationAsc = 'LOCATION_ASC',
  LocationDesc = 'LOCATION_DESC',
  LockedAsc = 'LOCKED_ASC',
  LockedDesc = 'LOCKED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PyrolyserInstallCountAsc = 'PYROLYSER_INSTALL_COUNT_ASC',
  PyrolyserInstallCountDesc = 'PYROLYSER_INSTALL_COUNT_DESC',
  PyrolyserInstallDueCountAsc = 'PYROLYSER_INSTALL_DUE_COUNT_ASC',
  PyrolyserInstallDueCountDesc = 'PYROLYSER_INSTALL_DUE_COUNT_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  RemarkCountAsc = 'REMARK_COUNT_ASC',
  RemarkCountDesc = 'REMARK_COUNT_DESC',
  SensorInstallCountAsc = 'SENSOR_INSTALL_COUNT_ASC',
  SensorInstallCountDesc = 'SENSOR_INSTALL_COUNT_DESC',
  SensorInstallDueCountAsc = 'SENSOR_INSTALL_DUE_COUNT_ASC',
  SensorInstallDueCountDesc = 'SENSOR_INSTALL_DUE_COUNT_DESC',
  SensorMaintenanceCountAsc = 'SENSOR_MAINTENANCE_COUNT_ASC',
  SensorMaintenanceCountDesc = 'SENSOR_MAINTENANCE_COUNT_DESC',
  SensorMaintenanceDueCountAsc = 'SENSOR_MAINTENANCE_DUE_COUNT_ASC',
  SensorMaintenanceDueCountDesc = 'SENSOR_MAINTENANCE_DUE_COUNT_DESC',
  UserFullnameAsc = 'USER_FULLNAME_ASC',
  UserFullnameDesc = 'USER_FULLNAME_DESC',
  UserInitialsAsc = 'USER_INITIALS_ASC',
  UserInitialsDesc = 'USER_INITIALS_DESC'
}

export type MaintenanceVisitsMaterial = {
  __typename?: 'MaintenanceVisitsMaterial';
  aantalbesteld?: Maybe<Scalars['BigInt']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  maintenanceVisitId?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  points?: Maybe<Scalars['BigInt']['output']>;
  quantity?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsMaterial` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsMaterialCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `points` field. */
  points?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

export type MaintenanceVisitsMaterialError = {
  __typename?: 'MaintenanceVisitsMaterialError';
  controller?: Maybe<Scalars['String']['output']>;
  controllerId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsMaterialError` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsMaterialErrorCondition = {
  /** Checks for equality with the object’s `controller` field. */
  controller?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `controllerId` field. */
  controllerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MaintenanceVisitsMaterialError` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsMaterialErrorFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsMaterialErrorFilter>>;
  /** Filter by the object’s `controller` field. */
  controller?: InputMaybe<StringFilter>;
  /** Filter by the object’s `controllerId` field. */
  controllerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsMaterialErrorFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsMaterialErrorFilter>>;
};

/** A connection to a list of `MaintenanceVisitsMaterialError` values. */
export type MaintenanceVisitsMaterialErrorsConnection = {
  __typename?: 'MaintenanceVisitsMaterialErrorsConnection';
  /** A list of edges which contains the `MaintenanceVisitsMaterialError` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsMaterialErrorsEdge>;
  /** A list of `MaintenanceVisitsMaterialError` objects. */
  nodes: Array<MaintenanceVisitsMaterialError>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsMaterialError` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsMaterialError` edge in the connection. */
export type MaintenanceVisitsMaterialErrorsEdge = {
  __typename?: 'MaintenanceVisitsMaterialErrorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsMaterialError` at the end of the edge. */
  node: MaintenanceVisitsMaterialError;
};

/** Methods to use when ordering `MaintenanceVisitsMaterialError`. */
export enum MaintenanceVisitsMaterialErrorsOrderBy {
  ControllerAsc = 'CONTROLLER_ASC',
  ControllerDesc = 'CONTROLLER_DESC',
  ControllerIdAsc = 'CONTROLLER_ID_ASC',
  ControllerIdDesc = 'CONTROLLER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL'
}

/** A filter to be used against `MaintenanceVisitsMaterial` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsMaterialFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigIntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsMaterialFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maintenanceVisitId` field. */
  maintenanceVisitId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsMaterialFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsMaterialFilter>>;
  /** Filter by the object’s `points` field. */
  points?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `MaintenanceVisitsMaterial` values. */
export type MaintenanceVisitsMaterialsConnection = {
  __typename?: 'MaintenanceVisitsMaterialsConnection';
  /** A list of edges which contains the `MaintenanceVisitsMaterial` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsMaterialsEdge>;
  /** A list of `MaintenanceVisitsMaterial` objects. */
  nodes: Array<MaintenanceVisitsMaterial>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsMaterial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsMaterial` edge in the connection. */
export type MaintenanceVisitsMaterialsEdge = {
  __typename?: 'MaintenanceVisitsMaterialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsMaterial` at the end of the edge. */
  node: MaintenanceVisitsMaterial;
};

/** Methods to use when ordering `MaintenanceVisitsMaterial`. */
export enum MaintenanceVisitsMaterialsOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MaintenanceVisitIdAsc = 'MAINTENANCE_VISIT_ID_ASC',
  MaintenanceVisitIdDesc = 'MAINTENANCE_VISIT_ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PointsAsc = 'POINTS_ASC',
  PointsDesc = 'POINTS_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type MaintenanceVisitsMembraneMaterial = {
  __typename?: 'MaintenanceVisitsMembraneMaterial';
  cdartikel?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  points?: Maybe<Scalars['BigInt']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsMembraneMaterial` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsMembraneMaterialCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `points` field. */
  points?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Float']['input']>;
};

/** A filter to be used against `MaintenanceVisitsMembraneMaterial` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsMembraneMaterialFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsMembraneMaterialFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsMembraneMaterialFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsMembraneMaterialFilter>>;
  /** Filter by the object’s `points` field. */
  points?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<FloatFilter>;
};

/** A connection to a list of `MaintenanceVisitsMembraneMaterial` values. */
export type MaintenanceVisitsMembraneMaterialsConnection = {
  __typename?: 'MaintenanceVisitsMembraneMaterialsConnection';
  /** A list of edges which contains the `MaintenanceVisitsMembraneMaterial` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsMembraneMaterialsEdge>;
  /** A list of `MaintenanceVisitsMembraneMaterial` objects. */
  nodes: Array<MaintenanceVisitsMembraneMaterial>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsMembraneMaterial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsMembraneMaterial` edge in the connection. */
export type MaintenanceVisitsMembraneMaterialsEdge = {
  __typename?: 'MaintenanceVisitsMembraneMaterialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsMembraneMaterial` at the end of the edge. */
  node: MaintenanceVisitsMembraneMaterial;
};

/** Methods to use when ordering `MaintenanceVisitsMembraneMaterial`. */
export enum MaintenanceVisitsMembraneMaterialsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PointsAsc = 'POINTS_ASC',
  PointsDesc = 'POINTS_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC'
}

export type MaintenanceVisitsORingMaterial = {
  __typename?: 'MaintenanceVisitsORingMaterial';
  cdartikel?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  points?: Maybe<Scalars['BigInt']['output']>;
  quantity?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsORingMaterial` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsORingMaterialCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `points` field. */
  points?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `MaintenanceVisitsORingMaterial` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsORingMaterialFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsORingMaterialFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsORingMaterialFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsORingMaterialFilter>>;
  /** Filter by the object’s `points` field. */
  points?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `MaintenanceVisitsORingMaterial` values. */
export type MaintenanceVisitsORingMaterialsConnection = {
  __typename?: 'MaintenanceVisitsORingMaterialsConnection';
  /** A list of edges which contains the `MaintenanceVisitsORingMaterial` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsORingMaterialsEdge>;
  /** A list of `MaintenanceVisitsORingMaterial` objects. */
  nodes: Array<MaintenanceVisitsORingMaterial>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsORingMaterial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsORingMaterial` edge in the connection. */
export type MaintenanceVisitsORingMaterialsEdge = {
  __typename?: 'MaintenanceVisitsORingMaterialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsORingMaterial` at the end of the edge. */
  node: MaintenanceVisitsORingMaterial;
};

/** Methods to use when ordering `MaintenanceVisitsORingMaterial`. */
export enum MaintenanceVisitsORingMaterialsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PointsAsc = 'POINTS_ASC',
  PointsDesc = 'POINTS_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC'
}

/** Methods to use when ordering `MaintenanceVisit`. */
export enum MaintenanceVisitsOrderBy {
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  CheckedAsc = 'CHECKED_ASC',
  CheckedDesc = 'CHECKED_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactNameAsc = 'CONTACT_NAME_ASC',
  ContactNameDesc = 'CONTACT_NAME_DESC',
  ContactPhoneAsc = 'CONTACT_PHONE_ASC',
  ContactPhoneDesc = 'CONTACT_PHONE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  EndUserByEndUserIdAddress1Asc = 'END_USER_BY_END_USER_ID__ADDRESS1_ASC',
  EndUserByEndUserIdAddress1Desc = 'END_USER_BY_END_USER_ID__ADDRESS1_DESC',
  EndUserByEndUserIdAddress2Asc = 'END_USER_BY_END_USER_ID__ADDRESS2_ASC',
  EndUserByEndUserIdAddress2Desc = 'END_USER_BY_END_USER_ID__ADDRESS2_DESC',
  EndUserByEndUserIdCityAsc = 'END_USER_BY_END_USER_ID__CITY_ASC',
  EndUserByEndUserIdCityDesc = 'END_USER_BY_END_USER_ID__CITY_DESC',
  EndUserByEndUserIdContactEmailAsc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_ASC',
  EndUserByEndUserIdContactEmailDesc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_DESC',
  EndUserByEndUserIdContactNameAsc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_ASC',
  EndUserByEndUserIdContactNameDesc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_DESC',
  EndUserByEndUserIdContactPhoneAsc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_ASC',
  EndUserByEndUserIdContactPhoneDesc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_DESC',
  EndUserByEndUserIdCountryAsc = 'END_USER_BY_END_USER_ID__COUNTRY_ASC',
  EndUserByEndUserIdCountryDesc = 'END_USER_BY_END_USER_ID__COUNTRY_DESC',
  EndUserByEndUserIdCreatedAsc = 'END_USER_BY_END_USER_ID__CREATED_ASC',
  EndUserByEndUserIdCreatedDesc = 'END_USER_BY_END_USER_ID__CREATED_DESC',
  EndUserByEndUserIdFormerName1Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_ASC',
  EndUserByEndUserIdFormerName1Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_DESC',
  EndUserByEndUserIdFormerName2Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_ASC',
  EndUserByEndUserIdFormerName2Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_DESC',
  EndUserByEndUserIdIdAsc = 'END_USER_BY_END_USER_ID__ID_ASC',
  EndUserByEndUserIdIdDesc = 'END_USER_BY_END_USER_ID__ID_DESC',
  EndUserByEndUserIdLocationAsc = 'END_USER_BY_END_USER_ID__LOCATION_ASC',
  EndUserByEndUserIdLocationDesc = 'END_USER_BY_END_USER_ID__LOCATION_DESC',
  EndUserByEndUserIdModifiedAsc = 'END_USER_BY_END_USER_ID__MODIFIED_ASC',
  EndUserByEndUserIdModifiedDesc = 'END_USER_BY_END_USER_ID__MODIFIED_DESC',
  EndUserByEndUserIdNameAsc = 'END_USER_BY_END_USER_ID__NAME_ASC',
  EndUserByEndUserIdNameDesc = 'END_USER_BY_END_USER_ID__NAME_DESC',
  EndUserByEndUserIdOwnerIdAsc = 'END_USER_BY_END_USER_ID__OWNER_ID_ASC',
  EndUserByEndUserIdOwnerIdDesc = 'END_USER_BY_END_USER_ID__OWNER_ID_DESC',
  EndUserByEndUserIdRegionAsc = 'END_USER_BY_END_USER_ID__REGION_ASC',
  EndUserByEndUserIdRegionDesc = 'END_USER_BY_END_USER_ID__REGION_DESC',
  EndUserByEndUserIdSubLocationAsc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_ASC',
  EndUserByEndUserIdSubLocationDesc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_DESC',
  EndUserByEndUserIdZipCodeAsc = 'END_USER_BY_END_USER_ID__ZIP_CODE_ASC',
  EndUserByEndUserIdZipCodeDesc = 'END_USER_BY_END_USER_ID__ZIP_CODE_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabourHoursAsc = 'LABOUR_HOURS_ASC',
  LabourHoursDesc = 'LABOUR_HOURS_DESC',
  LockedAsc = 'LOCKED_ASC',
  LockedDesc = 'LOCKED_DESC',
  MaintenanceVisitLinesByMaintenanceVisitIdCountAsc = 'MAINTENANCE_VISIT_LINES_BY_MAINTENANCE_VISIT_ID__COUNT_ASC',
  MaintenanceVisitLinesByMaintenanceVisitIdCountDesc = 'MAINTENANCE_VISIT_LINES_BY_MAINTENANCE_VISIT_ID__COUNT_DESC',
  MaintenanceVisitRemarksByMaintenanceVisitIdCountAsc = 'MAINTENANCE_VISIT_REMARKS_BY_MAINTENANCE_VISIT_ID__COUNT_ASC',
  MaintenanceVisitRemarksByMaintenanceVisitIdCountDesc = 'MAINTENANCE_VISIT_REMARKS_BY_MAINTENANCE_VISIT_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type MaintenanceVisitsPyrolyserMaterial = {
  __typename?: 'MaintenanceVisitsPyrolyserMaterial';
  cdartikel?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  points?: Maybe<Scalars['BigInt']['output']>;
  quantity?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsPyrolyserMaterial` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsPyrolyserMaterialCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `points` field. */
  points?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `MaintenanceVisitsPyrolyserMaterial` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsPyrolyserMaterialFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsPyrolyserMaterialFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsPyrolyserMaterialFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsPyrolyserMaterialFilter>>;
  /** Filter by the object’s `points` field. */
  points?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<BigIntFilter>;
};

/** A connection to a list of `MaintenanceVisitsPyrolyserMaterial` values. */
export type MaintenanceVisitsPyrolyserMaterialsConnection = {
  __typename?: 'MaintenanceVisitsPyrolyserMaterialsConnection';
  /** A list of edges which contains the `MaintenanceVisitsPyrolyserMaterial` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsPyrolyserMaterialsEdge>;
  /** A list of `MaintenanceVisitsPyrolyserMaterial` objects. */
  nodes: Array<MaintenanceVisitsPyrolyserMaterial>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsPyrolyserMaterial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsPyrolyserMaterial` edge in the connection. */
export type MaintenanceVisitsPyrolyserMaterialsEdge = {
  __typename?: 'MaintenanceVisitsPyrolyserMaterialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsPyrolyserMaterial` at the end of the edge. */
  node: MaintenanceVisitsPyrolyserMaterial;
};

/** Methods to use when ordering `MaintenanceVisitsPyrolyserMaterial`. */
export enum MaintenanceVisitsPyrolyserMaterialsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PointsAsc = 'POINTS_ASC',
  PointsDesc = 'POINTS_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC'
}

export type MaintenanceVisitsSensorMaterial = {
  __typename?: 'MaintenanceVisitsSensorMaterial';
  cdartikel?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  points?: Maybe<Scalars['BigInt']['output']>;
  quantity?: Maybe<Scalars['BigInt']['output']>;
};

/**
 * A condition to be used against `MaintenanceVisitsSensorMaterial` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type MaintenanceVisitsSensorMaterialCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `points` field. */
  points?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['BigInt']['input']>;
};

/** A filter to be used against `MaintenanceVisitsSensorMaterial` object types. All fields are combined with a logical ‘and.’ */
export type MaintenanceVisitsSensorMaterialFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MaintenanceVisitsSensorMaterialFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MaintenanceVisitsSensorMaterialFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MaintenanceVisitsSensorMaterialFilter>>;
  /** Filter by the object’s `points` field. */
  points?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<BigIntFilter>;
};

/** A connection to a list of `MaintenanceVisitsSensorMaterial` values. */
export type MaintenanceVisitsSensorMaterialsConnection = {
  __typename?: 'MaintenanceVisitsSensorMaterialsConnection';
  /** A list of edges which contains the `MaintenanceVisitsSensorMaterial` and cursor to aid in pagination. */
  edges: Array<MaintenanceVisitsSensorMaterialsEdge>;
  /** A list of `MaintenanceVisitsSensorMaterial` objects. */
  nodes: Array<MaintenanceVisitsSensorMaterial>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MaintenanceVisitsSensorMaterial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MaintenanceVisitsSensorMaterial` edge in the connection. */
export type MaintenanceVisitsSensorMaterialsEdge = {
  __typename?: 'MaintenanceVisitsSensorMaterialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MaintenanceVisitsSensorMaterial` at the end of the edge. */
  node: MaintenanceVisitsSensorMaterial;
};

/** Methods to use when ordering `MaintenanceVisitsSensorMaterial`. */
export enum MaintenanceVisitsSensorMaterialsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PointsAsc = 'POINTS_ASC',
  PointsDesc = 'POINTS_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC'
}

export type Membrane = Node & {
  __typename?: 'Membrane';
  cdartikel: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByMembraneId: SensorTypesConnection;
  /** Reads a single `User` that is related to this `Membrane`. */
  userByOwnerId?: Maybe<User>;
};


export type MembraneSensorTypesByMembraneIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/**
 * A condition to be used against `Membrane` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MembraneCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `MembraneEntity` values. */
export type MembraneEntitiesConnection = {
  __typename?: 'MembraneEntitiesConnection';
  /** A list of edges which contains the `MembraneEntity` and cursor to aid in pagination. */
  edges: Array<MembraneEntitiesEdge>;
  /** A list of `MembraneEntity` objects. */
  nodes: Array<MembraneEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MembraneEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MembraneEntity` edge in the connection. */
export type MembraneEntitiesEdge = {
  __typename?: 'MembraneEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MembraneEntity` at the end of the edge. */
  node: MembraneEntity;
};

/** Methods to use when ordering `MembraneEntity`. */
export enum MembraneEntitiesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC'
}

export type MembraneEntity = {
  __typename?: 'MembraneEntity';
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `MembraneEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MembraneEntityCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `MembraneEntity` object types. All fields are combined with a logical ‘and.’ */
export type MembraneEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MembraneEntityFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MembraneEntityFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MembraneEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
};

/** A filter to be used against `Membrane` object types. All fields are combined with a logical ‘and.’ */
export type MembraneFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MembraneFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MembraneFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MembraneFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypesByMembraneId` relation. */
  sensorTypesByMembraneId?: InputMaybe<MembraneToManySensorTypeFilter>;
  /** Some related `sensorTypesByMembraneId` exist. */
  sensorTypesByMembraneIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Membrane` */
export type MembraneInput = {
  cdartikel: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Membrane`. Fields that are set will be updated. */
export type MembranePatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type MembraneToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `Membrane` values. */
export type MembranesConnection = {
  __typename?: 'MembranesConnection';
  /** A list of edges which contains the `Membrane` and cursor to aid in pagination. */
  edges: Array<MembranesEdge>;
  /** A list of `Membrane` objects. */
  nodes: Array<Membrane>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Membrane` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Membrane` edge in the connection. */
export type MembranesEdge = {
  __typename?: 'MembranesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Membrane` at the end of the edge. */
  node: Membrane;
};

/** Methods to use when ordering `Membrane`. */
export enum MembranesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorTypesByMembraneIdCountAsc = 'SENSOR_TYPES_BY_MEMBRANE_ID__COUNT_ASC',
  SensorTypesByMembraneIdCountDesc = 'SENSOR_TYPES_BY_MEMBRANE_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  authenticate?: Maybe<AuthenticatePayload>;
  /** Creates a single `Aco`. */
  createAco?: Maybe<CreateAcoPayload>;
  /** Creates a single `Action`. */
  createAction?: Maybe<CreateActionPayload>;
  /** Creates a single `_Adre`. */
  createAdre?: Maybe<CreateAdrePayload>;
  /** Creates a single `AnotherRefreshToken`. */
  createAnotherRefreshToken?: Maybe<CreateAnotherRefreshTokenPayload>;
  /** Creates a single `Application`. */
  createApplication?: Maybe<CreateApplicationPayload>;
  /** Creates a single `Area`. */
  createArea?: Maybe<CreateAreaPayload>;
  /** Creates a single `Aro`. */
  createAro?: Maybe<CreateAroPayload>;
  /** Creates a single `ArosAco`. */
  createArosAco?: Maybe<CreateArosAcoPayload>;
  /** Creates a single `Artikel`. */
  createArtikel?: Maybe<CreateArtikelPayload>;
  /** Creates a single `ArtikelLog`. */
  createArtikelLog?: Maybe<CreateArtikelLogPayload>;
  /** Creates a single `Artikelomschr`. */
  createArtikelomschr?: Maybe<CreateArtikelomschrPayload>;
  /** Creates a single `AspNetRole`. */
  createAspNetRole?: Maybe<CreateAspNetRolePayload>;
  /** Creates a single `AspNetRoleClaim`. */
  createAspNetRoleClaim?: Maybe<CreateAspNetRoleClaimPayload>;
  /** Creates a single `AspNetUser`. */
  createAspNetUser?: Maybe<CreateAspNetUserPayload>;
  /** Creates a single `AspNetUserClaim`. */
  createAspNetUserClaim?: Maybe<CreateAspNetUserClaimPayload>;
  /** Creates a single `AspNetUserLogin`. */
  createAspNetUserLogin?: Maybe<CreateAspNetUserLoginPayload>;
  /** Creates a single `AspNetUserRole`. */
  createAspNetUserRole?: Maybe<CreateAspNetUserRolePayload>;
  /** Creates a single `AspNetUserToken`. */
  createAspNetUserToken?: Maybe<CreateAspNetUserTokenPayload>;
  /** Creates a single `Assembly`. */
  createAssembly?: Maybe<CreateAssemblyPayload>;
  /** Creates a single `AssemblyPart`. */
  createAssemblyPart?: Maybe<CreateAssemblyPartPayload>;
  /** Creates a single `AssemblyType`. */
  createAssemblyType?: Maybe<CreateAssemblyTypePayload>;
  /** Creates a single `AssemblyTypePart`. */
  createAssemblyTypePart?: Maybe<CreateAssemblyTypePartPayload>;
  /** Creates a single `Building`. */
  createBuilding?: Maybe<CreateBuildingPayload>;
  /** Creates a single `CalGas`. */
  createCalGas?: Maybe<CreateCalGasPayload>;
  /** Creates a single `CatalogGroup`. */
  createCatalogGroup?: Maybe<CreateCatalogGroupPayload>;
  /** Creates a single `CatalogItem`. */
  createCatalogItem?: Maybe<CreateCatalogItemPayload>;
  /** Creates a single `CatalogItemFile`. */
  createCatalogItemFile?: Maybe<CreateCatalogItemFilePayload>;
  /** Creates a single `CatalogItemRelation`. */
  createCatalogItemRelation?: Maybe<CreateCatalogItemRelationPayload>;
  /** Creates a single `CatalogSubGroup`. */
  createCatalogSubGroup?: Maybe<CreateCatalogSubGroupPayload>;
  /** Creates a single `ChemicalCompound`. */
  createChemicalCompound?: Maybe<CreateChemicalCompoundPayload>;
  /** Creates a single `Detector`. */
  createDetector?: Maybe<CreateDetectorPayload>;
  /** Creates a single `DetectorLocation`. */
  createDetectorLocation?: Maybe<CreateDetectorLocationPayload>;
  /** Creates a single `DetectorOrder`. */
  createDetectorOrder?: Maybe<CreateDetectorOrderPayload>;
  /** Creates a single `DetectorSensor`. */
  createDetectorSensor?: Maybe<CreateDetectorSensorPayload>;
  /** Creates a single `DetectorSensorLocation`. */
  createDetectorSensorLocation?: Maybe<CreateDetectorSensorLocationPayload>;
  /** Creates a single `DetectorSensorType`. */
  createDetectorSensorType?: Maybe<CreateDetectorSensorTypePayload>;
  /** Creates a single `DetectorType`. */
  createDetectorType?: Maybe<CreateDetectorTypePayload>;
  /** Creates a single `DpCard`. */
  createDpCard?: Maybe<CreateDpCardPayload>;
  /** Creates a single `Electrolyte`. */
  createElectrolyte?: Maybe<CreateElectrolytePayload>;
  /** Creates a single `EndUser`. */
  createEndUser?: Maybe<CreateEndUserPayload>;
  /** Creates a single `FactopdrachtArtikelExclusion`. */
  createFactopdrachtArtikelExclusion?: Maybe<CreateFactopdrachtArtikelExclusionPayload>;
  /** Creates a single `FactopdrachtregelLine`. */
  createFactopdrachtregelLine?: Maybe<CreateFactopdrachtregelLinePayload>;
  /** Creates a single `FactopdrachtregelLineDate`. */
  createFactopdrachtregelLineDate?: Maybe<CreateFactopdrachtregelLineDatePayload>;
  /** Creates a single `FactopdrachtregelLineRemark`. */
  createFactopdrachtregelLineRemark?: Maybe<CreateFactopdrachtregelLineRemarkPayload>;
  /** Creates a single `FactopdrachtregelLineWeek`. */
  createFactopdrachtregelLineWeek?: Maybe<CreateFactopdrachtregelLineWeekPayload>;
  /** Creates a single `Factuur`. */
  createFactuur?: Maybe<CreateFactuurPayload>;
  /** Creates a single `Filter`. */
  createFilter?: Maybe<CreateFilterPayload>;
  /** Creates a single `Floor`. */
  createFloor?: Maybe<CreateFloorPayload>;
  /** Creates a single `Gas`. */
  createGas?: Maybe<CreateGasPayload>;
  createGroup?: Maybe<CreateGroupPayload>;
  /** Creates a single `GroupPermission`. */
  createGroupPermission?: Maybe<CreateGroupPermissionPayload>;
  /** Creates a single `GroupRight`. */
  createGroupRight?: Maybe<CreateGroupRightPayload>;
  /** Creates a single `Hardware`. */
  createHardware?: Maybe<CreateHardwarePayload>;
  /** Creates a single `IncomingDocument`. */
  createIncomingDocument?: Maybe<CreateIncomingDocumentPayload>;
  /** Creates a single `Inkoopgegeven`. */
  createInkoopgegeven?: Maybe<CreateInkoopgegevenPayload>;
  /** Creates a single `InkoopgegevensLog`. */
  createInkoopgegevensLog?: Maybe<CreateInkoopgegevensLogPayload>;
  /** Creates a single `InkooporderregelLine`. */
  createInkooporderregelLine?: Maybe<CreateInkooporderregelLinePayload>;
  /** Creates a single `Item`. */
  createItem?: Maybe<CreateItemPayload>;
  /** Creates a single `Job`. */
  createJob?: Maybe<CreateJobPayload>;
  /** Creates a single `JunctionBox`. */
  createJunctionBox?: Maybe<CreateJunctionBoxPayload>;
  /** Creates a single `_Land`. */
  createLand?: Maybe<CreateLandPayload>;
  /** Creates a single `Lead`. */
  createLead?: Maybe<CreateLeadPayload>;
  /** Creates a single `License`. */
  createLicense?: Maybe<CreateLicensePayload>;
  /** Creates a single `LicenseCustomer`. */
  createLicenseCustomer?: Maybe<CreateLicenseCustomerPayload>;
  /** Creates a single `LicenseModule`. */
  createLicenseModule?: Maybe<CreateLicenseModulePayload>;
  /** Creates a single `LicenseOrder`. */
  createLicenseOrder?: Maybe<CreateLicenseOrderPayload>;
  /** Creates a single `LicenseRegistration`. */
  createLicenseRegistration?: Maybe<CreateLicenseRegistrationPayload>;
  /** Creates a single `MaintenanceVisit`. */
  createMaintenanceVisit?: Maybe<CreateMaintenanceVisitPayload>;
  /** Creates a single `MaintenanceVisitLine`. */
  createMaintenanceVisitLine?: Maybe<CreateMaintenanceVisitLinePayload>;
  /** Creates a single `MaintenanceVisitRemark`. */
  createMaintenanceVisitRemark?: Maybe<CreateMaintenanceVisitRemarkPayload>;
  /** Creates a single `Membrane`. */
  createMembrane?: Maybe<CreateMembranePayload>;
  /** Creates a single `ORing`. */
  createORing?: Maybe<CreateORingPayload>;
  /** Creates a single `OfferteRemark`. */
  createOfferteRemark?: Maybe<CreateOfferteRemarkPayload>;
  /** Creates a single `Opportunity`. */
  createOpportunity?: Maybe<CreateOpportunityPayload>;
  /** Creates a single `Permission`. */
  createPermission?: Maybe<CreatePermissionPayload>;
  /** Creates a single `PersoonRol`. */
  createPersoonRol?: Maybe<CreatePersoonRolPayload>;
  /** Creates a single `Plug`. */
  createPlug?: Maybe<CreatePlugPayload>;
  /** Creates a single `Principle`. */
  createPrinciple?: Maybe<CreatePrinciplePayload>;
  /** Creates a single `Production`. */
  createProduction?: Maybe<CreateProductionPayload>;
  /** Creates a single `Pyrolyser`. */
  createPyrolyser?: Maybe<CreatePyrolyserPayload>;
  /** Creates a single `Range`. */
  createRange?: Maybe<CreateRangePayload>;
  /** Creates a single `RcCard`. */
  createRcCard?: Maybe<CreateRcCardPayload>;
  /** Creates a single `RefreshToken`. */
  createRefreshToken?: Maybe<CreateRefreshTokenPayload>;
  /** Creates a single `Report`. */
  createReport?: Maybe<CreateReportPayload>;
  /** Creates a single `ReportDetector`. */
  createReportDetector?: Maybe<CreateReportDetectorPayload>;
  /** Creates a single `ReportItem`. */
  createReportItem?: Maybe<CreateReportItemPayload>;
  /** Creates a single `ReportSensor`. */
  createReportSensor?: Maybe<CreateReportSensorPayload>;
  /** Creates a single `Request`. */
  createRequest?: Maybe<CreateRequestPayload>;
  /** Creates a single `RxCard`. */
  createRxCard?: Maybe<CreateRxCardPayload>;
  /** Creates a single `SamplePoint`. */
  createSamplePoint?: Maybe<CreateSamplePointPayload>;
  /** Creates a single `SensorBaseType`. */
  createSensorBaseType?: Maybe<CreateSensorBaseTypePayload>;
  /** Creates a single `SensorElement`. */
  createSensorElement?: Maybe<CreateSensorElementPayload>;
  /** Creates a single `SensorElementLocation`. */
  createSensorElementLocation?: Maybe<CreateSensorElementLocationPayload>;
  /** Creates a single `SensorElementLog`. */
  createSensorElementLog?: Maybe<CreateSensorElementLogPayload>;
  /** Creates a single `SensorElementType`. */
  createSensorElementType?: Maybe<CreateSensorElementTypePayload>;
  /** Creates a single `SensorOrder`. */
  createSensorOrder?: Maybe<CreateSensorOrderPayload>;
  /** Creates a single `SensorSensorElement`. */
  createSensorSensorElement?: Maybe<CreateSensorSensorElementPayload>;
  /** Creates a single `SensorSetting`. */
  createSensorSetting?: Maybe<CreateSensorSettingPayload>;
  /** Creates a single `SensorTestResult`. */
  createSensorTestResult?: Maybe<CreateSensorTestResultPayload>;
  /** Creates a single `SensorType`. */
  createSensorType?: Maybe<CreateSensorTypePayload>;
  createSensors?: Maybe<CreateSensorsPayload>;
  /** Creates a single `Software`. */
  createSoftware?: Maybe<CreateSoftwarePayload>;
  /** Creates a single `StockGroup`. */
  createStockGroup?: Maybe<CreateStockGroupPayload>;
  /** Creates a single `StockItem`. */
  createStockItem?: Maybe<CreateStockItemPayload>;
  /** Creates a single `StockSupplier`. */
  createStockSupplier?: Maybe<CreateStockSupplierPayload>;
  /** Creates a single `Task`. */
  createTask?: Maybe<CreateTaskPayload>;
  /** Creates a single `TempFactopdrachtregel`. */
  createTempFactopdrachtregel?: Maybe<CreateTempFactopdrachtregelPayload>;
  /** Creates a single `TempLicense`. */
  createTempLicense?: Maybe<CreateTempLicensePayload>;
  /** Creates a single `TempRegistration`. */
  createTempRegistration?: Maybe<CreateTempRegistrationPayload>;
  /** Creates a single `TempRegistrationHistory`. */
  createTempRegistrationHistory?: Maybe<CreateTempRegistrationHistoryPayload>;
  /** Creates a single `TempRegistrations2`. */
  createTempRegistrations2?: Maybe<CreateTempRegistrations2Payload>;
  /** Creates a single `Test`. */
  createTest?: Maybe<CreateTestPayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserRight`. */
  createUserRight?: Maybe<CreateUserRightPayload>;
  /** Creates a single `UserTask`. */
  createUserTask?: Maybe<CreateUserTaskPayload>;
  /** Creates a single `Voorraden`. */
  createVoorraden?: Maybe<CreateVoorradenPayload>;
  /** Creates a single `VoorradenLog`. */
  createVoorradenLog?: Maybe<CreateVoorradenLogPayload>;
  /** Creates a single `WeeklyHour`. */
  createWeeklyHour?: Maybe<CreateWeeklyHourPayload>;
  /** Creates a single `WeeklyHourRemark`. */
  createWeeklyHourRemark?: Maybe<CreateWeeklyHourRemarkPayload>;
  /** Deletes a single `Aco` using its globally unique id. */
  deleteAco?: Maybe<DeleteAcoPayload>;
  /** Deletes a single `Aco` using a unique key. */
  deleteAcoById?: Maybe<DeleteAcoPayload>;
  /** Deletes a single `Action` using its globally unique id. */
  deleteAction?: Maybe<DeleteActionPayload>;
  /** Deletes a single `Action` using a unique key. */
  deleteActionById?: Maybe<DeleteActionPayload>;
  /** Deletes a single `_Adre` using its globally unique id. */
  deleteAdre?: Maybe<DeleteAdrePayload>;
  /** Deletes a single `_Adre` using a unique key. */
  deleteAdreByAdresGuid?: Maybe<DeleteAdrePayload>;
  /** Deletes a single `Application` using its globally unique id. */
  deleteApplication?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplicationById?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplicationByName?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Area` using its globally unique id. */
  deleteArea?: Maybe<DeleteAreaPayload>;
  /** Deletes a single `Area` using a unique key. */
  deleteAreaByFloorIdAndName?: Maybe<DeleteAreaPayload>;
  /** Deletes a single `Area` using a unique key. */
  deleteAreaById?: Maybe<DeleteAreaPayload>;
  /** Deletes a single `Aro` using its globally unique id. */
  deleteAro?: Maybe<DeleteAroPayload>;
  /** Deletes a single `Aro` using a unique key. */
  deleteAroById?: Maybe<DeleteAroPayload>;
  /** Deletes a single `ArosAco` using its globally unique id. */
  deleteArosAco?: Maybe<DeleteArosAcoPayload>;
  /** Deletes a single `ArosAco` using a unique key. */
  deleteArosAcoById?: Maybe<DeleteArosAcoPayload>;
  /** Deletes a single `Artikel` using its globally unique id. */
  deleteArtikel?: Maybe<DeleteArtikelPayload>;
  /** Deletes a single `Artikel` using a unique key. */
  deleteArtikelByCdartikel?: Maybe<DeleteArtikelPayload>;
  /** Deletes a single `ArtikelLog` using its globally unique id. */
  deleteArtikelLog?: Maybe<DeleteArtikelLogPayload>;
  /** Deletes a single `ArtikelLog` using a unique key. */
  deleteArtikelLogById?: Maybe<DeleteArtikelLogPayload>;
  /** Deletes a single `Artikelomschr` using its globally unique id. */
  deleteArtikelomschr?: Maybe<DeleteArtikelomschrPayload>;
  /** Deletes a single `Artikelomschr` using a unique key. */
  deleteArtikelomschrByCdartikelAndCdtaal?: Maybe<DeleteArtikelomschrPayload>;
  /** Deletes a single `AspNetRole` using its globally unique id. */
  deleteAspNetRole?: Maybe<DeleteAspNetRolePayload>;
  /** Deletes a single `AspNetRole` using a unique key. */
  deleteAspNetRoleById?: Maybe<DeleteAspNetRolePayload>;
  /** Deletes a single `AspNetRoleClaim` using its globally unique id. */
  deleteAspNetRoleClaim?: Maybe<DeleteAspNetRoleClaimPayload>;
  /** Deletes a single `AspNetRoleClaim` using a unique key. */
  deleteAspNetRoleClaimById?: Maybe<DeleteAspNetRoleClaimPayload>;
  /** Deletes a single `AspNetUser` using its globally unique id. */
  deleteAspNetUser?: Maybe<DeleteAspNetUserPayload>;
  /** Deletes a single `AspNetUser` using a unique key. */
  deleteAspNetUserById?: Maybe<DeleteAspNetUserPayload>;
  /** Deletes a single `AspNetUserClaim` using its globally unique id. */
  deleteAspNetUserClaim?: Maybe<DeleteAspNetUserClaimPayload>;
  /** Deletes a single `AspNetUserClaim` using a unique key. */
  deleteAspNetUserClaimById?: Maybe<DeleteAspNetUserClaimPayload>;
  /** Deletes a single `AspNetUserLogin` using its globally unique id. */
  deleteAspNetUserLogin?: Maybe<DeleteAspNetUserLoginPayload>;
  /** Deletes a single `AspNetUserLogin` using a unique key. */
  deleteAspNetUserLoginByLoginProviderAndProviderKey?: Maybe<DeleteAspNetUserLoginPayload>;
  /** Deletes a single `AspNetUserRole` using its globally unique id. */
  deleteAspNetUserRole?: Maybe<DeleteAspNetUserRolePayload>;
  /** Deletes a single `AspNetUserRole` using a unique key. */
  deleteAspNetUserRoleByUserIdAndRoleId?: Maybe<DeleteAspNetUserRolePayload>;
  /** Deletes a single `AspNetUserToken` using its globally unique id. */
  deleteAspNetUserToken?: Maybe<DeleteAspNetUserTokenPayload>;
  /** Deletes a single `AspNetUserToken` using a unique key. */
  deleteAspNetUserTokenByUserIdAndLoginProviderAndName?: Maybe<DeleteAspNetUserTokenPayload>;
  /** Deletes a single `Assembly` using its globally unique id. */
  deleteAssembly?: Maybe<DeleteAssemblyPayload>;
  /** Deletes a single `Assembly` using a unique key. */
  deleteAssemblyByCode?: Maybe<DeleteAssemblyPayload>;
  /** Deletes a single `Assembly` using a unique key. */
  deleteAssemblyById?: Maybe<DeleteAssemblyPayload>;
  /** Deletes a single `AssemblyPart` using its globally unique id. */
  deleteAssemblyPart?: Maybe<DeleteAssemblyPartPayload>;
  /** Deletes a single `AssemblyPart` using a unique key. */
  deleteAssemblyPartByAssemblyIdAndCdartikel?: Maybe<DeleteAssemblyPartPayload>;
  /** Deletes a single `AssemblyPart` using a unique key. */
  deleteAssemblyPartById?: Maybe<DeleteAssemblyPartPayload>;
  /** Deletes a single `AssemblyType` using its globally unique id. */
  deleteAssemblyType?: Maybe<DeleteAssemblyTypePayload>;
  /** Deletes a single `AssemblyType` using a unique key. */
  deleteAssemblyTypeById?: Maybe<DeleteAssemblyTypePayload>;
  /** Deletes a single `AssemblyTypePart` using its globally unique id. */
  deleteAssemblyTypePart?: Maybe<DeleteAssemblyTypePartPayload>;
  /** Deletes a single `AssemblyTypePart` using a unique key. */
  deleteAssemblyTypePartByAssemblyTypeIdAndCdartikel?: Maybe<DeleteAssemblyTypePartPayload>;
  /** Deletes a single `AssemblyTypePart` using a unique key. */
  deleteAssemblyTypePartById?: Maybe<DeleteAssemblyTypePartPayload>;
  /** Deletes a single `Building` using its globally unique id. */
  deleteBuilding?: Maybe<DeleteBuildingPayload>;
  /** Deletes a single `Building` using a unique key. */
  deleteBuildingByEndUserIdAndName?: Maybe<DeleteBuildingPayload>;
  /** Deletes a single `Building` using a unique key. */
  deleteBuildingById?: Maybe<DeleteBuildingPayload>;
  /** Deletes a single `CalGas` using its globally unique id. */
  deleteCalGas?: Maybe<DeleteCalGasPayload>;
  /** Deletes a single `CalGas` using a unique key. */
  deleteCalGasByConcentrationAndEngineeringUnitsAndGasId?: Maybe<DeleteCalGasPayload>;
  /** Deletes a single `CalGas` using a unique key. */
  deleteCalGasById?: Maybe<DeleteCalGasPayload>;
  /** Deletes a single `CatalogGroup` using its globally unique id. */
  deleteCatalogGroup?: Maybe<DeleteCatalogGroupPayload>;
  /** Deletes a single `CatalogGroup` using a unique key. */
  deleteCatalogGroupById?: Maybe<DeleteCatalogGroupPayload>;
  /** Deletes a single `CatalogItem` using its globally unique id. */
  deleteCatalogItem?: Maybe<DeleteCatalogItemPayload>;
  /** Deletes a single `CatalogItem` using a unique key. */
  deleteCatalogItemById?: Maybe<DeleteCatalogItemPayload>;
  /** Deletes a single `CatalogItemFile` using its globally unique id. */
  deleteCatalogItemFile?: Maybe<DeleteCatalogItemFilePayload>;
  /** Deletes a single `CatalogItemFile` using a unique key. */
  deleteCatalogItemFileById?: Maybe<DeleteCatalogItemFilePayload>;
  /** Deletes a single `CatalogItemRelation` using its globally unique id. */
  deleteCatalogItemRelation?: Maybe<DeleteCatalogItemRelationPayload>;
  /** Deletes a single `CatalogItemRelation` using a unique key. */
  deleteCatalogItemRelationById?: Maybe<DeleteCatalogItemRelationPayload>;
  /** Deletes a single `CatalogSubGroup` using its globally unique id. */
  deleteCatalogSubGroup?: Maybe<DeleteCatalogSubGroupPayload>;
  /** Deletes a single `CatalogSubGroup` using a unique key. */
  deleteCatalogSubGroupById?: Maybe<DeleteCatalogSubGroupPayload>;
  /** Deletes a single `ChemicalCompound` using its globally unique id. */
  deleteChemicalCompound?: Maybe<DeleteChemicalCompoundPayload>;
  /** Deletes a single `ChemicalCompound` using a unique key. */
  deleteChemicalCompoundById?: Maybe<DeleteChemicalCompoundPayload>;
  /** Deletes a single `Detector` using its globally unique id. */
  deleteDetector?: Maybe<DeleteDetectorPayload>;
  /** Deletes a single `Detector` using a unique key. */
  deleteDetectorById?: Maybe<DeleteDetectorPayload>;
  /** Deletes a single `Detector` using a unique key. */
  deleteDetectorBySerialNumberAndDetectorTypeId?: Maybe<DeleteDetectorPayload>;
  /** Deletes a single `DetectorLocation` using its globally unique id. */
  deleteDetectorLocation?: Maybe<DeleteDetectorLocationPayload>;
  /** Deletes a single `DetectorLocation` using a unique key. */
  deleteDetectorLocationByDetectorId?: Maybe<DeleteDetectorLocationPayload>;
  /** Deletes a single `DetectorLocation` using a unique key. */
  deleteDetectorLocationById?: Maybe<DeleteDetectorLocationPayload>;
  /** Deletes a single `DetectorOrder` using its globally unique id. */
  deleteDetectorOrder?: Maybe<DeleteDetectorOrderPayload>;
  /** Deletes a single `DetectorOrder` using a unique key. */
  deleteDetectorOrderByFactuuropdrachtAndDetectorId?: Maybe<DeleteDetectorOrderPayload>;
  /** Deletes a single `DetectorOrder` using a unique key. */
  deleteDetectorOrderById?: Maybe<DeleteDetectorOrderPayload>;
  /** Deletes a single `DetectorSensor` using its globally unique id. */
  deleteDetectorSensor?: Maybe<DeleteDetectorSensorPayload>;
  /** Deletes a single `DetectorSensor` using a unique key. */
  deleteDetectorSensorByDetectorIdAndDetectorPosition?: Maybe<DeleteDetectorSensorPayload>;
  /** Deletes a single `DetectorSensor` using a unique key. */
  deleteDetectorSensorById?: Maybe<DeleteDetectorSensorPayload>;
  /** Deletes a single `DetectorSensor` using a unique key. */
  deleteDetectorSensorBySensorId?: Maybe<DeleteDetectorSensorPayload>;
  /** Deletes a single `DetectorSensorLocation` using its globally unique id. */
  deleteDetectorSensorLocation?: Maybe<DeleteDetectorSensorLocationPayload>;
  /** Deletes a single `DetectorSensorLocation` using a unique key. */
  deleteDetectorSensorLocationByDetectorSensorId?: Maybe<DeleteDetectorSensorLocationPayload>;
  /** Deletes a single `DetectorSensorLocation` using a unique key. */
  deleteDetectorSensorLocationById?: Maybe<DeleteDetectorSensorLocationPayload>;
  /** Deletes a single `DetectorSensorLocation` using a unique key. */
  deleteDetectorSensorLocationByLicenseIdAndSimsChannel?: Maybe<DeleteDetectorSensorLocationPayload>;
  /** Deletes a single `DetectorSensorType` using its globally unique id. */
  deleteDetectorSensorType?: Maybe<DeleteDetectorSensorTypePayload>;
  /** Deletes a single `DetectorSensorType` using a unique key. */
  deleteDetectorSensorTypeByDetectorIdAndDetectorPosition?: Maybe<DeleteDetectorSensorTypePayload>;
  /** Deletes a single `DetectorSensorType` using a unique key. */
  deleteDetectorSensorTypeById?: Maybe<DeleteDetectorSensorTypePayload>;
  /** Deletes a single `DetectorType` using its globally unique id. */
  deleteDetectorType?: Maybe<DeleteDetectorTypePayload>;
  /** Deletes a single `DetectorType` using a unique key. */
  deleteDetectorTypeById?: Maybe<DeleteDetectorTypePayload>;
  /** Deletes a single `DetectorType` using a unique key. */
  deleteDetectorTypeByPrefixAndCodeAndSuffix?: Maybe<DeleteDetectorTypePayload>;
  /** Deletes a single `DpCard` using its globally unique id. */
  deleteDpCard?: Maybe<DeleteDpCardPayload>;
  /** Deletes a single `DpCard` using a unique key. */
  deleteDpCardById?: Maybe<DeleteDpCardPayload>;
  /** Deletes a single `Electrolyte` using its globally unique id. */
  deleteElectrolyte?: Maybe<DeleteElectrolytePayload>;
  /** Deletes a single `Electrolyte` using a unique key. */
  deleteElectrolyteById?: Maybe<DeleteElectrolytePayload>;
  /** Deletes a single `Electrolyte` using a unique key. */
  deleteElectrolyteByName?: Maybe<DeleteElectrolytePayload>;
  /** Deletes a single `EndUser` using its globally unique id. */
  deleteEndUser?: Maybe<DeleteEndUserPayload>;
  /** Deletes a single `EndUser` using a unique key. */
  deleteEndUserById?: Maybe<DeleteEndUserPayload>;
  /** Deletes a single `EndUser` using a unique key. */
  deleteEndUserByNameAndLocationAndSubLocation?: Maybe<DeleteEndUserPayload>;
  /** Deletes a single `FactopdrachtArtikelExclusion` using its globally unique id. */
  deleteFactopdrachtArtikelExclusion?: Maybe<DeleteFactopdrachtArtikelExclusionPayload>;
  /** Deletes a single `FactopdrachtArtikelExclusion` using a unique key. */
  deleteFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikel?: Maybe<DeleteFactopdrachtArtikelExclusionPayload>;
  /** Deletes a single `FactopdrachtArtikelExclusion` using a unique key. */
  deleteFactopdrachtArtikelExclusionById?: Maybe<DeleteFactopdrachtArtikelExclusionPayload>;
  /** Deletes a single `FactopdrachtregelLine` using its globally unique id. */
  deleteFactopdrachtregelLine?: Maybe<DeleteFactopdrachtregelLinePayload>;
  /** Deletes a single `FactopdrachtregelLine` using a unique key. */
  deleteFactopdrachtregelLineByFactopdrRglGuid?: Maybe<DeleteFactopdrachtregelLinePayload>;
  /** Deletes a single `FactopdrachtregelLine` using a unique key. */
  deleteFactopdrachtregelLineById?: Maybe<DeleteFactopdrachtregelLinePayload>;
  /** Deletes a single `FactopdrachtregelLineDate` using its globally unique id. */
  deleteFactopdrachtregelLineDate?: Maybe<DeleteFactopdrachtregelLineDatePayload>;
  /** Deletes a single `FactopdrachtregelLineDate` using a unique key. */
  deleteFactopdrachtregelLineDateById?: Maybe<DeleteFactopdrachtregelLineDatePayload>;
  /** Deletes a single `FactopdrachtregelLineRemark` using its globally unique id. */
  deleteFactopdrachtregelLineRemark?: Maybe<DeleteFactopdrachtregelLineRemarkPayload>;
  /** Deletes a single `FactopdrachtregelLineRemark` using a unique key. */
  deleteFactopdrachtregelLineRemarkById?: Maybe<DeleteFactopdrachtregelLineRemarkPayload>;
  /** Deletes a single `Factuur` using its globally unique id. */
  deleteFactuur?: Maybe<DeleteFactuurPayload>;
  /** Deletes a single `Factuur` using a unique key. */
  deleteFactuurByFactuuropdracht?: Maybe<DeleteFactuurPayload>;
  /** Deletes a single `Factuur` using a unique key. */
  deleteFactuurById?: Maybe<DeleteFactuurPayload>;
  /** Deletes a single `Filter` using its globally unique id. */
  deleteFilter?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `Filter` using a unique key. */
  deleteFilterById?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `Filter` using a unique key. */
  deleteFilterByName?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `Floor` using its globally unique id. */
  deleteFloor?: Maybe<DeleteFloorPayload>;
  /** Deletes a single `Floor` using a unique key. */
  deleteFloorByBuildingIdAndName?: Maybe<DeleteFloorPayload>;
  /** Deletes a single `Floor` using a unique key. */
  deleteFloorById?: Maybe<DeleteFloorPayload>;
  /** Deletes a single `Gas` using its globally unique id. */
  deleteGas?: Maybe<DeleteGasPayload>;
  /** Deletes a single `Gas` using a unique key. */
  deleteGasById?: Maybe<DeleteGasPayload>;
  /** Deletes a single `Gas` using a unique key. */
  deleteGasByName?: Maybe<DeleteGasPayload>;
  /** Deletes a single `Group` using its globally unique id. */
  deleteGroup?: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroupById?: Maybe<DeleteGroupPayload>;
  /** Deletes a single `GroupPermission` using its globally unique id. */
  deleteGroupPermission?: Maybe<DeleteGroupPermissionPayload>;
  /** Deletes a single `GroupPermission` using a unique key. */
  deleteGroupPermissionByGroupId?: Maybe<DeleteGroupPermissionPayload>;
  /** Deletes a single `GroupPermission` using a unique key. */
  deleteGroupPermissionById?: Maybe<DeleteGroupPermissionPayload>;
  /** Deletes a single `GroupRight` using its globally unique id. */
  deleteGroupRight?: Maybe<DeleteGroupRightPayload>;
  /** Deletes a single `GroupRight` using a unique key. */
  deleteGroupRightByGroupIdAndPath?: Maybe<DeleteGroupRightPayload>;
  /** Deletes a single `GroupRight` using a unique key. */
  deleteGroupRightById?: Maybe<DeleteGroupRightPayload>;
  /** Deletes a single `Hardware` using its globally unique id. */
  deleteHardware?: Maybe<DeleteHardwarePayload>;
  /** Deletes a single `Hardware` using a unique key. */
  deleteHardwareById?: Maybe<DeleteHardwarePayload>;
  /** Deletes a single `IncomingDocument` using its globally unique id. */
  deleteIncomingDocument?: Maybe<DeleteIncomingDocumentPayload>;
  /** Deletes a single `IncomingDocument` using a unique key. */
  deleteIncomingDocumentById?: Maybe<DeleteIncomingDocumentPayload>;
  /** Deletes a single `Inkoopgegeven` using its globally unique id. */
  deleteInkoopgegeven?: Maybe<DeleteInkoopgegevenPayload>;
  /** Deletes a single `Inkoopgegeven` using a unique key. */
  deleteInkoopgegevenByCdartikelAndInkvolgnr?: Maybe<DeleteInkoopgegevenPayload>;
  /** Deletes a single `InkoopgegevensLog` using its globally unique id. */
  deleteInkoopgegevensLog?: Maybe<DeleteInkoopgegevensLogPayload>;
  /** Deletes a single `InkoopgegevensLog` using a unique key. */
  deleteInkoopgegevensLogById?: Maybe<DeleteInkoopgegevensLogPayload>;
  /** Deletes a single `InkooporderregelLine` using its globally unique id. */
  deleteInkooporderregelLine?: Maybe<DeleteInkooporderregelLinePayload>;
  /** Deletes a single `InkooporderregelLine` using a unique key. */
  deleteInkooporderregelLineById?: Maybe<DeleteInkooporderregelLinePayload>;
  /** Deletes a single `InkooporderregelLine` using a unique key. */
  deleteInkooporderregelLineByInkopdrRglGuid?: Maybe<DeleteInkooporderregelLinePayload>;
  /** Deletes a single `Item` using its globally unique id. */
  deleteItem?: Maybe<DeleteItemPayload>;
  /** Deletes a single `Item` using a unique key. */
  deleteItemByCdartikelAndSerialNumber?: Maybe<DeleteItemPayload>;
  /** Deletes a single `Item` using a unique key. */
  deleteItemById?: Maybe<DeleteItemPayload>;
  /** Deletes a single `Job` using its globally unique id. */
  deleteJob?: Maybe<DeleteJobPayload>;
  /** Deletes a single `Job` using a unique key. */
  deleteJobById?: Maybe<DeleteJobPayload>;
  /** Deletes a single `JunctionBox` using its globally unique id. */
  deleteJunctionBox?: Maybe<DeleteJunctionBoxPayload>;
  /** Deletes a single `JunctionBox` using a unique key. */
  deleteJunctionBoxById?: Maybe<DeleteJunctionBoxPayload>;
  /** Deletes a single `_Land` using its globally unique id. */
  deleteLand?: Maybe<DeleteLandPayload>;
  /** Deletes a single `_Land` using a unique key. */
  deleteLandByCdland?: Maybe<DeleteLandPayload>;
  /** Deletes a single `Lead` using its globally unique id. */
  deleteLead?: Maybe<DeleteLeadPayload>;
  /** Deletes a single `Lead` using a unique key. */
  deleteLeadById?: Maybe<DeleteLeadPayload>;
  /** Deletes a single `License` using its globally unique id. */
  deleteLicense?: Maybe<DeleteLicensePayload>;
  /** Deletes a single `License` using a unique key. */
  deleteLicenseById?: Maybe<DeleteLicensePayload>;
  /** Deletes a single `LicenseCustomer` using its globally unique id. */
  deleteLicenseCustomer?: Maybe<DeleteLicenseCustomerPayload>;
  /** Deletes a single `LicenseCustomer` using a unique key. */
  deleteLicenseCustomerById?: Maybe<DeleteLicenseCustomerPayload>;
  /** Deletes a single `LicenseModule` using its globally unique id. */
  deleteLicenseModule?: Maybe<DeleteLicenseModulePayload>;
  /** Deletes a single `LicenseModule` using a unique key. */
  deleteLicenseModuleById?: Maybe<DeleteLicenseModulePayload>;
  /** Deletes a single `LicenseOrder` using its globally unique id. */
  deleteLicenseOrder?: Maybe<DeleteLicenseOrderPayload>;
  /** Deletes a single `LicenseOrder` using a unique key. */
  deleteLicenseOrderById?: Maybe<DeleteLicenseOrderPayload>;
  /** Deletes a single `LicenseOrder` using a unique key. */
  deleteLicenseOrderByLicenseIdAndFactuuropdracht?: Maybe<DeleteLicenseOrderPayload>;
  /** Deletes a single `LicenseOrder` using a unique key. */
  deleteLicenseOrderByLicenseRegistrationIdAndFactuuropdracht?: Maybe<DeleteLicenseOrderPayload>;
  /** Deletes a single `LicenseRegistration` using its globally unique id. */
  deleteLicenseRegistration?: Maybe<DeleteLicenseRegistrationPayload>;
  /** Deletes a single `LicenseRegistration` using a unique key. */
  deleteLicenseRegistrationById?: Maybe<DeleteLicenseRegistrationPayload>;
  /** Deletes a single `MaintenanceVisit` using its globally unique id. */
  deleteMaintenanceVisit?: Maybe<DeleteMaintenanceVisitPayload>;
  /** Deletes a single `MaintenanceVisit` using a unique key. */
  deleteMaintenanceVisitById?: Maybe<DeleteMaintenanceVisitPayload>;
  /** Deletes a single `MaintenanceVisitLine` using its globally unique id. */
  deleteMaintenanceVisitLine?: Maybe<DeleteMaintenanceVisitLinePayload>;
  /** Deletes a single `MaintenanceVisitLine` using a unique key. */
  deleteMaintenanceVisitLineById?: Maybe<DeleteMaintenanceVisitLinePayload>;
  /** Deletes a single `MaintenanceVisitLine` using a unique key. */
  deleteMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationId?: Maybe<DeleteMaintenanceVisitLinePayload>;
  /** Deletes a single `MaintenanceVisitRemark` using its globally unique id. */
  deleteMaintenanceVisitRemark?: Maybe<DeleteMaintenanceVisitRemarkPayload>;
  /** Deletes a single `MaintenanceVisitRemark` using a unique key. */
  deleteMaintenanceVisitRemarkById?: Maybe<DeleteMaintenanceVisitRemarkPayload>;
  /** Deletes a single `MaintenanceVisitRemark` using a unique key. */
  deleteMaintenanceVisitRemarkByMaintenanceVisitIdAndLine?: Maybe<DeleteMaintenanceVisitRemarkPayload>;
  /** Deletes a single `Membrane` using its globally unique id. */
  deleteMembrane?: Maybe<DeleteMembranePayload>;
  /** Deletes a single `Membrane` using a unique key. */
  deleteMembraneById?: Maybe<DeleteMembranePayload>;
  /** Deletes a single `Membrane` using a unique key. */
  deleteMembraneByName?: Maybe<DeleteMembranePayload>;
  /** Deletes a single `ORing` using its globally unique id. */
  deleteORing?: Maybe<DeleteORingPayload>;
  /** Deletes a single `ORing` using a unique key. */
  deleteORingById?: Maybe<DeleteORingPayload>;
  /** Deletes a single `ORing` using a unique key. */
  deleteORingByName?: Maybe<DeleteORingPayload>;
  /** Deletes a single `OfferteRemark` using its globally unique id. */
  deleteOfferteRemark?: Maybe<DeleteOfferteRemarkPayload>;
  /** Deletes a single `OfferteRemark` using a unique key. */
  deleteOfferteRemarkById?: Maybe<DeleteOfferteRemarkPayload>;
  /** Deletes a single `OfferteRemark` using a unique key. */
  deleteOfferteRemarkByOfferteId?: Maybe<DeleteOfferteRemarkPayload>;
  /** Deletes a single `Opportunity` using its globally unique id. */
  deleteOpportunity?: Maybe<DeleteOpportunityPayload>;
  /** Deletes a single `Opportunity` using a unique key. */
  deleteOpportunityById?: Maybe<DeleteOpportunityPayload>;
  /** Deletes a single `Permission` using its globally unique id. */
  deletePermission?: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Permission` using a unique key. */
  deletePermissionById?: Maybe<DeletePermissionPayload>;
  /** Deletes a single `PersoonRol` using its globally unique id. */
  deletePersoonRol?: Maybe<DeletePersoonRolPayload>;
  /** Deletes a single `PersoonRol` using a unique key. */
  deletePersoonRolByPersoonRolGuid?: Maybe<DeletePersoonRolPayload>;
  /** Deletes a single `Plug` using its globally unique id. */
  deletePlug?: Maybe<DeletePlugPayload>;
  /** Deletes a single `Plug` using a unique key. */
  deletePlugById?: Maybe<DeletePlugPayload>;
  /** Deletes a single `Plug` using a unique key. */
  deletePlugByName?: Maybe<DeletePlugPayload>;
  /** Deletes a single `Principle` using its globally unique id. */
  deletePrinciple?: Maybe<DeletePrinciplePayload>;
  /** Deletes a single `Principle` using a unique key. */
  deletePrincipleById?: Maybe<DeletePrinciplePayload>;
  /** Deletes a single `Principle` using a unique key. */
  deletePrincipleByName?: Maybe<DeletePrinciplePayload>;
  /** Deletes a single `Production` using its globally unique id. */
  deleteProduction?: Maybe<DeleteProductionPayload>;
  /** Deletes a single `Production` using a unique key. */
  deleteProductionById?: Maybe<DeleteProductionPayload>;
  /** Deletes a single `Pyrolyser` using its globally unique id. */
  deletePyrolyser?: Maybe<DeletePyrolyserPayload>;
  /** Deletes a single `Pyrolyser` using a unique key. */
  deletePyrolyserById?: Maybe<DeletePyrolyserPayload>;
  /** Deletes a single `Pyrolyser` using a unique key. */
  deletePyrolyserByName?: Maybe<DeletePyrolyserPayload>;
  /** Deletes a single `Range` using its globally unique id. */
  deleteRange?: Maybe<DeleteRangePayload>;
  /** Deletes a single `Range` using a unique key. */
  deleteRangeById?: Maybe<DeleteRangePayload>;
  /** Deletes a single `Range` using a unique key. */
  deleteRangeByLowEuAndHighEuAndEngineeringUnitsAndGasId?: Maybe<DeleteRangePayload>;
  /** Deletes a single `RcCard` using its globally unique id. */
  deleteRcCard?: Maybe<DeleteRcCardPayload>;
  /** Deletes a single `RcCard` using a unique key. */
  deleteRcCardById?: Maybe<DeleteRcCardPayload>;
  /** Deletes a single `RefreshToken` using its globally unique id. */
  deleteRefreshToken?: Maybe<DeleteRefreshTokenPayload>;
  /** Deletes a single `RefreshToken` using a unique key. */
  deleteRefreshTokenById?: Maybe<DeleteRefreshTokenPayload>;
  /** Deletes a single `Report` using its globally unique id. */
  deleteReport?: Maybe<DeleteReportPayload>;
  /** Deletes a single `Report` using a unique key. */
  deleteReportByFilename?: Maybe<DeleteReportPayload>;
  /** Deletes a single `Report` using a unique key. */
  deleteReportById?: Maybe<DeleteReportPayload>;
  /** Deletes a single `Report` using a unique key. */
  deleteReportByTsrNumberAndVersion?: Maybe<DeleteReportPayload>;
  /** Deletes a single `ReportDetector` using its globally unique id. */
  deleteReportDetector?: Maybe<DeleteReportDetectorPayload>;
  /** Deletes a single `ReportDetector` using a unique key. */
  deleteReportDetectorById?: Maybe<DeleteReportDetectorPayload>;
  /** Deletes a single `ReportDetector` using a unique key. */
  deleteReportDetectorByReportIdAndDetectorId?: Maybe<DeleteReportDetectorPayload>;
  /** Deletes a single `ReportItem` using its globally unique id. */
  deleteReportItem?: Maybe<DeleteReportItemPayload>;
  /** Deletes a single `ReportItem` using a unique key. */
  deleteReportItemById?: Maybe<DeleteReportItemPayload>;
  /** Deletes a single `ReportSensor` using its globally unique id. */
  deleteReportSensor?: Maybe<DeleteReportSensorPayload>;
  /** Deletes a single `ReportSensor` using a unique key. */
  deleteReportSensorById?: Maybe<DeleteReportSensorPayload>;
  /** Deletes a single `ReportSensor` using a unique key. */
  deleteReportSensorByReportIdAndSensorId?: Maybe<DeleteReportSensorPayload>;
  /** Deletes a single `Request` using its globally unique id. */
  deleteRequest?: Maybe<DeleteRequestPayload>;
  /** Deletes a single `Request` using a unique key. */
  deleteRequestById?: Maybe<DeleteRequestPayload>;
  /** Deletes a single `RxCard` using its globally unique id. */
  deleteRxCard?: Maybe<DeleteRxCardPayload>;
  /** Deletes a single `RxCard` using a unique key. */
  deleteRxCardById?: Maybe<DeleteRxCardPayload>;
  /** Deletes a single `SamplePoint` using its globally unique id. */
  deleteSamplePoint?: Maybe<DeleteSamplePointPayload>;
  /** Deletes a single `SamplePoint` using a unique key. */
  deleteSamplePointByAreaIdAndName?: Maybe<DeleteSamplePointPayload>;
  /** Deletes a single `SamplePoint` using a unique key. */
  deleteSamplePointById?: Maybe<DeleteSamplePointPayload>;
  /** Deletes a single `Sensor` using its globally unique id. */
  deleteSensor?: Maybe<DeleteSensorPayload>;
  /** Deletes a single `SensorBaseType` using its globally unique id. */
  deleteSensorBaseType?: Maybe<DeleteSensorBaseTypePayload>;
  /** Deletes a single `SensorBaseType` using a unique key. */
  deleteSensorBaseTypeById?: Maybe<DeleteSensorBaseTypePayload>;
  /** Deletes a single `SensorBaseType` using a unique key. */
  deleteSensorBaseTypeByPrefixAndSuffix?: Maybe<DeleteSensorBaseTypePayload>;
  /** Deletes a single `Sensor` using a unique key. */
  deleteSensorById?: Maybe<DeleteSensorPayload>;
  /** Deletes a single `Sensor` using a unique key. */
  deleteSensorBySerialNumberAndSensorTypeId?: Maybe<DeleteSensorPayload>;
  /** Deletes a single `SensorElement` using its globally unique id. */
  deleteSensorElement?: Maybe<DeleteSensorElementPayload>;
  /** Deletes a single `SensorElement` using a unique key. */
  deleteSensorElementById?: Maybe<DeleteSensorElementPayload>;
  /** Deletes a single `SensorElementLocation` using its globally unique id. */
  deleteSensorElementLocation?: Maybe<DeleteSensorElementLocationPayload>;
  /** Deletes a single `SensorElementLocation` using a unique key. */
  deleteSensorElementLocationById?: Maybe<DeleteSensorElementLocationPayload>;
  /** Deletes a single `SensorElementLocation` using a unique key. */
  deleteSensorElementLocationBySensorElementId?: Maybe<DeleteSensorElementLocationPayload>;
  /** Deletes a single `SensorElementLog` using its globally unique id. */
  deleteSensorElementLog?: Maybe<DeleteSensorElementLogPayload>;
  /** Deletes a single `SensorElementLog` using a unique key. */
  deleteSensorElementLogById?: Maybe<DeleteSensorElementLogPayload>;
  /** Deletes a single `SensorElementType` using its globally unique id. */
  deleteSensorElementType?: Maybe<DeleteSensorElementTypePayload>;
  /** Deletes a single `SensorElementType` using a unique key. */
  deleteSensorElementTypeById?: Maybe<DeleteSensorElementTypePayload>;
  /** Deletes a single `SensorOrder` using its globally unique id. */
  deleteSensorOrder?: Maybe<DeleteSensorOrderPayload>;
  /** Deletes a single `SensorOrder` using a unique key. */
  deleteSensorOrderById?: Maybe<DeleteSensorOrderPayload>;
  /** Deletes a single `SensorOrder` using a unique key. */
  deleteSensorOrderBySensorIdAndFactuuropdracht?: Maybe<DeleteSensorOrderPayload>;
  /** Deletes a single `SensorSensorElement` using its globally unique id. */
  deleteSensorSensorElement?: Maybe<DeleteSensorSensorElementPayload>;
  /** Deletes a single `SensorSensorElement` using a unique key. */
  deleteSensorSensorElementById?: Maybe<DeleteSensorSensorElementPayload>;
  /** Deletes a single `SensorSensorElement` using a unique key. */
  deleteSensorSensorElementBySensorElementId?: Maybe<DeleteSensorSensorElementPayload>;
  /** Deletes a single `SensorSensorElement` using a unique key. */
  deleteSensorSensorElementBySensorIdAndSensorPosition?: Maybe<DeleteSensorSensorElementPayload>;
  /** Deletes a single `SensorSetting` using its globally unique id. */
  deleteSensorSetting?: Maybe<DeleteSensorSettingPayload>;
  /** Deletes a single `SensorSetting` using a unique key. */
  deleteSensorSettingById?: Maybe<DeleteSensorSettingPayload>;
  /** Deletes a single `SensorSetting` using a unique key. */
  deleteSensorSettingByTypeTarget?: Maybe<DeleteSensorSettingPayload>;
  /** Deletes a single `SensorTestResult` using its globally unique id. */
  deleteSensorTestResult?: Maybe<DeleteSensorTestResultPayload>;
  /** Deletes a single `SensorTestResult` using a unique key. */
  deleteSensorTestResultById?: Maybe<DeleteSensorTestResultPayload>;
  /** Deletes a single `SensorType` using its globally unique id. */
  deleteSensorType?: Maybe<DeleteSensorTypePayload>;
  /** Deletes a single `SensorType` using a unique key. */
  deleteSensorTypeById?: Maybe<DeleteSensorTypePayload>;
  /** Deletes a single `SensorType` using a unique key. */
  deleteSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserId?: Maybe<DeleteSensorTypePayload>;
  /** Deletes a single `SensorType` using a unique key. */
  deleteSensorTypeBySensorTypeId?: Maybe<DeleteSensorTypePayload>;
  /** Deletes a single `Software` using its globally unique id. */
  deleteSoftware?: Maybe<DeleteSoftwarePayload>;
  /** Deletes a single `Software` using a unique key. */
  deleteSoftwareById?: Maybe<DeleteSoftwarePayload>;
  /** Deletes a single `StockGroup` using its globally unique id. */
  deleteStockGroup?: Maybe<DeleteStockGroupPayload>;
  /** Deletes a single `StockGroup` using a unique key. */
  deleteStockGroupById?: Maybe<DeleteStockGroupPayload>;
  /** Deletes a single `StockItem` using its globally unique id. */
  deleteStockItem?: Maybe<DeleteStockItemPayload>;
  /** Deletes a single `StockItem` using a unique key. */
  deleteStockItemById?: Maybe<DeleteStockItemPayload>;
  /** Deletes a single `StockItem` using a unique key. */
  deleteStockItemByStockGroupIdAndCdartikel?: Maybe<DeleteStockItemPayload>;
  /** Deletes a single `StockSupplier` using its globally unique id. */
  deleteStockSupplier?: Maybe<DeleteStockSupplierPayload>;
  /** Deletes a single `StockSupplier` using a unique key. */
  deleteStockSupplierById?: Maybe<DeleteStockSupplierPayload>;
  /** Deletes a single `Task` using its globally unique id. */
  deleteTask?: Maybe<DeleteTaskPayload>;
  /** Deletes a single `Task` using a unique key. */
  deleteTaskById?: Maybe<DeleteTaskPayload>;
  /** Deletes a single `TempFactopdrachtregel` using its globally unique id. */
  deleteTempFactopdrachtregel?: Maybe<DeleteTempFactopdrachtregelPayload>;
  /** Deletes a single `TempFactopdrachtregel` using a unique key. */
  deleteTempFactopdrachtregelByFactuuropdrachtAndFactuurregel?: Maybe<DeleteTempFactopdrachtregelPayload>;
  /** Deletes a single `TempFactopdrachtregel` using a unique key. */
  deleteTempFactopdrachtregelById?: Maybe<DeleteTempFactopdrachtregelPayload>;
  /** Deletes a single `TempLicense` using its globally unique id. */
  deleteTempLicense?: Maybe<DeleteTempLicensePayload>;
  /** Deletes a single `TempLicense` using a unique key. */
  deleteTempLicenseById?: Maybe<DeleteTempLicensePayload>;
  /** Deletes a single `TempRegistration` using its globally unique id. */
  deleteTempRegistration?: Maybe<DeleteTempRegistrationPayload>;
  /** Deletes a single `TempRegistration` using a unique key. */
  deleteTempRegistrationById?: Maybe<DeleteTempRegistrationPayload>;
  /** Deletes a single `TempRegistrationHistory` using its globally unique id. */
  deleteTempRegistrationHistory?: Maybe<DeleteTempRegistrationHistoryPayload>;
  /** Deletes a single `TempRegistrationHistory` using a unique key. */
  deleteTempRegistrationHistoryById?: Maybe<DeleteTempRegistrationHistoryPayload>;
  /** Deletes a single `TempRegistrations2` using its globally unique id. */
  deleteTempRegistrations2?: Maybe<DeleteTempRegistrations2Payload>;
  /** Deletes a single `TempRegistrations2` using a unique key. */
  deleteTempRegistrations2ById?: Maybe<DeleteTempRegistrations2Payload>;
  /** Deletes a single `Test` using its globally unique id. */
  deleteTest?: Maybe<DeleteTestPayload>;
  /** Deletes a single `Test` using a unique key. */
  deleteTestById?: Maybe<DeleteTestPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserById?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserRight` using its globally unique id. */
  deleteUserRight?: Maybe<DeleteUserRightPayload>;
  /** Deletes a single `UserRight` using a unique key. */
  deleteUserRightById?: Maybe<DeleteUserRightPayload>;
  /** Deletes a single `UserRight` using a unique key. */
  deleteUserRightByUserIdAndPath?: Maybe<DeleteUserRightPayload>;
  /** Deletes a single `UserTask` using its globally unique id. */
  deleteUserTask?: Maybe<DeleteUserTaskPayload>;
  /** Deletes a single `UserTask` using a unique key. */
  deleteUserTaskById?: Maybe<DeleteUserTaskPayload>;
  /** Deletes a single `UserTask` using a unique key. */
  deleteUserTaskByUserIdAndTaskId?: Maybe<DeleteUserTaskPayload>;
  /** Deletes a single `UsersGroup` using its globally unique id. */
  deleteUsersGroup?: Maybe<DeleteUsersGroupPayload>;
  /** Deletes a single `UsersGroup` using a unique key. */
  deleteUsersGroupById?: Maybe<DeleteUsersGroupPayload>;
  /** Deletes a single `UsersGroup` using a unique key. */
  deleteUsersGroupByUserIdAndGroupId?: Maybe<DeleteUsersGroupPayload>;
  /** Deletes a single `Voorraden` using its globally unique id. */
  deleteVoorraden?: Maybe<DeleteVoorradenPayload>;
  /** Deletes a single `Voorraden` using a unique key. */
  deleteVoorradenByCdartikelAndCdmagazijn?: Maybe<DeleteVoorradenPayload>;
  /** Deletes a single `VoorradenLog` using its globally unique id. */
  deleteVoorradenLog?: Maybe<DeleteVoorradenLogPayload>;
  /** Deletes a single `VoorradenLog` using a unique key. */
  deleteVoorradenLogById?: Maybe<DeleteVoorradenLogPayload>;
  /** Deletes a single `WeeklyHour` using its globally unique id. */
  deleteWeeklyHour?: Maybe<DeleteWeeklyHourPayload>;
  /** Deletes a single `WeeklyHour` using a unique key. */
  deleteWeeklyHourById?: Maybe<DeleteWeeklyHourPayload>;
  /** Deletes a single `WeeklyHourRemark` using its globally unique id. */
  deleteWeeklyHourRemark?: Maybe<DeleteWeeklyHourRemarkPayload>;
  /** Deletes a single `WeeklyHourRemark` using a unique key. */
  deleteWeeklyHourRemarkById?: Maybe<DeleteWeeklyHourRemarkPayload>;
  /** Deletes a single `WeeklyHourRemark` using a unique key. */
  deleteWeeklyHourRemarkByUserIdAndTaskIdAndDate?: Maybe<DeleteWeeklyHourRemarkPayload>;
  dueClass?: Maybe<DueClassPayload>;
  exchangeDetectors?: Maybe<ExchangeDetectorsPayload>;
  exchangeDetectorsById?: Maybe<ExchangeDetectorsByIdPayload>;
  exchangeSensors?: Maybe<ExchangeSensorsPayload>;
  exchangeSensorsById?: Maybe<ExchangeSensorsByIdPayload>;
  pc5109DSettings?: Maybe<Pc5109DSettingsPayload>;
  pc5154BSettings?: Maybe<Pc5154BSettingsPayload>;
  pc5155BSettings?: Maybe<Pc5155BSettingsPayload>;
  /** Updates a single `Aco` using its globally unique id and a patch. */
  updateAco?: Maybe<UpdateAcoPayload>;
  /** Updates a single `Aco` using a unique key and a patch. */
  updateAcoById?: Maybe<UpdateAcoPayload>;
  /** Updates a single `Action` using its globally unique id and a patch. */
  updateAction?: Maybe<UpdateActionPayload>;
  /** Updates a single `Action` using a unique key and a patch. */
  updateActionById?: Maybe<UpdateActionPayload>;
  /** Updates a single `_Adre` using its globally unique id and a patch. */
  updateAdre?: Maybe<UpdateAdrePayload>;
  /** Updates a single `_Adre` using a unique key and a patch. */
  updateAdreByAdresGuid?: Maybe<UpdateAdrePayload>;
  /** Updates a single `Application` using its globally unique id and a patch. */
  updateApplication?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplicationById?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplicationByName?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Area` using its globally unique id and a patch. */
  updateArea?: Maybe<UpdateAreaPayload>;
  /** Updates a single `Area` using a unique key and a patch. */
  updateAreaByFloorIdAndName?: Maybe<UpdateAreaPayload>;
  /** Updates a single `Area` using a unique key and a patch. */
  updateAreaById?: Maybe<UpdateAreaPayload>;
  /** Updates a single `Aro` using its globally unique id and a patch. */
  updateAro?: Maybe<UpdateAroPayload>;
  /** Updates a single `Aro` using a unique key and a patch. */
  updateAroById?: Maybe<UpdateAroPayload>;
  /** Updates a single `ArosAco` using its globally unique id and a patch. */
  updateArosAco?: Maybe<UpdateArosAcoPayload>;
  /** Updates a single `ArosAco` using a unique key and a patch. */
  updateArosAcoById?: Maybe<UpdateArosAcoPayload>;
  /** Updates a single `Artikel` using its globally unique id and a patch. */
  updateArtikel?: Maybe<UpdateArtikelPayload>;
  /** Updates a single `Artikel` using a unique key and a patch. */
  updateArtikelByCdartikel?: Maybe<UpdateArtikelPayload>;
  /** Updates a single `ArtikelLog` using its globally unique id and a patch. */
  updateArtikelLog?: Maybe<UpdateArtikelLogPayload>;
  /** Updates a single `ArtikelLog` using a unique key and a patch. */
  updateArtikelLogById?: Maybe<UpdateArtikelLogPayload>;
  /** Updates a single `Artikelomschr` using its globally unique id and a patch. */
  updateArtikelomschr?: Maybe<UpdateArtikelomschrPayload>;
  /** Updates a single `Artikelomschr` using a unique key and a patch. */
  updateArtikelomschrByCdartikelAndCdtaal?: Maybe<UpdateArtikelomschrPayload>;
  /** Updates a single `AspNetRole` using its globally unique id and a patch. */
  updateAspNetRole?: Maybe<UpdateAspNetRolePayload>;
  /** Updates a single `AspNetRole` using a unique key and a patch. */
  updateAspNetRoleById?: Maybe<UpdateAspNetRolePayload>;
  /** Updates a single `AspNetRoleClaim` using its globally unique id and a patch. */
  updateAspNetRoleClaim?: Maybe<UpdateAspNetRoleClaimPayload>;
  /** Updates a single `AspNetRoleClaim` using a unique key and a patch. */
  updateAspNetRoleClaimById?: Maybe<UpdateAspNetRoleClaimPayload>;
  /** Updates a single `AspNetUser` using its globally unique id and a patch. */
  updateAspNetUser?: Maybe<UpdateAspNetUserPayload>;
  /** Updates a single `AspNetUser` using a unique key and a patch. */
  updateAspNetUserById?: Maybe<UpdateAspNetUserPayload>;
  /** Updates a single `AspNetUserClaim` using its globally unique id and a patch. */
  updateAspNetUserClaim?: Maybe<UpdateAspNetUserClaimPayload>;
  /** Updates a single `AspNetUserClaim` using a unique key and a patch. */
  updateAspNetUserClaimById?: Maybe<UpdateAspNetUserClaimPayload>;
  /** Updates a single `AspNetUserLogin` using its globally unique id and a patch. */
  updateAspNetUserLogin?: Maybe<UpdateAspNetUserLoginPayload>;
  /** Updates a single `AspNetUserLogin` using a unique key and a patch. */
  updateAspNetUserLoginByLoginProviderAndProviderKey?: Maybe<UpdateAspNetUserLoginPayload>;
  /** Updates a single `AspNetUserRole` using its globally unique id and a patch. */
  updateAspNetUserRole?: Maybe<UpdateAspNetUserRolePayload>;
  /** Updates a single `AspNetUserRole` using a unique key and a patch. */
  updateAspNetUserRoleByUserIdAndRoleId?: Maybe<UpdateAspNetUserRolePayload>;
  /** Updates a single `AspNetUserToken` using its globally unique id and a patch. */
  updateAspNetUserToken?: Maybe<UpdateAspNetUserTokenPayload>;
  /** Updates a single `AspNetUserToken` using a unique key and a patch. */
  updateAspNetUserTokenByUserIdAndLoginProviderAndName?: Maybe<UpdateAspNetUserTokenPayload>;
  /** Updates a single `Assembly` using its globally unique id and a patch. */
  updateAssembly?: Maybe<UpdateAssemblyPayload>;
  /** Updates a single `Assembly` using a unique key and a patch. */
  updateAssemblyByCode?: Maybe<UpdateAssemblyPayload>;
  /** Updates a single `Assembly` using a unique key and a patch. */
  updateAssemblyById?: Maybe<UpdateAssemblyPayload>;
  /** Updates a single `AssemblyPart` using its globally unique id and a patch. */
  updateAssemblyPart?: Maybe<UpdateAssemblyPartPayload>;
  /** Updates a single `AssemblyPart` using a unique key and a patch. */
  updateAssemblyPartByAssemblyIdAndCdartikel?: Maybe<UpdateAssemblyPartPayload>;
  /** Updates a single `AssemblyPart` using a unique key and a patch. */
  updateAssemblyPartById?: Maybe<UpdateAssemblyPartPayload>;
  /** Updates a single `AssemblyType` using its globally unique id and a patch. */
  updateAssemblyType?: Maybe<UpdateAssemblyTypePayload>;
  /** Updates a single `AssemblyType` using a unique key and a patch. */
  updateAssemblyTypeById?: Maybe<UpdateAssemblyTypePayload>;
  /** Updates a single `AssemblyTypePart` using its globally unique id and a patch. */
  updateAssemblyTypePart?: Maybe<UpdateAssemblyTypePartPayload>;
  /** Updates a single `AssemblyTypePart` using a unique key and a patch. */
  updateAssemblyTypePartByAssemblyTypeIdAndCdartikel?: Maybe<UpdateAssemblyTypePartPayload>;
  /** Updates a single `AssemblyTypePart` using a unique key and a patch. */
  updateAssemblyTypePartById?: Maybe<UpdateAssemblyTypePartPayload>;
  /** Updates a single `Building` using its globally unique id and a patch. */
  updateBuilding?: Maybe<UpdateBuildingPayload>;
  /** Updates a single `Building` using a unique key and a patch. */
  updateBuildingByEndUserIdAndName?: Maybe<UpdateBuildingPayload>;
  /** Updates a single `Building` using a unique key and a patch. */
  updateBuildingById?: Maybe<UpdateBuildingPayload>;
  /** Updates a single `CalGas` using its globally unique id and a patch. */
  updateCalGas?: Maybe<UpdateCalGasPayload>;
  /** Updates a single `CalGas` using a unique key and a patch. */
  updateCalGasByConcentrationAndEngineeringUnitsAndGasId?: Maybe<UpdateCalGasPayload>;
  /** Updates a single `CalGas` using a unique key and a patch. */
  updateCalGasById?: Maybe<UpdateCalGasPayload>;
  /** Updates a single `CatalogGroup` using its globally unique id and a patch. */
  updateCatalogGroup?: Maybe<UpdateCatalogGroupPayload>;
  /** Updates a single `CatalogGroup` using a unique key and a patch. */
  updateCatalogGroupById?: Maybe<UpdateCatalogGroupPayload>;
  /** Updates a single `CatalogItem` using its globally unique id and a patch. */
  updateCatalogItem?: Maybe<UpdateCatalogItemPayload>;
  /** Updates a single `CatalogItem` using a unique key and a patch. */
  updateCatalogItemById?: Maybe<UpdateCatalogItemPayload>;
  /** Updates a single `CatalogItemFile` using its globally unique id and a patch. */
  updateCatalogItemFile?: Maybe<UpdateCatalogItemFilePayload>;
  /** Updates a single `CatalogItemFile` using a unique key and a patch. */
  updateCatalogItemFileById?: Maybe<UpdateCatalogItemFilePayload>;
  /** Updates a single `CatalogItemRelation` using its globally unique id and a patch. */
  updateCatalogItemRelation?: Maybe<UpdateCatalogItemRelationPayload>;
  /** Updates a single `CatalogItemRelation` using a unique key and a patch. */
  updateCatalogItemRelationById?: Maybe<UpdateCatalogItemRelationPayload>;
  /** Updates a single `CatalogSubGroup` using its globally unique id and a patch. */
  updateCatalogSubGroup?: Maybe<UpdateCatalogSubGroupPayload>;
  /** Updates a single `CatalogSubGroup` using a unique key and a patch. */
  updateCatalogSubGroupById?: Maybe<UpdateCatalogSubGroupPayload>;
  /** Updates a single `ChemicalCompound` using its globally unique id and a patch. */
  updateChemicalCompound?: Maybe<UpdateChemicalCompoundPayload>;
  /** Updates a single `ChemicalCompound` using a unique key and a patch. */
  updateChemicalCompoundById?: Maybe<UpdateChemicalCompoundPayload>;
  /** Updates a single `Detector` using its globally unique id and a patch. */
  updateDetector?: Maybe<UpdateDetectorPayload>;
  updateDetectorAndSensors?: Maybe<UpdateDetectorAndSensorsPayload>;
  /** Updates a single `Detector` using a unique key and a patch. */
  updateDetectorById?: Maybe<UpdateDetectorPayload>;
  /** Updates a single `Detector` using a unique key and a patch. */
  updateDetectorBySerialNumberAndDetectorTypeId?: Maybe<UpdateDetectorPayload>;
  /** Updates a single `DetectorLocation` using its globally unique id and a patch. */
  updateDetectorLocation?: Maybe<UpdateDetectorLocationPayload>;
  /** Updates a single `DetectorLocation` using a unique key and a patch. */
  updateDetectorLocationByDetectorId?: Maybe<UpdateDetectorLocationPayload>;
  /** Updates a single `DetectorLocation` using a unique key and a patch. */
  updateDetectorLocationById?: Maybe<UpdateDetectorLocationPayload>;
  /** Updates a single `DetectorOrder` using its globally unique id and a patch. */
  updateDetectorOrder?: Maybe<UpdateDetectorOrderPayload>;
  /** Updates a single `DetectorOrder` using a unique key and a patch. */
  updateDetectorOrderByFactuuropdrachtAndDetectorId?: Maybe<UpdateDetectorOrderPayload>;
  /** Updates a single `DetectorOrder` using a unique key and a patch. */
  updateDetectorOrderById?: Maybe<UpdateDetectorOrderPayload>;
  /** Updates a single `DetectorSensor` using its globally unique id and a patch. */
  updateDetectorSensor?: Maybe<UpdateDetectorSensorPayload>;
  /** Updates a single `DetectorSensor` using a unique key and a patch. */
  updateDetectorSensorByDetectorIdAndDetectorPosition?: Maybe<UpdateDetectorSensorPayload>;
  /** Updates a single `DetectorSensor` using a unique key and a patch. */
  updateDetectorSensorById?: Maybe<UpdateDetectorSensorPayload>;
  /** Updates a single `DetectorSensor` using a unique key and a patch. */
  updateDetectorSensorBySensorId?: Maybe<UpdateDetectorSensorPayload>;
  /** Updates a single `DetectorSensorLocation` using its globally unique id and a patch. */
  updateDetectorSensorLocation?: Maybe<UpdateDetectorSensorLocationPayload>;
  /** Updates a single `DetectorSensorLocation` using a unique key and a patch. */
  updateDetectorSensorLocationByDetectorSensorId?: Maybe<UpdateDetectorSensorLocationPayload>;
  /** Updates a single `DetectorSensorLocation` using a unique key and a patch. */
  updateDetectorSensorLocationById?: Maybe<UpdateDetectorSensorLocationPayload>;
  /** Updates a single `DetectorSensorLocation` using a unique key and a patch. */
  updateDetectorSensorLocationByLicenseIdAndSimsChannel?: Maybe<UpdateDetectorSensorLocationPayload>;
  /** Updates a single `DetectorSensorType` using its globally unique id and a patch. */
  updateDetectorSensorType?: Maybe<UpdateDetectorSensorTypePayload>;
  /** Updates a single `DetectorSensorType` using a unique key and a patch. */
  updateDetectorSensorTypeByDetectorIdAndDetectorPosition?: Maybe<UpdateDetectorSensorTypePayload>;
  /** Updates a single `DetectorSensorType` using a unique key and a patch. */
  updateDetectorSensorTypeById?: Maybe<UpdateDetectorSensorTypePayload>;
  /** Updates a single `DetectorType` using its globally unique id and a patch. */
  updateDetectorType?: Maybe<UpdateDetectorTypePayload>;
  /** Updates a single `DetectorType` using a unique key and a patch. */
  updateDetectorTypeById?: Maybe<UpdateDetectorTypePayload>;
  /** Updates a single `DetectorType` using a unique key and a patch. */
  updateDetectorTypeByPrefixAndCodeAndSuffix?: Maybe<UpdateDetectorTypePayload>;
  /** Updates a single `DpCard` using its globally unique id and a patch. */
  updateDpCard?: Maybe<UpdateDpCardPayload>;
  /** Updates a single `DpCard` using a unique key and a patch. */
  updateDpCardById?: Maybe<UpdateDpCardPayload>;
  /** Updates a single `Electrolyte` using its globally unique id and a patch. */
  updateElectrolyte?: Maybe<UpdateElectrolytePayload>;
  /** Updates a single `Electrolyte` using a unique key and a patch. */
  updateElectrolyteById?: Maybe<UpdateElectrolytePayload>;
  /** Updates a single `Electrolyte` using a unique key and a patch. */
  updateElectrolyteByName?: Maybe<UpdateElectrolytePayload>;
  /** Updates a single `EndUser` using its globally unique id and a patch. */
  updateEndUser?: Maybe<UpdateEndUserPayload>;
  /** Updates a single `EndUser` using a unique key and a patch. */
  updateEndUserById?: Maybe<UpdateEndUserPayload>;
  /** Updates a single `EndUser` using a unique key and a patch. */
  updateEndUserByNameAndLocationAndSubLocation?: Maybe<UpdateEndUserPayload>;
  /** Updates a single `FactopdrachtArtikelExclusion` using its globally unique id and a patch. */
  updateFactopdrachtArtikelExclusion?: Maybe<UpdateFactopdrachtArtikelExclusionPayload>;
  /** Updates a single `FactopdrachtArtikelExclusion` using a unique key and a patch. */
  updateFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikel?: Maybe<UpdateFactopdrachtArtikelExclusionPayload>;
  /** Updates a single `FactopdrachtArtikelExclusion` using a unique key and a patch. */
  updateFactopdrachtArtikelExclusionById?: Maybe<UpdateFactopdrachtArtikelExclusionPayload>;
  /** Updates a single `FactopdrachtregelLine` using its globally unique id and a patch. */
  updateFactopdrachtregelLine?: Maybe<UpdateFactopdrachtregelLinePayload>;
  /** Updates a single `FactopdrachtregelLine` using a unique key and a patch. */
  updateFactopdrachtregelLineByFactopdrRglGuid?: Maybe<UpdateFactopdrachtregelLinePayload>;
  /** Updates a single `FactopdrachtregelLine` using a unique key and a patch. */
  updateFactopdrachtregelLineById?: Maybe<UpdateFactopdrachtregelLinePayload>;
  /** Updates a single `FactopdrachtregelLineDate` using its globally unique id and a patch. */
  updateFactopdrachtregelLineDate?: Maybe<UpdateFactopdrachtregelLineDatePayload>;
  /** Updates a single `FactopdrachtregelLineDate` using a unique key and a patch. */
  updateFactopdrachtregelLineDateById?: Maybe<UpdateFactopdrachtregelLineDatePayload>;
  /** Updates a single `FactopdrachtregelLineRemark` using its globally unique id and a patch. */
  updateFactopdrachtregelLineRemark?: Maybe<UpdateFactopdrachtregelLineRemarkPayload>;
  /** Updates a single `FactopdrachtregelLineRemark` using a unique key and a patch. */
  updateFactopdrachtregelLineRemarkById?: Maybe<UpdateFactopdrachtregelLineRemarkPayload>;
  /** Updates a single `Factuur` using its globally unique id and a patch. */
  updateFactuur?: Maybe<UpdateFactuurPayload>;
  /** Updates a single `Factuur` using a unique key and a patch. */
  updateFactuurByFactuuropdracht?: Maybe<UpdateFactuurPayload>;
  /** Updates a single `Factuur` using a unique key and a patch. */
  updateFactuurById?: Maybe<UpdateFactuurPayload>;
  /** Updates a single `Filter` using its globally unique id and a patch. */
  updateFilter?: Maybe<UpdateFilterPayload>;
  /** Updates a single `Filter` using a unique key and a patch. */
  updateFilterById?: Maybe<UpdateFilterPayload>;
  /** Updates a single `Filter` using a unique key and a patch. */
  updateFilterByName?: Maybe<UpdateFilterPayload>;
  /** Updates a single `Floor` using its globally unique id and a patch. */
  updateFloor?: Maybe<UpdateFloorPayload>;
  /** Updates a single `Floor` using a unique key and a patch. */
  updateFloorByBuildingIdAndName?: Maybe<UpdateFloorPayload>;
  /** Updates a single `Floor` using a unique key and a patch. */
  updateFloorById?: Maybe<UpdateFloorPayload>;
  /** Updates a single `Gas` using its globally unique id and a patch. */
  updateGas?: Maybe<UpdateGasPayload>;
  /** Updates a single `Gas` using a unique key and a patch. */
  updateGasById?: Maybe<UpdateGasPayload>;
  /** Updates a single `Gas` using a unique key and a patch. */
  updateGasByName?: Maybe<UpdateGasPayload>;
  /** Updates a single `Group` using its globally unique id and a patch. */
  updateGroup?: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroupById?: Maybe<UpdateGroupPayload>;
  /** Updates a single `GroupPermission` using its globally unique id and a patch. */
  updateGroupPermission?: Maybe<UpdateGroupPermissionPayload>;
  /** Updates a single `GroupPermission` using a unique key and a patch. */
  updateGroupPermissionByGroupId?: Maybe<UpdateGroupPermissionPayload>;
  /** Updates a single `GroupPermission` using a unique key and a patch. */
  updateGroupPermissionById?: Maybe<UpdateGroupPermissionPayload>;
  /** Updates a single `GroupRight` using its globally unique id and a patch. */
  updateGroupRight?: Maybe<UpdateGroupRightPayload>;
  /** Updates a single `GroupRight` using a unique key and a patch. */
  updateGroupRightByGroupIdAndPath?: Maybe<UpdateGroupRightPayload>;
  /** Updates a single `GroupRight` using a unique key and a patch. */
  updateGroupRightById?: Maybe<UpdateGroupRightPayload>;
  /** Updates a single `Hardware` using its globally unique id and a patch. */
  updateHardware?: Maybe<UpdateHardwarePayload>;
  /** Updates a single `Hardware` using a unique key and a patch. */
  updateHardwareById?: Maybe<UpdateHardwarePayload>;
  /** Updates a single `IncomingDocument` using its globally unique id and a patch. */
  updateIncomingDocument?: Maybe<UpdateIncomingDocumentPayload>;
  /** Updates a single `IncomingDocument` using a unique key and a patch. */
  updateIncomingDocumentById?: Maybe<UpdateIncomingDocumentPayload>;
  /** Updates a single `Inkoopgegeven` using its globally unique id and a patch. */
  updateInkoopgegeven?: Maybe<UpdateInkoopgegevenPayload>;
  /** Updates a single `Inkoopgegeven` using a unique key and a patch. */
  updateInkoopgegevenByCdartikelAndInkvolgnr?: Maybe<UpdateInkoopgegevenPayload>;
  /** Updates a single `InkoopgegevensLog` using its globally unique id and a patch. */
  updateInkoopgegevensLog?: Maybe<UpdateInkoopgegevensLogPayload>;
  /** Updates a single `InkoopgegevensLog` using a unique key and a patch. */
  updateInkoopgegevensLogById?: Maybe<UpdateInkoopgegevensLogPayload>;
  /** Updates a single `InkooporderregelLine` using its globally unique id and a patch. */
  updateInkooporderregelLine?: Maybe<UpdateInkooporderregelLinePayload>;
  /** Updates a single `InkooporderregelLine` using a unique key and a patch. */
  updateInkooporderregelLineById?: Maybe<UpdateInkooporderregelLinePayload>;
  /** Updates a single `InkooporderregelLine` using a unique key and a patch. */
  updateInkooporderregelLineByInkopdrRglGuid?: Maybe<UpdateInkooporderregelLinePayload>;
  /** Updates a single `Item` using its globally unique id and a patch. */
  updateItem?: Maybe<UpdateItemPayload>;
  /** Updates a single `Item` using a unique key and a patch. */
  updateItemByCdartikelAndSerialNumber?: Maybe<UpdateItemPayload>;
  /** Updates a single `Item` using a unique key and a patch. */
  updateItemById?: Maybe<UpdateItemPayload>;
  /** Updates a single `Job` using its globally unique id and a patch. */
  updateJob?: Maybe<UpdateJobPayload>;
  /** Updates a single `Job` using a unique key and a patch. */
  updateJobById?: Maybe<UpdateJobPayload>;
  /** Updates a single `JunctionBox` using its globally unique id and a patch. */
  updateJunctionBox?: Maybe<UpdateJunctionBoxPayload>;
  /** Updates a single `JunctionBox` using a unique key and a patch. */
  updateJunctionBoxById?: Maybe<UpdateJunctionBoxPayload>;
  /** Updates a single `_Land` using its globally unique id and a patch. */
  updateLand?: Maybe<UpdateLandPayload>;
  /** Updates a single `_Land` using a unique key and a patch. */
  updateLandByCdland?: Maybe<UpdateLandPayload>;
  /** Updates a single `Lead` using its globally unique id and a patch. */
  updateLead?: Maybe<UpdateLeadPayload>;
  /** Updates a single `Lead` using a unique key and a patch. */
  updateLeadById?: Maybe<UpdateLeadPayload>;
  /** Updates a single `License` using its globally unique id and a patch. */
  updateLicense?: Maybe<UpdateLicensePayload>;
  /** Updates a single `License` using a unique key and a patch. */
  updateLicenseById?: Maybe<UpdateLicensePayload>;
  /** Updates a single `LicenseCustomer` using its globally unique id and a patch. */
  updateLicenseCustomer?: Maybe<UpdateLicenseCustomerPayload>;
  /** Updates a single `LicenseCustomer` using a unique key and a patch. */
  updateLicenseCustomerById?: Maybe<UpdateLicenseCustomerPayload>;
  /** Updates a single `LicenseModule` using its globally unique id and a patch. */
  updateLicenseModule?: Maybe<UpdateLicenseModulePayload>;
  /** Updates a single `LicenseModule` using a unique key and a patch. */
  updateLicenseModuleById?: Maybe<UpdateLicenseModulePayload>;
  /** Updates a single `LicenseOrder` using its globally unique id and a patch. */
  updateLicenseOrder?: Maybe<UpdateLicenseOrderPayload>;
  /** Updates a single `LicenseOrder` using a unique key and a patch. */
  updateLicenseOrderById?: Maybe<UpdateLicenseOrderPayload>;
  /** Updates a single `LicenseOrder` using a unique key and a patch. */
  updateLicenseOrderByLicenseIdAndFactuuropdracht?: Maybe<UpdateLicenseOrderPayload>;
  /** Updates a single `LicenseOrder` using a unique key and a patch. */
  updateLicenseOrderByLicenseRegistrationIdAndFactuuropdracht?: Maybe<UpdateLicenseOrderPayload>;
  /** Updates a single `LicenseRegistration` using its globally unique id and a patch. */
  updateLicenseRegistration?: Maybe<UpdateLicenseRegistrationPayload>;
  /** Updates a single `LicenseRegistration` using a unique key and a patch. */
  updateLicenseRegistrationById?: Maybe<UpdateLicenseRegistrationPayload>;
  /** Updates a single `MaintenanceVisit` using its globally unique id and a patch. */
  updateMaintenanceVisit?: Maybe<UpdateMaintenanceVisitPayload>;
  /** Updates a single `MaintenanceVisit` using a unique key and a patch. */
  updateMaintenanceVisitById?: Maybe<UpdateMaintenanceVisitPayload>;
  /** Updates a single `MaintenanceVisitLine` using its globally unique id and a patch. */
  updateMaintenanceVisitLine?: Maybe<UpdateMaintenanceVisitLinePayload>;
  /** Updates a single `MaintenanceVisitLine` using a unique key and a patch. */
  updateMaintenanceVisitLineById?: Maybe<UpdateMaintenanceVisitLinePayload>;
  /** Updates a single `MaintenanceVisitLine` using a unique key and a patch. */
  updateMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationId?: Maybe<UpdateMaintenanceVisitLinePayload>;
  /** Updates a single `MaintenanceVisitRemark` using its globally unique id and a patch. */
  updateMaintenanceVisitRemark?: Maybe<UpdateMaintenanceVisitRemarkPayload>;
  /** Updates a single `MaintenanceVisitRemark` using a unique key and a patch. */
  updateMaintenanceVisitRemarkById?: Maybe<UpdateMaintenanceVisitRemarkPayload>;
  /** Updates a single `MaintenanceVisitRemark` using a unique key and a patch. */
  updateMaintenanceVisitRemarkByMaintenanceVisitIdAndLine?: Maybe<UpdateMaintenanceVisitRemarkPayload>;
  /** Updates a single `Membrane` using its globally unique id and a patch. */
  updateMembrane?: Maybe<UpdateMembranePayload>;
  /** Updates a single `Membrane` using a unique key and a patch. */
  updateMembraneById?: Maybe<UpdateMembranePayload>;
  /** Updates a single `Membrane` using a unique key and a patch. */
  updateMembraneByName?: Maybe<UpdateMembranePayload>;
  /** Updates a single `ORing` using its globally unique id and a patch. */
  updateORing?: Maybe<UpdateORingPayload>;
  /** Updates a single `ORing` using a unique key and a patch. */
  updateORingById?: Maybe<UpdateORingPayload>;
  /** Updates a single `ORing` using a unique key and a patch. */
  updateORingByName?: Maybe<UpdateORingPayload>;
  /** Updates a single `OfferteRemark` using its globally unique id and a patch. */
  updateOfferteRemark?: Maybe<UpdateOfferteRemarkPayload>;
  /** Updates a single `OfferteRemark` using a unique key and a patch. */
  updateOfferteRemarkById?: Maybe<UpdateOfferteRemarkPayload>;
  /** Updates a single `OfferteRemark` using a unique key and a patch. */
  updateOfferteRemarkByOfferteId?: Maybe<UpdateOfferteRemarkPayload>;
  /** Updates a single `Opportunity` using its globally unique id and a patch. */
  updateOpportunity?: Maybe<UpdateOpportunityPayload>;
  /** Updates a single `Opportunity` using a unique key and a patch. */
  updateOpportunityById?: Maybe<UpdateOpportunityPayload>;
  /** Updates a single `Permission` using its globally unique id and a patch. */
  updatePermission?: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Permission` using a unique key and a patch. */
  updatePermissionById?: Maybe<UpdatePermissionPayload>;
  /** Updates a single `PersoonRol` using its globally unique id and a patch. */
  updatePersoonRol?: Maybe<UpdatePersoonRolPayload>;
  /** Updates a single `PersoonRol` using a unique key and a patch. */
  updatePersoonRolByPersoonRolGuid?: Maybe<UpdatePersoonRolPayload>;
  /** Updates a single `Plug` using its globally unique id and a patch. */
  updatePlug?: Maybe<UpdatePlugPayload>;
  /** Updates a single `Plug` using a unique key and a patch. */
  updatePlugById?: Maybe<UpdatePlugPayload>;
  /** Updates a single `Plug` using a unique key and a patch. */
  updatePlugByName?: Maybe<UpdatePlugPayload>;
  /** Updates a single `Principle` using its globally unique id and a patch. */
  updatePrinciple?: Maybe<UpdatePrinciplePayload>;
  /** Updates a single `Principle` using a unique key and a patch. */
  updatePrincipleById?: Maybe<UpdatePrinciplePayload>;
  /** Updates a single `Principle` using a unique key and a patch. */
  updatePrincipleByName?: Maybe<UpdatePrinciplePayload>;
  /** Updates a single `Production` using its globally unique id and a patch. */
  updateProduction?: Maybe<UpdateProductionPayload>;
  /** Updates a single `Production` using a unique key and a patch. */
  updateProductionById?: Maybe<UpdateProductionPayload>;
  /** Updates a single `Pyrolyser` using its globally unique id and a patch. */
  updatePyrolyser?: Maybe<UpdatePyrolyserPayload>;
  /** Updates a single `Pyrolyser` using a unique key and a patch. */
  updatePyrolyserById?: Maybe<UpdatePyrolyserPayload>;
  /** Updates a single `Pyrolyser` using a unique key and a patch. */
  updatePyrolyserByName?: Maybe<UpdatePyrolyserPayload>;
  /** Updates a single `Range` using its globally unique id and a patch. */
  updateRange?: Maybe<UpdateRangePayload>;
  /** Updates a single `Range` using a unique key and a patch. */
  updateRangeById?: Maybe<UpdateRangePayload>;
  /** Updates a single `Range` using a unique key and a patch. */
  updateRangeByLowEuAndHighEuAndEngineeringUnitsAndGasId?: Maybe<UpdateRangePayload>;
  /** Updates a single `RcCard` using its globally unique id and a patch. */
  updateRcCard?: Maybe<UpdateRcCardPayload>;
  /** Updates a single `RcCard` using a unique key and a patch. */
  updateRcCardById?: Maybe<UpdateRcCardPayload>;
  /** Updates a single `RefreshToken` using its globally unique id and a patch. */
  updateRefreshToken?: Maybe<UpdateRefreshTokenPayload>;
  /** Updates a single `RefreshToken` using a unique key and a patch. */
  updateRefreshTokenById?: Maybe<UpdateRefreshTokenPayload>;
  /** Updates a single `Report` using its globally unique id and a patch. */
  updateReport?: Maybe<UpdateReportPayload>;
  /** Updates a single `Report` using a unique key and a patch. */
  updateReportByFilename?: Maybe<UpdateReportPayload>;
  /** Updates a single `Report` using a unique key and a patch. */
  updateReportById?: Maybe<UpdateReportPayload>;
  /** Updates a single `Report` using a unique key and a patch. */
  updateReportByTsrNumberAndVersion?: Maybe<UpdateReportPayload>;
  /** Updates a single `ReportDetector` using its globally unique id and a patch. */
  updateReportDetector?: Maybe<UpdateReportDetectorPayload>;
  /** Updates a single `ReportDetector` using a unique key and a patch. */
  updateReportDetectorById?: Maybe<UpdateReportDetectorPayload>;
  /** Updates a single `ReportDetector` using a unique key and a patch. */
  updateReportDetectorByReportIdAndDetectorId?: Maybe<UpdateReportDetectorPayload>;
  /** Updates a single `ReportItem` using its globally unique id and a patch. */
  updateReportItem?: Maybe<UpdateReportItemPayload>;
  /** Updates a single `ReportItem` using a unique key and a patch. */
  updateReportItemById?: Maybe<UpdateReportItemPayload>;
  /** Updates a single `ReportSensor` using its globally unique id and a patch. */
  updateReportSensor?: Maybe<UpdateReportSensorPayload>;
  /** Updates a single `ReportSensor` using a unique key and a patch. */
  updateReportSensorById?: Maybe<UpdateReportSensorPayload>;
  /** Updates a single `ReportSensor` using a unique key and a patch. */
  updateReportSensorByReportIdAndSensorId?: Maybe<UpdateReportSensorPayload>;
  /** Updates a single `Request` using its globally unique id and a patch. */
  updateRequest?: Maybe<UpdateRequestPayload>;
  /** Updates a single `Request` using a unique key and a patch. */
  updateRequestById?: Maybe<UpdateRequestPayload>;
  /** Updates a single `RxCard` using its globally unique id and a patch. */
  updateRxCard?: Maybe<UpdateRxCardPayload>;
  /** Updates a single `RxCard` using a unique key and a patch. */
  updateRxCardById?: Maybe<UpdateRxCardPayload>;
  /** Updates a single `SamplePoint` using its globally unique id and a patch. */
  updateSamplePoint?: Maybe<UpdateSamplePointPayload>;
  /** Updates a single `SamplePoint` using a unique key and a patch. */
  updateSamplePointByAreaIdAndName?: Maybe<UpdateSamplePointPayload>;
  /** Updates a single `SamplePoint` using a unique key and a patch. */
  updateSamplePointById?: Maybe<UpdateSamplePointPayload>;
  /** Updates a single `Sensor` using its globally unique id and a patch. */
  updateSensor?: Maybe<UpdateSensorPayload>;
  /** Updates a single `SensorBaseType` using its globally unique id and a patch. */
  updateSensorBaseType?: Maybe<UpdateSensorBaseTypePayload>;
  /** Updates a single `SensorBaseType` using a unique key and a patch. */
  updateSensorBaseTypeById?: Maybe<UpdateSensorBaseTypePayload>;
  /** Updates a single `SensorBaseType` using a unique key and a patch. */
  updateSensorBaseTypeByPrefixAndSuffix?: Maybe<UpdateSensorBaseTypePayload>;
  /** Updates a single `Sensor` using a unique key and a patch. */
  updateSensorById?: Maybe<UpdateSensorPayload>;
  /** Updates a single `Sensor` using a unique key and a patch. */
  updateSensorBySerialNumberAndSensorTypeId?: Maybe<UpdateSensorPayload>;
  /** Updates a single `SensorElement` using its globally unique id and a patch. */
  updateSensorElement?: Maybe<UpdateSensorElementPayload>;
  /** Updates a single `SensorElement` using a unique key and a patch. */
  updateSensorElementById?: Maybe<UpdateSensorElementPayload>;
  /** Updates a single `SensorElementLocation` using its globally unique id and a patch. */
  updateSensorElementLocation?: Maybe<UpdateSensorElementLocationPayload>;
  /** Updates a single `SensorElementLocation` using a unique key and a patch. */
  updateSensorElementLocationById?: Maybe<UpdateSensorElementLocationPayload>;
  /** Updates a single `SensorElementLocation` using a unique key and a patch. */
  updateSensorElementLocationBySensorElementId?: Maybe<UpdateSensorElementLocationPayload>;
  /** Updates a single `SensorElementLog` using its globally unique id and a patch. */
  updateSensorElementLog?: Maybe<UpdateSensorElementLogPayload>;
  /** Updates a single `SensorElementLog` using a unique key and a patch. */
  updateSensorElementLogById?: Maybe<UpdateSensorElementLogPayload>;
  /** Updates a single `SensorElementType` using its globally unique id and a patch. */
  updateSensorElementType?: Maybe<UpdateSensorElementTypePayload>;
  /** Updates a single `SensorElementType` using a unique key and a patch. */
  updateSensorElementTypeById?: Maybe<UpdateSensorElementTypePayload>;
  /** Updates a single `SensorOrder` using its globally unique id and a patch. */
  updateSensorOrder?: Maybe<UpdateSensorOrderPayload>;
  /** Updates a single `SensorOrder` using a unique key and a patch. */
  updateSensorOrderById?: Maybe<UpdateSensorOrderPayload>;
  /** Updates a single `SensorOrder` using a unique key and a patch. */
  updateSensorOrderBySensorIdAndFactuuropdracht?: Maybe<UpdateSensorOrderPayload>;
  /** Updates a single `SensorSensorElement` using its globally unique id and a patch. */
  updateSensorSensorElement?: Maybe<UpdateSensorSensorElementPayload>;
  /** Updates a single `SensorSensorElement` using a unique key and a patch. */
  updateSensorSensorElementById?: Maybe<UpdateSensorSensorElementPayload>;
  /** Updates a single `SensorSensorElement` using a unique key and a patch. */
  updateSensorSensorElementBySensorElementId?: Maybe<UpdateSensorSensorElementPayload>;
  /** Updates a single `SensorSensorElement` using a unique key and a patch. */
  updateSensorSensorElementBySensorIdAndSensorPosition?: Maybe<UpdateSensorSensorElementPayload>;
  /** Updates a single `SensorSetting` using its globally unique id and a patch. */
  updateSensorSetting?: Maybe<UpdateSensorSettingPayload>;
  /** Updates a single `SensorSetting` using a unique key and a patch. */
  updateSensorSettingById?: Maybe<UpdateSensorSettingPayload>;
  /** Updates a single `SensorSetting` using a unique key and a patch. */
  updateSensorSettingByTypeTarget?: Maybe<UpdateSensorSettingPayload>;
  /** Updates a single `SensorTestResult` using its globally unique id and a patch. */
  updateSensorTestResult?: Maybe<UpdateSensorTestResultPayload>;
  /** Updates a single `SensorTestResult` using a unique key and a patch. */
  updateSensorTestResultById?: Maybe<UpdateSensorTestResultPayload>;
  /** Updates a single `SensorType` using its globally unique id and a patch. */
  updateSensorType?: Maybe<UpdateSensorTypePayload>;
  /** Updates a single `SensorType` using a unique key and a patch. */
  updateSensorTypeById?: Maybe<UpdateSensorTypePayload>;
  /** Updates a single `SensorType` using a unique key and a patch. */
  updateSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserId?: Maybe<UpdateSensorTypePayload>;
  /** Updates a single `SensorType` using a unique key and a patch. */
  updateSensorTypeBySensorTypeId?: Maybe<UpdateSensorTypePayload>;
  /** Updates a single `Software` using its globally unique id and a patch. */
  updateSoftware?: Maybe<UpdateSoftwarePayload>;
  /** Updates a single `Software` using a unique key and a patch. */
  updateSoftwareById?: Maybe<UpdateSoftwarePayload>;
  /** Updates a single `StockGroup` using its globally unique id and a patch. */
  updateStockGroup?: Maybe<UpdateStockGroupPayload>;
  /** Updates a single `StockGroup` using a unique key and a patch. */
  updateStockGroupById?: Maybe<UpdateStockGroupPayload>;
  /** Updates a single `StockItem` using its globally unique id and a patch. */
  updateStockItem?: Maybe<UpdateStockItemPayload>;
  /** Updates a single `StockItem` using a unique key and a patch. */
  updateStockItemById?: Maybe<UpdateStockItemPayload>;
  /** Updates a single `StockItem` using a unique key and a patch. */
  updateStockItemByStockGroupIdAndCdartikel?: Maybe<UpdateStockItemPayload>;
  /** Updates a single `StockSupplier` using its globally unique id and a patch. */
  updateStockSupplier?: Maybe<UpdateStockSupplierPayload>;
  /** Updates a single `StockSupplier` using a unique key and a patch. */
  updateStockSupplierById?: Maybe<UpdateStockSupplierPayload>;
  /** Updates a single `Task` using its globally unique id and a patch. */
  updateTask?: Maybe<UpdateTaskPayload>;
  /** Updates a single `Task` using a unique key and a patch. */
  updateTaskById?: Maybe<UpdateTaskPayload>;
  /** Updates a single `TempFactopdrachtregel` using its globally unique id and a patch. */
  updateTempFactopdrachtregel?: Maybe<UpdateTempFactopdrachtregelPayload>;
  /** Updates a single `TempFactopdrachtregel` using a unique key and a patch. */
  updateTempFactopdrachtregelByFactuuropdrachtAndFactuurregel?: Maybe<UpdateTempFactopdrachtregelPayload>;
  /** Updates a single `TempFactopdrachtregel` using a unique key and a patch. */
  updateTempFactopdrachtregelById?: Maybe<UpdateTempFactopdrachtregelPayload>;
  /** Updates a single `TempLicense` using its globally unique id and a patch. */
  updateTempLicense?: Maybe<UpdateTempLicensePayload>;
  /** Updates a single `TempLicense` using a unique key and a patch. */
  updateTempLicenseById?: Maybe<UpdateTempLicensePayload>;
  /** Updates a single `TempRegistration` using its globally unique id and a patch. */
  updateTempRegistration?: Maybe<UpdateTempRegistrationPayload>;
  /** Updates a single `TempRegistration` using a unique key and a patch. */
  updateTempRegistrationById?: Maybe<UpdateTempRegistrationPayload>;
  /** Updates a single `TempRegistrationHistory` using its globally unique id and a patch. */
  updateTempRegistrationHistory?: Maybe<UpdateTempRegistrationHistoryPayload>;
  /** Updates a single `TempRegistrationHistory` using a unique key and a patch. */
  updateTempRegistrationHistoryById?: Maybe<UpdateTempRegistrationHistoryPayload>;
  /** Updates a single `TempRegistrations2` using its globally unique id and a patch. */
  updateTempRegistrations2?: Maybe<UpdateTempRegistrations2Payload>;
  /** Updates a single `TempRegistrations2` using a unique key and a patch. */
  updateTempRegistrations2ById?: Maybe<UpdateTempRegistrations2Payload>;
  /** Updates a single `Test` using its globally unique id and a patch. */
  updateTest?: Maybe<UpdateTestPayload>;
  /** Updates a single `Test` using a unique key and a patch. */
  updateTestById?: Maybe<UpdateTestPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserById?: Maybe<UpdateUserPayload>;
  updateUserGroups?: Maybe<UpdateUserGroupsPayload>;
  /** Updates a single `UserRight` using its globally unique id and a patch. */
  updateUserRight?: Maybe<UpdateUserRightPayload>;
  /** Updates a single `UserRight` using a unique key and a patch. */
  updateUserRightById?: Maybe<UpdateUserRightPayload>;
  /** Updates a single `UserRight` using a unique key and a patch. */
  updateUserRightByUserIdAndPath?: Maybe<UpdateUserRightPayload>;
  /** Updates a single `UserTask` using its globally unique id and a patch. */
  updateUserTask?: Maybe<UpdateUserTaskPayload>;
  /** Updates a single `UserTask` using a unique key and a patch. */
  updateUserTaskById?: Maybe<UpdateUserTaskPayload>;
  /** Updates a single `UserTask` using a unique key and a patch. */
  updateUserTaskByUserIdAndTaskId?: Maybe<UpdateUserTaskPayload>;
  /** Updates a single `Voorraden` using its globally unique id and a patch. */
  updateVoorraden?: Maybe<UpdateVoorradenPayload>;
  /** Updates a single `Voorraden` using a unique key and a patch. */
  updateVoorradenByCdartikelAndCdmagazijn?: Maybe<UpdateVoorradenPayload>;
  /** Updates a single `VoorradenLog` using its globally unique id and a patch. */
  updateVoorradenLog?: Maybe<UpdateVoorradenLogPayload>;
  /** Updates a single `VoorradenLog` using a unique key and a patch. */
  updateVoorradenLogById?: Maybe<UpdateVoorradenLogPayload>;
  /** Updates a single `WeeklyHour` using its globally unique id and a patch. */
  updateWeeklyHour?: Maybe<UpdateWeeklyHourPayload>;
  /** Updates a single `WeeklyHour` using a unique key and a patch. */
  updateWeeklyHourById?: Maybe<UpdateWeeklyHourPayload>;
  /** Updates a single `WeeklyHourRemark` using its globally unique id and a patch. */
  updateWeeklyHourRemark?: Maybe<UpdateWeeklyHourRemarkPayload>;
  /** Updates a single `WeeklyHourRemark` using a unique key and a patch. */
  updateWeeklyHourRemarkById?: Maybe<UpdateWeeklyHourRemarkPayload>;
  /** Updates a single `WeeklyHourRemark` using a unique key and a patch. */
  updateWeeklyHourRemarkByUserIdAndTaskIdAndDate?: Maybe<UpdateWeeklyHourRemarkPayload>;
  upsertDetectorSensorBySensorId?: Maybe<UpsertDetectorSensorBySensorIdPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAuthenticateArgs = {
  input: AuthenticateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAcoArgs = {
  input: CreateAcoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActionArgs = {
  input: CreateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAdreArgs = {
  input: CreateAdreInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAnotherRefreshTokenArgs = {
  input: CreateAnotherRefreshTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationArgs = {
  input: CreateApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAreaArgs = {
  input: CreateAreaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAroArgs = {
  input: CreateAroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateArosAcoArgs = {
  input: CreateArosAcoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateArtikelArgs = {
  input: CreateArtikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateArtikelLogArgs = {
  input: CreateArtikelLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateArtikelomschrArgs = {
  input: CreateArtikelomschrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAspNetRoleArgs = {
  input: CreateAspNetRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAspNetRoleClaimArgs = {
  input: CreateAspNetRoleClaimInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAspNetUserArgs = {
  input: CreateAspNetUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAspNetUserClaimArgs = {
  input: CreateAspNetUserClaimInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAspNetUserLoginArgs = {
  input: CreateAspNetUserLoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAspNetUserRoleArgs = {
  input: CreateAspNetUserRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAspNetUserTokenArgs = {
  input: CreateAspNetUserTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAssemblyArgs = {
  input: CreateAssemblyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAssemblyPartArgs = {
  input: CreateAssemblyPartInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAssemblyTypeArgs = {
  input: CreateAssemblyTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAssemblyTypePartArgs = {
  input: CreateAssemblyTypePartInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBuildingArgs = {
  input: CreateBuildingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCalGasArgs = {
  input: CreateCalGasInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCatalogGroupArgs = {
  input: CreateCatalogGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCatalogItemArgs = {
  input: CreateCatalogItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCatalogItemFileArgs = {
  input: CreateCatalogItemFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCatalogItemRelationArgs = {
  input: CreateCatalogItemRelationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCatalogSubGroupArgs = {
  input: CreateCatalogSubGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateChemicalCompoundArgs = {
  input: CreateChemicalCompoundInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDetectorArgs = {
  input: CreateDetectorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDetectorLocationArgs = {
  input: CreateDetectorLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDetectorOrderArgs = {
  input: CreateDetectorOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDetectorSensorArgs = {
  input: CreateDetectorSensorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDetectorSensorLocationArgs = {
  input: CreateDetectorSensorLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDetectorSensorTypeArgs = {
  input: CreateDetectorSensorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDetectorTypeArgs = {
  input: CreateDetectorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDpCardArgs = {
  input: CreateDpCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateElectrolyteArgs = {
  input: CreateElectrolyteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEndUserArgs = {
  input: CreateEndUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFactopdrachtArtikelExclusionArgs = {
  input: CreateFactopdrachtArtikelExclusionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFactopdrachtregelLineArgs = {
  input: CreateFactopdrachtregelLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFactopdrachtregelLineDateArgs = {
  input: CreateFactopdrachtregelLineDateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFactopdrachtregelLineRemarkArgs = {
  input: CreateFactopdrachtregelLineRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFactopdrachtregelLineWeekArgs = {
  input: CreateFactopdrachtregelLineWeekInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFactuurArgs = {
  input: CreateFactuurInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFilterArgs = {
  input: CreateFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFloorArgs = {
  input: CreateFloorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGasArgs = {
  input: CreateGasInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupPermissionArgs = {
  input: CreateGroupPermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupRightArgs = {
  input: CreateGroupRightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateHardwareArgs = {
  input: CreateHardwareInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateIncomingDocumentArgs = {
  input: CreateIncomingDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInkoopgegevenArgs = {
  input: CreateInkoopgegevenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInkoopgegevensLogArgs = {
  input: CreateInkoopgegevensLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInkooporderregelLineArgs = {
  input: CreateInkooporderregelLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateItemArgs = {
  input: CreateItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJobArgs = {
  input: CreateJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateJunctionBoxArgs = {
  input: CreateJunctionBoxInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLandArgs = {
  input: CreateLandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLeadArgs = {
  input: CreateLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLicenseArgs = {
  input: CreateLicenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLicenseCustomerArgs = {
  input: CreateLicenseCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLicenseModuleArgs = {
  input: CreateLicenseModuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLicenseOrderArgs = {
  input: CreateLicenseOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLicenseRegistrationArgs = {
  input: CreateLicenseRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMaintenanceVisitArgs = {
  input: CreateMaintenanceVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMaintenanceVisitLineArgs = {
  input: CreateMaintenanceVisitLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMaintenanceVisitRemarkArgs = {
  input: CreateMaintenanceVisitRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMembraneArgs = {
  input: CreateMembraneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateORingArgs = {
  input: CreateORingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOfferteRemarkArgs = {
  input: CreateOfferteRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOpportunityArgs = {
  input: CreateOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionArgs = {
  input: CreatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePersoonRolArgs = {
  input: CreatePersoonRolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlugArgs = {
  input: CreatePlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePrincipleArgs = {
  input: CreatePrincipleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateProductionArgs = {
  input: CreateProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePyrolyserArgs = {
  input: CreatePyrolyserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRangeArgs = {
  input: CreateRangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRcCardArgs = {
  input: CreateRcCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRefreshTokenArgs = {
  input: CreateRefreshTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReportArgs = {
  input: CreateReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReportDetectorArgs = {
  input: CreateReportDetectorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReportItemArgs = {
  input: CreateReportItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReportSensorArgs = {
  input: CreateReportSensorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRequestArgs = {
  input: CreateRequestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateRxCardArgs = {
  input: CreateRxCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSamplePointArgs = {
  input: CreateSamplePointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorBaseTypeArgs = {
  input: CreateSensorBaseTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorElementArgs = {
  input: CreateSensorElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorElementLocationArgs = {
  input: CreateSensorElementLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorElementLogArgs = {
  input: CreateSensorElementLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorElementTypeArgs = {
  input: CreateSensorElementTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorOrderArgs = {
  input: CreateSensorOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorSensorElementArgs = {
  input: CreateSensorSensorElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorSettingArgs = {
  input: CreateSensorSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorTestResultArgs = {
  input: CreateSensorTestResultInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorTypeArgs = {
  input: CreateSensorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSensorsArgs = {
  input: CreateSensorsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSoftwareArgs = {
  input: CreateSoftwareInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStockGroupArgs = {
  input: CreateStockGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStockItemArgs = {
  input: CreateStockItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStockSupplierArgs = {
  input: CreateStockSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTaskArgs = {
  input: CreateTaskInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTempFactopdrachtregelArgs = {
  input: CreateTempFactopdrachtregelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTempLicenseArgs = {
  input: CreateTempLicenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTempRegistrationArgs = {
  input: CreateTempRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTempRegistrationHistoryArgs = {
  input: CreateTempRegistrationHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTempRegistrations2Args = {
  input: CreateTempRegistrations2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTestArgs = {
  input: CreateTestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserRightArgs = {
  input: CreateUserRightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserTaskArgs = {
  input: CreateUserTaskInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVoorradenArgs = {
  input: CreateVoorradenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVoorradenLogArgs = {
  input: CreateVoorradenLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWeeklyHourArgs = {
  input: CreateWeeklyHourInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateWeeklyHourRemarkArgs = {
  input: CreateWeeklyHourRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAcoArgs = {
  input: DeleteAcoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAcoByIdArgs = {
  input: DeleteAcoByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionArgs = {
  input: DeleteActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionByIdArgs = {
  input: DeleteActionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAdreArgs = {
  input: DeleteAdreInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAdreByAdresGuidArgs = {
  input: DeleteAdreByAdresGuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationArgs = {
  input: DeleteApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationByIdArgs = {
  input: DeleteApplicationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationByNameArgs = {
  input: DeleteApplicationByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAreaArgs = {
  input: DeleteAreaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAreaByFloorIdAndNameArgs = {
  input: DeleteAreaByFloorIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAreaByIdArgs = {
  input: DeleteAreaByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAroArgs = {
  input: DeleteAroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAroByIdArgs = {
  input: DeleteAroByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteArosAcoArgs = {
  input: DeleteArosAcoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteArosAcoByIdArgs = {
  input: DeleteArosAcoByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteArtikelArgs = {
  input: DeleteArtikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteArtikelByCdartikelArgs = {
  input: DeleteArtikelByCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteArtikelLogArgs = {
  input: DeleteArtikelLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteArtikelLogByIdArgs = {
  input: DeleteArtikelLogByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteArtikelomschrArgs = {
  input: DeleteArtikelomschrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteArtikelomschrByCdartikelAndCdtaalArgs = {
  input: DeleteArtikelomschrByCdartikelAndCdtaalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetRoleArgs = {
  input: DeleteAspNetRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetRoleByIdArgs = {
  input: DeleteAspNetRoleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetRoleClaimArgs = {
  input: DeleteAspNetRoleClaimInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetRoleClaimByIdArgs = {
  input: DeleteAspNetRoleClaimByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserArgs = {
  input: DeleteAspNetUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserByIdArgs = {
  input: DeleteAspNetUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserClaimArgs = {
  input: DeleteAspNetUserClaimInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserClaimByIdArgs = {
  input: DeleteAspNetUserClaimByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserLoginArgs = {
  input: DeleteAspNetUserLoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserLoginByLoginProviderAndProviderKeyArgs = {
  input: DeleteAspNetUserLoginByLoginProviderAndProviderKeyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserRoleArgs = {
  input: DeleteAspNetUserRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserRoleByUserIdAndRoleIdArgs = {
  input: DeleteAspNetUserRoleByUserIdAndRoleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserTokenArgs = {
  input: DeleteAspNetUserTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAspNetUserTokenByUserIdAndLoginProviderAndNameArgs = {
  input: DeleteAspNetUserTokenByUserIdAndLoginProviderAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyArgs = {
  input: DeleteAssemblyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyByCodeArgs = {
  input: DeleteAssemblyByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyByIdArgs = {
  input: DeleteAssemblyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyPartArgs = {
  input: DeleteAssemblyPartInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyPartByAssemblyIdAndCdartikelArgs = {
  input: DeleteAssemblyPartByAssemblyIdAndCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyPartByIdArgs = {
  input: DeleteAssemblyPartByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyTypeArgs = {
  input: DeleteAssemblyTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyTypeByIdArgs = {
  input: DeleteAssemblyTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyTypePartArgs = {
  input: DeleteAssemblyTypePartInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyTypePartByAssemblyTypeIdAndCdartikelArgs = {
  input: DeleteAssemblyTypePartByAssemblyTypeIdAndCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAssemblyTypePartByIdArgs = {
  input: DeleteAssemblyTypePartByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBuildingArgs = {
  input: DeleteBuildingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBuildingByEndUserIdAndNameArgs = {
  input: DeleteBuildingByEndUserIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBuildingByIdArgs = {
  input: DeleteBuildingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCalGasArgs = {
  input: DeleteCalGasInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCalGasByConcentrationAndEngineeringUnitsAndGasIdArgs = {
  input: DeleteCalGasByConcentrationAndEngineeringUnitsAndGasIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCalGasByIdArgs = {
  input: DeleteCalGasByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogGroupArgs = {
  input: DeleteCatalogGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogGroupByIdArgs = {
  input: DeleteCatalogGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogItemArgs = {
  input: DeleteCatalogItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogItemByIdArgs = {
  input: DeleteCatalogItemByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogItemFileArgs = {
  input: DeleteCatalogItemFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogItemFileByIdArgs = {
  input: DeleteCatalogItemFileByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogItemRelationArgs = {
  input: DeleteCatalogItemRelationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogItemRelationByIdArgs = {
  input: DeleteCatalogItemRelationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogSubGroupArgs = {
  input: DeleteCatalogSubGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCatalogSubGroupByIdArgs = {
  input: DeleteCatalogSubGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChemicalCompoundArgs = {
  input: DeleteChemicalCompoundInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteChemicalCompoundByIdArgs = {
  input: DeleteChemicalCompoundByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorArgs = {
  input: DeleteDetectorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorByIdArgs = {
  input: DeleteDetectorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorBySerialNumberAndDetectorTypeIdArgs = {
  input: DeleteDetectorBySerialNumberAndDetectorTypeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorLocationArgs = {
  input: DeleteDetectorLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorLocationByDetectorIdArgs = {
  input: DeleteDetectorLocationByDetectorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorLocationByIdArgs = {
  input: DeleteDetectorLocationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorOrderArgs = {
  input: DeleteDetectorOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorOrderByFactuuropdrachtAndDetectorIdArgs = {
  input: DeleteDetectorOrderByFactuuropdrachtAndDetectorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorOrderByIdArgs = {
  input: DeleteDetectorOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorArgs = {
  input: DeleteDetectorSensorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorByDetectorIdAndDetectorPositionArgs = {
  input: DeleteDetectorSensorByDetectorIdAndDetectorPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorByIdArgs = {
  input: DeleteDetectorSensorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorBySensorIdArgs = {
  input: DeleteDetectorSensorBySensorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorLocationArgs = {
  input: DeleteDetectorSensorLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorLocationByDetectorSensorIdArgs = {
  input: DeleteDetectorSensorLocationByDetectorSensorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorLocationByIdArgs = {
  input: DeleteDetectorSensorLocationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorLocationByLicenseIdAndSimsChannelArgs = {
  input: DeleteDetectorSensorLocationByLicenseIdAndSimsChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorTypeArgs = {
  input: DeleteDetectorSensorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorTypeByDetectorIdAndDetectorPositionArgs = {
  input: DeleteDetectorSensorTypeByDetectorIdAndDetectorPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorSensorTypeByIdArgs = {
  input: DeleteDetectorSensorTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorTypeArgs = {
  input: DeleteDetectorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorTypeByIdArgs = {
  input: DeleteDetectorTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDetectorTypeByPrefixAndCodeAndSuffixArgs = {
  input: DeleteDetectorTypeByPrefixAndCodeAndSuffixInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDpCardArgs = {
  input: DeleteDpCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDpCardByIdArgs = {
  input: DeleteDpCardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElectrolyteArgs = {
  input: DeleteElectrolyteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElectrolyteByIdArgs = {
  input: DeleteElectrolyteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElectrolyteByNameArgs = {
  input: DeleteElectrolyteByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEndUserArgs = {
  input: DeleteEndUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEndUserByIdArgs = {
  input: DeleteEndUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEndUserByNameAndLocationAndSubLocationArgs = {
  input: DeleteEndUserByNameAndLocationAndSubLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtArtikelExclusionArgs = {
  input: DeleteFactopdrachtArtikelExclusionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikelArgs = {
  input: DeleteFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtArtikelExclusionByIdArgs = {
  input: DeleteFactopdrachtArtikelExclusionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtregelLineArgs = {
  input: DeleteFactopdrachtregelLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtregelLineByFactopdrRglGuidArgs = {
  input: DeleteFactopdrachtregelLineByFactopdrRglGuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtregelLineByIdArgs = {
  input: DeleteFactopdrachtregelLineByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtregelLineDateArgs = {
  input: DeleteFactopdrachtregelLineDateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtregelLineDateByIdArgs = {
  input: DeleteFactopdrachtregelLineDateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtregelLineRemarkArgs = {
  input: DeleteFactopdrachtregelLineRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactopdrachtregelLineRemarkByIdArgs = {
  input: DeleteFactopdrachtregelLineRemarkByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactuurArgs = {
  input: DeleteFactuurInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactuurByFactuuropdrachtArgs = {
  input: DeleteFactuurByFactuuropdrachtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFactuurByIdArgs = {
  input: DeleteFactuurByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterArgs = {
  input: DeleteFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterByIdArgs = {
  input: DeleteFilterByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterByNameArgs = {
  input: DeleteFilterByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFloorArgs = {
  input: DeleteFloorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFloorByBuildingIdAndNameArgs = {
  input: DeleteFloorByBuildingIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFloorByIdArgs = {
  input: DeleteFloorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGasArgs = {
  input: DeleteGasInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGasByIdArgs = {
  input: DeleteGasByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGasByNameArgs = {
  input: DeleteGasByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByIdArgs = {
  input: DeleteGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupPermissionArgs = {
  input: DeleteGroupPermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupPermissionByGroupIdArgs = {
  input: DeleteGroupPermissionByGroupIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupPermissionByIdArgs = {
  input: DeleteGroupPermissionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupRightArgs = {
  input: DeleteGroupRightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupRightByGroupIdAndPathArgs = {
  input: DeleteGroupRightByGroupIdAndPathInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupRightByIdArgs = {
  input: DeleteGroupRightByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteHardwareArgs = {
  input: DeleteHardwareInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteHardwareByIdArgs = {
  input: DeleteHardwareByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteIncomingDocumentArgs = {
  input: DeleteIncomingDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteIncomingDocumentByIdArgs = {
  input: DeleteIncomingDocumentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInkoopgegevenArgs = {
  input: DeleteInkoopgegevenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInkoopgegevenByCdartikelAndInkvolgnrArgs = {
  input: DeleteInkoopgegevenByCdartikelAndInkvolgnrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInkoopgegevensLogArgs = {
  input: DeleteInkoopgegevensLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInkoopgegevensLogByIdArgs = {
  input: DeleteInkoopgegevensLogByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInkooporderregelLineArgs = {
  input: DeleteInkooporderregelLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInkooporderregelLineByIdArgs = {
  input: DeleteInkooporderregelLineByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInkooporderregelLineByInkopdrRglGuidArgs = {
  input: DeleteInkooporderregelLineByInkopdrRglGuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItemArgs = {
  input: DeleteItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItemByCdartikelAndSerialNumberArgs = {
  input: DeleteItemByCdartikelAndSerialNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteItemByIdArgs = {
  input: DeleteItemByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobArgs = {
  input: DeleteJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJobByIdArgs = {
  input: DeleteJobByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJunctionBoxArgs = {
  input: DeleteJunctionBoxInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteJunctionBoxByIdArgs = {
  input: DeleteJunctionBoxByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLandArgs = {
  input: DeleteLandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLandByCdlandArgs = {
  input: DeleteLandByCdlandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLeadArgs = {
  input: DeleteLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLeadByIdArgs = {
  input: DeleteLeadByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseArgs = {
  input: DeleteLicenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseByIdArgs = {
  input: DeleteLicenseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseCustomerArgs = {
  input: DeleteLicenseCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseCustomerByIdArgs = {
  input: DeleteLicenseCustomerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseModuleArgs = {
  input: DeleteLicenseModuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseModuleByIdArgs = {
  input: DeleteLicenseModuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseOrderArgs = {
  input: DeleteLicenseOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseOrderByIdArgs = {
  input: DeleteLicenseOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseOrderByLicenseIdAndFactuuropdrachtArgs = {
  input: DeleteLicenseOrderByLicenseIdAndFactuuropdrachtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseOrderByLicenseRegistrationIdAndFactuuropdrachtArgs = {
  input: DeleteLicenseOrderByLicenseRegistrationIdAndFactuuropdrachtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseRegistrationArgs = {
  input: DeleteLicenseRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLicenseRegistrationByIdArgs = {
  input: DeleteLicenseRegistrationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMaintenanceVisitArgs = {
  input: DeleteMaintenanceVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMaintenanceVisitByIdArgs = {
  input: DeleteMaintenanceVisitByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMaintenanceVisitLineArgs = {
  input: DeleteMaintenanceVisitLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMaintenanceVisitLineByIdArgs = {
  input: DeleteMaintenanceVisitLineByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationIdArgs = {
  input: DeleteMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMaintenanceVisitRemarkArgs = {
  input: DeleteMaintenanceVisitRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMaintenanceVisitRemarkByIdArgs = {
  input: DeleteMaintenanceVisitRemarkByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMaintenanceVisitRemarkByMaintenanceVisitIdAndLineArgs = {
  input: DeleteMaintenanceVisitRemarkByMaintenanceVisitIdAndLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMembraneArgs = {
  input: DeleteMembraneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMembraneByIdArgs = {
  input: DeleteMembraneByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMembraneByNameArgs = {
  input: DeleteMembraneByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteORingArgs = {
  input: DeleteORingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteORingByIdArgs = {
  input: DeleteORingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteORingByNameArgs = {
  input: DeleteORingByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOfferteRemarkArgs = {
  input: DeleteOfferteRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOfferteRemarkByIdArgs = {
  input: DeleteOfferteRemarkByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOfferteRemarkByOfferteIdArgs = {
  input: DeleteOfferteRemarkByOfferteIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOpportunityArgs = {
  input: DeleteOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOpportunityByIdArgs = {
  input: DeleteOpportunityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionArgs = {
  input: DeletePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionByIdArgs = {
  input: DeletePermissionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersoonRolArgs = {
  input: DeletePersoonRolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePersoonRolByPersoonRolGuidArgs = {
  input: DeletePersoonRolByPersoonRolGuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlugArgs = {
  input: DeletePlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlugByIdArgs = {
  input: DeletePlugByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlugByNameArgs = {
  input: DeletePlugByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePrincipleArgs = {
  input: DeletePrincipleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePrincipleByIdArgs = {
  input: DeletePrincipleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePrincipleByNameArgs = {
  input: DeletePrincipleByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductionArgs = {
  input: DeleteProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteProductionByIdArgs = {
  input: DeleteProductionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePyrolyserArgs = {
  input: DeletePyrolyserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePyrolyserByIdArgs = {
  input: DeletePyrolyserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePyrolyserByNameArgs = {
  input: DeletePyrolyserByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRangeArgs = {
  input: DeleteRangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRangeByIdArgs = {
  input: DeleteRangeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRangeByLowEuAndHighEuAndEngineeringUnitsAndGasIdArgs = {
  input: DeleteRangeByLowEuAndHighEuAndEngineeringUnitsAndGasIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRcCardArgs = {
  input: DeleteRcCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRcCardByIdArgs = {
  input: DeleteRcCardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRefreshTokenArgs = {
  input: DeleteRefreshTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRefreshTokenByIdArgs = {
  input: DeleteRefreshTokenByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportArgs = {
  input: DeleteReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportByFilenameArgs = {
  input: DeleteReportByFilenameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportByIdArgs = {
  input: DeleteReportByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportByTsrNumberAndVersionArgs = {
  input: DeleteReportByTsrNumberAndVersionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportDetectorArgs = {
  input: DeleteReportDetectorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportDetectorByIdArgs = {
  input: DeleteReportDetectorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportDetectorByReportIdAndDetectorIdArgs = {
  input: DeleteReportDetectorByReportIdAndDetectorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportItemArgs = {
  input: DeleteReportItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportItemByIdArgs = {
  input: DeleteReportItemByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportSensorArgs = {
  input: DeleteReportSensorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportSensorByIdArgs = {
  input: DeleteReportSensorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReportSensorByReportIdAndSensorIdArgs = {
  input: DeleteReportSensorByReportIdAndSensorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRequestArgs = {
  input: DeleteRequestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRequestByIdArgs = {
  input: DeleteRequestByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRxCardArgs = {
  input: DeleteRxCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteRxCardByIdArgs = {
  input: DeleteRxCardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSamplePointArgs = {
  input: DeleteSamplePointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSamplePointByAreaIdAndNameArgs = {
  input: DeleteSamplePointByAreaIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSamplePointByIdArgs = {
  input: DeleteSamplePointByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorArgs = {
  input: DeleteSensorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorBaseTypeArgs = {
  input: DeleteSensorBaseTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorBaseTypeByIdArgs = {
  input: DeleteSensorBaseTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorBaseTypeByPrefixAndSuffixArgs = {
  input: DeleteSensorBaseTypeByPrefixAndSuffixInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorByIdArgs = {
  input: DeleteSensorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorBySerialNumberAndSensorTypeIdArgs = {
  input: DeleteSensorBySerialNumberAndSensorTypeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementArgs = {
  input: DeleteSensorElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementByIdArgs = {
  input: DeleteSensorElementByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementLocationArgs = {
  input: DeleteSensorElementLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementLocationByIdArgs = {
  input: DeleteSensorElementLocationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementLocationBySensorElementIdArgs = {
  input: DeleteSensorElementLocationBySensorElementIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementLogArgs = {
  input: DeleteSensorElementLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementLogByIdArgs = {
  input: DeleteSensorElementLogByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementTypeArgs = {
  input: DeleteSensorElementTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorElementTypeByIdArgs = {
  input: DeleteSensorElementTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorOrderArgs = {
  input: DeleteSensorOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorOrderByIdArgs = {
  input: DeleteSensorOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorOrderBySensorIdAndFactuuropdrachtArgs = {
  input: DeleteSensorOrderBySensorIdAndFactuuropdrachtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorSensorElementArgs = {
  input: DeleteSensorSensorElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorSensorElementByIdArgs = {
  input: DeleteSensorSensorElementByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorSensorElementBySensorElementIdArgs = {
  input: DeleteSensorSensorElementBySensorElementIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorSensorElementBySensorIdAndSensorPositionArgs = {
  input: DeleteSensorSensorElementBySensorIdAndSensorPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorSettingArgs = {
  input: DeleteSensorSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorSettingByIdArgs = {
  input: DeleteSensorSettingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorSettingByTypeTargetArgs = {
  input: DeleteSensorSettingByTypeTargetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorTestResultArgs = {
  input: DeleteSensorTestResultInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorTestResultByIdArgs = {
  input: DeleteSensorTestResultByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorTypeArgs = {
  input: DeleteSensorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorTypeByIdArgs = {
  input: DeleteSensorTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserIdArgs = {
  input: DeleteSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSensorTypeBySensorTypeIdArgs = {
  input: DeleteSensorTypeBySensorTypeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSoftwareArgs = {
  input: DeleteSoftwareInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSoftwareByIdArgs = {
  input: DeleteSoftwareByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStockGroupArgs = {
  input: DeleteStockGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStockGroupByIdArgs = {
  input: DeleteStockGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStockItemArgs = {
  input: DeleteStockItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStockItemByIdArgs = {
  input: DeleteStockItemByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStockItemByStockGroupIdAndCdartikelArgs = {
  input: DeleteStockItemByStockGroupIdAndCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStockSupplierArgs = {
  input: DeleteStockSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStockSupplierByIdArgs = {
  input: DeleteStockSupplierByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTaskArgs = {
  input: DeleteTaskInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTaskByIdArgs = {
  input: DeleteTaskByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempFactopdrachtregelArgs = {
  input: DeleteTempFactopdrachtregelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempFactopdrachtregelByFactuuropdrachtAndFactuurregelArgs = {
  input: DeleteTempFactopdrachtregelByFactuuropdrachtAndFactuurregelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempFactopdrachtregelByIdArgs = {
  input: DeleteTempFactopdrachtregelByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempLicenseArgs = {
  input: DeleteTempLicenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempLicenseByIdArgs = {
  input: DeleteTempLicenseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempRegistrationArgs = {
  input: DeleteTempRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempRegistrationByIdArgs = {
  input: DeleteTempRegistrationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempRegistrationHistoryArgs = {
  input: DeleteTempRegistrationHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempRegistrationHistoryByIdArgs = {
  input: DeleteTempRegistrationHistoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempRegistrations2Args = {
  input: DeleteTempRegistrations2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTempRegistrations2ByIdArgs = {
  input: DeleteTempRegistrations2ByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTestArgs = {
  input: DeleteTestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTestByIdArgs = {
  input: DeleteTestByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByIdArgs = {
  input: DeleteUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserRightArgs = {
  input: DeleteUserRightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserRightByIdArgs = {
  input: DeleteUserRightByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserRightByUserIdAndPathArgs = {
  input: DeleteUserRightByUserIdAndPathInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserTaskArgs = {
  input: DeleteUserTaskInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserTaskByIdArgs = {
  input: DeleteUserTaskByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserTaskByUserIdAndTaskIdArgs = {
  input: DeleteUserTaskByUserIdAndTaskIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUsersGroupArgs = {
  input: DeleteUsersGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUsersGroupByIdArgs = {
  input: DeleteUsersGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUsersGroupByUserIdAndGroupIdArgs = {
  input: DeleteUsersGroupByUserIdAndGroupIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVoorradenArgs = {
  input: DeleteVoorradenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVoorradenByCdartikelAndCdmagazijnArgs = {
  input: DeleteVoorradenByCdartikelAndCdmagazijnInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVoorradenLogArgs = {
  input: DeleteVoorradenLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVoorradenLogByIdArgs = {
  input: DeleteVoorradenLogByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWeeklyHourArgs = {
  input: DeleteWeeklyHourInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWeeklyHourByIdArgs = {
  input: DeleteWeeklyHourByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWeeklyHourRemarkArgs = {
  input: DeleteWeeklyHourRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWeeklyHourRemarkByIdArgs = {
  input: DeleteWeeklyHourRemarkByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWeeklyHourRemarkByUserIdAndTaskIdAndDateArgs = {
  input: DeleteWeeklyHourRemarkByUserIdAndTaskIdAndDateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDueClassArgs = {
  input: DueClassInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationExchangeDetectorsArgs = {
  input: ExchangeDetectorsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationExchangeDetectorsByIdArgs = {
  input: ExchangeDetectorsByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationExchangeSensorsArgs = {
  input: ExchangeSensorsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationExchangeSensorsByIdArgs = {
  input: ExchangeSensorsByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationPc5109DSettingsArgs = {
  input: Pc5109DSettingsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationPc5154BSettingsArgs = {
  input: Pc5154BSettingsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationPc5155BSettingsArgs = {
  input: Pc5155BSettingsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAcoArgs = {
  input: UpdateAcoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAcoByIdArgs = {
  input: UpdateAcoByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionArgs = {
  input: UpdateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionByIdArgs = {
  input: UpdateActionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAdreArgs = {
  input: UpdateAdreInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAdreByAdresGuidArgs = {
  input: UpdateAdreByAdresGuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationArgs = {
  input: UpdateApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationByIdArgs = {
  input: UpdateApplicationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationByNameArgs = {
  input: UpdateApplicationByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAreaArgs = {
  input: UpdateAreaInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAreaByFloorIdAndNameArgs = {
  input: UpdateAreaByFloorIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAreaByIdArgs = {
  input: UpdateAreaByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAroArgs = {
  input: UpdateAroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAroByIdArgs = {
  input: UpdateAroByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateArosAcoArgs = {
  input: UpdateArosAcoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateArosAcoByIdArgs = {
  input: UpdateArosAcoByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateArtikelArgs = {
  input: UpdateArtikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateArtikelByCdartikelArgs = {
  input: UpdateArtikelByCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateArtikelLogArgs = {
  input: UpdateArtikelLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateArtikelLogByIdArgs = {
  input: UpdateArtikelLogByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateArtikelomschrArgs = {
  input: UpdateArtikelomschrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateArtikelomschrByCdartikelAndCdtaalArgs = {
  input: UpdateArtikelomschrByCdartikelAndCdtaalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetRoleArgs = {
  input: UpdateAspNetRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetRoleByIdArgs = {
  input: UpdateAspNetRoleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetRoleClaimArgs = {
  input: UpdateAspNetRoleClaimInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetRoleClaimByIdArgs = {
  input: UpdateAspNetRoleClaimByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserArgs = {
  input: UpdateAspNetUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserByIdArgs = {
  input: UpdateAspNetUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserClaimArgs = {
  input: UpdateAspNetUserClaimInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserClaimByIdArgs = {
  input: UpdateAspNetUserClaimByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserLoginArgs = {
  input: UpdateAspNetUserLoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserLoginByLoginProviderAndProviderKeyArgs = {
  input: UpdateAspNetUserLoginByLoginProviderAndProviderKeyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserRoleArgs = {
  input: UpdateAspNetUserRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserRoleByUserIdAndRoleIdArgs = {
  input: UpdateAspNetUserRoleByUserIdAndRoleIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserTokenArgs = {
  input: UpdateAspNetUserTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAspNetUserTokenByUserIdAndLoginProviderAndNameArgs = {
  input: UpdateAspNetUserTokenByUserIdAndLoginProviderAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyArgs = {
  input: UpdateAssemblyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyByCodeArgs = {
  input: UpdateAssemblyByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyByIdArgs = {
  input: UpdateAssemblyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyPartArgs = {
  input: UpdateAssemblyPartInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyPartByAssemblyIdAndCdartikelArgs = {
  input: UpdateAssemblyPartByAssemblyIdAndCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyPartByIdArgs = {
  input: UpdateAssemblyPartByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyTypeArgs = {
  input: UpdateAssemblyTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyTypeByIdArgs = {
  input: UpdateAssemblyTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyTypePartArgs = {
  input: UpdateAssemblyTypePartInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyTypePartByAssemblyTypeIdAndCdartikelArgs = {
  input: UpdateAssemblyTypePartByAssemblyTypeIdAndCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAssemblyTypePartByIdArgs = {
  input: UpdateAssemblyTypePartByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBuildingArgs = {
  input: UpdateBuildingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBuildingByEndUserIdAndNameArgs = {
  input: UpdateBuildingByEndUserIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBuildingByIdArgs = {
  input: UpdateBuildingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCalGasArgs = {
  input: UpdateCalGasInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCalGasByConcentrationAndEngineeringUnitsAndGasIdArgs = {
  input: UpdateCalGasByConcentrationAndEngineeringUnitsAndGasIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCalGasByIdArgs = {
  input: UpdateCalGasByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogGroupArgs = {
  input: UpdateCatalogGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogGroupByIdArgs = {
  input: UpdateCatalogGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogItemArgs = {
  input: UpdateCatalogItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogItemByIdArgs = {
  input: UpdateCatalogItemByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogItemFileArgs = {
  input: UpdateCatalogItemFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogItemFileByIdArgs = {
  input: UpdateCatalogItemFileByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogItemRelationArgs = {
  input: UpdateCatalogItemRelationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogItemRelationByIdArgs = {
  input: UpdateCatalogItemRelationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogSubGroupArgs = {
  input: UpdateCatalogSubGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCatalogSubGroupByIdArgs = {
  input: UpdateCatalogSubGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChemicalCompoundArgs = {
  input: UpdateChemicalCompoundInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateChemicalCompoundByIdArgs = {
  input: UpdateChemicalCompoundByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorArgs = {
  input: UpdateDetectorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorAndSensorsArgs = {
  input: UpdateDetectorAndSensorsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorByIdArgs = {
  input: UpdateDetectorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorBySerialNumberAndDetectorTypeIdArgs = {
  input: UpdateDetectorBySerialNumberAndDetectorTypeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorLocationArgs = {
  input: UpdateDetectorLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorLocationByDetectorIdArgs = {
  input: UpdateDetectorLocationByDetectorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorLocationByIdArgs = {
  input: UpdateDetectorLocationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorOrderArgs = {
  input: UpdateDetectorOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorOrderByFactuuropdrachtAndDetectorIdArgs = {
  input: UpdateDetectorOrderByFactuuropdrachtAndDetectorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorOrderByIdArgs = {
  input: UpdateDetectorOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorArgs = {
  input: UpdateDetectorSensorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorByDetectorIdAndDetectorPositionArgs = {
  input: UpdateDetectorSensorByDetectorIdAndDetectorPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorByIdArgs = {
  input: UpdateDetectorSensorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorBySensorIdArgs = {
  input: UpdateDetectorSensorBySensorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorLocationArgs = {
  input: UpdateDetectorSensorLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorLocationByDetectorSensorIdArgs = {
  input: UpdateDetectorSensorLocationByDetectorSensorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorLocationByIdArgs = {
  input: UpdateDetectorSensorLocationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorLocationByLicenseIdAndSimsChannelArgs = {
  input: UpdateDetectorSensorLocationByLicenseIdAndSimsChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorTypeArgs = {
  input: UpdateDetectorSensorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorTypeByDetectorIdAndDetectorPositionArgs = {
  input: UpdateDetectorSensorTypeByDetectorIdAndDetectorPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorSensorTypeByIdArgs = {
  input: UpdateDetectorSensorTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorTypeArgs = {
  input: UpdateDetectorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorTypeByIdArgs = {
  input: UpdateDetectorTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDetectorTypeByPrefixAndCodeAndSuffixArgs = {
  input: UpdateDetectorTypeByPrefixAndCodeAndSuffixInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDpCardArgs = {
  input: UpdateDpCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDpCardByIdArgs = {
  input: UpdateDpCardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElectrolyteArgs = {
  input: UpdateElectrolyteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElectrolyteByIdArgs = {
  input: UpdateElectrolyteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElectrolyteByNameArgs = {
  input: UpdateElectrolyteByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEndUserArgs = {
  input: UpdateEndUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEndUserByIdArgs = {
  input: UpdateEndUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEndUserByNameAndLocationAndSubLocationArgs = {
  input: UpdateEndUserByNameAndLocationAndSubLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtArtikelExclusionArgs = {
  input: UpdateFactopdrachtArtikelExclusionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikelArgs = {
  input: UpdateFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtArtikelExclusionByIdArgs = {
  input: UpdateFactopdrachtArtikelExclusionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtregelLineArgs = {
  input: UpdateFactopdrachtregelLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtregelLineByFactopdrRglGuidArgs = {
  input: UpdateFactopdrachtregelLineByFactopdrRglGuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtregelLineByIdArgs = {
  input: UpdateFactopdrachtregelLineByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtregelLineDateArgs = {
  input: UpdateFactopdrachtregelLineDateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtregelLineDateByIdArgs = {
  input: UpdateFactopdrachtregelLineDateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtregelLineRemarkArgs = {
  input: UpdateFactopdrachtregelLineRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactopdrachtregelLineRemarkByIdArgs = {
  input: UpdateFactopdrachtregelLineRemarkByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactuurArgs = {
  input: UpdateFactuurInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactuurByFactuuropdrachtArgs = {
  input: UpdateFactuurByFactuuropdrachtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFactuurByIdArgs = {
  input: UpdateFactuurByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterArgs = {
  input: UpdateFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterByIdArgs = {
  input: UpdateFilterByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterByNameArgs = {
  input: UpdateFilterByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFloorArgs = {
  input: UpdateFloorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFloorByBuildingIdAndNameArgs = {
  input: UpdateFloorByBuildingIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFloorByIdArgs = {
  input: UpdateFloorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGasArgs = {
  input: UpdateGasInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGasByIdArgs = {
  input: UpdateGasByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGasByNameArgs = {
  input: UpdateGasByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByIdArgs = {
  input: UpdateGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupPermissionArgs = {
  input: UpdateGroupPermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupPermissionByGroupIdArgs = {
  input: UpdateGroupPermissionByGroupIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupPermissionByIdArgs = {
  input: UpdateGroupPermissionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupRightArgs = {
  input: UpdateGroupRightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupRightByGroupIdAndPathArgs = {
  input: UpdateGroupRightByGroupIdAndPathInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupRightByIdArgs = {
  input: UpdateGroupRightByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateHardwareArgs = {
  input: UpdateHardwareInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateHardwareByIdArgs = {
  input: UpdateHardwareByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateIncomingDocumentArgs = {
  input: UpdateIncomingDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateIncomingDocumentByIdArgs = {
  input: UpdateIncomingDocumentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInkoopgegevenArgs = {
  input: UpdateInkoopgegevenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInkoopgegevenByCdartikelAndInkvolgnrArgs = {
  input: UpdateInkoopgegevenByCdartikelAndInkvolgnrInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInkoopgegevensLogArgs = {
  input: UpdateInkoopgegevensLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInkoopgegevensLogByIdArgs = {
  input: UpdateInkoopgegevensLogByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInkooporderregelLineArgs = {
  input: UpdateInkooporderregelLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInkooporderregelLineByIdArgs = {
  input: UpdateInkooporderregelLineByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInkooporderregelLineByInkopdrRglGuidArgs = {
  input: UpdateInkooporderregelLineByInkopdrRglGuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItemArgs = {
  input: UpdateItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItemByCdartikelAndSerialNumberArgs = {
  input: UpdateItemByCdartikelAndSerialNumberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateItemByIdArgs = {
  input: UpdateItemByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobArgs = {
  input: UpdateJobInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJobByIdArgs = {
  input: UpdateJobByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJunctionBoxArgs = {
  input: UpdateJunctionBoxInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateJunctionBoxByIdArgs = {
  input: UpdateJunctionBoxByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLandArgs = {
  input: UpdateLandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLandByCdlandArgs = {
  input: UpdateLandByCdlandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLeadArgs = {
  input: UpdateLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLeadByIdArgs = {
  input: UpdateLeadByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseArgs = {
  input: UpdateLicenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseByIdArgs = {
  input: UpdateLicenseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseCustomerArgs = {
  input: UpdateLicenseCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseCustomerByIdArgs = {
  input: UpdateLicenseCustomerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseModuleArgs = {
  input: UpdateLicenseModuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseModuleByIdArgs = {
  input: UpdateLicenseModuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseOrderArgs = {
  input: UpdateLicenseOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseOrderByIdArgs = {
  input: UpdateLicenseOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseOrderByLicenseIdAndFactuuropdrachtArgs = {
  input: UpdateLicenseOrderByLicenseIdAndFactuuropdrachtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseOrderByLicenseRegistrationIdAndFactuuropdrachtArgs = {
  input: UpdateLicenseOrderByLicenseRegistrationIdAndFactuuropdrachtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseRegistrationArgs = {
  input: UpdateLicenseRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLicenseRegistrationByIdArgs = {
  input: UpdateLicenseRegistrationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMaintenanceVisitArgs = {
  input: UpdateMaintenanceVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMaintenanceVisitByIdArgs = {
  input: UpdateMaintenanceVisitByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMaintenanceVisitLineArgs = {
  input: UpdateMaintenanceVisitLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMaintenanceVisitLineByIdArgs = {
  input: UpdateMaintenanceVisitLineByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationIdArgs = {
  input: UpdateMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMaintenanceVisitRemarkArgs = {
  input: UpdateMaintenanceVisitRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMaintenanceVisitRemarkByIdArgs = {
  input: UpdateMaintenanceVisitRemarkByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMaintenanceVisitRemarkByMaintenanceVisitIdAndLineArgs = {
  input: UpdateMaintenanceVisitRemarkByMaintenanceVisitIdAndLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMembraneArgs = {
  input: UpdateMembraneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMembraneByIdArgs = {
  input: UpdateMembraneByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMembraneByNameArgs = {
  input: UpdateMembraneByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateORingArgs = {
  input: UpdateORingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateORingByIdArgs = {
  input: UpdateORingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateORingByNameArgs = {
  input: UpdateORingByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOfferteRemarkArgs = {
  input: UpdateOfferteRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOfferteRemarkByIdArgs = {
  input: UpdateOfferteRemarkByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOfferteRemarkByOfferteIdArgs = {
  input: UpdateOfferteRemarkByOfferteIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOpportunityArgs = {
  input: UpdateOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOpportunityByIdArgs = {
  input: UpdateOpportunityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionArgs = {
  input: UpdatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionByIdArgs = {
  input: UpdatePermissionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersoonRolArgs = {
  input: UpdatePersoonRolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePersoonRolByPersoonRolGuidArgs = {
  input: UpdatePersoonRolByPersoonRolGuidInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlugArgs = {
  input: UpdatePlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlugByIdArgs = {
  input: UpdatePlugByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlugByNameArgs = {
  input: UpdatePlugByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePrincipleArgs = {
  input: UpdatePrincipleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePrincipleByIdArgs = {
  input: UpdatePrincipleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePrincipleByNameArgs = {
  input: UpdatePrincipleByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductionArgs = {
  input: UpdateProductionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateProductionByIdArgs = {
  input: UpdateProductionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePyrolyserArgs = {
  input: UpdatePyrolyserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePyrolyserByIdArgs = {
  input: UpdatePyrolyserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePyrolyserByNameArgs = {
  input: UpdatePyrolyserByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRangeArgs = {
  input: UpdateRangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRangeByIdArgs = {
  input: UpdateRangeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRangeByLowEuAndHighEuAndEngineeringUnitsAndGasIdArgs = {
  input: UpdateRangeByLowEuAndHighEuAndEngineeringUnitsAndGasIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRcCardArgs = {
  input: UpdateRcCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRcCardByIdArgs = {
  input: UpdateRcCardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRefreshTokenArgs = {
  input: UpdateRefreshTokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRefreshTokenByIdArgs = {
  input: UpdateRefreshTokenByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportArgs = {
  input: UpdateReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportByFilenameArgs = {
  input: UpdateReportByFilenameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportByIdArgs = {
  input: UpdateReportByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportByTsrNumberAndVersionArgs = {
  input: UpdateReportByTsrNumberAndVersionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportDetectorArgs = {
  input: UpdateReportDetectorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportDetectorByIdArgs = {
  input: UpdateReportDetectorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportDetectorByReportIdAndDetectorIdArgs = {
  input: UpdateReportDetectorByReportIdAndDetectorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportItemArgs = {
  input: UpdateReportItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportItemByIdArgs = {
  input: UpdateReportItemByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportSensorArgs = {
  input: UpdateReportSensorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportSensorByIdArgs = {
  input: UpdateReportSensorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReportSensorByReportIdAndSensorIdArgs = {
  input: UpdateReportSensorByReportIdAndSensorIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRequestArgs = {
  input: UpdateRequestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRequestByIdArgs = {
  input: UpdateRequestByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRxCardArgs = {
  input: UpdateRxCardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateRxCardByIdArgs = {
  input: UpdateRxCardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSamplePointArgs = {
  input: UpdateSamplePointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSamplePointByAreaIdAndNameArgs = {
  input: UpdateSamplePointByAreaIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSamplePointByIdArgs = {
  input: UpdateSamplePointByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorArgs = {
  input: UpdateSensorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorBaseTypeArgs = {
  input: UpdateSensorBaseTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorBaseTypeByIdArgs = {
  input: UpdateSensorBaseTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorBaseTypeByPrefixAndSuffixArgs = {
  input: UpdateSensorBaseTypeByPrefixAndSuffixInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorByIdArgs = {
  input: UpdateSensorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorBySerialNumberAndSensorTypeIdArgs = {
  input: UpdateSensorBySerialNumberAndSensorTypeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementArgs = {
  input: UpdateSensorElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementByIdArgs = {
  input: UpdateSensorElementByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementLocationArgs = {
  input: UpdateSensorElementLocationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementLocationByIdArgs = {
  input: UpdateSensorElementLocationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementLocationBySensorElementIdArgs = {
  input: UpdateSensorElementLocationBySensorElementIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementLogArgs = {
  input: UpdateSensorElementLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementLogByIdArgs = {
  input: UpdateSensorElementLogByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementTypeArgs = {
  input: UpdateSensorElementTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorElementTypeByIdArgs = {
  input: UpdateSensorElementTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorOrderArgs = {
  input: UpdateSensorOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorOrderByIdArgs = {
  input: UpdateSensorOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorOrderBySensorIdAndFactuuropdrachtArgs = {
  input: UpdateSensorOrderBySensorIdAndFactuuropdrachtInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorSensorElementArgs = {
  input: UpdateSensorSensorElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorSensorElementByIdArgs = {
  input: UpdateSensorSensorElementByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorSensorElementBySensorElementIdArgs = {
  input: UpdateSensorSensorElementBySensorElementIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorSensorElementBySensorIdAndSensorPositionArgs = {
  input: UpdateSensorSensorElementBySensorIdAndSensorPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorSettingArgs = {
  input: UpdateSensorSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorSettingByIdArgs = {
  input: UpdateSensorSettingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorSettingByTypeTargetArgs = {
  input: UpdateSensorSettingByTypeTargetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorTestResultArgs = {
  input: UpdateSensorTestResultInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorTestResultByIdArgs = {
  input: UpdateSensorTestResultByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorTypeArgs = {
  input: UpdateSensorTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorTypeByIdArgs = {
  input: UpdateSensorTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserIdArgs = {
  input: UpdateSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSensorTypeBySensorTypeIdArgs = {
  input: UpdateSensorTypeBySensorTypeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSoftwareArgs = {
  input: UpdateSoftwareInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSoftwareByIdArgs = {
  input: UpdateSoftwareByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStockGroupArgs = {
  input: UpdateStockGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStockGroupByIdArgs = {
  input: UpdateStockGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStockItemArgs = {
  input: UpdateStockItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStockItemByIdArgs = {
  input: UpdateStockItemByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStockItemByStockGroupIdAndCdartikelArgs = {
  input: UpdateStockItemByStockGroupIdAndCdartikelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStockSupplierArgs = {
  input: UpdateStockSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStockSupplierByIdArgs = {
  input: UpdateStockSupplierByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTaskArgs = {
  input: UpdateTaskInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTaskByIdArgs = {
  input: UpdateTaskByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempFactopdrachtregelArgs = {
  input: UpdateTempFactopdrachtregelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempFactopdrachtregelByFactuuropdrachtAndFactuurregelArgs = {
  input: UpdateTempFactopdrachtregelByFactuuropdrachtAndFactuurregelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempFactopdrachtregelByIdArgs = {
  input: UpdateTempFactopdrachtregelByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempLicenseArgs = {
  input: UpdateTempLicenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempLicenseByIdArgs = {
  input: UpdateTempLicenseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempRegistrationArgs = {
  input: UpdateTempRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempRegistrationByIdArgs = {
  input: UpdateTempRegistrationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempRegistrationHistoryArgs = {
  input: UpdateTempRegistrationHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempRegistrationHistoryByIdArgs = {
  input: UpdateTempRegistrationHistoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempRegistrations2Args = {
  input: UpdateTempRegistrations2Input;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTempRegistrations2ByIdArgs = {
  input: UpdateTempRegistrations2ByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTestArgs = {
  input: UpdateTestInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTestByIdArgs = {
  input: UpdateTestByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByIdArgs = {
  input: UpdateUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserGroupsArgs = {
  input: UpdateUserGroupsInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserRightArgs = {
  input: UpdateUserRightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserRightByIdArgs = {
  input: UpdateUserRightByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserRightByUserIdAndPathArgs = {
  input: UpdateUserRightByUserIdAndPathInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserTaskArgs = {
  input: UpdateUserTaskInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserTaskByIdArgs = {
  input: UpdateUserTaskByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserTaskByUserIdAndTaskIdArgs = {
  input: UpdateUserTaskByUserIdAndTaskIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVoorradenArgs = {
  input: UpdateVoorradenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVoorradenByCdartikelAndCdmagazijnArgs = {
  input: UpdateVoorradenByCdartikelAndCdmagazijnInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVoorradenLogArgs = {
  input: UpdateVoorradenLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVoorradenLogByIdArgs = {
  input: UpdateVoorradenLogByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWeeklyHourArgs = {
  input: UpdateWeeklyHourInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWeeklyHourByIdArgs = {
  input: UpdateWeeklyHourByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWeeklyHourRemarkArgs = {
  input: UpdateWeeklyHourRemarkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWeeklyHourRemarkByIdArgs = {
  input: UpdateWeeklyHourRemarkByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateWeeklyHourRemarkByUserIdAndTaskIdAndDateArgs = {
  input: UpdateWeeklyHourRemarkByUserIdAndTaskIdAndDateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpsertDetectorSensorBySensorIdArgs = {
  input: UpsertDetectorSensorBySensorIdInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** A connection to a list of `Notity` values. */
export type NotitiesConnection = {
  __typename?: 'NotitiesConnection';
  /** A list of edges which contains the `Notity` and cursor to aid in pagination. */
  edges: Array<NotitiesEdge>;
  /** A list of `Notity` objects. */
  nodes: Array<Notity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Notity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Notity` edge in the connection. */
export type NotitiesEdge = {
  __typename?: 'NotitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Notity` at the end of the edge. */
  node: Notity;
};

export type NotitiesMv = {
  __typename?: 'NotitiesMv';
  afgehandeld?: Maybe<Scalars['String']['output']>;
  aktiedatum?: Maybe<Scalars['Date']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cdnotitie?: Maybe<Scalars['Int']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdsoort?: Maybe<Scalars['String']['output']>;
  datum?: Maybe<Scalars['Date']['output']>;
  docVolgnummer?: Maybe<Scalars['Int']['output']>;
  document?: Maybe<Scalars['String']['output']>;
  gebruiker?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  guidItemHerkomst?: Maybe<Scalars['String']['output']>;
  guidWfProces?: Maybe<Scalars['String']['output']>;
  guidWfWorkflow?: Maybe<Scalars['String']['output']>;
  herkomst?: Maybe<Scalars['String']['output']>;
  onderwerp?: Maybe<Scalars['String']['output']>;
  sellijstid?: Maybe<Scalars['Int']['output']>;
  tekst?: Maybe<Scalars['String']['output']>;
  wfTabelnaam?: Maybe<Scalars['String']['output']>;
  wfTabelnaamHerkomst?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `NotitiesMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type NotitiesMvCondition = {
  /** Checks for equality with the object’s `afgehandeld` field. */
  afgehandeld?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `aktiedatum` field. */
  aktiedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdnotitie` field. */
  cdnotitie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datum` field. */
  datum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `docVolgnummer` field. */
  docVolgnummer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `document` field. */
  document?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gebruiker` field. */
  gebruiker?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItemHerkomst` field. */
  guidItemHerkomst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidWfProces` field. */
  guidWfProces?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidWfWorkflow` field. */
  guidWfWorkflow?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `herkomst` field. */
  herkomst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `onderwerp` field. */
  onderwerp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sellijstid` field. */
  sellijstid?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tekst` field. */
  tekst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `wfTabelnaam` field. */
  wfTabelnaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `wfTabelnaamHerkomst` field. */
  wfTabelnaamHerkomst?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `NotitiesMv` object types. All fields are combined with a logical ‘and.’ */
export type NotitiesMvFilter = {
  /** Filter by the object’s `afgehandeld` field. */
  afgehandeld?: InputMaybe<StringFilter>;
  /** Filter by the object’s `aktiedatum` field. */
  aktiedatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<NotitiesMvFilter>>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdnotitie` field. */
  cdnotitie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datum` field. */
  datum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `docVolgnummer` field. */
  docVolgnummer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `document` field. */
  document?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gebruiker` field. */
  gebruiker?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItemHerkomst` field. */
  guidItemHerkomst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidWfProces` field. */
  guidWfProces?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidWfWorkflow` field. */
  guidWfWorkflow?: InputMaybe<StringFilter>;
  /** Filter by the object’s `herkomst` field. */
  herkomst?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<NotitiesMvFilter>;
  /** Filter by the object’s `onderwerp` field. */
  onderwerp?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<NotitiesMvFilter>>;
  /** Filter by the object’s `sellijstid` field. */
  sellijstid?: InputMaybe<IntFilter>;
  /** Filter by the object’s `tekst` field. */
  tekst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `wfTabelnaam` field. */
  wfTabelnaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `wfTabelnaamHerkomst` field. */
  wfTabelnaamHerkomst?: InputMaybe<StringFilter>;
};

/** A connection to a list of `NotitiesMv` values. */
export type NotitiesMvsConnection = {
  __typename?: 'NotitiesMvsConnection';
  /** A list of edges which contains the `NotitiesMv` and cursor to aid in pagination. */
  edges: Array<NotitiesMvsEdge>;
  /** A list of `NotitiesMv` objects. */
  nodes: Array<NotitiesMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `NotitiesMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `NotitiesMv` edge in the connection. */
export type NotitiesMvsEdge = {
  __typename?: 'NotitiesMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `NotitiesMv` at the end of the edge. */
  node: NotitiesMv;
};

/** Methods to use when ordering `NotitiesMv`. */
export enum NotitiesMvsOrderBy {
  AfgehandeldAsc = 'AFGEHANDELD_ASC',
  AfgehandeldDesc = 'AFGEHANDELD_DESC',
  AktiedatumAsc = 'AKTIEDATUM_ASC',
  AktiedatumDesc = 'AKTIEDATUM_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CdnotitieAsc = 'CDNOTITIE_ASC',
  CdnotitieDesc = 'CDNOTITIE_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdsoortAsc = 'CDSOORT_ASC',
  CdsoortDesc = 'CDSOORT_DESC',
  DatumAsc = 'DATUM_ASC',
  DatumDesc = 'DATUM_DESC',
  DocumentAsc = 'DOCUMENT_ASC',
  DocumentDesc = 'DOCUMENT_DESC',
  DocVolgnummerAsc = 'DOC_VOLGNUMMER_ASC',
  DocVolgnummerDesc = 'DOC_VOLGNUMMER_DESC',
  GebruikerAsc = 'GEBRUIKER_ASC',
  GebruikerDesc = 'GEBRUIKER_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  GuidItemHerkomstAsc = 'GUID_ITEM_HERKOMST_ASC',
  GuidItemHerkomstDesc = 'GUID_ITEM_HERKOMST_DESC',
  GuidWfProcesAsc = 'GUID_WF_PROCES_ASC',
  GuidWfProcesDesc = 'GUID_WF_PROCES_DESC',
  GuidWfWorkflowAsc = 'GUID_WF_WORKFLOW_ASC',
  GuidWfWorkflowDesc = 'GUID_WF_WORKFLOW_DESC',
  HerkomstAsc = 'HERKOMST_ASC',
  HerkomstDesc = 'HERKOMST_DESC',
  Natural = 'NATURAL',
  OnderwerpAsc = 'ONDERWERP_ASC',
  OnderwerpDesc = 'ONDERWERP_DESC',
  SellijstidAsc = 'SELLIJSTID_ASC',
  SellijstidDesc = 'SELLIJSTID_DESC',
  TekstAsc = 'TEKST_ASC',
  TekstDesc = 'TEKST_DESC',
  WfTabelnaamAsc = 'WF_TABELNAAM_ASC',
  WfTabelnaamDesc = 'WF_TABELNAAM_DESC',
  WfTabelnaamHerkomstAsc = 'WF_TABELNAAM_HERKOMST_ASC',
  WfTabelnaamHerkomstDesc = 'WF_TABELNAAM_HERKOMST_DESC'
}

/** Methods to use when ordering `Notity`. */
export enum NotitiesOrderBy {
  AfgehandeldAsc = 'AFGEHANDELD_ASC',
  AfgehandeldDesc = 'AFGEHANDELD_DESC',
  AktiedatumAsc = 'AKTIEDATUM_ASC',
  AktiedatumDesc = 'AKTIEDATUM_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CdnotitieAsc = 'CDNOTITIE_ASC',
  CdnotitieDesc = 'CDNOTITIE_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdsoortAsc = 'CDSOORT_ASC',
  CdsoortDesc = 'CDSOORT_DESC',
  DatumAsc = 'DATUM_ASC',
  DatumDesc = 'DATUM_DESC',
  DocumentAsc = 'DOCUMENT_ASC',
  DocumentDesc = 'DOCUMENT_DESC',
  DocVolgnummerAsc = 'DOC_VOLGNUMMER_ASC',
  DocVolgnummerDesc = 'DOC_VOLGNUMMER_DESC',
  GebruikerAsc = 'GEBRUIKER_ASC',
  GebruikerDesc = 'GEBRUIKER_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  GuidItemHerkomstAsc = 'GUID_ITEM_HERKOMST_ASC',
  GuidItemHerkomstDesc = 'GUID_ITEM_HERKOMST_DESC',
  GuidWfProcesAsc = 'GUID_WF_PROCES_ASC',
  GuidWfProcesDesc = 'GUID_WF_PROCES_DESC',
  GuidWfWorkflowAsc = 'GUID_WF_WORKFLOW_ASC',
  GuidWfWorkflowDesc = 'GUID_WF_WORKFLOW_DESC',
  HerkomstAsc = 'HERKOMST_ASC',
  HerkomstDesc = 'HERKOMST_DESC',
  Natural = 'NATURAL',
  OnderwerpAsc = 'ONDERWERP_ASC',
  OnderwerpDesc = 'ONDERWERP_DESC',
  SellijstidAsc = 'SELLIJSTID_ASC',
  SellijstidDesc = 'SELLIJSTID_DESC',
  TekstAsc = 'TEKST_ASC',
  TekstDesc = 'TEKST_DESC',
  WfTabelnaamAsc = 'WF_TABELNAAM_ASC',
  WfTabelnaamDesc = 'WF_TABELNAAM_DESC',
  WfTabelnaamHerkomstAsc = 'WF_TABELNAAM_HERKOMST_ASC',
  WfTabelnaamHerkomstDesc = 'WF_TABELNAAM_HERKOMST_DESC'
}

export type Notity = {
  __typename?: 'Notity';
  afgehandeld?: Maybe<Scalars['String']['output']>;
  aktiedatum?: Maybe<Scalars['Date']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cdnotitie?: Maybe<Scalars['Int']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdsoort?: Maybe<Scalars['String']['output']>;
  datum?: Maybe<Scalars['Date']['output']>;
  docVolgnummer?: Maybe<Scalars['Int']['output']>;
  document?: Maybe<Scalars['String']['output']>;
  gebruiker?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  guidItemHerkomst?: Maybe<Scalars['String']['output']>;
  guidWfProces?: Maybe<Scalars['String']['output']>;
  guidWfWorkflow?: Maybe<Scalars['String']['output']>;
  herkomst?: Maybe<Scalars['String']['output']>;
  onderwerp?: Maybe<Scalars['String']['output']>;
  sellijstid?: Maybe<Scalars['Int']['output']>;
  tekst?: Maybe<Scalars['String']['output']>;
  wfTabelnaam?: Maybe<Scalars['String']['output']>;
  wfTabelnaamHerkomst?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Notity` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NotityCondition = {
  /** Checks for equality with the object’s `afgehandeld` field. */
  afgehandeld?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `aktiedatum` field. */
  aktiedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdnotitie` field. */
  cdnotitie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datum` field. */
  datum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `docVolgnummer` field. */
  docVolgnummer?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `document` field. */
  document?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gebruiker` field. */
  gebruiker?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItemHerkomst` field. */
  guidItemHerkomst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidWfProces` field. */
  guidWfProces?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidWfWorkflow` field. */
  guidWfWorkflow?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `herkomst` field. */
  herkomst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `onderwerp` field. */
  onderwerp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sellijstid` field. */
  sellijstid?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tekst` field. */
  tekst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `wfTabelnaam` field. */
  wfTabelnaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `wfTabelnaamHerkomst` field. */
  wfTabelnaamHerkomst?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Notity` object types. All fields are combined with a logical ‘and.’ */
export type NotityFilter = {
  /** Filter by the object’s `afgehandeld` field. */
  afgehandeld?: InputMaybe<StringFilter>;
  /** Filter by the object’s `aktiedatum` field. */
  aktiedatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<NotityFilter>>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdnotitie` field. */
  cdnotitie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datum` field. */
  datum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `docVolgnummer` field. */
  docVolgnummer?: InputMaybe<IntFilter>;
  /** Filter by the object’s `document` field. */
  document?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gebruiker` field. */
  gebruiker?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItemHerkomst` field. */
  guidItemHerkomst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidWfProces` field. */
  guidWfProces?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidWfWorkflow` field. */
  guidWfWorkflow?: InputMaybe<StringFilter>;
  /** Filter by the object’s `herkomst` field. */
  herkomst?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<NotityFilter>;
  /** Filter by the object’s `onderwerp` field. */
  onderwerp?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<NotityFilter>>;
  /** Filter by the object’s `sellijstid` field. */
  sellijstid?: InputMaybe<IntFilter>;
  /** Filter by the object’s `tekst` field. */
  tekst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `wfTabelnaam` field. */
  wfTabelnaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `wfTabelnaamHerkomst` field. */
  wfTabelnaamHerkomst?: InputMaybe<StringFilter>;
};

export type ORing = Node & {
  __typename?: 'ORing';
  cdartikel: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByORingId: SensorTypesConnection;
  /** Reads a single `User` that is related to this `ORing`. */
  userByOwnerId?: Maybe<User>;
};


export type ORingSensorTypesByORingIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/** A condition to be used against `ORing` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ORingCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ORingEntity` values. */
export type ORingEntitiesConnection = {
  __typename?: 'ORingEntitiesConnection';
  /** A list of edges which contains the `ORingEntity` and cursor to aid in pagination. */
  edges: Array<ORingEntitiesEdge>;
  /** A list of `ORingEntity` objects. */
  nodes: Array<ORingEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ORingEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ORingEntity` edge in the connection. */
export type ORingEntitiesEdge = {
  __typename?: 'ORingEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ORingEntity` at the end of the edge. */
  node: ORingEntity;
};

/** Methods to use when ordering `ORingEntity`. */
export enum ORingEntitiesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC'
}

export type ORingEntity = {
  __typename?: 'ORingEntity';
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `ORingEntity` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ORingEntityCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ORingEntity` object types. All fields are combined with a logical ‘and.’ */
export type ORingEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ORingEntityFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ORingEntityFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ORingEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
};

/** A filter to be used against `ORing` object types. All fields are combined with a logical ‘and.’ */
export type ORingFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ORingFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ORingFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ORingFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypesByORingId` relation. */
  sensorTypesByORingId?: InputMaybe<ORingToManySensorTypeFilter>;
  /** Some related `sensorTypesByORingId` exist. */
  sensorTypesByORingIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `ORing` */
export type ORingInput = {
  cdartikel: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `ORing`. Fields that are set will be updated. */
export type ORingPatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type ORingToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `ORing` values. */
export type ORingsConnection = {
  __typename?: 'ORingsConnection';
  /** A list of edges which contains the `ORing` and cursor to aid in pagination. */
  edges: Array<ORingsEdge>;
  /** A list of `ORing` objects. */
  nodes: Array<ORing>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ORing` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ORing` edge in the connection. */
export type ORingsEdge = {
  __typename?: 'ORingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ORing` at the end of the edge. */
  node: ORing;
};

/** Methods to use when ordering `ORing`. */
export enum ORingsOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorTypesByORingIdCountAsc = 'SENSOR_TYPES_BY_O_RING_ID__COUNT_ASC',
  SensorTypesByORingIdCountDesc = 'SENSOR_TYPES_BY_O_RING_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Offerte = {
  __typename?: 'Offerte';
  adres?: Maybe<Scalars['String']['output']>;
  afdrukteller?: Maybe<Scalars['Int']['output']>;
  behandelddoor?: Maybe<Scalars['String']['output']>;
  betkortperc?: Maybe<Scalars['BigFloat']['output']>;
  btwscenario?: Maybe<Scalars['Int']['output']>;
  cdadres?: Maybe<Scalars['Int']['output']>;
  cdbehandelddoor?: Maybe<Scalars['String']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdbtw?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cdfiatteur?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdreden?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdsoort?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  datumafwijzing?: Maybe<Scalars['Date']['output']>;
  gefiatteerd?: Maybe<Scalars['String']['output']>;
  geldigtm?: Maybe<Scalars['Date']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  kans?: Maybe<Scalars['BigFloat']['output']>;
  koptekst?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kredbepperc?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  margeblokkade?: Maybe<Scalars['String']['output']>;
  notitieafwijzing?: Maybe<Scalars['String']['output']>;
  offertedatum?: Maybe<Scalars['Date']['output']>;
  offertenummer?: Maybe<Scalars['String']['output']>;
  offertevolgnr?: Maybe<Scalars['Int']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  projOfferte?: Maybe<Scalars['String']['output']>;
  projOmschr?: Maybe<Scalars['String']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  subadres?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  verlorenaan?: Maybe<Scalars['String']['output']>;
  vertegenwoordiger?: Maybe<Scalars['String']['output']>;
  voettekst?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Offerte` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type OfferteCondition = {
  /** Checks for equality with the object’s `adres` field. */
  adres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `betkortperc` field. */
  betkortperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdadres` field. */
  cdadres?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbtw` field. */
  cdbtw?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdreden` field. */
  cdreden?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumafwijzing` field. */
  datumafwijzing?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geldigtm` field. */
  geldigtm?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kans` field. */
  kans?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `koptekst` field. */
  koptekst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kredbepperc` field. */
  kredbepperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margeblokkade` field. */
  margeblokkade?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `notitieafwijzing` field. */
  notitieafwijzing?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertedatum` field. */
  offertedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projOfferte` field. */
  projOfferte?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projOmschr` field. */
  projOmschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `subadres` field. */
  subadres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verlorenaan` field. */
  verlorenaan?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voettekst` field. */
  voettekst?: InputMaybe<Scalars['String']['input']>;
};

export type OfferteCsv = {
  __typename?: 'OfferteCsv';
  actionDate?: Maybe<Scalars['Date']['output']>;
  actions?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['Int']['output']>;
  chance?: Maybe<Scalars['Int']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  companyCode?: Maybe<Scalars['Int']['output']>;
  competitors?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  countryCode?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['Date']['output']>;
  decisionDate?: Maybe<Scalars['Date']['output']>;
  detectorsSensors?: Maybe<Scalars['String']['output']>;
  industry?: Maybe<Scalars['String']['output']>;
  quote?: Maybe<Scalars['String']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  rejectedDate?: Maybe<Scalars['Date']['output']>;
  representative?: Maybe<Scalars['String']['output']>;
  representativeCode?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `OfferteCsv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OfferteCsvCondition = {
  /** Checks for equality with the object’s `actionDate` field. */
  actionDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `actions` field. */
  actions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `chance` field. */
  chance?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `company` field. */
  company?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `companyCode` field. */
  companyCode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `competitors` field. */
  competitors?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `countryCode` field. */
  countryCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `decisionDate` field. */
  decisionDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `detectorsSensors` field. */
  detectorsSensors?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `industry` field. */
  industry?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `quote` field. */
  quote?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `reference` field. */
  reference?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rejectedDate` field. */
  rejectedDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `representative` field. */
  representative?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `representativeCode` field. */
  representativeCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `OfferteCsv` object types. All fields are combined with a logical ‘and.’ */
export type OfferteCsvFilter = {
  /** Filter by the object’s `actionDate` field. */
  actionDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `actions` field. */
  actions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OfferteCsvFilter>>;
  /** Filter by the object’s `chance` field. */
  chance?: InputMaybe<IntFilter>;
  /** Filter by the object’s `company` field. */
  company?: InputMaybe<StringFilter>;
  /** Filter by the object’s `companyCode` field. */
  companyCode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `competitors` field. */
  competitors?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `countryCode` field. */
  countryCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Filter by the object’s `decisionDate` field. */
  decisionDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `detectorsSensors` field. */
  detectorsSensors?: InputMaybe<StringFilter>;
  /** Filter by the object’s `industry` field. */
  industry?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OfferteCsvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OfferteCsvFilter>>;
  /** Filter by the object’s `quote` field. */
  quote?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reference` field. */
  reference?: InputMaybe<StringFilter>;
  /** Filter by the object’s `rejectedDate` field. */
  rejectedDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `representative` field. */
  representative?: InputMaybe<StringFilter>;
  /** Filter by the object’s `representativeCode` field. */
  representativeCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
};

/** A connection to a list of `OfferteCsv` values. */
export type OfferteCsvsConnection = {
  __typename?: 'OfferteCsvsConnection';
  /** A list of edges which contains the `OfferteCsv` and cursor to aid in pagination. */
  edges: Array<OfferteCsvsEdge>;
  /** A list of `OfferteCsv` objects. */
  nodes: Array<OfferteCsv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OfferteCsv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OfferteCsv` edge in the connection. */
export type OfferteCsvsEdge = {
  __typename?: 'OfferteCsvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OfferteCsv` at the end of the edge. */
  node: OfferteCsv;
};

/** Methods to use when ordering `OfferteCsv`. */
export enum OfferteCsvsOrderBy {
  ActionsAsc = 'ACTIONS_ASC',
  ActionsDesc = 'ACTIONS_DESC',
  ActionDateAsc = 'ACTION_DATE_ASC',
  ActionDateDesc = 'ACTION_DATE_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  ChanceAsc = 'CHANCE_ASC',
  ChanceDesc = 'CHANCE_DESC',
  CompanyAsc = 'COMPANY_ASC',
  CompanyCodeAsc = 'COMPANY_CODE_ASC',
  CompanyCodeDesc = 'COMPANY_CODE_DESC',
  CompanyDesc = 'COMPANY_DESC',
  CompetitorsAsc = 'COMPETITORS_ASC',
  CompetitorsDesc = 'COMPETITORS_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryCodeAsc = 'COUNTRY_CODE_ASC',
  CountryCodeDesc = 'COUNTRY_CODE_DESC',
  CountryDesc = 'COUNTRY_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DecisionDateAsc = 'DECISION_DATE_ASC',
  DecisionDateDesc = 'DECISION_DATE_DESC',
  DetectorsSensorsAsc = 'DETECTORS_SENSORS_ASC',
  DetectorsSensorsDesc = 'DETECTORS_SENSORS_DESC',
  IndustryAsc = 'INDUSTRY_ASC',
  IndustryDesc = 'INDUSTRY_DESC',
  Natural = 'NATURAL',
  QuoteAsc = 'QUOTE_ASC',
  QuoteDesc = 'QUOTE_DESC',
  ReferenceAsc = 'REFERENCE_ASC',
  ReferenceDesc = 'REFERENCE_DESC',
  RejectedDateAsc = 'REJECTED_DATE_ASC',
  RejectedDateDesc = 'REJECTED_DATE_DESC',
  RepresentativeAsc = 'REPRESENTATIVE_ASC',
  RepresentativeCodeAsc = 'REPRESENTATIVE_CODE_ASC',
  RepresentativeCodeDesc = 'REPRESENTATIVE_CODE_DESC',
  RepresentativeDesc = 'REPRESENTATIVE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC'
}

/** A filter to be used against `Offerte` object types. All fields are combined with a logical ‘and.’ */
export type OfferteFilter = {
  /** Filter by the object’s `adres` field. */
  adres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OfferteFilter>>;
  /** Filter by the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `betkortperc` field. */
  betkortperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdadres` field. */
  cdadres?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbtw` field. */
  cdbtw?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdreden` field. */
  cdreden?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumafwijzing` field. */
  datumafwijzing?: InputMaybe<DateFilter>;
  /** Filter by the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geldigtm` field. */
  geldigtm?: InputMaybe<DateFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kans` field. */
  kans?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `koptekst` field. */
  koptekst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kredbepperc` field. */
  kredbepperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margeblokkade` field. */
  margeblokkade?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OfferteFilter>;
  /** Filter by the object’s `notitieafwijzing` field. */
  notitieafwijzing?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offertedatum` field. */
  offertedatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OfferteFilter>>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projOfferte` field. */
  projOfferte?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projOmschr` field. */
  projOmschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `subadres` field. */
  subadres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verlorenaan` field. */
  verlorenaan?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voettekst` field. */
  voettekst?: InputMaybe<StringFilter>;
};

export type OfferteMv = {
  __typename?: 'OfferteMv';
  adres?: Maybe<Scalars['String']['output']>;
  afdrukteller?: Maybe<Scalars['Int']['output']>;
  behandelddoor?: Maybe<Scalars['String']['output']>;
  betkortperc?: Maybe<Scalars['BigFloat']['output']>;
  btwscenario?: Maybe<Scalars['Int']['output']>;
  cdadres?: Maybe<Scalars['Int']['output']>;
  cdbehandelddoor?: Maybe<Scalars['String']['output']>;
  cdbetcond?: Maybe<Scalars['String']['output']>;
  cdbtw?: Maybe<Scalars['String']['output']>;
  cddebiteur?: Maybe<Scalars['String']['output']>;
  cdfiatteur?: Maybe<Scalars['String']['output']>;
  cdlevcond?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdreden?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdsoort?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  datumafwijzing?: Maybe<Scalars['Date']['output']>;
  gefiatteerd?: Maybe<Scalars['String']['output']>;
  geldigtm?: Maybe<Scalars['Date']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  kans?: Maybe<Scalars['BigFloat']['output']>;
  koptekst?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kredbepperc?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  margeblokkade?: Maybe<Scalars['String']['output']>;
  notitieafwijzing?: Maybe<Scalars['String']['output']>;
  offertedatum?: Maybe<Scalars['Date']['output']>;
  offertenummer?: Maybe<Scalars['String']['output']>;
  offertevolgnr?: Maybe<Scalars['Int']['output']>;
  persoon?: Maybe<Scalars['String']['output']>;
  projOfferte?: Maybe<Scalars['String']['output']>;
  projOmschr?: Maybe<Scalars['String']['output']>;
  referentie?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  subadres?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  verlorenaan?: Maybe<Scalars['String']['output']>;
  vertegenwoordiger?: Maybe<Scalars['String']['output']>;
  voettekst?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `OfferteMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OfferteMvCondition = {
  /** Checks for equality with the object’s `adres` field. */
  adres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `betkortperc` field. */
  betkortperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdadres` field. */
  cdadres?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdbtw` field. */
  cdbtw?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdreden` field. */
  cdreden?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumafwijzing` field. */
  datumafwijzing?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geldigtm` field. */
  geldigtm?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kans` field. */
  kans?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `koptekst` field. */
  koptekst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kredbepperc` field. */
  kredbepperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margeblokkade` field. */
  margeblokkade?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `notitieafwijzing` field. */
  notitieafwijzing?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertedatum` field. */
  offertedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `persoon` field. */
  persoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projOfferte` field. */
  projOfferte?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projOmschr` field. */
  projOmschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `referentie` field. */
  referentie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `subadres` field. */
  subadres?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verlorenaan` field. */
  verlorenaan?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voettekst` field. */
  voettekst?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `OfferteMv` object types. All fields are combined with a logical ‘and.’ */
export type OfferteMvFilter = {
  /** Filter by the object’s `adres` field. */
  adres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `afdrukteller` field. */
  afdrukteller?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OfferteMvFilter>>;
  /** Filter by the object’s `behandelddoor` field. */
  behandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `betkortperc` field. */
  betkortperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `btwscenario` field. */
  btwscenario?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdadres` field. */
  cdadres?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdbehandelddoor` field. */
  cdbehandelddoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbetcond` field. */
  cdbetcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdbtw` field. */
  cdbtw?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddebiteur` field. */
  cddebiteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfiatteur` field. */
  cdfiatteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdlevcond` field. */
  cdlevcond?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdreden` field. */
  cdreden?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdsoort` field. */
  cdsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumafwijzing` field. */
  datumafwijzing?: InputMaybe<DateFilter>;
  /** Filter by the object’s `gefiatteerd` field. */
  gefiatteerd?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geldigtm` field. */
  geldigtm?: InputMaybe<DateFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kans` field. */
  kans?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `koptekst` field. */
  koptekst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kredbepperc` field. */
  kredbepperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margeblokkade` field. */
  margeblokkade?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OfferteMvFilter>;
  /** Filter by the object’s `notitieafwijzing` field. */
  notitieafwijzing?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offertedatum` field. */
  offertedatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OfferteMvFilter>>;
  /** Filter by the object’s `persoon` field. */
  persoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projOfferte` field. */
  projOfferte?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projOmschr` field. */
  projOmschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `referentie` field. */
  referentie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `subadres` field. */
  subadres?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verlorenaan` field. */
  verlorenaan?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vertegenwoordiger` field. */
  vertegenwoordiger?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voettekst` field. */
  voettekst?: InputMaybe<StringFilter>;
};

/** A connection to a list of `OfferteMv` values. */
export type OfferteMvsConnection = {
  __typename?: 'OfferteMvsConnection';
  /** A list of edges which contains the `OfferteMv` and cursor to aid in pagination. */
  edges: Array<OfferteMvsEdge>;
  /** A list of `OfferteMv` objects. */
  nodes: Array<OfferteMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OfferteMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OfferteMv` edge in the connection. */
export type OfferteMvsEdge = {
  __typename?: 'OfferteMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OfferteMv` at the end of the edge. */
  node: OfferteMv;
};

/** Methods to use when ordering `OfferteMv`. */
export enum OfferteMvsOrderBy {
  AdresAsc = 'ADRES_ASC',
  AdresDesc = 'ADRES_DESC',
  AfdruktellerAsc = 'AFDRUKTELLER_ASC',
  AfdruktellerDesc = 'AFDRUKTELLER_DESC',
  BehandelddoorAsc = 'BEHANDELDDOOR_ASC',
  BehandelddoorDesc = 'BEHANDELDDOOR_DESC',
  BetkortpercAsc = 'BETKORTPERC_ASC',
  BetkortpercDesc = 'BETKORTPERC_DESC',
  BtwscenarioAsc = 'BTWSCENARIO_ASC',
  BtwscenarioDesc = 'BTWSCENARIO_DESC',
  CdadresAsc = 'CDADRES_ASC',
  CdadresDesc = 'CDADRES_DESC',
  CdbehandelddoorAsc = 'CDBEHANDELDDOOR_ASC',
  CdbehandelddoorDesc = 'CDBEHANDELDDOOR_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  CdbtwAsc = 'CDBTW_ASC',
  CdbtwDesc = 'CDBTW_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CdfiatteurAsc = 'CDFIATTEUR_ASC',
  CdfiatteurDesc = 'CDFIATTEUR_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdredenAsc = 'CDREDEN_ASC',
  CdredenDesc = 'CDREDEN_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdsoortAsc = 'CDSOORT_ASC',
  CdsoortDesc = 'CDSOORT_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  DatumafwijzingAsc = 'DATUMAFWIJZING_ASC',
  DatumafwijzingDesc = 'DATUMAFWIJZING_DESC',
  GefiatteerdAsc = 'GEFIATTEERD_ASC',
  GefiatteerdDesc = 'GEFIATTEERD_DESC',
  GeldigtmAsc = 'GELDIGTM_ASC',
  GeldigtmDesc = 'GELDIGTM_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  KansAsc = 'KANS_ASC',
  KansDesc = 'KANS_DESC',
  KoptekstAsc = 'KOPTEKST_ASC',
  KoptekstDesc = 'KOPTEKST_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KredbeppercAsc = 'KREDBEPPERC_ASC',
  KredbeppercDesc = 'KREDBEPPERC_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  MargeblokkadeAsc = 'MARGEBLOKKADE_ASC',
  MargeblokkadeDesc = 'MARGEBLOKKADE_DESC',
  Natural = 'NATURAL',
  NotitieafwijzingAsc = 'NOTITIEAFWIJZING_ASC',
  NotitieafwijzingDesc = 'NOTITIEAFWIJZING_DESC',
  OffertedatumAsc = 'OFFERTEDATUM_ASC',
  OffertedatumDesc = 'OFFERTEDATUM_DESC',
  OffertenummerAsc = 'OFFERTENUMMER_ASC',
  OffertenummerDesc = 'OFFERTENUMMER_DESC',
  OffertevolgnrAsc = 'OFFERTEVOLGNR_ASC',
  OffertevolgnrDesc = 'OFFERTEVOLGNR_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  ProjOfferteAsc = 'PROJ_OFFERTE_ASC',
  ProjOfferteDesc = 'PROJ_OFFERTE_DESC',
  ProjOmschrAsc = 'PROJ_OMSCHR_ASC',
  ProjOmschrDesc = 'PROJ_OMSCHR_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SubadresAsc = 'SUBADRES_ASC',
  SubadresDesc = 'SUBADRES_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  VerlorenaanAsc = 'VERLORENAAN_ASC',
  VerlorenaanDesc = 'VERLORENAAN_DESC',
  VertegenwoordigerAsc = 'VERTEGENWOORDIGER_ASC',
  VertegenwoordigerDesc = 'VERTEGENWOORDIGER_DESC',
  VoettekstAsc = 'VOETTEKST_ASC',
  VoettekstDesc = 'VOETTEKST_DESC'
}

export type OfferteRemark = Node & {
  __typename?: 'OfferteRemark';
  actionDate?: Maybe<Scalars['Date']['output']>;
  actions?: Maybe<Scalars['String']['output']>;
  competitors?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  decisionDate?: Maybe<Scalars['Date']['output']>;
  id: Scalars['Int']['output'];
  kans?: Maybe<Scalars['BigFloat']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  offerteId: Scalars['String']['output'];
  ownerId: Scalars['Int']['output'];
  rejectRequest?: Maybe<Scalars['Boolean']['output']>;
  representative?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  statusApproved?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `User` that is related to this `OfferteRemark`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `OfferteRemark` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OfferteRemarkCondition = {
  /** Checks for equality with the object’s `actionDate` field. */
  actionDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `actions` field. */
  actions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `competitors` field. */
  competitors?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `decisionDate` field. */
  decisionDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `kans` field. */
  kans?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offerteId` field. */
  offerteId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `rejectRequest` field. */
  rejectRequest?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `representative` field. */
  representative?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `statusApproved` field. */
  statusApproved?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A filter to be used against `OfferteRemark` object types. All fields are combined with a logical ‘and.’ */
export type OfferteRemarkFilter = {
  /** Filter by the object’s `actionDate` field. */
  actionDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `actions` field. */
  actions?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OfferteRemarkFilter>>;
  /** Filter by the object’s `competitors` field. */
  competitors?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `decisionDate` field. */
  decisionDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `kans` field. */
  kans?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OfferteRemarkFilter>;
  /** Filter by the object’s `offerteId` field. */
  offerteId?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OfferteRemarkFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `rejectRequest` field. */
  rejectRequest?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `representative` field. */
  representative?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `statusApproved` field. */
  statusApproved?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `OfferteRemark` */
export type OfferteRemarkInput = {
  actionDate?: InputMaybe<Scalars['Date']['input']>;
  actions?: InputMaybe<Scalars['String']['input']>;
  competitors?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  decisionDate?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  kans?: InputMaybe<Scalars['BigFloat']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offerteId: Scalars['String']['input'];
  ownerId: Scalars['Int']['input'];
  rejectRequest?: InputMaybe<Scalars['Boolean']['input']>;
  representative?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusApproved?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents an update to a `OfferteRemark`. Fields that are set will be updated. */
export type OfferteRemarkPatch = {
  actionDate?: InputMaybe<Scalars['Date']['input']>;
  actions?: InputMaybe<Scalars['String']['input']>;
  competitors?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  decisionDate?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  kans?: InputMaybe<Scalars['BigFloat']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offerteId?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  rejectRequest?: InputMaybe<Scalars['Boolean']['input']>;
  representative?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  statusApproved?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A connection to a list of `OfferteRemark` values. */
export type OfferteRemarksConnection = {
  __typename?: 'OfferteRemarksConnection';
  /** A list of edges which contains the `OfferteRemark` and cursor to aid in pagination. */
  edges: Array<OfferteRemarksEdge>;
  /** A list of `OfferteRemark` objects. */
  nodes: Array<OfferteRemark>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OfferteRemark` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OfferteRemark` edge in the connection. */
export type OfferteRemarksEdge = {
  __typename?: 'OfferteRemarksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OfferteRemark` at the end of the edge. */
  node: OfferteRemark;
};

/** Methods to use when ordering `OfferteRemark`. */
export enum OfferteRemarksOrderBy {
  ActionsAsc = 'ACTIONS_ASC',
  ActionsDesc = 'ACTIONS_DESC',
  ActionDateAsc = 'ACTION_DATE_ASC',
  ActionDateDesc = 'ACTION_DATE_DESC',
  CompetitorsAsc = 'COMPETITORS_ASC',
  CompetitorsDesc = 'COMPETITORS_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DecisionDateAsc = 'DECISION_DATE_ASC',
  DecisionDateDesc = 'DECISION_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KansAsc = 'KANS_ASC',
  KansDesc = 'KANS_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OfferteIdAsc = 'OFFERTE_ID_ASC',
  OfferteIdDesc = 'OFFERTE_ID_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RejectRequestAsc = 'REJECT_REQUEST_ASC',
  RejectRequestDesc = 'REJECT_REQUEST_DESC',
  RepresentativeAsc = 'REPRESENTATIVE_ASC',
  RepresentativeDesc = 'REPRESENTATIVE_DESC',
  StatusApprovedAsc = 'STATUS_APPROVED_ASC',
  StatusApprovedDesc = 'STATUS_APPROVED_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Offerteregel = {
  __typename?: 'Offerteregel';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  aantaldec?: Maybe<Scalars['Int']['output']>;
  bedragexcl?: Maybe<Scalars['BigFloat']['output']>;
  bedragincl?: Maybe<Scalars['BigFloat']['output']>;
  btwcode?: Maybe<Scalars['Int']['output']>;
  btwperc?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdreden?: Maybe<Scalars['String']['output']>;
  cdstatus?: Maybe<Scalars['String']['output']>;
  cduursoort?: Maybe<Scalars['String']['output']>;
  datum?: Maybe<Scalars['Date']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  offerteId?: Maybe<Scalars['String']['output']>;
  offertenummer?: Maybe<Scalars['String']['output']>;
  offerteregel?: Maybe<Scalars['Int']['output']>;
  offertevolgnr?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  projDeelOmschr?: Maybe<Scalars['String']['output']>;
  projMutsoort?: Maybe<Scalars['String']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  vvbestand?: Maybe<Scalars['String']['output']>;
  vvdatumopdracht?: Maybe<Scalars['Date']['output']>;
  vvgroepscode?: Maybe<Scalars['String']['output']>;
  vvvrijvelda?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Offerteregel` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OfferteregelCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `bedragexcl` field. */
  bedragexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bedragincl` field. */
  bedragincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `btwcode` field. */
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `btwperc` field. */
  btwperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdreden` field. */
  cdreden?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cduursoort` field. */
  cduursoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datum` field. */
  datum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offerteId` field. */
  offerteId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offerteregel` field. */
  offerteregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projDeelOmschr` field. */
  projDeelOmschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvdatumopdracht` field. */
  vvdatumopdracht?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `vvgroepscode` field. */
  vvgroepscode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Offerteregel` object types. All fields are combined with a logical ‘and.’ */
export type OfferteregelFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OfferteregelFilter>>;
  /** Filter by the object’s `bedragexcl` field. */
  bedragexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `bedragincl` field. */
  bedragincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `btwcode` field. */
  btwcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `btwperc` field. */
  btwperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdreden` field. */
  cdreden?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cduursoort` field. */
  cduursoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datum` field. */
  datum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OfferteregelFilter>;
  /** Filter by the object’s `offerteId` field. */
  offerteId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offerteregel` field. */
  offerteregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OfferteregelFilter>>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projDeelOmschr` field. */
  projDeelOmschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvdatumopdracht` field. */
  vvdatumopdracht?: InputMaybe<DateFilter>;
  /** Filter by the object’s `vvgroepscode` field. */
  vvgroepscode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<StringFilter>;
};

export type OfferteregelMv = {
  __typename?: 'OfferteregelMv';
  aantal?: Maybe<Scalars['BigFloat']['output']>;
  aantaldec?: Maybe<Scalars['Int']['output']>;
  bedragexcl?: Maybe<Scalars['BigFloat']['output']>;
  bedragincl?: Maybe<Scalars['BigFloat']['output']>;
  btwcode?: Maybe<Scalars['Int']['output']>;
  btwperc?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdreden?: Maybe<Scalars['String']['output']>;
  cdstatus?: Maybe<Scalars['String']['output']>;
  cduursoort?: Maybe<Scalars['String']['output']>;
  datum?: Maybe<Scalars['Date']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  offertenummer?: Maybe<Scalars['String']['output']>;
  offerteregel?: Maybe<Scalars['Int']['output']>;
  offertevolgnr?: Maybe<Scalars['Int']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  projDeelOmschr?: Maybe<Scalars['String']['output']>;
  projMutsoort?: Maybe<Scalars['String']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  vvbestand?: Maybe<Scalars['String']['output']>;
  vvdatumopdracht?: Maybe<Scalars['Date']['output']>;
  vvgroepscode?: Maybe<Scalars['String']['output']>;
  vvvrijvelda?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `OfferteregelMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OfferteregelMvCondition = {
  /** Checks for equality with the object’s `aantal` field. */
  aantal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `bedragexcl` field. */
  bedragexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bedragincl` field. */
  bedragincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `btwcode` field. */
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `btwperc` field. */
  btwperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdreden` field. */
  cdreden?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cduursoort` field. */
  cduursoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datum` field. */
  datum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `offerteregel` field. */
  offerteregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projDeelOmschr` field. */
  projDeelOmschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvdatumopdracht` field. */
  vvdatumopdracht?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `vvgroepscode` field. */
  vvgroepscode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `OfferteregelMv` object types. All fields are combined with a logical ‘and.’ */
export type OfferteregelMvFilter = {
  /** Filter by the object’s `aantal` field. */
  aantal?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OfferteregelMvFilter>>;
  /** Filter by the object’s `bedragexcl` field. */
  bedragexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `bedragincl` field. */
  bedragincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `btwcode` field. */
  btwcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `btwperc` field. */
  btwperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdreden` field. */
  cdreden?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cduursoort` field. */
  cduursoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datum` field. */
  datum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OfferteregelMvFilter>;
  /** Filter by the object’s `offertenummer` field. */
  offertenummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `offerteregel` field. */
  offerteregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `offertevolgnr` field. */
  offertevolgnr?: InputMaybe<IntFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OfferteregelMvFilter>>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projDeelOmschr` field. */
  projDeelOmschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvbestand` field. */
  vvbestand?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvdatumopdracht` field. */
  vvdatumopdracht?: InputMaybe<DateFilter>;
  /** Filter by the object’s `vvgroepscode` field. */
  vvgroepscode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<StringFilter>;
};

/** A connection to a list of `OfferteregelMv` values. */
export type OfferteregelMvsConnection = {
  __typename?: 'OfferteregelMvsConnection';
  /** A list of edges which contains the `OfferteregelMv` and cursor to aid in pagination. */
  edges: Array<OfferteregelMvsEdge>;
  /** A list of `OfferteregelMv` objects. */
  nodes: Array<OfferteregelMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OfferteregelMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OfferteregelMv` edge in the connection. */
export type OfferteregelMvsEdge = {
  __typename?: 'OfferteregelMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OfferteregelMv` at the end of the edge. */
  node: OfferteregelMv;
};

/** Methods to use when ordering `OfferteregelMv`. */
export enum OfferteregelMvsOrderBy {
  AantaldecAsc = 'AANTALDEC_ASC',
  AantaldecDesc = 'AANTALDEC_DESC',
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  BedragexclAsc = 'BEDRAGEXCL_ASC',
  BedragexclDesc = 'BEDRAGEXCL_DESC',
  BedraginclAsc = 'BEDRAGINCL_ASC',
  BedraginclDesc = 'BEDRAGINCL_DESC',
  BtwcodeAsc = 'BTWCODE_ASC',
  BtwcodeDesc = 'BTWCODE_DESC',
  BtwpercAsc = 'BTWPERC_ASC',
  BtwpercDesc = 'BTWPERC_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdredenAsc = 'CDREDEN_ASC',
  CdredenDesc = 'CDREDEN_DESC',
  CdstatusAsc = 'CDSTATUS_ASC',
  CdstatusDesc = 'CDSTATUS_DESC',
  CduursoortAsc = 'CDUURSOORT_ASC',
  CduursoortDesc = 'CDUURSOORT_DESC',
  DatumAsc = 'DATUM_ASC',
  DatumDesc = 'DATUM_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  Natural = 'NATURAL',
  OffertenummerAsc = 'OFFERTENUMMER_ASC',
  OffertenummerDesc = 'OFFERTENUMMER_DESC',
  OfferteregelAsc = 'OFFERTEREGEL_ASC',
  OfferteregelDesc = 'OFFERTEREGEL_DESC',
  OffertevolgnrAsc = 'OFFERTEVOLGNR_ASC',
  OffertevolgnrDesc = 'OFFERTEVOLGNR_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  ProjDeelOmschrAsc = 'PROJ_DEEL_OMSCHR_ASC',
  ProjDeelOmschrDesc = 'PROJ_DEEL_OMSCHR_DESC',
  ProjMutsoortAsc = 'PROJ_MUTSOORT_ASC',
  ProjMutsoortDesc = 'PROJ_MUTSOORT_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  VvbestandAsc = 'VVBESTAND_ASC',
  VvbestandDesc = 'VVBESTAND_DESC',
  VvdatumopdrachtAsc = 'VVDATUMOPDRACHT_ASC',
  VvdatumopdrachtDesc = 'VVDATUMOPDRACHT_DESC',
  VvgroepscodeAsc = 'VVGROEPSCODE_ASC',
  VvgroepscodeDesc = 'VVGROEPSCODE_DESC',
  VvvrijveldaAsc = 'VVVRIJVELDA_ASC',
  VvvrijveldaDesc = 'VVVRIJVELDA_DESC'
}

/** A connection to a list of `Offerteregel` values. */
export type OfferteregelsConnection = {
  __typename?: 'OfferteregelsConnection';
  /** A list of edges which contains the `Offerteregel` and cursor to aid in pagination. */
  edges: Array<OfferteregelsEdge>;
  /** A list of `Offerteregel` objects. */
  nodes: Array<Offerteregel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Offerteregel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Offerteregel` edge in the connection. */
export type OfferteregelsEdge = {
  __typename?: 'OfferteregelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Offerteregel` at the end of the edge. */
  node: Offerteregel;
};

/** Methods to use when ordering `Offerteregel`. */
export enum OfferteregelsOrderBy {
  AantaldecAsc = 'AANTALDEC_ASC',
  AantaldecDesc = 'AANTALDEC_DESC',
  AantalAsc = 'AANTAL_ASC',
  AantalDesc = 'AANTAL_DESC',
  BedragexclAsc = 'BEDRAGEXCL_ASC',
  BedragexclDesc = 'BEDRAGEXCL_DESC',
  BedraginclAsc = 'BEDRAGINCL_ASC',
  BedraginclDesc = 'BEDRAGINCL_DESC',
  BtwcodeAsc = 'BTWCODE_ASC',
  BtwcodeDesc = 'BTWCODE_DESC',
  BtwpercAsc = 'BTWPERC_ASC',
  BtwpercDesc = 'BTWPERC_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdredenAsc = 'CDREDEN_ASC',
  CdredenDesc = 'CDREDEN_DESC',
  CdstatusAsc = 'CDSTATUS_ASC',
  CdstatusDesc = 'CDSTATUS_DESC',
  CduursoortAsc = 'CDUURSOORT_ASC',
  CduursoortDesc = 'CDUURSOORT_DESC',
  DatumAsc = 'DATUM_ASC',
  DatumDesc = 'DATUM_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  Natural = 'NATURAL',
  OffertenummerAsc = 'OFFERTENUMMER_ASC',
  OffertenummerDesc = 'OFFERTENUMMER_DESC',
  OfferteregelAsc = 'OFFERTEREGEL_ASC',
  OfferteregelDesc = 'OFFERTEREGEL_DESC',
  OffertevolgnrAsc = 'OFFERTEVOLGNR_ASC',
  OffertevolgnrDesc = 'OFFERTEVOLGNR_DESC',
  OfferteIdAsc = 'OFFERTE_ID_ASC',
  OfferteIdDesc = 'OFFERTE_ID_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  ProjDeelOmschrAsc = 'PROJ_DEEL_OMSCHR_ASC',
  ProjDeelOmschrDesc = 'PROJ_DEEL_OMSCHR_DESC',
  ProjMutsoortAsc = 'PROJ_MUTSOORT_ASC',
  ProjMutsoortDesc = 'PROJ_MUTSOORT_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  VvbestandAsc = 'VVBESTAND_ASC',
  VvbestandDesc = 'VVBESTAND_DESC',
  VvdatumopdrachtAsc = 'VVDATUMOPDRACHT_ASC',
  VvdatumopdrachtDesc = 'VVDATUMOPDRACHT_DESC',
  VvgroepscodeAsc = 'VVGROEPSCODE_ASC',
  VvgroepscodeDesc = 'VVGROEPSCODE_DESC',
  VvvrijveldaAsc = 'VVVRIJVELDA_ASC',
  VvvrijveldaDesc = 'VVVRIJVELDA_DESC'
}

/** A connection to a list of `Offerte` values. */
export type OffertesConnection = {
  __typename?: 'OffertesConnection';
  /** A list of edges which contains the `Offerte` and cursor to aid in pagination. */
  edges: Array<OffertesEdge>;
  /** A list of `Offerte` objects. */
  nodes: Array<Offerte>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Offerte` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Offerte` edge in the connection. */
export type OffertesEdge = {
  __typename?: 'OffertesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Offerte` at the end of the edge. */
  node: Offerte;
};

/** Methods to use when ordering `Offerte`. */
export enum OffertesOrderBy {
  AdresAsc = 'ADRES_ASC',
  AdresDesc = 'ADRES_DESC',
  AfdruktellerAsc = 'AFDRUKTELLER_ASC',
  AfdruktellerDesc = 'AFDRUKTELLER_DESC',
  BehandelddoorAsc = 'BEHANDELDDOOR_ASC',
  BehandelddoorDesc = 'BEHANDELDDOOR_DESC',
  BetkortpercAsc = 'BETKORTPERC_ASC',
  BetkortpercDesc = 'BETKORTPERC_DESC',
  BtwscenarioAsc = 'BTWSCENARIO_ASC',
  BtwscenarioDesc = 'BTWSCENARIO_DESC',
  CdadresAsc = 'CDADRES_ASC',
  CdadresDesc = 'CDADRES_DESC',
  CdbehandelddoorAsc = 'CDBEHANDELDDOOR_ASC',
  CdbehandelddoorDesc = 'CDBEHANDELDDOOR_DESC',
  CdbetcondAsc = 'CDBETCOND_ASC',
  CdbetcondDesc = 'CDBETCOND_DESC',
  CdbtwAsc = 'CDBTW_ASC',
  CdbtwDesc = 'CDBTW_DESC',
  CddebiteurAsc = 'CDDEBITEUR_ASC',
  CddebiteurDesc = 'CDDEBITEUR_DESC',
  CdfiatteurAsc = 'CDFIATTEUR_ASC',
  CdfiatteurDesc = 'CDFIATTEUR_DESC',
  CdlevcondAsc = 'CDLEVCOND_ASC',
  CdlevcondDesc = 'CDLEVCOND_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdredenAsc = 'CDREDEN_ASC',
  CdredenDesc = 'CDREDEN_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdsoortAsc = 'CDSOORT_ASC',
  CdsoortDesc = 'CDSOORT_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  DatumafwijzingAsc = 'DATUMAFWIJZING_ASC',
  DatumafwijzingDesc = 'DATUMAFWIJZING_DESC',
  GefiatteerdAsc = 'GEFIATTEERD_ASC',
  GefiatteerdDesc = 'GEFIATTEERD_DESC',
  GeldigtmAsc = 'GELDIGTM_ASC',
  GeldigtmDesc = 'GELDIGTM_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KansAsc = 'KANS_ASC',
  KansDesc = 'KANS_DESC',
  KoptekstAsc = 'KOPTEKST_ASC',
  KoptekstDesc = 'KOPTEKST_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KredbeppercAsc = 'KREDBEPPERC_ASC',
  KredbeppercDesc = 'KREDBEPPERC_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  MargeblokkadeAsc = 'MARGEBLOKKADE_ASC',
  MargeblokkadeDesc = 'MARGEBLOKKADE_DESC',
  Natural = 'NATURAL',
  NotitieafwijzingAsc = 'NOTITIEAFWIJZING_ASC',
  NotitieafwijzingDesc = 'NOTITIEAFWIJZING_DESC',
  OffertedatumAsc = 'OFFERTEDATUM_ASC',
  OffertedatumDesc = 'OFFERTEDATUM_DESC',
  OffertenummerAsc = 'OFFERTENUMMER_ASC',
  OffertenummerDesc = 'OFFERTENUMMER_DESC',
  OffertevolgnrAsc = 'OFFERTEVOLGNR_ASC',
  OffertevolgnrDesc = 'OFFERTEVOLGNR_DESC',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  ProjOfferteAsc = 'PROJ_OFFERTE_ASC',
  ProjOfferteDesc = 'PROJ_OFFERTE_DESC',
  ProjOmschrAsc = 'PROJ_OMSCHR_ASC',
  ProjOmschrDesc = 'PROJ_OMSCHR_DESC',
  ReferentieAsc = 'REFERENTIE_ASC',
  ReferentieDesc = 'REFERENTIE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SubadresAsc = 'SUBADRES_ASC',
  SubadresDesc = 'SUBADRES_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  VerlorenaanAsc = 'VERLORENAAN_ASC',
  VerlorenaanDesc = 'VERLORENAAN_DESC',
  VertegenwoordigerAsc = 'VERTEGENWOORDIGER_ASC',
  VertegenwoordigerDesc = 'VERTEGENWOORDIGER_DESC',
  VoettekstAsc = 'VOETTEKST_ASC',
  VoettekstDesc = 'VOETTEKST_DESC'
}

/** A connection to a list of `Opportunity` values. */
export type OpportunitiesConnection = {
  __typename?: 'OpportunitiesConnection';
  /** A list of edges which contains the `Opportunity` and cursor to aid in pagination. */
  edges: Array<OpportunitiesEdge>;
  /** A list of `Opportunity` objects. */
  nodes: Array<Opportunity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Opportunity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Opportunity` edge in the connection. */
export type OpportunitiesEdge = {
  __typename?: 'OpportunitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Opportunity` at the end of the edge. */
  node: Opportunity;
};

/** Methods to use when ordering `Opportunity`. */
export enum OpportunitiesOrderBy {
  ActionsAsc = 'ACTIONS_ASC',
  ActionsDesc = 'ACTIONS_DESC',
  ActionDateAsc = 'ACTION_DATE_ASC',
  ActionDateDesc = 'ACTION_DATE_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerAsc = 'CUSTOMER_ASC',
  CustomerDesc = 'CUSTOMER_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  DistributorAsc = 'DISTRIBUTOR_ASC',
  DistributorDesc = 'DISTRIBUTOR_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProjectDateAsc = 'PROJECT_DATE_ASC',
  ProjectDateDesc = 'PROJECT_DATE_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  LandByCdlandCbslandAsc = '_LAND_BY_CDLAND__CBSLAND_ASC',
  LandByCdlandCbslandDesc = '_LAND_BY_CDLAND__CBSLAND_DESC',
  LandByCdlandCdeglidAsc = '_LAND_BY_CDLAND__CDEGLID_ASC',
  LandByCdlandCdeglidDesc = '_LAND_BY_CDLAND__CDEGLID_DESC',
  LandByCdlandCdlandAsc = '_LAND_BY_CDLAND__CDLAND_ASC',
  LandByCdlandCdlandDesc = '_LAND_BY_CDLAND__CDLAND_DESC',
  LandByCdlandIsolandAsc = '_LAND_BY_CDLAND__ISOLAND_ASC',
  LandByCdlandIsolandDesc = '_LAND_BY_CDLAND__ISOLAND_DESC',
  LandByCdlandOmschrAsc = '_LAND_BY_CDLAND__OMSCHR_ASC',
  LandByCdlandOmschrDesc = '_LAND_BY_CDLAND__OMSCHR_DESC',
  LandByCdlandRszlandAsc = '_LAND_BY_CDLAND__RSZLAND_ASC',
  LandByCdlandRszlandDesc = '_LAND_BY_CDLAND__RSZLAND_DESC',
  LandByCdlandSepaAsc = '_LAND_BY_CDLAND__SEPA_ASC',
  LandByCdlandSepaDesc = '_LAND_BY_CDLAND__SEPA_DESC'
}

export type Opportunity = Node & {
  __typename?: 'Opportunity';
  /** Reads a single `_Land` that is related to this `Opportunity`. */
  _landByCdland?: Maybe<_Land>;
  actionDate?: Maybe<Scalars['Date']['output']>;
  actions?: Maybe<Scalars['String']['output']>;
  amount?: Maybe<Scalars['BigFloat']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  customer?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  distributor?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  projectDate?: Maybe<Scalars['Date']['output']>;
  source?: Maybe<Scalars['String']['output']>;
  status: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `Opportunity`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `Opportunity` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OpportunityCondition = {
  /** Checks for equality with the object’s `actionDate` field. */
  actionDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `actions` field. */
  actions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `customer` field. */
  customer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `distributor` field. */
  distributor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `projectDate` field. */
  projectDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `source` field. */
  source?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Opportunity` object types. All fields are combined with a logical ‘and.’ */
export type OpportunityFilter = {
  /** Filter by the object’s `_landByCdland` relation. */
  _landByCdland?: InputMaybe<_LandFilter>;
  /** A related `_landByCdland` exists. */
  _landByCdlandExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `actionDate` field. */
  actionDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `actions` field. */
  actions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OpportunityFilter>>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customer` field. */
  customer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `distributor` field. */
  distributor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OpportunityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OpportunityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `projectDate` field. */
  projectDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `source` field. */
  source?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `Opportunity` */
export type OpportunityInput = {
  actionDate?: InputMaybe<Scalars['Date']['input']>;
  actions?: InputMaybe<Scalars['String']['input']>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  cdland?: InputMaybe<Scalars['String']['input']>;
  cdvert?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customer?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  distributor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  projectDate?: InputMaybe<Scalars['Date']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Opportunity`. Fields that are set will be updated. */
export type OpportunityPatch = {
  actionDate?: InputMaybe<Scalars['Date']['input']>;
  actions?: InputMaybe<Scalars['String']['input']>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  cdland?: InputMaybe<Scalars['String']['input']>;
  cdvert?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customer?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  distributor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  projectDate?: InputMaybe<Scalars['Date']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};

export type Overtime = {
  __typename?: 'Overtime';
  date?: Maybe<Scalars['Date']['output']>;
  overtime?: Maybe<Scalars['BigFloat']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

export type Overtime2 = {
  __typename?: 'Overtime2';
  compensation?: Maybe<Scalars['BigFloat']['output']>;
  totalCompensation?: Maybe<Scalars['BigFloat']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  week?: Maybe<Scalars['String']['output']>;
  year?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Overtime2` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type Overtime2Condition = {
  /** Checks for equality with the object’s `compensation` field. */
  compensation?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalCompensation` field. */
  totalCompensation?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `week` field. */
  week?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `year` field. */
  year?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Overtime2` object types. All fields are combined with a logical ‘and.’ */
export type Overtime2Filter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<Overtime2Filter>>;
  /** Filter by the object’s `compensation` field. */
  compensation?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<Overtime2Filter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<Overtime2Filter>>;
  /** Filter by the object’s `totalCompensation` field. */
  totalCompensation?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `week` field. */
  week?: InputMaybe<StringFilter>;
  /** Filter by the object’s `year` field. */
  year?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Overtime2` values. */
export type Overtime2SConnection = {
  __typename?: 'Overtime2SConnection';
  /** A list of edges which contains the `Overtime2` and cursor to aid in pagination. */
  edges: Array<Overtime2SEdge>;
  /** A list of `Overtime2` objects. */
  nodes: Array<Overtime2>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Overtime2` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Overtime2` edge in the connection. */
export type Overtime2SEdge = {
  __typename?: 'Overtime2SEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Overtime2` at the end of the edge. */
  node: Overtime2;
};

/** Methods to use when ordering `Overtime2`. */
export enum Overtime2SOrderBy {
  CompensationAsc = 'COMPENSATION_ASC',
  CompensationDesc = 'COMPENSATION_DESC',
  Natural = 'NATURAL',
  TotalCompensationAsc = 'TOTAL_COMPENSATION_ASC',
  TotalCompensationDesc = 'TOTAL_COMPENSATION_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  WeekAsc = 'WEEK_ASC',
  WeekDesc = 'WEEK_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC'
}

/**
 * A condition to be used against `Overtime` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OvertimeCondition = {
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `overtime` field. */
  overtime?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Overtime` object types. All fields are combined with a logical ‘and.’ */
export type OvertimeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OvertimeFilter>>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OvertimeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OvertimeFilter>>;
  /** Filter by the object’s `overtime` field. */
  overtime?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `Overtime` values. */
export type OvertimesConnection = {
  __typename?: 'OvertimesConnection';
  /** A list of edges which contains the `Overtime` and cursor to aid in pagination. */
  edges: Array<OvertimesEdge>;
  /** A list of `Overtime` objects. */
  nodes: Array<Overtime>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Overtime` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Overtime` edge in the connection. */
export type OvertimesEdge = {
  __typename?: 'OvertimesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Overtime` at the end of the edge. */
  node: Overtime;
};

/** Methods to use when ordering `Overtime`. */
export enum OvertimesOrderBy {
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  Natural = 'NATURAL',
  OvertimeAsc = 'OVERTIME_ASC',
  OvertimeDesc = 'OVERTIME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

/** All input for the `pc5109DSettings` mutation. */
export type Pc5109DSettingsInput = {
  battery?: InputMaybe<Scalars['Boolean']['input']>;
  biasMv?: InputMaybe<Scalars['Int']['input']>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  direction?: InputMaybe<Scalars['Boolean']['input']>;
  electrodeCount?: InputMaybe<Scalars['Int']['input']>;
  lowElectrolyte?: InputMaybe<Scalars['Boolean']['input']>;
  spanResistor?: InputMaybe<Scalars['BigFloat']['input']>;
  zero?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The output of our `pc5109DSettings` mutation. */
export type Pc5109DSettingsPayload = {
  __typename?: 'Pc5109DSettingsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  json?: Maybe<Scalars['JSON']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `pc5154BSettings` mutation. */
export type Pc5154BSettingsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  direction?: InputMaybe<Scalars['Boolean']['input']>;
  lowElectrolyte?: InputMaybe<Scalars['Boolean']['input']>;
  powerMonitor?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The output of our `pc5154BSettings` mutation. */
export type Pc5154BSettingsPayload = {
  __typename?: 'Pc5154BSettingsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  json?: Maybe<Scalars['JSON']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** All input for the `pc5155BSettings` mutation. */
export type Pc5155BSettingsInput = {
  biasMv?: InputMaybe<Scalars['Int']['input']>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  spanResistor?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** The output of our `pc5155BSettings` mutation. */
export type Pc5155BSettingsPayload = {
  __typename?: 'Pc5155BSettingsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  json?: Maybe<Scalars['JSON']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type Permission = Node & {
  __typename?: 'Permission';
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `Permission` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PermissionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Permission` object types. All fields are combined with a logical ‘and.’ */
export type PermissionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionFilter>>;
};

/** An input for mutations affecting `Permission` */
export type PermissionInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Permission`. Fields that are set will be updated. */
export type PermissionPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  __typename?: 'PermissionsConnection';
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** A list of `Permission` objects. */
  nodes: Array<Permission>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  __typename?: 'PermissionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Permission` at the end of the edge. */
  node: Permission;
};

/** Methods to use when ordering `Permission`. */
export enum PermissionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Persoon = {
  __typename?: 'Persoon';
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdtitelna?: Maybe<Scalars['String']['output']>;
  cdtitelvoor?: Maybe<Scalars['String']['output']>;
  geboortedatum?: Maybe<Scalars['Date']['output']>;
  geslacht?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  voorletters?: Maybe<Scalars['String']['output']>;
  voornaam?: Maybe<Scalars['String']['output']>;
  vvbriefvertrekdh?: Maybe<Scalars['String']['output']>;
  vvdiverse?: Maybe<Scalars['String']['output']>;
  vvkalender?: Maybe<Scalars['String']['output']>;
  vvkerst?: Maybe<Scalars['String']['output']>;
  vvlead?: Maybe<Scalars['String']['output']>;
  vvlocatie?: Maybe<Scalars['String']['output']>;
  vvopvolgingbeurs?: Maybe<Scalars['String']['output']>;
  vvuitnodigingbeurs?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Persoon` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PersoonCondition = {
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geboortedatum` field. */
  geboortedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `geslacht` field. */
  geslacht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorletters` field. */
  voorletters?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voornaam` field. */
  voornaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvbriefvertrekdh` field. */
  vvbriefvertrekdh?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvdiverse` field. */
  vvdiverse?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvkalender` field. */
  vvkalender?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvkerst` field. */
  vvkerst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvlead` field. */
  vvlead?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvlocatie` field. */
  vvlocatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvopvolgingbeurs` field. */
  vvopvolgingbeurs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvuitnodigingbeurs` field. */
  vvuitnodigingbeurs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Persoon` object types. All fields are combined with a logical ‘and.’ */
export type PersoonFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PersoonFilter>>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geboortedatum` field. */
  geboortedatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `geslacht` field. */
  geslacht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PersoonFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PersoonFilter>>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorletters` field. */
  voorletters?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voornaam` field. */
  voornaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvbriefvertrekdh` field. */
  vvbriefvertrekdh?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvdiverse` field. */
  vvdiverse?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvkalender` field. */
  vvkalender?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvkerst` field. */
  vvkerst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvlead` field. */
  vvlead?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvlocatie` field. */
  vvlocatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvopvolgingbeurs` field. */
  vvopvolgingbeurs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvuitnodigingbeurs` field. */
  vvuitnodigingbeurs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

export type PersoonInfo = {
  __typename?: 'PersoonInfo';
  aanhef?: Maybe<Scalars['String']['output']>;
  adresvoorkeur?: Maybe<Scalars['String']['output']>;
  afdeling?: Maybe<Scalars['String']['output']>;
  cdaanhef?: Maybe<Scalars['String']['output']>;
  cdafdeling?: Maybe<Scalars['String']['output']>;
  cdfunctie?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdrol?: Maybe<Scalars['String']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdtitelna?: Maybe<Scalars['String']['output']>;
  cdtitelvoor?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  functie?: Maybe<Scalars['String']['output']>;
  geboortedatum?: Maybe<Scalars['Date']['output']>;
  geslacht?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  rolvoorkeur?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  taal?: Maybe<Scalars['String']['output']>;
  tav?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  titelna?: Maybe<Scalars['String']['output']>;
  titelvoor?: Maybe<Scalars['String']['output']>;
  voorletters?: Maybe<Scalars['String']['output']>;
  voornaam?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `PersoonInfo` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PersoonInfoCondition = {
  /** Checks for equality with the object’s `aanhef` field. */
  aanhef?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `adresvoorkeur` field. */
  adresvoorkeur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `afdeling` field. */
  afdeling?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdaanhef` field. */
  cdaanhef?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdafdeling` field. */
  cdafdeling?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfunctie` field. */
  cdfunctie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdrol` field. */
  cdrol?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `functie` field. */
  functie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geboortedatum` field. */
  geboortedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `geslacht` field. */
  geslacht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rolvoorkeur` field. */
  rolvoorkeur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `taal` field. */
  taal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tav` field. */
  tav?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `titelna` field. */
  titelna?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `titelvoor` field. */
  titelvoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorletters` field. */
  voorletters?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voornaam` field. */
  voornaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PersoonInfo` object types. All fields are combined with a logical ‘and.’ */
export type PersoonInfoFilter = {
  /** Filter by the object’s `aanhef` field. */
  aanhef?: InputMaybe<StringFilter>;
  /** Filter by the object’s `adresvoorkeur` field. */
  adresvoorkeur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `afdeling` field. */
  afdeling?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PersoonInfoFilter>>;
  /** Filter by the object’s `cdaanhef` field. */
  cdaanhef?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdafdeling` field. */
  cdafdeling?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfunctie` field. */
  cdfunctie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdrol` field. */
  cdrol?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `functie` field. */
  functie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geboortedatum` field. */
  geboortedatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `geslacht` field. */
  geslacht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PersoonInfoFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PersoonInfoFilter>>;
  /** Filter by the object’s `rolvoorkeur` field. */
  rolvoorkeur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `taal` field. */
  taal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tav` field. */
  tav?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `titelna` field. */
  titelna?: InputMaybe<StringFilter>;
  /** Filter by the object’s `titelvoor` field. */
  titelvoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorletters` field. */
  voorletters?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voornaam` field. */
  voornaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

export type PersoonInfoMv = {
  __typename?: 'PersoonInfoMv';
  aanhef?: Maybe<Scalars['String']['output']>;
  adresvoorkeur?: Maybe<Scalars['String']['output']>;
  afdeling?: Maybe<Scalars['String']['output']>;
  cdaanhef?: Maybe<Scalars['String']['output']>;
  cdafdeling?: Maybe<Scalars['String']['output']>;
  cdfunctie?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdrol?: Maybe<Scalars['String']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdtitelna?: Maybe<Scalars['String']['output']>;
  cdtitelvoor?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  functie?: Maybe<Scalars['String']['output']>;
  geboortedatum?: Maybe<Scalars['Date']['output']>;
  geslacht?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  rolvoorkeur?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  taal?: Maybe<Scalars['String']['output']>;
  tav?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  titelna?: Maybe<Scalars['String']['output']>;
  titelvoor?: Maybe<Scalars['String']['output']>;
  voorletters?: Maybe<Scalars['String']['output']>;
  voornaam?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `PersoonInfoMv` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PersoonInfoMvCondition = {
  /** Checks for equality with the object’s `aanhef` field. */
  aanhef?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `adresvoorkeur` field. */
  adresvoorkeur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `afdeling` field. */
  afdeling?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdaanhef` field. */
  cdaanhef?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdafdeling` field. */
  cdafdeling?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfunctie` field. */
  cdfunctie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdrol` field. */
  cdrol?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `functie` field. */
  functie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geboortedatum` field. */
  geboortedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `geslacht` field. */
  geslacht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rolvoorkeur` field. */
  rolvoorkeur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `taal` field. */
  taal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tav` field. */
  tav?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `titelna` field. */
  titelna?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `titelvoor` field. */
  titelvoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorletters` field. */
  voorletters?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voornaam` field. */
  voornaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PersoonInfoMv` object types. All fields are combined with a logical ‘and.’ */
export type PersoonInfoMvFilter = {
  /** Filter by the object’s `aanhef` field. */
  aanhef?: InputMaybe<StringFilter>;
  /** Filter by the object’s `adresvoorkeur` field. */
  adresvoorkeur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `afdeling` field. */
  afdeling?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PersoonInfoMvFilter>>;
  /** Filter by the object’s `cdaanhef` field. */
  cdaanhef?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdafdeling` field. */
  cdafdeling?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfunctie` field. */
  cdfunctie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdrol` field. */
  cdrol?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `functie` field. */
  functie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geboortedatum` field. */
  geboortedatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `geslacht` field. */
  geslacht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PersoonInfoMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PersoonInfoMvFilter>>;
  /** Filter by the object’s `rolvoorkeur` field. */
  rolvoorkeur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `taal` field. */
  taal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tav` field. */
  tav?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `titelna` field. */
  titelna?: InputMaybe<StringFilter>;
  /** Filter by the object’s `titelvoor` field. */
  titelvoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorletters` field. */
  voorletters?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voornaam` field. */
  voornaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `PersoonInfoMv` values. */
export type PersoonInfoMvsConnection = {
  __typename?: 'PersoonInfoMvsConnection';
  /** A list of edges which contains the `PersoonInfoMv` and cursor to aid in pagination. */
  edges: Array<PersoonInfoMvsEdge>;
  /** A list of `PersoonInfoMv` objects. */
  nodes: Array<PersoonInfoMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersoonInfoMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PersoonInfoMv` edge in the connection. */
export type PersoonInfoMvsEdge = {
  __typename?: 'PersoonInfoMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PersoonInfoMv` at the end of the edge. */
  node: PersoonInfoMv;
};

/** Methods to use when ordering `PersoonInfoMv`. */
export enum PersoonInfoMvsOrderBy {
  AanhefAsc = 'AANHEF_ASC',
  AanhefDesc = 'AANHEF_DESC',
  AdresvoorkeurAsc = 'ADRESVOORKEUR_ASC',
  AdresvoorkeurDesc = 'ADRESVOORKEUR_DESC',
  AfdelingAsc = 'AFDELING_ASC',
  AfdelingDesc = 'AFDELING_DESC',
  CdaanhefAsc = 'CDAANHEF_ASC',
  CdaanhefDesc = 'CDAANHEF_DESC',
  CdafdelingAsc = 'CDAFDELING_ASC',
  CdafdelingDesc = 'CDAFDELING_DESC',
  CdfunctieAsc = 'CDFUNCTIE_ASC',
  CdfunctieDesc = 'CDFUNCTIE_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdrolAsc = 'CDROL_ASC',
  CdrolDesc = 'CDROL_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdtitelnaAsc = 'CDTITELNA_ASC',
  CdtitelnaDesc = 'CDTITELNA_DESC',
  CdtitelvoorAsc = 'CDTITELVOOR_ASC',
  CdtitelvoorDesc = 'CDTITELVOOR_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FunctieAsc = 'FUNCTIE_ASC',
  FunctieDesc = 'FUNCTIE_DESC',
  GeboortedatumAsc = 'GEBOORTEDATUM_ASC',
  GeboortedatumDesc = 'GEBOORTEDATUM_DESC',
  GeslachtAsc = 'GESLACHT_ASC',
  GeslachtDesc = 'GESLACHT_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  RolvoorkeurAsc = 'ROLVOORKEUR_ASC',
  RolvoorkeurDesc = 'ROLVOORKEUR_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TaalAsc = 'TAAL_ASC',
  TaalDesc = 'TAAL_DESC',
  TavAsc = 'TAV_ASC',
  TavDesc = 'TAV_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  TitelnaAsc = 'TITELNA_ASC',
  TitelnaDesc = 'TITELNA_DESC',
  TitelvoorAsc = 'TITELVOOR_ASC',
  TitelvoorDesc = 'TITELVOOR_DESC',
  VoorlettersAsc = 'VOORLETTERS_ASC',
  VoorlettersDesc = 'VOORLETTERS_DESC',
  VoornaamAsc = 'VOORNAAM_ASC',
  VoornaamDesc = 'VOORNAAM_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A connection to a list of `PersoonInfo` values. */
export type PersoonInfosConnection = {
  __typename?: 'PersoonInfosConnection';
  /** A list of edges which contains the `PersoonInfo` and cursor to aid in pagination. */
  edges: Array<PersoonInfosEdge>;
  /** A list of `PersoonInfo` objects. */
  nodes: Array<PersoonInfo>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersoonInfo` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PersoonInfo` edge in the connection. */
export type PersoonInfosEdge = {
  __typename?: 'PersoonInfosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PersoonInfo` at the end of the edge. */
  node: PersoonInfo;
};

/** Methods to use when ordering `PersoonInfo`. */
export enum PersoonInfosOrderBy {
  AanhefAsc = 'AANHEF_ASC',
  AanhefDesc = 'AANHEF_DESC',
  AdresvoorkeurAsc = 'ADRESVOORKEUR_ASC',
  AdresvoorkeurDesc = 'ADRESVOORKEUR_DESC',
  AfdelingAsc = 'AFDELING_ASC',
  AfdelingDesc = 'AFDELING_DESC',
  CdaanhefAsc = 'CDAANHEF_ASC',
  CdaanhefDesc = 'CDAANHEF_DESC',
  CdafdelingAsc = 'CDAFDELING_ASC',
  CdafdelingDesc = 'CDAFDELING_DESC',
  CdfunctieAsc = 'CDFUNCTIE_ASC',
  CdfunctieDesc = 'CDFUNCTIE_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdrolAsc = 'CDROL_ASC',
  CdrolDesc = 'CDROL_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdtitelnaAsc = 'CDTITELNA_ASC',
  CdtitelnaDesc = 'CDTITELNA_DESC',
  CdtitelvoorAsc = 'CDTITELVOOR_ASC',
  CdtitelvoorDesc = 'CDTITELVOOR_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FunctieAsc = 'FUNCTIE_ASC',
  FunctieDesc = 'FUNCTIE_DESC',
  GeboortedatumAsc = 'GEBOORTEDATUM_ASC',
  GeboortedatumDesc = 'GEBOORTEDATUM_DESC',
  GeslachtAsc = 'GESLACHT_ASC',
  GeslachtDesc = 'GESLACHT_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  RolvoorkeurAsc = 'ROLVOORKEUR_ASC',
  RolvoorkeurDesc = 'ROLVOORKEUR_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TaalAsc = 'TAAL_ASC',
  TaalDesc = 'TAAL_DESC',
  TavAsc = 'TAV_ASC',
  TavDesc = 'TAV_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  TitelnaAsc = 'TITELNA_ASC',
  TitelnaDesc = 'TITELNA_DESC',
  TitelvoorAsc = 'TITELVOOR_ASC',
  TitelvoorDesc = 'TITELVOOR_DESC',
  VoorlettersAsc = 'VOORLETTERS_ASC',
  VoorlettersDesc = 'VOORLETTERS_DESC',
  VoornaamAsc = 'VOORNAAM_ASC',
  VoornaamDesc = 'VOORNAAM_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type PersoonMv = {
  __typename?: 'PersoonMv';
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdtitelna?: Maybe<Scalars['String']['output']>;
  cdtitelvoor?: Maybe<Scalars['String']['output']>;
  geboortedatum?: Maybe<Scalars['Date']['output']>;
  geslacht?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  voorletters?: Maybe<Scalars['String']['output']>;
  voornaam?: Maybe<Scalars['String']['output']>;
  vvbriefvertrekdh?: Maybe<Scalars['String']['output']>;
  vvdiverse?: Maybe<Scalars['String']['output']>;
  vvkalender?: Maybe<Scalars['String']['output']>;
  vvkerst?: Maybe<Scalars['String']['output']>;
  vvlead?: Maybe<Scalars['String']['output']>;
  vvlocatie?: Maybe<Scalars['String']['output']>;
  vvopvolgingbeurs?: Maybe<Scalars['String']['output']>;
  vvuitnodigingbeurs?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `PersoonMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PersoonMvCondition = {
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geboortedatum` field. */
  geboortedatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `geslacht` field. */
  geslacht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorletters` field. */
  voorletters?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voornaam` field. */
  voornaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvbriefvertrekdh` field. */
  vvbriefvertrekdh?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvdiverse` field. */
  vvdiverse?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvkalender` field. */
  vvkalender?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvkerst` field. */
  vvkerst?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvlead` field. */
  vvlead?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvlocatie` field. */
  vvlocatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvopvolgingbeurs` field. */
  vvopvolgingbeurs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvuitnodigingbeurs` field. */
  vvuitnodigingbeurs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PersoonMv` object types. All fields are combined with a logical ‘and.’ */
export type PersoonMvFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PersoonMvFilter>>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelna` field. */
  cdtitelna?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtitelvoor` field. */
  cdtitelvoor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geboortedatum` field. */
  geboortedatum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `geslacht` field. */
  geslacht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PersoonMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PersoonMvFilter>>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorletters` field. */
  voorletters?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voornaam` field. */
  voornaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvbriefvertrekdh` field. */
  vvbriefvertrekdh?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvdiverse` field. */
  vvdiverse?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvkalender` field. */
  vvkalender?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvkerst` field. */
  vvkerst?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvlead` field. */
  vvlead?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvlocatie` field. */
  vvlocatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvopvolgingbeurs` field. */
  vvopvolgingbeurs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvuitnodigingbeurs` field. */
  vvuitnodigingbeurs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `PersoonMv` values. */
export type PersoonMvsConnection = {
  __typename?: 'PersoonMvsConnection';
  /** A list of edges which contains the `PersoonMv` and cursor to aid in pagination. */
  edges: Array<PersoonMvsEdge>;
  /** A list of `PersoonMv` objects. */
  nodes: Array<PersoonMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersoonMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PersoonMv` edge in the connection. */
export type PersoonMvsEdge = {
  __typename?: 'PersoonMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PersoonMv` at the end of the edge. */
  node: PersoonMv;
};

/** Methods to use when ordering `PersoonMv`. */
export enum PersoonMvsOrderBy {
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdtitelnaAsc = 'CDTITELNA_ASC',
  CdtitelnaDesc = 'CDTITELNA_DESC',
  CdtitelvoorAsc = 'CDTITELVOOR_ASC',
  CdtitelvoorDesc = 'CDTITELVOOR_DESC',
  GeboortedatumAsc = 'GEBOORTEDATUM_ASC',
  GeboortedatumDesc = 'GEBOORTEDATUM_DESC',
  GeslachtAsc = 'GESLACHT_ASC',
  GeslachtDesc = 'GESLACHT_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  VoorlettersAsc = 'VOORLETTERS_ASC',
  VoorlettersDesc = 'VOORLETTERS_DESC',
  VoornaamAsc = 'VOORNAAM_ASC',
  VoornaamDesc = 'VOORNAAM_DESC',
  VvbriefvertrekdhAsc = 'VVBRIEFVERTREKDH_ASC',
  VvbriefvertrekdhDesc = 'VVBRIEFVERTREKDH_DESC',
  VvdiverseAsc = 'VVDIVERSE_ASC',
  VvdiverseDesc = 'VVDIVERSE_DESC',
  VvkalenderAsc = 'VVKALENDER_ASC',
  VvkalenderDesc = 'VVKALENDER_DESC',
  VvkerstAsc = 'VVKERST_ASC',
  VvkerstDesc = 'VVKERST_DESC',
  VvleadAsc = 'VVLEAD_ASC',
  VvleadDesc = 'VVLEAD_DESC',
  VvlocatieAsc = 'VVLOCATIE_ASC',
  VvlocatieDesc = 'VVLOCATIE_DESC',
  VvopvolgingbeursAsc = 'VVOPVOLGINGBEURS_ASC',
  VvopvolgingbeursDesc = 'VVOPVOLGINGBEURS_DESC',
  VvuitnodigingbeursAsc = 'VVUITNODIGINGBEURS_ASC',
  VvuitnodigingbeursDesc = 'VVUITNODIGINGBEURS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type PersoonRol = Node & {
  __typename?: 'PersoonRol';
  cdafdeling?: Maybe<Scalars['String']['output']>;
  cdfunctie?: Maybe<Scalars['String']['output']>;
  cdpersoon: Scalars['String']['output'];
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdrol: Scalars['String']['output'];
  limiet?: Maybe<Scalars['BigFloat']['output']>;
  limietPerc?: Maybe<Scalars['BigFloat']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  persoonRolGuid: Scalars['String']['output'];
  rolcode?: Maybe<Scalars['String']['output']>;
  voorkeur: Scalars['String']['output'];
};

/**
 * A condition to be used against `PersoonRol` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PersoonRolCondition = {
  /** Checks for equality with the object’s `cdafdeling` field. */
  cdafdeling?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdfunctie` field. */
  cdfunctie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdrol` field. */
  cdrol?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `limiet` field. */
  limiet?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `limietPerc` field. */
  limietPerc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `persoonRolGuid` field. */
  persoonRolGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rolcode` field. */
  rolcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PersoonRol` object types. All fields are combined with a logical ‘and.’ */
export type PersoonRolFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PersoonRolFilter>>;
  /** Filter by the object’s `cdafdeling` field. */
  cdafdeling?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdfunctie` field. */
  cdfunctie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdpersoon` field. */
  cdpersoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdrol` field. */
  cdrol?: InputMaybe<StringFilter>;
  /** Filter by the object’s `limiet` field. */
  limiet?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `limietPerc` field. */
  limietPerc?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PersoonRolFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PersoonRolFilter>>;
  /** Filter by the object’s `persoonRolGuid` field. */
  persoonRolGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `rolcode` field. */
  rolcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `PersoonRol` */
export type PersoonRolInput = {
  cdafdeling?: InputMaybe<Scalars['String']['input']>;
  cdfunctie?: InputMaybe<Scalars['String']['input']>;
  cdpersoon: Scalars['String']['input'];
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  cdrol: Scalars['String']['input'];
  limiet?: InputMaybe<Scalars['BigFloat']['input']>;
  limietPerc?: InputMaybe<Scalars['BigFloat']['input']>;
  persoonRolGuid: Scalars['String']['input'];
  rolcode?: InputMaybe<Scalars['String']['input']>;
  voorkeur: Scalars['String']['input'];
};

/** Represents an update to a `PersoonRol`. Fields that are set will be updated. */
export type PersoonRolPatch = {
  cdafdeling?: InputMaybe<Scalars['String']['input']>;
  cdfunctie?: InputMaybe<Scalars['String']['input']>;
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  cdrol?: InputMaybe<Scalars['String']['input']>;
  limiet?: InputMaybe<Scalars['BigFloat']['input']>;
  limietPerc?: InputMaybe<Scalars['BigFloat']['input']>;
  persoonRolGuid?: InputMaybe<Scalars['String']['input']>;
  rolcode?: InputMaybe<Scalars['String']['input']>;
  voorkeur?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `PersoonRol` values. */
export type PersoonRolsConnection = {
  __typename?: 'PersoonRolsConnection';
  /** A list of edges which contains the `PersoonRol` and cursor to aid in pagination. */
  edges: Array<PersoonRolsEdge>;
  /** A list of `PersoonRol` objects. */
  nodes: Array<PersoonRol>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PersoonRol` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PersoonRol` edge in the connection. */
export type PersoonRolsEdge = {
  __typename?: 'PersoonRolsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PersoonRol` at the end of the edge. */
  node: PersoonRol;
};

/** Methods to use when ordering `PersoonRol`. */
export enum PersoonRolsOrderBy {
  CdafdelingAsc = 'CDAFDELING_ASC',
  CdafdelingDesc = 'CDAFDELING_DESC',
  CdfunctieAsc = 'CDFUNCTIE_ASC',
  CdfunctieDesc = 'CDFUNCTIE_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdrolAsc = 'CDROL_ASC',
  CdrolDesc = 'CDROL_DESC',
  LimietAsc = 'LIMIET_ASC',
  LimietDesc = 'LIMIET_DESC',
  LimietPercAsc = 'LIMIET_PERC_ASC',
  LimietPercDesc = 'LIMIET_PERC_DESC',
  Natural = 'NATURAL',
  PersoonRolGuidAsc = 'PERSOON_ROL_GUID_ASC',
  PersoonRolGuidDesc = 'PERSOON_ROL_GUID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RolcodeAsc = 'ROLCODE_ASC',
  RolcodeDesc = 'ROLCODE_DESC',
  VoorkeurAsc = 'VOORKEUR_ASC',
  VoorkeurDesc = 'VOORKEUR_DESC'
}

/** A connection to a list of `Persoon` values. */
export type PersoonsConnection = {
  __typename?: 'PersoonsConnection';
  /** A list of edges which contains the `Persoon` and cursor to aid in pagination. */
  edges: Array<PersoonsEdge>;
  /** A list of `Persoon` objects. */
  nodes: Array<Persoon>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Persoon` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Persoon` edge in the connection. */
export type PersoonsEdge = {
  __typename?: 'PersoonsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Persoon` at the end of the edge. */
  node: Persoon;
};

/** Methods to use when ordering `Persoon`. */
export enum PersoonsOrderBy {
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdtitelnaAsc = 'CDTITELNA_ASC',
  CdtitelnaDesc = 'CDTITELNA_DESC',
  CdtitelvoorAsc = 'CDTITELVOOR_ASC',
  CdtitelvoorDesc = 'CDTITELVOOR_DESC',
  GeboortedatumAsc = 'GEBOORTEDATUM_ASC',
  GeboortedatumDesc = 'GEBOORTEDATUM_DESC',
  GeslachtAsc = 'GESLACHT_ASC',
  GeslachtDesc = 'GESLACHT_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  VoorlettersAsc = 'VOORLETTERS_ASC',
  VoorlettersDesc = 'VOORLETTERS_DESC',
  VoornaamAsc = 'VOORNAAM_ASC',
  VoornaamDesc = 'VOORNAAM_DESC',
  VvbriefvertrekdhAsc = 'VVBRIEFVERTREKDH_ASC',
  VvbriefvertrekdhDesc = 'VVBRIEFVERTREKDH_DESC',
  VvdiverseAsc = 'VVDIVERSE_ASC',
  VvdiverseDesc = 'VVDIVERSE_DESC',
  VvkalenderAsc = 'VVKALENDER_ASC',
  VvkalenderDesc = 'VVKALENDER_DESC',
  VvkerstAsc = 'VVKERST_ASC',
  VvkerstDesc = 'VVKERST_DESC',
  VvleadAsc = 'VVLEAD_ASC',
  VvleadDesc = 'VVLEAD_DESC',
  VvlocatieAsc = 'VVLOCATIE_ASC',
  VvlocatieDesc = 'VVLOCATIE_DESC',
  VvopvolgingbeursAsc = 'VVOPVOLGINGBEURS_ASC',
  VvopvolgingbeursDesc = 'VVOPVOLGINGBEURS_DESC',
  VvuitnodigingbeursAsc = 'VVUITNODIGINGBEURS_ASC',
  VvuitnodigingbeursDesc = 'VVUITNODIGINGBEURS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type Plug = Node & {
  __typename?: 'Plug';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByPlugId: SensorTypesConnection;
  /** Reads a single `User` that is related to this `Plug`. */
  userByOwnerId?: Maybe<User>;
};


export type PlugSensorTypesByPlugIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/** A condition to be used against `Plug` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PlugCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Plug` object types. All fields are combined with a logical ‘and.’ */
export type PlugFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PlugFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PlugFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PlugFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypesByPlugId` relation. */
  sensorTypesByPlugId?: InputMaybe<PlugToManySensorTypeFilter>;
  /** Some related `sensorTypesByPlugId` exist. */
  sensorTypesByPlugIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Plug` */
export type PlugInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Plug`. Fields that are set will be updated. */
export type PlugPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type PlugToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `Plug` values. */
export type PlugsConnection = {
  __typename?: 'PlugsConnection';
  /** A list of edges which contains the `Plug` and cursor to aid in pagination. */
  edges: Array<PlugsEdge>;
  /** A list of `Plug` objects. */
  nodes: Array<Plug>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Plug` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Plug` edge in the connection. */
export type PlugsEdge = {
  __typename?: 'PlugsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Plug` at the end of the edge. */
  node: Plug;
};

/** Methods to use when ordering `Plug`. */
export enum PlugsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorTypesByPlugIdCountAsc = 'SENSOR_TYPES_BY_PLUG_ID__COUNT_ASC',
  SensorTypesByPlugIdCountDesc = 'SENSOR_TYPES_BY_PLUG_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Principle = Node & {
  __typename?: 'Principle';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorBaseType`. */
  sensorBaseTypesByPrincipleId: SensorBaseTypesConnection;
  /** Reads a single `User` that is related to this `Principle`. */
  userByOwnerId?: Maybe<User>;
};


export type PrincipleSensorBaseTypesByPrincipleIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorBaseTypeCondition>;
  filter?: InputMaybe<SensorBaseTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorBaseTypesOrderBy>>;
};

/**
 * A condition to be used against `Principle` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PrincipleCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Principle` object types. All fields are combined with a logical ‘and.’ */
export type PrincipleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PrincipleFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PrincipleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PrincipleFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorBaseTypesByPrincipleId` relation. */
  sensorBaseTypesByPrincipleId?: InputMaybe<PrincipleToManySensorBaseTypeFilter>;
  /** Some related `sensorBaseTypesByPrincipleId` exist. */
  sensorBaseTypesByPrincipleIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Principle` */
export type PrincipleInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Principle`. Fields that are set will be updated. */
export type PrinciplePatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `SensorBaseType` object types. All fields are combined with a logical ‘and.’ */
export type PrincipleToManySensorBaseTypeFilter = {
  /** Every related `SensorBaseType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorBaseTypeFilter>;
  /** No related `SensorBaseType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorBaseTypeFilter>;
  /** Some related `SensorBaseType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorBaseTypeFilter>;
};

/** A connection to a list of `Principle` values. */
export type PrinciplesConnection = {
  __typename?: 'PrinciplesConnection';
  /** A list of edges which contains the `Principle` and cursor to aid in pagination. */
  edges: Array<PrinciplesEdge>;
  /** A list of `Principle` objects. */
  nodes: Array<Principle>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Principle` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Principle` edge in the connection. */
export type PrinciplesEdge = {
  __typename?: 'PrinciplesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Principle` at the end of the edge. */
  node: Principle;
};

/** Methods to use when ordering `Principle`. */
export enum PrinciplesOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorBaseTypesByPrincipleIdCountAsc = 'SENSOR_BASE_TYPES_BY_PRINCIPLE_ID__COUNT_ASC',
  SensorBaseTypesByPrincipleIdCountDesc = 'SENSOR_BASE_TYPES_BY_PRINCIPLE_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Production = Node & {
  __typename?: 'Production';
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `Production` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ProductionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Production` object types. All fields are combined with a logical ‘and.’ */
export type ProductionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ProductionFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ProductionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ProductionFilter>>;
};

/** An input for mutations affecting `Production` */
export type ProductionInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Production`. Fields that are set will be updated. */
export type ProductionPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Production` values. */
export type ProductionsConnection = {
  __typename?: 'ProductionsConnection';
  /** A list of edges which contains the `Production` and cursor to aid in pagination. */
  edges: Array<ProductionsEdge>;
  /** A list of `Production` objects. */
  nodes: Array<Production>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Production` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Production` edge in the connection. */
export type ProductionsEdge = {
  __typename?: 'ProductionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Production` at the end of the edge. */
  node: Production;
};

/** Methods to use when ordering `Production`. */
export enum ProductionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type Pyrolyser = Node & {
  __typename?: 'Pyrolyser';
  cdartikel: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DetectorSensor`. */
  detectorSensorsByPyrolyserId: DetectorSensorsConnection;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  maintenanceVisitLinesByPyrolyserId: MaintenanceVisitLinesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByPyrolyserId: SensorTypesConnection;
  /** Reads a single `User` that is related to this `Pyrolyser`. */
  userByOwnerId?: Maybe<User>;
};


export type PyrolyserDetectorSensorsByPyrolyserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorCondition>;
  filter?: InputMaybe<DetectorSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};


export type PyrolyserMaintenanceVisitLinesByPyrolyserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};


export type PyrolyserSensorTypesByPyrolyserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/**
 * A condition to be used against `Pyrolyser` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PyrolyserCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `PyrolyserEntity` values. */
export type PyrolyserEntitiesConnection = {
  __typename?: 'PyrolyserEntitiesConnection';
  /** A list of edges which contains the `PyrolyserEntity` and cursor to aid in pagination. */
  edges: Array<PyrolyserEntitiesEdge>;
  /** A list of `PyrolyserEntity` objects. */
  nodes: Array<PyrolyserEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PyrolyserEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PyrolyserEntity` edge in the connection. */
export type PyrolyserEntitiesEdge = {
  __typename?: 'PyrolyserEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PyrolyserEntity` at the end of the edge. */
  node: PyrolyserEntity;
};

/** Methods to use when ordering `PyrolyserEntity`. */
export enum PyrolyserEntitiesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC'
}

export type PyrolyserEntity = {
  __typename?: 'PyrolyserEntity';
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `PyrolyserEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PyrolyserEntityCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `PyrolyserEntity` object types. All fields are combined with a logical ‘and.’ */
export type PyrolyserEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PyrolyserEntityFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PyrolyserEntityFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PyrolyserEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
};

/** A filter to be used against `Pyrolyser` object types. All fields are combined with a logical ‘and.’ */
export type PyrolyserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PyrolyserFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorSensorsByPyrolyserId` relation. */
  detectorSensorsByPyrolyserId?: InputMaybe<PyrolyserToManyDetectorSensorFilter>;
  /** Some related `detectorSensorsByPyrolyserId` exist. */
  detectorSensorsByPyrolyserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceVisitLinesByPyrolyserId` relation. */
  maintenanceVisitLinesByPyrolyserId?: InputMaybe<PyrolyserToManyMaintenanceVisitLineFilter>;
  /** Some related `maintenanceVisitLinesByPyrolyserId` exist. */
  maintenanceVisitLinesByPyrolyserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PyrolyserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PyrolyserFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypesByPyrolyserId` relation. */
  sensorTypesByPyrolyserId?: InputMaybe<PyrolyserToManySensorTypeFilter>;
  /** Some related `sensorTypesByPyrolyserId` exist. */
  sensorTypesByPyrolyserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Pyrolyser` */
export type PyrolyserInput = {
  cdartikel: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Pyrolyser`. Fields that are set will be updated. */
export type PyrolyserPatch = {
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `DetectorSensor` object types. All fields are combined with a logical ‘and.’ */
export type PyrolyserToManyDetectorSensorFilter = {
  /** Every related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorFilter>;
  /** No related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorFilter>;
  /** Some related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorFilter>;
};

/** A filter to be used against many `MaintenanceVisitLine` object types. All fields are combined with a logical ‘and.’ */
export type PyrolyserToManyMaintenanceVisitLineFilter = {
  /** Every related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitLineFilter>;
  /** No related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitLineFilter>;
  /** Some related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitLineFilter>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type PyrolyserToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `Pyrolyser` values. */
export type PyrolysersConnection = {
  __typename?: 'PyrolysersConnection';
  /** A list of edges which contains the `Pyrolyser` and cursor to aid in pagination. */
  edges: Array<PyrolysersEdge>;
  /** A list of `Pyrolyser` objects. */
  nodes: Array<Pyrolyser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pyrolyser` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Pyrolyser` edge in the connection. */
export type PyrolysersEdge = {
  __typename?: 'PyrolysersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Pyrolyser` at the end of the edge. */
  node: Pyrolyser;
};

/** Methods to use when ordering `Pyrolyser`. */
export enum PyrolysersOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorSensorsByPyrolyserIdCountAsc = 'DETECTOR_SENSORS_BY_PYROLYSER_ID__COUNT_ASC',
  DetectorSensorsByPyrolyserIdCountDesc = 'DETECTOR_SENSORS_BY_PYROLYSER_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceVisitLinesByPyrolyserIdCountAsc = 'MAINTENANCE_VISIT_LINES_BY_PYROLYSER_ID__COUNT_ASC',
  MaintenanceVisitLinesByPyrolyserIdCountDesc = 'MAINTENANCE_VISIT_LINES_BY_PYROLYSER_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorTypesByPyrolyserIdCountAsc = 'SENSOR_TYPES_BY_PYROLYSER_ID__COUNT_ASC',
  SensorTypesByPyrolyserIdCountDesc = 'SENSOR_TYPES_BY_PYROLYSER_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Reads a single `_Adre` using its globally unique `ID`. */
  _adre?: Maybe<_Adre>;
  _adreByAdresGuid?: Maybe<_Adre>;
  /** Reads a single `_Land` using its globally unique `ID`. */
  _land?: Maybe<_Land>;
  _landByCdland?: Maybe<_Land>;
  /** Reads a single `Aco` using its globally unique `ID`. */
  aco?: Maybe<Aco>;
  acoById?: Maybe<Aco>;
  /** Reads a single `Action` using its globally unique `ID`. */
  action?: Maybe<Action>;
  actionById?: Maybe<Action>;
  /** Reads and enables pagination through a set of `Aco`. */
  allAcos?: Maybe<AcosConnection>;
  /** Reads and enables pagination through a set of `Action`. */
  allActions?: Maybe<ActionsConnection>;
  /** Reads and enables pagination through a set of `Adre`. */
  allAdres?: Maybe<AdresConnection>;
  /** Reads and enables pagination through a set of `AdresMv`. */
  allAdresMvs?: Maybe<AdresMvsConnection>;
  /** Reads and enables pagination through a set of `AnotherRefreshToken`. */
  allAnotherRefreshTokens?: Maybe<AnotherRefreshTokensConnection>;
  /** Reads and enables pagination through a set of `Application`. */
  allApplications?: Maybe<ApplicationsConnection>;
  /** Reads and enables pagination through a set of `AreaEntity`. */
  allAreaEntities?: Maybe<AreaEntitiesConnection>;
  /** Reads and enables pagination through a set of `Area`. */
  allAreas?: Maybe<AreasConnection>;
  /** Reads and enables pagination through a set of `Aro`. */
  allAros?: Maybe<ArosConnection>;
  /** Reads and enables pagination through a set of `ArosAco`. */
  allArosAcos?: Maybe<ArosAcosConnection>;
  /** Reads and enables pagination through a set of `Artikel2`. */
  allArtikel2S?: Maybe<Artikel2SConnection>;
  /** Reads and enables pagination through a set of `ArtikelAssemblyIndex`. */
  allArtikelAssemblyIndices?: Maybe<ArtikelAssemblyIndicesConnection>;
  /** Reads and enables pagination through a set of `ArtikelComponenten`. */
  allArtikelComponentens?: Maybe<ArtikelComponentensConnection>;
  /** Reads and enables pagination through a set of `ArtikelIndex2`. */
  allArtikelIndex2S?: Maybe<ArtikelIndex2SConnection>;
  /** Reads and enables pagination through a set of `ArtikelIndex`. */
  allArtikelIndices?: Maybe<ArtikelIndicesConnection>;
  /** Reads and enables pagination through a set of `ArtikelLog`. */
  allArtikelLogs?: Maybe<ArtikelLogsConnection>;
  /** Reads and enables pagination through a set of `ArtikelLogsIndex`. */
  allArtikelLogsIndices?: Maybe<ArtikelLogsIndicesConnection>;
  /** Reads and enables pagination through a set of `ArtikelMv`. */
  allArtikelMvs?: Maybe<ArtikelMvsConnection>;
  /** Reads and enables pagination through a set of `ArtikelSamenstellingen`. */
  allArtikelSamenstellingens?: Maybe<ArtikelSamenstellingensConnection>;
  /** Reads and enables pagination through a set of `ArtikelomschrMv`. */
  allArtikelomschrMvs?: Maybe<ArtikelomschrMvsConnection>;
  /** Reads and enables pagination through a set of `Artikelomschr`. */
  allArtikelomschrs?: Maybe<ArtikelomschrsConnection>;
  /** Reads and enables pagination through a set of `Artikel`. */
  allArtikels?: Maybe<ArtikelsConnection>;
  /** Reads and enables pagination through a set of `ArtsamcomponentenMv`. */
  allArtsamcomponentenMvs?: Maybe<ArtsamcomponentenMvsConnection>;
  /** Reads and enables pagination through a set of `Artsamcomponenten`. */
  allArtsamcomponentens?: Maybe<ArtsamcomponentensConnection>;
  /** Reads and enables pagination through a set of `ArtsamenstellingMv`. */
  allArtsamenstellingMvs?: Maybe<ArtsamenstellingMvsConnection>;
  /** Reads and enables pagination through a set of `Artsamenstelling`. */
  allArtsamenstellings?: Maybe<ArtsamenstellingsConnection>;
  /** Reads and enables pagination through a set of `AspNetRoleClaim`. */
  allAspNetRoleClaims?: Maybe<AspNetRoleClaimsConnection>;
  /** Reads and enables pagination through a set of `AspNetRole`. */
  allAspNetRoles?: Maybe<AspNetRolesConnection>;
  /** Reads and enables pagination through a set of `AspNetUserClaim`. */
  allAspNetUserClaims?: Maybe<AspNetUserClaimsConnection>;
  /** Reads and enables pagination through a set of `AspNetUserLogin`. */
  allAspNetUserLogins?: Maybe<AspNetUserLoginsConnection>;
  /** Reads and enables pagination through a set of `AspNetUserRole`. */
  allAspNetUserRoles?: Maybe<AspNetUserRolesConnection>;
  /** Reads and enables pagination through a set of `AspNetUserToken`. */
  allAspNetUserTokens?: Maybe<AspNetUserTokensConnection>;
  /** Reads and enables pagination through a set of `AspNetUser`. */
  allAspNetUsers?: Maybe<AspNetUsersConnection>;
  /** Reads and enables pagination through a set of `AssemblageMv`. */
  allAssemblageMvs?: Maybe<AssemblageMvsConnection>;
  /** Reads and enables pagination through a set of `AssemblageregelMv`. */
  allAssemblageregelMvs?: Maybe<AssemblageregelMvsConnection>;
  /** Reads and enables pagination through a set of `Assemblageregel`. */
  allAssemblageregels?: Maybe<AssemblageregelsConnection>;
  /** Reads and enables pagination through a set of `Assemblage`. */
  allAssemblages?: Maybe<AssemblagesConnection>;
  /** Reads and enables pagination through a set of `Assembly`. */
  allAssemblies?: Maybe<AssembliesConnection>;
  /** Reads and enables pagination through a set of `AssemblyEntity`. */
  allAssemblyEntities?: Maybe<AssemblyEntitiesConnection>;
  /** Reads and enables pagination through a set of `AssemblyLineEntity`. */
  allAssemblyLineEntities?: Maybe<AssemblyLineEntitiesConnection>;
  /** Reads and enables pagination through a set of `AssemblyMultiversEntity`. */
  allAssemblyMultiversEntities?: Maybe<AssemblyMultiversEntitiesConnection>;
  /** Reads and enables pagination through a set of `AssemblyPart`. */
  allAssemblyParts?: Maybe<AssemblyPartsConnection>;
  /** Reads and enables pagination through a set of `AssemblyTypePart`. */
  allAssemblyTypeParts?: Maybe<AssemblyTypePartsConnection>;
  /** Reads and enables pagination through a set of `AssemblyType`. */
  allAssemblyTypes?: Maybe<AssemblyTypesConnection>;
  /** Reads and enables pagination through a set of `AssemblyTypesEntity`. */
  allAssemblyTypesEntities?: Maybe<AssemblyTypesEntitiesConnection>;
  /** Reads and enables pagination through a set of `Besteladvy`. */
  allBesteladvies?: Maybe<BesteladviesConnection>;
  /** Reads and enables pagination through a set of `BieStatus`. */
  allBieStatuses?: Maybe<BieStatusesConnection>;
  /** Reads and enables pagination through a set of `Building`. */
  allBuildings?: Maybe<BuildingsConnection>;
  /** Reads and enables pagination through a set of `CalGas`. */
  allCalGases?: Maybe<CalGasesConnection>;
  /** Reads and enables pagination through a set of `CalgasEntity`. */
  allCalgasEntities?: Maybe<CalgasEntitiesConnection>;
  /** Reads and enables pagination through a set of `CatalogGroup`. */
  allCatalogGroups?: Maybe<CatalogGroupsConnection>;
  /** Reads and enables pagination through a set of `CatalogItemFile`. */
  allCatalogItemFiles?: Maybe<CatalogItemFilesConnection>;
  /** Reads and enables pagination through a set of `CatalogItemRelation`. */
  allCatalogItemRelations?: Maybe<CatalogItemRelationsConnection>;
  /** Reads and enables pagination through a set of `CatalogItem`. */
  allCatalogItems?: Maybe<CatalogItemsConnection>;
  /** Reads and enables pagination through a set of `CatalogSubGroup`. */
  allCatalogSubGroups?: Maybe<CatalogSubGroupsConnection>;
  /** Reads and enables pagination through a set of `CdartikelJoin`. */
  allCdartikelJoins?: Maybe<CdartikelJoinsConnection>;
  /** Reads and enables pagination through a set of `ChemicalCompound`. */
  allChemicalCompounds?: Maybe<ChemicalCompoundsConnection>;
  /** Reads and enables pagination through a set of `ContactpersoonMv`. */
  allContactpersoonMvs?: Maybe<ContactpersoonMvsConnection>;
  /** Reads and enables pagination through a set of `CrediteurMv`. */
  allCrediteurMvs?: Maybe<CrediteurMvsConnection>;
  /** Reads and enables pagination through a set of `Crediteur`. */
  allCrediteurs?: Maybe<CrediteursConnection>;
  /** Reads and enables pagination through a set of `DebiteurMv`. */
  allDebiteurMvs?: Maybe<DebiteurMvsConnection>;
  /** Reads and enables pagination through a set of `Debiteur`. */
  allDebiteurs?: Maybe<DebiteursConnection>;
  /** Reads and enables pagination through a set of `DetectorEntity`. */
  allDetectorEntities?: Maybe<DetectorEntitiesConnection>;
  /** Reads and enables pagination through a set of `DetectorIndex`. */
  allDetectorIndices?: Maybe<DetectorIndicesConnection>;
  /** Reads and enables pagination through a set of `DetectorLocation`. */
  allDetectorLocations?: Maybe<DetectorLocationsConnection>;
  /** Reads and enables pagination through a set of `DetectorOrder`. */
  allDetectorOrders?: Maybe<DetectorOrdersConnection>;
  /** Reads and enables pagination through a set of `DetectorSensorIndex`. */
  allDetectorSensorIndices?: Maybe<DetectorSensorIndicesConnection>;
  /** Reads and enables pagination through a set of `DetectorSensorLocation`. */
  allDetectorSensorLocations?: Maybe<DetectorSensorLocationsConnection>;
  /** Reads and enables pagination through a set of `DetectorSensorLocationsEndUser`. */
  allDetectorSensorLocationsEndUsers?: Maybe<DetectorSensorLocationsEndUsersConnection>;
  /** Reads and enables pagination through a set of `DetectorSensorLocationsIndex`. */
  allDetectorSensorLocationsIndices?: Maybe<DetectorSensorLocationsIndicesConnection>;
  /** Reads and enables pagination through a set of `DetectorSensorType`. */
  allDetectorSensorTypes?: Maybe<DetectorSensorTypesConnection>;
  /** Reads and enables pagination through a set of `DetectorSensor`. */
  allDetectorSensors?: Maybe<DetectorSensorsConnection>;
  /** Reads and enables pagination through a set of `DetectorType`. */
  allDetectorTypes?: Maybe<DetectorTypesConnection>;
  /** Reads and enables pagination through a set of `DetectorTypesEntity`. */
  allDetectorTypesEntities?: Maybe<DetectorTypesEntitiesConnection>;
  /** Reads and enables pagination through a set of `Detector`. */
  allDetectors?: Maybe<DetectorsConnection>;
  /** Reads and enables pagination through a set of `DetectorsChecklist`. */
  allDetectorsChecklists?: Maybe<DetectorsChecklistsConnection>;
  /** Reads and enables pagination through a set of `DpCard`. */
  allDpCards?: Maybe<DpCardsConnection>;
  /** Reads and enables pagination through a set of `ElectrolyteEntity`. */
  allElectrolyteEntities?: Maybe<ElectrolyteEntitiesConnection>;
  /** Reads and enables pagination through a set of `Electrolyte`. */
  allElectrolytes?: Maybe<ElectrolytesConnection>;
  /** Reads and enables pagination through a set of `EndUser`. */
  allEndUsers?: Maybe<EndUsersConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtArtikelExclusion`. */
  allFactopdrachtArtikelExclusions?: Maybe<FactopdrachtArtikelExclusionsConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelAmount`. */
  allFactopdrachtregelAmounts?: Maybe<FactopdrachtregelAmountsConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelAmounts2`. */
  allFactopdrachtregelAmounts2S?: Maybe<FactopdrachtregelAmounts2SConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelFilterView`. */
  allFactopdrachtregelFilterViews?: Maybe<FactopdrachtregelFilterViewsConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelIndex`. */
  allFactopdrachtregelIndices?: Maybe<FactopdrachtregelIndicesConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineDate`. */
  allFactopdrachtregelLineDates?: Maybe<FactopdrachtregelLineDatesConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineDatesIndex`. */
  allFactopdrachtregelLineDatesIndices?: Maybe<FactopdrachtregelLineDatesIndicesConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineDatesTotal`. */
  allFactopdrachtregelLineDatesTotals?: Maybe<FactopdrachtregelLineDatesTotalsConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineDatesTotals2`. */
  allFactopdrachtregelLineDatesTotals2S?: Maybe<FactopdrachtregelLineDatesTotals2SConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineRemark`. */
  allFactopdrachtregelLineRemarks?: Maybe<FactopdrachtregelLineRemarksConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineRemarksIndex`. */
  allFactopdrachtregelLineRemarksIndices?: Maybe<FactopdrachtregelLineRemarksIndicesConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineWeek`. */
  allFactopdrachtregelLineWeeks?: Maybe<FactopdrachtregelLineWeeksConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineWeeksIndex`. */
  allFactopdrachtregelLineWeeksIndices?: Maybe<FactopdrachtregelLineWeeksIndicesConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelLine`. */
  allFactopdrachtregelLines?: Maybe<FactopdrachtregelLinesConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelMv`. */
  allFactopdrachtregelMvs?: Maybe<FactopdrachtregelMvsConnection>;
  /** Reads and enables pagination through a set of `FactopdrachtregelTotalAmount`. */
  allFactopdrachtregelTotalAmounts?: Maybe<FactopdrachtregelTotalAmountsConnection>;
  /** Reads and enables pagination through a set of `Factopdrachtregel`. */
  allFactopdrachtregels?: Maybe<FactopdrachtregelsConnection>;
  /** Reads and enables pagination through a set of `FactureeropdrachtIndex`. */
  allFactureeropdrachtIndices?: Maybe<FactureeropdrachtIndicesConnection>;
  /** Reads and enables pagination through a set of `FactureeropdrachtMv`. */
  allFactureeropdrachtMvs?: Maybe<FactureeropdrachtMvsConnection>;
  /** Reads and enables pagination through a set of `Factureeropdracht`. */
  allFactureeropdrachts?: Maybe<FactureeropdrachtsConnection>;
  /** Reads and enables pagination through a set of `Factuur`. */
  allFactuurs?: Maybe<FactuursConnection>;
  /** Reads and enables pagination through a set of `FilterEntity`. */
  allFilterEntities?: Maybe<FilterEntitiesConnection>;
  /** Reads and enables pagination through a set of `Filter`. */
  allFilters?: Maybe<FiltersConnection>;
  /** Reads and enables pagination through a set of `FloorEntity`. */
  allFloorEntities?: Maybe<FloorEntitiesConnection>;
  /** Reads and enables pagination through a set of `Floor`. */
  allFloors?: Maybe<FloorsConnection>;
  /** Reads and enables pagination through a set of `Gas`. */
  allGases?: Maybe<GasesConnection>;
  /** Reads and enables pagination through a set of `GroupPermission`. */
  allGroupPermissions?: Maybe<GroupPermissionsConnection>;
  /** Reads and enables pagination through a set of `GroupRight`. */
  allGroupRights?: Maybe<GroupRightsConnection>;
  /** Reads and enables pagination through a set of `Group`. */
  allGroups?: Maybe<GroupsConnection>;
  /** Reads and enables pagination through a set of `Hardware`. */
  allHardwares?: Maybe<HardwaresConnection>;
  /** Reads and enables pagination through a set of `IncomingDocument`. */
  allIncomingDocuments?: Maybe<IncomingDocumentsConnection>;
  /** Reads and enables pagination through a set of `Inkoopgegeven`. */
  allInkoopgegevens?: Maybe<InkoopgegevensConnection>;
  /** Reads and enables pagination through a set of `InkoopgegevensFactopdrachtregel`. */
  allInkoopgegevensFactopdrachtregels?: Maybe<InkoopgegevensFactopdrachtregelsConnection>;
  /** Reads and enables pagination through a set of `InkoopgegevensIndex`. */
  allInkoopgegevensIndices?: Maybe<InkoopgegevensIndicesConnection>;
  /** Reads and enables pagination through a set of `InkoopgegevensLog`. */
  allInkoopgegevensLogs?: Maybe<InkoopgegevensLogsConnection>;
  /** Reads and enables pagination through a set of `InkoopgegevensLogsIndex`. */
  allInkoopgegevensLogsIndices?: Maybe<InkoopgegevensLogsIndicesConnection>;
  /** Reads and enables pagination through a set of `InkoopgegevensMv`. */
  allInkoopgegevensMvs?: Maybe<InkoopgegevensMvsConnection>;
  /** Reads and enables pagination through a set of `InkooporderIndex`. */
  allInkooporderIndices?: Maybe<InkooporderIndicesConnection>;
  /** Reads and enables pagination through a set of `InkooporderMv`. */
  allInkooporderMvs?: Maybe<InkooporderMvsConnection>;
  /** Reads and enables pagination through a set of `InkooporderregelFilterView`. */
  allInkooporderregelFilterViews?: Maybe<InkooporderregelFilterViewsConnection>;
  /** Reads and enables pagination through a set of `InkooporderregelLevertijden`. */
  allInkooporderregelLevertijdens?: Maybe<InkooporderregelLevertijdensConnection>;
  /** Reads and enables pagination through a set of `InkooporderregelLine`. */
  allInkooporderregelLines?: Maybe<InkooporderregelLinesConnection>;
  /** Reads and enables pagination through a set of `InkooporderregelMv`. */
  allInkooporderregelMvs?: Maybe<InkooporderregelMvsConnection>;
  /** Reads and enables pagination through a set of `Inkooporderregel`. */
  allInkooporderregels?: Maybe<InkooporderregelsConnection>;
  /** Reads and enables pagination through a set of `InkooporderregelsFactopdrachtregel`. */
  allInkooporderregelsFactopdrachtregels?: Maybe<InkooporderregelsFactopdrachtregelsConnection>;
  /** Reads and enables pagination through a set of `InkooporderregelsIndex`. */
  allInkooporderregelsIndices?: Maybe<InkooporderregelsIndicesConnection>;
  /** Reads and enables pagination through a set of `Inkooporder`. */
  allInkooporders?: Maybe<InkoopordersConnection>;
  /** Reads and enables pagination through a set of `InkoopprijsChangesIndex`. */
  allInkoopprijsChangesIndices?: Maybe<InkoopprijsChangesIndicesConnection>;
  /** Reads and enables pagination through a set of `Item`. */
  allItems?: Maybe<ItemsConnection>;
  /** Reads and enables pagination through a set of `Job`. */
  allJobs?: Maybe<JobsConnection>;
  /** Reads and enables pagination through a set of `JunctionBox`. */
  allJunctionBoxes?: Maybe<JunctionBoxesConnection>;
  /** Reads and enables pagination through a set of `LandMv`. */
  allLandMvs?: Maybe<LandMvsConnection>;
  /** Reads and enables pagination through a set of `Land`. */
  allLands?: Maybe<LandsConnection>;
  /** Reads and enables pagination through a set of `Lead`. */
  allLeads?: Maybe<LeadsConnection>;
  /** Reads and enables pagination through a set of `LevertijdenExcel`. */
  allLevertijdenExcels?: Maybe<LevertijdenExcelsConnection>;
  /** Reads and enables pagination through a set of `Levertijden`. */
  allLevertijdens?: Maybe<LevertijdensConnection>;
  /** Reads and enables pagination through a set of `LicenseCustomer`. */
  allLicenseCustomers?: Maybe<LicenseCustomersConnection>;
  /** Reads and enables pagination through a set of `LicenseModule`. */
  allLicenseModules?: Maybe<LicenseModulesConnection>;
  /** Reads and enables pagination through a set of `LicenseOrder`. */
  allLicenseOrders?: Maybe<LicenseOrdersConnection>;
  /** Reads and enables pagination through a set of `LicenseRegistration`. */
  allLicenseRegistrations?: Maybe<LicenseRegistrationsConnection>;
  /** Reads and enables pagination through a set of `License`. */
  allLicenses?: Maybe<LicensesConnection>;
  /** Reads and enables pagination through a set of `MagazijnMv`. */
  allMagazijnMvs?: Maybe<MagazijnMvsConnection>;
  /** Reads and enables pagination through a set of `Magazijn`. */
  allMagazijns?: Maybe<MagazijnsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitArea`. */
  allMaintenanceVisitAreas?: Maybe<MaintenanceVisitAreasConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  allMaintenanceVisitLines?: Maybe<MaintenanceVisitLinesConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitLinesMaintain`. */
  allMaintenanceVisitLinesMaintains?: Maybe<MaintenanceVisitLinesMaintainsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitRemark`. */
  allMaintenanceVisitRemarks?: Maybe<MaintenanceVisitRemarksConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitRemarksIndex`. */
  allMaintenanceVisitRemarksIndices?: Maybe<MaintenanceVisitRemarksIndicesConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisit`. */
  allMaintenanceVisits?: Maybe<MaintenanceVisitsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsCalGasMaterial`. */
  allMaintenanceVisitsCalGasMaterials?: Maybe<MaintenanceVisitsCalGasMaterialsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsEdit`. */
  allMaintenanceVisitsEdits?: Maybe<MaintenanceVisitsEditsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsElectrolyteMaterial`. */
  allMaintenanceVisitsElectrolyteMaterials?: Maybe<MaintenanceVisitsElectrolyteMaterialsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsFilterMaterial`. */
  allMaintenanceVisitsFilterMaterials?: Maybe<MaintenanceVisitsFilterMaterialsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsIndex`. */
  allMaintenanceVisitsIndices?: Maybe<MaintenanceVisitsIndicesConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsMaterialError`. */
  allMaintenanceVisitsMaterialErrors?: Maybe<MaintenanceVisitsMaterialErrorsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsMaterial`. */
  allMaintenanceVisitsMaterials?: Maybe<MaintenanceVisitsMaterialsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsMembraneMaterial`. */
  allMaintenanceVisitsMembraneMaterials?: Maybe<MaintenanceVisitsMembraneMaterialsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsORingMaterial`. */
  allMaintenanceVisitsORingMaterials?: Maybe<MaintenanceVisitsORingMaterialsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsPyrolyserMaterial`. */
  allMaintenanceVisitsPyrolyserMaterials?: Maybe<MaintenanceVisitsPyrolyserMaterialsConnection>;
  /** Reads and enables pagination through a set of `MaintenanceVisitsSensorMaterial`. */
  allMaintenanceVisitsSensorMaterials?: Maybe<MaintenanceVisitsSensorMaterialsConnection>;
  /** Reads and enables pagination through a set of `MembraneEntity`. */
  allMembraneEntities?: Maybe<MembraneEntitiesConnection>;
  /** Reads and enables pagination through a set of `Membrane`. */
  allMembranes?: Maybe<MembranesConnection>;
  /** Reads and enables pagination through a set of `Notity`. */
  allNotities?: Maybe<NotitiesConnection>;
  /** Reads and enables pagination through a set of `NotitiesMv`. */
  allNotitiesMvs?: Maybe<NotitiesMvsConnection>;
  /** Reads and enables pagination through a set of `ORingEntity`. */
  allORingEntities?: Maybe<ORingEntitiesConnection>;
  /** Reads and enables pagination through a set of `ORing`. */
  allORings?: Maybe<ORingsConnection>;
  /** Reads and enables pagination through a set of `OfferteCsv`. */
  allOfferteCsvs?: Maybe<OfferteCsvsConnection>;
  /** Reads and enables pagination through a set of `OfferteMv`. */
  allOfferteMvs?: Maybe<OfferteMvsConnection>;
  /** Reads and enables pagination through a set of `OfferteRemark`. */
  allOfferteRemarks?: Maybe<OfferteRemarksConnection>;
  /** Reads and enables pagination through a set of `OfferteregelMv`. */
  allOfferteregelMvs?: Maybe<OfferteregelMvsConnection>;
  /** Reads and enables pagination through a set of `Offerteregel`. */
  allOfferteregels?: Maybe<OfferteregelsConnection>;
  /** Reads and enables pagination through a set of `Offerte`. */
  allOffertes?: Maybe<OffertesConnection>;
  /** Reads and enables pagination through a set of `Opportunity`. */
  allOpportunities?: Maybe<OpportunitiesConnection>;
  /** Reads and enables pagination through a set of `Overtime2`. */
  allOvertime2S?: Maybe<Overtime2SConnection>;
  /** Reads and enables pagination through a set of `Overtime`. */
  allOvertimes?: Maybe<OvertimesConnection>;
  /** Reads and enables pagination through a set of `Permission`. */
  allPermissions?: Maybe<PermissionsConnection>;
  /** Reads and enables pagination through a set of `PersoonInfoMv`. */
  allPersoonInfoMvs?: Maybe<PersoonInfoMvsConnection>;
  /** Reads and enables pagination through a set of `PersoonInfo`. */
  allPersoonInfos?: Maybe<PersoonInfosConnection>;
  /** Reads and enables pagination through a set of `PersoonMv`. */
  allPersoonMvs?: Maybe<PersoonMvsConnection>;
  /** Reads and enables pagination through a set of `PersoonRol`. */
  allPersoonRols?: Maybe<PersoonRolsConnection>;
  /** Reads and enables pagination through a set of `Persoon`. */
  allPersoons?: Maybe<PersoonsConnection>;
  /** Reads and enables pagination through a set of `Plug`. */
  allPlugs?: Maybe<PlugsConnection>;
  /** Reads and enables pagination through a set of `Principle`. */
  allPrinciples?: Maybe<PrinciplesConnection>;
  /** Reads and enables pagination through a set of `Production`. */
  allProductions?: Maybe<ProductionsConnection>;
  /** Reads and enables pagination through a set of `PyrolyserEntity`. */
  allPyrolyserEntities?: Maybe<PyrolyserEntitiesConnection>;
  /** Reads and enables pagination through a set of `Pyrolyser`. */
  allPyrolysers?: Maybe<PyrolysersConnection>;
  /** Reads and enables pagination through a set of `Range`. */
  allRanges?: Maybe<RangesConnection>;
  /** Reads and enables pagination through a set of `RcCard`. */
  allRcCards?: Maybe<RcCardsConnection>;
  /** Reads and enables pagination through a set of `RefreshToken`. */
  allRefreshTokens?: Maybe<RefreshTokensConnection>;
  /** Reads and enables pagination through a set of `RelatieMv`. */
  allRelatieMvs?: Maybe<RelatieMvsConnection>;
  /** Reads and enables pagination through a set of `Relatie`. */
  allRelaties?: Maybe<RelatiesConnection>;
  /** Reads and enables pagination through a set of `ReportDetector`. */
  allReportDetectors?: Maybe<ReportDetectorsConnection>;
  /** Reads and enables pagination through a set of `ReportItem`. */
  allReportItems?: Maybe<ReportItemsConnection>;
  /** Reads and enables pagination through a set of `ReportList`. */
  allReportLists?: Maybe<ReportListsConnection>;
  /** Reads and enables pagination through a set of `ReportSensor`. */
  allReportSensors?: Maybe<ReportSensorsConnection>;
  /** Reads and enables pagination through a set of `Report`. */
  allReports?: Maybe<ReportsConnection>;
  /** Reads and enables pagination through a set of `Request`. */
  allRequests?: Maybe<RequestsConnection>;
  /** Reads and enables pagination through a set of `RxCard`. */
  allRxCards?: Maybe<RxCardsConnection>;
  /** Reads and enables pagination through a set of `SamplePointEntity`. */
  allSamplePointEntities?: Maybe<SamplePointEntitiesConnection>;
  /** Reads and enables pagination through a set of `SamplePoint`. */
  allSamplePoints?: Maybe<SamplePointsConnection>;
  /** Reads and enables pagination through a set of `SensorBaseType`. */
  allSensorBaseTypes?: Maybe<SensorBaseTypesConnection>;
  /** Reads and enables pagination through a set of `SensorElementLocation`. */
  allSensorElementLocations?: Maybe<SensorElementLocationsConnection>;
  /** Reads and enables pagination through a set of `SensorElementLog`. */
  allSensorElementLogs?: Maybe<SensorElementLogsConnection>;
  /** Reads and enables pagination through a set of `SensorElementType`. */
  allSensorElementTypes?: Maybe<SensorElementTypesConnection>;
  /** Reads and enables pagination through a set of `SensorElement`. */
  allSensorElements?: Maybe<SensorElementsConnection>;
  /** Reads and enables pagination through a set of `SensorIndex`. */
  allSensorIndices?: Maybe<SensorIndicesConnection>;
  /** Reads and enables pagination through a set of `SensorOrder`. */
  allSensorOrders?: Maybe<SensorOrdersConnection>;
  /** Reads and enables pagination through a set of `SensorSensorElement`. */
  allSensorSensorElements?: Maybe<SensorSensorElementsConnection>;
  /** Reads and enables pagination through a set of `SensorSetting`. */
  allSensorSettings?: Maybe<SensorSettingsConnection>;
  /** Reads and enables pagination through a set of `SensorTestResult`. */
  allSensorTestResults?: Maybe<SensorTestResultsConnection>;
  /** Reads and enables pagination through a set of `SensorType`. */
  allSensorTypes?: Maybe<SensorTypesConnection>;
  /** Reads and enables pagination through a set of `SensorTypesChecklist`. */
  allSensorTypesChecklists?: Maybe<SensorTypesChecklistsConnection>;
  /** Reads and enables pagination through a set of `SensorTypesIndex`. */
  allSensorTypesIndices?: Maybe<SensorTypesIndicesConnection>;
  /** Reads and enables pagination through a set of `Sensor`. */
  allSensors?: Maybe<SensorsConnection>;
  /** Reads and enables pagination through a set of `SensorsChecklist`. */
  allSensorsChecklists?: Maybe<SensorsChecklistsConnection>;
  /** Reads and enables pagination through a set of `Software`. */
  allSoftwares?: Maybe<SoftwaresConnection>;
  /** Reads and enables pagination through a set of `StockGroup`. */
  allStockGroups?: Maybe<StockGroupsConnection>;
  /** Reads and enables pagination through a set of `StockItem`. */
  allStockItems?: Maybe<StockItemsConnection>;
  /** Reads and enables pagination through a set of `StockSupplier`. */
  allStockSuppliers?: Maybe<StockSuppliersConnection>;
  /** Reads and enables pagination through a set of `StockSuppliersIndexOld`. */
  allStockSuppliersIndexOlds?: Maybe<StockSuppliersIndexOldsConnection>;
  /** Reads and enables pagination through a set of `StockSuppliersIndex`. */
  allStockSuppliersIndices?: Maybe<StockSuppliersIndicesConnection>;
  /** Reads and enables pagination through a set of `Task`. */
  allTasks?: Maybe<TasksConnection>;
  /** Reads and enables pagination through a set of `TempFactopdrachtregel`. */
  allTempFactopdrachtregels?: Maybe<TempFactopdrachtregelsConnection>;
  /** Reads and enables pagination through a set of `TempLicense`. */
  allTempLicenses?: Maybe<TempLicensesConnection>;
  /** Reads and enables pagination through a set of `TempRegistrationHistory`. */
  allTempRegistrationHistories?: Maybe<TempRegistrationHistoriesConnection>;
  /** Reads and enables pagination through a set of `TempRegistration`. */
  allTempRegistrations?: Maybe<TempRegistrationsConnection>;
  /** Reads and enables pagination through a set of `TempRegistrations2`. */
  allTempRegistrations2S?: Maybe<TempRegistrations2SConnection>;
  /** Reads and enables pagination through a set of `Test`. */
  allTests?: Maybe<TestsConnection>;
  /** Reads and enables pagination through a set of `Tztadvy`. */
  allTztadvies?: Maybe<TztadviesConnection>;
  /** Reads and enables pagination through a set of `UserRight`. */
  allUserRights?: Maybe<UserRightsConnection>;
  /** Reads and enables pagination through a set of `UserTask`. */
  allUserTasks?: Maybe<UserTasksConnection>;
  /** Reads and enables pagination through a set of `User`. */
  allUsers?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `UsersGroup`. */
  allUsersGroups?: Maybe<UsersGroupsConnection>;
  /** Reads and enables pagination through a set of `ValutaMv`. */
  allValutaMvs?: Maybe<ValutaMvsConnection>;
  /** Reads and enables pagination through a set of `Valuta`. */
  allValutas?: Maybe<ValutasConnection>;
  /** Reads and enables pagination through a set of `VerrekenprijsChangesIndex`. */
  allVerrekenprijsChangesIndices?: Maybe<VerrekenprijsChangesIndicesConnection>;
  /** Reads and enables pagination through a set of `VerrekenprijsIndex`. */
  allVerrekenprijsIndices?: Maybe<VerrekenprijsIndicesConnection>;
  /** Reads and enables pagination through a set of `VooradenIndex`. */
  allVooradenIndices?: Maybe<VooradenIndicesConnection>;
  /** Reads and enables pagination through a set of `VoorradenLog`. */
  allVoorradenLogs?: Maybe<VoorradenLogsConnection>;
  /** Reads and enables pagination through a set of `VoorradenLogsIndex`. */
  allVoorradenLogsIndices?: Maybe<VoorradenLogsIndicesConnection>;
  /** Reads and enables pagination through a set of `VoorradenMv`. */
  allVoorradenMvs?: Maybe<VoorradenMvsConnection>;
  /** Reads and enables pagination through a set of `Voorraden`. */
  allVoorradens?: Maybe<VoorradensConnection>;
  /** Reads and enables pagination through a set of `WeeklyHourRemark`. */
  allWeeklyHourRemarks?: Maybe<WeeklyHourRemarksConnection>;
  /** Reads and enables pagination through a set of `WeeklyHour`. */
  allWeeklyHours?: Maybe<WeeklyHoursConnection>;
  /** Reads and enables pagination through a set of `WeeklyHoursWeekTotal`. */
  allWeeklyHoursWeekTotals?: Maybe<WeeklyHoursWeekTotalsConnection>;
  /** Reads a single `Application` using its globally unique `ID`. */
  application?: Maybe<Application>;
  applicationById?: Maybe<Application>;
  applicationByName?: Maybe<Application>;
  /** Reads a single `Area` using its globally unique `ID`. */
  area?: Maybe<Area>;
  areaByFloorIdAndName?: Maybe<Area>;
  areaById?: Maybe<Area>;
  /** Reads a single `Aro` using its globally unique `ID`. */
  aro?: Maybe<Aro>;
  aroById?: Maybe<Aro>;
  /** Reads a single `ArosAco` using its globally unique `ID`. */
  arosAco?: Maybe<ArosAco>;
  arosAcoById?: Maybe<ArosAco>;
  /** Reads a single `Artikel` using its globally unique `ID`. */
  artikel?: Maybe<Artikel>;
  artikelByCdartikel?: Maybe<Artikel>;
  /** Reads a single `ArtikelLog` using its globally unique `ID`. */
  artikelLog?: Maybe<ArtikelLog>;
  artikelLogById?: Maybe<ArtikelLog>;
  /** Reads a single `Artikelomschr` using its globally unique `ID`. */
  artikelomschr?: Maybe<Artikelomschr>;
  artikelomschrByCdartikelAndCdtaal?: Maybe<Artikelomschr>;
  /** Reads a single `AspNetRole` using its globally unique `ID`. */
  aspNetRole?: Maybe<AspNetRole>;
  aspNetRoleById?: Maybe<AspNetRole>;
  /** Reads a single `AspNetRoleClaim` using its globally unique `ID`. */
  aspNetRoleClaim?: Maybe<AspNetRoleClaim>;
  aspNetRoleClaimById?: Maybe<AspNetRoleClaim>;
  /** Reads a single `AspNetUser` using its globally unique `ID`. */
  aspNetUser?: Maybe<AspNetUser>;
  aspNetUserById?: Maybe<AspNetUser>;
  /** Reads a single `AspNetUserClaim` using its globally unique `ID`. */
  aspNetUserClaim?: Maybe<AspNetUserClaim>;
  aspNetUserClaimById?: Maybe<AspNetUserClaim>;
  /** Reads a single `AspNetUserLogin` using its globally unique `ID`. */
  aspNetUserLogin?: Maybe<AspNetUserLogin>;
  aspNetUserLoginByLoginProviderAndProviderKey?: Maybe<AspNetUserLogin>;
  /** Reads a single `AspNetUserRole` using its globally unique `ID`. */
  aspNetUserRole?: Maybe<AspNetUserRole>;
  aspNetUserRoleByUserIdAndRoleId?: Maybe<AspNetUserRole>;
  /** Reads a single `AspNetUserToken` using its globally unique `ID`. */
  aspNetUserToken?: Maybe<AspNetUserToken>;
  aspNetUserTokenByUserIdAndLoginProviderAndName?: Maybe<AspNetUserToken>;
  /** Reads a single `Assembly` using its globally unique `ID`. */
  assembly?: Maybe<Assembly>;
  assemblyByCode?: Maybe<Assembly>;
  assemblyById?: Maybe<Assembly>;
  /** Reads a single `AssemblyPart` using its globally unique `ID`. */
  assemblyPart?: Maybe<AssemblyPart>;
  assemblyPartByAssemblyIdAndCdartikel?: Maybe<AssemblyPart>;
  assemblyPartById?: Maybe<AssemblyPart>;
  /** Reads a single `AssemblyType` using its globally unique `ID`. */
  assemblyType?: Maybe<AssemblyType>;
  assemblyTypeById?: Maybe<AssemblyType>;
  /** Reads a single `AssemblyTypePart` using its globally unique `ID`. */
  assemblyTypePart?: Maybe<AssemblyTypePart>;
  assemblyTypePartByAssemblyTypeIdAndCdartikel?: Maybe<AssemblyTypePart>;
  assemblyTypePartById?: Maybe<AssemblyTypePart>;
  /** Reads a single `Building` using its globally unique `ID`. */
  building?: Maybe<Building>;
  buildingByEndUserIdAndName?: Maybe<Building>;
  buildingById?: Maybe<Building>;
  /** Reads a single `CalGas` using its globally unique `ID`. */
  calGas?: Maybe<CalGas>;
  calGasByConcentrationAndEngineeringUnitsAndGasId?: Maybe<CalGas>;
  calGasById?: Maybe<CalGas>;
  /** Reads a single `CatalogGroup` using its globally unique `ID`. */
  catalogGroup?: Maybe<CatalogGroup>;
  catalogGroupById?: Maybe<CatalogGroup>;
  /** Reads a single `CatalogItem` using its globally unique `ID`. */
  catalogItem?: Maybe<CatalogItem>;
  catalogItemById?: Maybe<CatalogItem>;
  /** Reads a single `CatalogItemFile` using its globally unique `ID`. */
  catalogItemFile?: Maybe<CatalogItemFile>;
  catalogItemFileById?: Maybe<CatalogItemFile>;
  /** Reads a single `CatalogItemRelation` using its globally unique `ID`. */
  catalogItemRelation?: Maybe<CatalogItemRelation>;
  catalogItemRelationById?: Maybe<CatalogItemRelation>;
  /** Reads a single `CatalogSubGroup` using its globally unique `ID`. */
  catalogSubGroup?: Maybe<CatalogSubGroup>;
  catalogSubGroupById?: Maybe<CatalogSubGroup>;
  /** Reads a single `ChemicalCompound` using its globally unique `ID`. */
  chemicalCompound?: Maybe<ChemicalCompound>;
  chemicalCompoundById?: Maybe<ChemicalCompound>;
  currentReadIds?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  /** Reads and enables pagination through a set of `Permission`. */
  currentReadPermissions?: Maybe<PermissionsConnection>;
  currentUserId?: Maybe<Scalars['Int']['output']>;
  currentUsername?: Maybe<Scalars['String']['output']>;
  currentWriteIds?: Maybe<Array<Maybe<Scalars['Int']['output']>>>;
  /** Reads and enables pagination through a set of `Permission`. */
  currentWritePermissions?: Maybe<PermissionsConnection>;
  /** Reads a single `Detector` using its globally unique `ID`. */
  detector?: Maybe<Detector>;
  detectorById?: Maybe<Detector>;
  detectorBySerialNumberAndDetectorTypeId?: Maybe<Detector>;
  /** Reads a single `DetectorLocation` using its globally unique `ID`. */
  detectorLocation?: Maybe<DetectorLocation>;
  detectorLocationByDetectorId?: Maybe<DetectorLocation>;
  detectorLocationById?: Maybe<DetectorLocation>;
  /** Reads a single `DetectorOrder` using its globally unique `ID`. */
  detectorOrder?: Maybe<DetectorOrder>;
  detectorOrderByFactuuropdrachtAndDetectorId?: Maybe<DetectorOrder>;
  detectorOrderById?: Maybe<DetectorOrder>;
  /** Reads a single `DetectorSensor` using its globally unique `ID`. */
  detectorSensor?: Maybe<DetectorSensor>;
  detectorSensorByDetectorIdAndDetectorPosition?: Maybe<DetectorSensor>;
  detectorSensorById?: Maybe<DetectorSensor>;
  detectorSensorBySensorId?: Maybe<DetectorSensor>;
  /** Reads a single `DetectorSensorLocation` using its globally unique `ID`. */
  detectorSensorLocation?: Maybe<DetectorSensorLocation>;
  detectorSensorLocationByDetectorSensorId?: Maybe<DetectorSensorLocation>;
  detectorSensorLocationById?: Maybe<DetectorSensorLocation>;
  detectorSensorLocationByLicenseIdAndSimsChannel?: Maybe<DetectorSensorLocation>;
  /** Reads a single `DetectorSensorType` using its globally unique `ID`. */
  detectorSensorType?: Maybe<DetectorSensorType>;
  detectorSensorTypeByDetectorIdAndDetectorPosition?: Maybe<DetectorSensorType>;
  detectorSensorTypeById?: Maybe<DetectorSensorType>;
  /** Reads a single `DetectorType` using its globally unique `ID`. */
  detectorType?: Maybe<DetectorType>;
  detectorTypeById?: Maybe<DetectorType>;
  detectorTypeByPrefixAndCodeAndSuffix?: Maybe<DetectorType>;
  detectorTypeByType?: Maybe<DetectorType>;
  /** Reads a single `DpCard` using its globally unique `ID`. */
  dpCard?: Maybe<DpCard>;
  dpCardById?: Maybe<DpCard>;
  /** Reads a single `Electrolyte` using its globally unique `ID`. */
  electrolyte?: Maybe<Electrolyte>;
  electrolyteById?: Maybe<Electrolyte>;
  electrolyteByName?: Maybe<Electrolyte>;
  /** Reads a single `EndUser` using its globally unique `ID`. */
  endUser?: Maybe<EndUser>;
  endUserById?: Maybe<EndUser>;
  endUserByNameAndLocationAndSubLocation?: Maybe<EndUser>;
  /** Reads a single `FactopdrachtArtikelExclusion` using its globally unique `ID`. */
  factopdrachtArtikelExclusion?: Maybe<FactopdrachtArtikelExclusion>;
  factopdrachtArtikelExclusionByFactuuropdrachtAndCdartikel?: Maybe<FactopdrachtArtikelExclusion>;
  factopdrachtArtikelExclusionById?: Maybe<FactopdrachtArtikelExclusion>;
  /** Reads a single `FactopdrachtregelLine` using its globally unique `ID`. */
  factopdrachtregelLine?: Maybe<FactopdrachtregelLine>;
  factopdrachtregelLineByFactopdrRglGuid?: Maybe<FactopdrachtregelLine>;
  factopdrachtregelLineById?: Maybe<FactopdrachtregelLine>;
  /** Reads a single `FactopdrachtregelLineDate` using its globally unique `ID`. */
  factopdrachtregelLineDate?: Maybe<FactopdrachtregelLineDate>;
  factopdrachtregelLineDateById?: Maybe<FactopdrachtregelLineDate>;
  /** Reads a single `FactopdrachtregelLineRemark` using its globally unique `ID`. */
  factopdrachtregelLineRemark?: Maybe<FactopdrachtregelLineRemark>;
  factopdrachtregelLineRemarkById?: Maybe<FactopdrachtregelLineRemark>;
  /** Reads a single `Factureeropdracht` using its globally unique `ID`. */
  factureeropdracht?: Maybe<Factureeropdracht>;
  factureeropdrachtByFactuuropdracht?: Maybe<Factureeropdracht>;
  /** Reads a single `Factuur` using its globally unique `ID`. */
  factuur?: Maybe<Factuur>;
  factuurByFactuuropdracht?: Maybe<Factuur>;
  factuurById?: Maybe<Factuur>;
  /** Reads a single `Filter` using its globally unique `ID`. */
  filter?: Maybe<Filter>;
  filterById?: Maybe<Filter>;
  filterByName?: Maybe<Filter>;
  /** Reads and enables pagination through a set of `Area`. */
  findAreas?: Maybe<AreasConnection>;
  /** Reads and enables pagination through a set of `Building`. */
  findBuildings?: Maybe<BuildingsConnection>;
  /** Reads and enables pagination through a set of `DetectorType`. */
  findDetectorTypes?: Maybe<DetectorTypesConnection>;
  /** Reads and enables pagination through a set of `Detector`. */
  findDetectors?: Maybe<DetectorsConnection>;
  /** Reads and enables pagination through a set of `EndUser`. */
  findEndUsers?: Maybe<EndUsersConnection>;
  /** Reads and enables pagination through a set of `Range`. */
  findEngineeringUnits?: Maybe<RangesConnection>;
  /** Reads and enables pagination through a set of `Floor`. */
  findFloors?: Maybe<FloorsConnection>;
  /** Reads and enables pagination through a set of `Gas`. */
  findGasNames?: Maybe<GasesConnection>;
  /** Reads and enables pagination through a set of `Range`. */
  findHighEus?: Maybe<RangesConnection>;
  /** Reads and enables pagination through a set of `Range`. */
  findLowEus?: Maybe<RangesConnection>;
  /** Reads and enables pagination through a set of `SamplePoint`. */
  findSamplePointNames?: Maybe<SamplePointsConnection>;
  /** Reads and enables pagination through a set of `Sensor`. */
  findSensorSerialNumbers?: Maybe<SensorsConnection>;
  /** Reads and enables pagination through a set of `SensorType`. */
  findSensorTypeNames?: Maybe<SensorTypesConnection>;
  /** Reads a single `Floor` using its globally unique `ID`. */
  floor?: Maybe<Floor>;
  floorByBuildingIdAndName?: Maybe<Floor>;
  floorById?: Maybe<Floor>;
  /** Reads a single `Gas` using its globally unique `ID`. */
  gas?: Maybe<Gas>;
  gasById?: Maybe<Gas>;
  gasByName?: Maybe<Gas>;
  /** Reads and enables pagination through a set of `Artikel`. */
  getArtikelByCdartikel?: Maybe<ArtikelsConnection>;
  /** Reads a single `Group` using its globally unique `ID`. */
  group?: Maybe<Group>;
  groupById?: Maybe<Group>;
  /** Reads a single `GroupPermission` using its globally unique `ID`. */
  groupPermission?: Maybe<GroupPermission>;
  groupPermissionByGroupId?: Maybe<GroupPermission>;
  groupPermissionById?: Maybe<GroupPermission>;
  /** Reads a single `GroupRight` using its globally unique `ID`. */
  groupRight?: Maybe<GroupRight>;
  groupRightByGroupIdAndPath?: Maybe<GroupRight>;
  groupRightById?: Maybe<GroupRight>;
  /** Reads a single `Hardware` using its globally unique `ID`. */
  hardware?: Maybe<Hardware>;
  hardwareById?: Maybe<Hardware>;
  /** Reads a single `IncomingDocument` using its globally unique `ID`. */
  incomingDocument?: Maybe<IncomingDocument>;
  incomingDocumentById?: Maybe<IncomingDocument>;
  /** Reads a single `Inkoopgegeven` using its globally unique `ID`. */
  inkoopgegeven?: Maybe<Inkoopgegeven>;
  inkoopgegevenByCdartikelAndInkvolgnr?: Maybe<Inkoopgegeven>;
  /** Reads a single `InkoopgegevensLog` using its globally unique `ID`. */
  inkoopgegevensLog?: Maybe<InkoopgegevensLog>;
  inkoopgegevensLogById?: Maybe<InkoopgegevensLog>;
  /** Reads a single `InkooporderregelLine` using its globally unique `ID`. */
  inkooporderregelLine?: Maybe<InkooporderregelLine>;
  inkooporderregelLineById?: Maybe<InkooporderregelLine>;
  inkooporderregelLineByInkopdrRglGuid?: Maybe<InkooporderregelLine>;
  /** Reads a single `Item` using its globally unique `ID`. */
  item?: Maybe<Item>;
  itemByCdartikelAndSerialNumber?: Maybe<Item>;
  itemById?: Maybe<Item>;
  /** Reads a single `Job` using its globally unique `ID`. */
  job?: Maybe<Job>;
  jobById?: Maybe<Job>;
  /** Reads a single `JunctionBox` using its globally unique `ID`. */
  junctionBox?: Maybe<JunctionBox>;
  junctionBoxById?: Maybe<JunctionBox>;
  jwtToken: Scalars['String']['output'];
  /** Reads a single `Lead` using its globally unique `ID`. */
  lead?: Maybe<Lead>;
  leadById?: Maybe<Lead>;
  /** Reads a single `License` using its globally unique `ID`. */
  license?: Maybe<License>;
  licenseById?: Maybe<License>;
  /** Reads a single `LicenseCustomer` using its globally unique `ID`. */
  licenseCustomer?: Maybe<LicenseCustomer>;
  licenseCustomerById?: Maybe<LicenseCustomer>;
  /** Reads a single `LicenseModule` using its globally unique `ID`. */
  licenseModule?: Maybe<LicenseModule>;
  licenseModuleById?: Maybe<LicenseModule>;
  /** Reads a single `LicenseOrder` using its globally unique `ID`. */
  licenseOrder?: Maybe<LicenseOrder>;
  licenseOrderById?: Maybe<LicenseOrder>;
  licenseOrderByLicenseIdAndFactuuropdracht?: Maybe<LicenseOrder>;
  licenseOrderByLicenseRegistrationIdAndFactuuropdracht?: Maybe<LicenseOrder>;
  /** Reads a single `LicenseRegistration` using its globally unique `ID`. */
  licenseRegistration?: Maybe<LicenseRegistration>;
  licenseRegistrationById?: Maybe<LicenseRegistration>;
  /** Reads a single `MaintenanceVisit` using its globally unique `ID`. */
  maintenanceVisit?: Maybe<MaintenanceVisit>;
  maintenanceVisitById?: Maybe<MaintenanceVisit>;
  /** Reads a single `MaintenanceVisitLine` using its globally unique `ID`. */
  maintenanceVisitLine?: Maybe<MaintenanceVisitLine>;
  maintenanceVisitLineById?: Maybe<MaintenanceVisitLine>;
  maintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationId?: Maybe<MaintenanceVisitLine>;
  /** Reads a single `MaintenanceVisitRemark` using its globally unique `ID`. */
  maintenanceVisitRemark?: Maybe<MaintenanceVisitRemark>;
  maintenanceVisitRemarkById?: Maybe<MaintenanceVisitRemark>;
  maintenanceVisitRemarkByMaintenanceVisitIdAndLine?: Maybe<MaintenanceVisitRemark>;
  /** Reads a single `Membrane` using its globally unique `ID`. */
  membrane?: Maybe<Membrane>;
  membraneById?: Maybe<Membrane>;
  membraneByName?: Maybe<Membrane>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `ORing` using its globally unique `ID`. */
  oRing?: Maybe<ORing>;
  oRingById?: Maybe<ORing>;
  oRingByName?: Maybe<ORing>;
  /** Reads a single `OfferteRemark` using its globally unique `ID`. */
  offerteRemark?: Maybe<OfferteRemark>;
  offerteRemarkById?: Maybe<OfferteRemark>;
  offerteRemarkByOfferteId?: Maybe<OfferteRemark>;
  /** Reads a single `Opportunity` using its globally unique `ID`. */
  opportunity?: Maybe<Opportunity>;
  opportunityById?: Maybe<Opportunity>;
  /** Reads a single `Permission` using its globally unique `ID`. */
  permission?: Maybe<Permission>;
  permissionById?: Maybe<Permission>;
  /** Reads a single `PersoonRol` using its globally unique `ID`. */
  persoonRol?: Maybe<PersoonRol>;
  persoonRolByPersoonRolGuid?: Maybe<PersoonRol>;
  /** Reads a single `Plug` using its globally unique `ID`. */
  plug?: Maybe<Plug>;
  plugById?: Maybe<Plug>;
  plugByName?: Maybe<Plug>;
  /** Reads a single `Principle` using its globally unique `ID`. */
  principle?: Maybe<Principle>;
  principleById?: Maybe<Principle>;
  principleByName?: Maybe<Principle>;
  /** Reads a single `Production` using its globally unique `ID`. */
  production?: Maybe<Production>;
  productionById?: Maybe<Production>;
  /** Reads a single `Pyrolyser` using its globally unique `ID`. */
  pyrolyser?: Maybe<Pyrolyser>;
  /** Reads and enables pagination through a set of `Artikel`. */
  pyrolyserArtikelByCdartikel?: Maybe<ArtikelsConnection>;
  pyrolyserById?: Maybe<Pyrolyser>;
  pyrolyserByName?: Maybe<Pyrolyser>;
  /** Reads and enables pagination through a set of `Artikel`. */
  pyrolysersArtikelByCdartikel?: Maybe<ArtikelsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Reads a single `Range` using its globally unique `ID`. */
  range?: Maybe<Range>;
  rangeById?: Maybe<Range>;
  rangeByLowEuAndHighEuAndEngineeringUnitsAndGasId?: Maybe<Range>;
  /** Reads a single `RcCard` using its globally unique `ID`. */
  rcCard?: Maybe<RcCard>;
  rcCardById?: Maybe<RcCard>;
  /** Reads a single `RefreshToken` using its globally unique `ID`. */
  refreshToken?: Maybe<RefreshToken>;
  refreshTokenById?: Maybe<RefreshToken>;
  /** Reads a single `Report` using its globally unique `ID`. */
  report?: Maybe<Report>;
  reportByFilename?: Maybe<Report>;
  reportById?: Maybe<Report>;
  reportByTsrNumberAndVersion?: Maybe<Report>;
  /** Reads a single `ReportDetector` using its globally unique `ID`. */
  reportDetector?: Maybe<ReportDetector>;
  reportDetectorById?: Maybe<ReportDetector>;
  reportDetectorByReportIdAndDetectorId?: Maybe<ReportDetector>;
  /** Reads a single `ReportItem` using its globally unique `ID`. */
  reportItem?: Maybe<ReportItem>;
  reportItemById?: Maybe<ReportItem>;
  /** Reads a single `ReportSensor` using its globally unique `ID`. */
  reportSensor?: Maybe<ReportSensor>;
  reportSensorById?: Maybe<ReportSensor>;
  reportSensorByReportIdAndSensorId?: Maybe<ReportSensor>;
  /** Reads a single `Request` using its globally unique `ID`. */
  request?: Maybe<Request>;
  requestById?: Maybe<Request>;
  /** Reads a single `RxCard` using its globally unique `ID`. */
  rxCard?: Maybe<RxCard>;
  rxCardById?: Maybe<RxCard>;
  /** Reads a single `SamplePoint` using its globally unique `ID`. */
  samplePoint?: Maybe<SamplePoint>;
  samplePointByAreaIdAndName?: Maybe<SamplePoint>;
  samplePointById?: Maybe<SamplePoint>;
  /** Reads a single `Sensor` using its globally unique `ID`. */
  sensor?: Maybe<Sensor>;
  /** Reads a single `SensorBaseType` using its globally unique `ID`. */
  sensorBaseType?: Maybe<SensorBaseType>;
  sensorBaseTypeById?: Maybe<SensorBaseType>;
  sensorBaseTypeByPrefixAndSuffix?: Maybe<SensorBaseType>;
  sensorById?: Maybe<Sensor>;
  sensorBySerialNumberAndSensorTypeId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` using its globally unique `ID`. */
  sensorElement?: Maybe<SensorElement>;
  sensorElementById?: Maybe<SensorElement>;
  /** Reads a single `SensorElementLocation` using its globally unique `ID`. */
  sensorElementLocation?: Maybe<SensorElementLocation>;
  sensorElementLocationById?: Maybe<SensorElementLocation>;
  sensorElementLocationBySensorElementId?: Maybe<SensorElementLocation>;
  /** Reads a single `SensorElementLog` using its globally unique `ID`. */
  sensorElementLog?: Maybe<SensorElementLog>;
  sensorElementLogById?: Maybe<SensorElementLog>;
  /** Reads a single `SensorElementType` using its globally unique `ID`. */
  sensorElementType?: Maybe<SensorElementType>;
  sensorElementTypeById?: Maybe<SensorElementType>;
  /** Reads a single `SensorOrder` using its globally unique `ID`. */
  sensorOrder?: Maybe<SensorOrder>;
  sensorOrderById?: Maybe<SensorOrder>;
  sensorOrderBySensorIdAndFactuuropdracht?: Maybe<SensorOrder>;
  /** Reads a single `SensorSensorElement` using its globally unique `ID`. */
  sensorSensorElement?: Maybe<SensorSensorElement>;
  sensorSensorElementById?: Maybe<SensorSensorElement>;
  sensorSensorElementBySensorElementId?: Maybe<SensorSensorElement>;
  sensorSensorElementBySensorIdAndSensorPosition?: Maybe<SensorSensorElement>;
  /** Reads a single `SensorSetting` using its globally unique `ID`. */
  sensorSetting?: Maybe<SensorSetting>;
  sensorSettingById?: Maybe<SensorSetting>;
  sensorSettingByTypeTarget?: Maybe<SensorSetting>;
  /** Reads a single `SensorTestResult` using its globally unique `ID`. */
  sensorTestResult?: Maybe<SensorTestResult>;
  sensorTestResultById?: Maybe<SensorTestResult>;
  /** Reads a single `SensorType` using its globally unique `ID`. */
  sensorType?: Maybe<SensorType>;
  sensorTypeById?: Maybe<SensorType>;
  sensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserId?: Maybe<SensorType>;
  sensorTypeBySensorTypeId?: Maybe<SensorType>;
  /** Reads a single `Software` using its globally unique `ID`. */
  software?: Maybe<Software>;
  softwareById?: Maybe<Software>;
  /** Reads a single `StockGroup` using its globally unique `ID`. */
  stockGroup?: Maybe<StockGroup>;
  stockGroupById?: Maybe<StockGroup>;
  /** Reads a single `StockItem` using its globally unique `ID`. */
  stockItem?: Maybe<StockItem>;
  stockItemById?: Maybe<StockItem>;
  stockItemByStockGroupIdAndCdartikel?: Maybe<StockItem>;
  /** Reads a single `StockSupplier` using its globally unique `ID`. */
  stockSupplier?: Maybe<StockSupplier>;
  stockSupplierById?: Maybe<StockSupplier>;
  /** Reads a single `Task` using its globally unique `ID`. */
  task?: Maybe<Task>;
  taskById?: Maybe<Task>;
  /** Reads a single `TempFactopdrachtregel` using its globally unique `ID`. */
  tempFactopdrachtregel?: Maybe<TempFactopdrachtregel>;
  tempFactopdrachtregelByFactuuropdrachtAndFactuurregel?: Maybe<TempFactopdrachtregel>;
  tempFactopdrachtregelById?: Maybe<TempFactopdrachtregel>;
  /** Reads a single `TempLicense` using its globally unique `ID`. */
  tempLicense?: Maybe<TempLicense>;
  tempLicenseById?: Maybe<TempLicense>;
  /** Reads a single `TempRegistration` using its globally unique `ID`. */
  tempRegistration?: Maybe<TempRegistration>;
  tempRegistrationById?: Maybe<TempRegistration>;
  /** Reads a single `TempRegistrationHistory` using its globally unique `ID`. */
  tempRegistrationHistory?: Maybe<TempRegistrationHistory>;
  tempRegistrationHistoryById?: Maybe<TempRegistrationHistory>;
  /** Reads a single `TempRegistrations2` using its globally unique `ID`. */
  tempRegistrations2?: Maybe<TempRegistrations2>;
  tempRegistrations2ById?: Maybe<TempRegistrations2>;
  /** Reads a single `Test` using its globally unique `ID`. */
  test?: Maybe<Test>;
  testById?: Maybe<Test>;
  /** Reads a single `User` using its globally unique `ID`. */
  user?: Maybe<User>;
  userById?: Maybe<User>;
  /** Reads a single `UserRight` using its globally unique `ID`. */
  userRight?: Maybe<UserRight>;
  userRightById?: Maybe<UserRight>;
  userRightByUserIdAndPath?: Maybe<UserRight>;
  /** Reads a single `UserTask` using its globally unique `ID`. */
  userTask?: Maybe<UserTask>;
  userTaskById?: Maybe<UserTask>;
  userTaskByUserIdAndTaskId?: Maybe<UserTask>;
  /** Reads a single `UsersGroup` using its globally unique `ID`. */
  usersGroup?: Maybe<UsersGroup>;
  usersGroupById?: Maybe<UsersGroup>;
  usersGroupByUserIdAndGroupId?: Maybe<UsersGroup>;
  /** Reads a single `Voorraden` using its globally unique `ID`. */
  voorraden?: Maybe<Voorraden>;
  voorradenByCdartikelAndCdmagazijn?: Maybe<Voorraden>;
  /** Reads a single `VoorradenLog` using its globally unique `ID`. */
  voorradenLog?: Maybe<VoorradenLog>;
  voorradenLogById?: Maybe<VoorradenLog>;
  /** Reads a single `WeeklyHour` using its globally unique `ID`. */
  weeklyHour?: Maybe<WeeklyHour>;
  weeklyHourById?: Maybe<WeeklyHour>;
  /** Reads a single `WeeklyHourRemark` using its globally unique `ID`. */
  weeklyHourRemark?: Maybe<WeeklyHourRemark>;
  weeklyHourRemarkById?: Maybe<WeeklyHourRemark>;
  weeklyHourRemarkByUserIdAndTaskIdAndDate?: Maybe<WeeklyHourRemark>;
};


/** The root query type which gives access points into the data universe. */
export type Query_AdreArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type Query_AdreByAdresGuidArgs = {
  adresGuid: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type Query_LandArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type Query_LandByCdlandArgs = {
  cdland: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcoArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcoByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAcosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcoCondition>;
  filter?: InputMaybe<AcoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionCondition>;
  filter?: InputMaybe<ActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAdresArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdreCondition>;
  filter?: InputMaybe<AdreFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdresOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAdresMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AdresMvCondition>;
  filter?: InputMaybe<AdresMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdresMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAnotherRefreshTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AnotherRefreshTokenCondition>;
  filter?: InputMaybe<AnotherRefreshTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AnotherRefreshTokensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAreaEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AreaEntityCondition>;
  filter?: InputMaybe<AreaEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AreaEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAreasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AreaCondition>;
  filter?: InputMaybe<AreaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AreasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AroCondition>;
  filter?: InputMaybe<AroFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArosAcosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArosAcoCondition>;
  filter?: InputMaybe<ArosAcoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArosAcosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikel2SArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<Artikel2Condition>;
  filter?: InputMaybe<Artikel2Filter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<Artikel2SOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelAssemblyIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelAssemblyIndexCondition>;
  filter?: InputMaybe<ArtikelAssemblyIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelAssemblyIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelComponentensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelComponentenCondition>;
  filter?: InputMaybe<ArtikelComponentenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelComponentensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelIndex2SArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelIndex2Condition>;
  filter?: InputMaybe<ArtikelIndex2Filter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelIndex2SOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelIndexCondition>;
  filter?: InputMaybe<ArtikelIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelLogCondition>;
  filter?: InputMaybe<ArtikelLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelLogsIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelLogsIndexCondition>;
  filter?: InputMaybe<ArtikelLogsIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelLogsIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelMvCondition>;
  filter?: InputMaybe<ArtikelMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelSamenstellingensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelSamenstellingenCondition>;
  filter?: InputMaybe<ArtikelSamenstellingenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelSamenstellingensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelomschrMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelomschrMvCondition>;
  filter?: InputMaybe<ArtikelomschrMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelomschrMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelomschrsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelomschrCondition>;
  filter?: InputMaybe<ArtikelomschrFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelomschrsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtikelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtikelCondition>;
  filter?: InputMaybe<ArtikelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtikelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtsamcomponentenMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtsamcomponentenMvCondition>;
  filter?: InputMaybe<ArtsamcomponentenMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtsamcomponentenMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtsamcomponentensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtsamcomponentenCondition>;
  filter?: InputMaybe<ArtsamcomponentenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtsamcomponentensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtsamenstellingMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtsamenstellingMvCondition>;
  filter?: InputMaybe<ArtsamenstellingMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtsamenstellingMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllArtsamenstellingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ArtsamenstellingCondition>;
  filter?: InputMaybe<ArtsamenstellingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ArtsamenstellingsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAspNetRoleClaimsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetRoleClaimCondition>;
  filter?: InputMaybe<AspNetRoleClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetRoleClaimsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAspNetRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetRoleCondition>;
  filter?: InputMaybe<AspNetRoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetRolesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAspNetUserClaimsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserClaimCondition>;
  filter?: InputMaybe<AspNetUserClaimFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserClaimsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAspNetUserLoginsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserLoginCondition>;
  filter?: InputMaybe<AspNetUserLoginFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserLoginsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAspNetUserRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserRoleCondition>;
  filter?: InputMaybe<AspNetUserRoleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserRolesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAspNetUserTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserTokenCondition>;
  filter?: InputMaybe<AspNetUserTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUserTokensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAspNetUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AspNetUserCondition>;
  filter?: InputMaybe<AspNetUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AspNetUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblageMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblageMvCondition>;
  filter?: InputMaybe<AssemblageMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblageMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblageregelMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblageregelMvCondition>;
  filter?: InputMaybe<AssemblageregelMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblageregelMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblageregelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblageregelCondition>;
  filter?: InputMaybe<AssemblageregelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblageregelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblageCondition>;
  filter?: InputMaybe<AssemblageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssembliesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyCondition>;
  filter?: InputMaybe<AssemblyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssembliesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblyEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyEntityCondition>;
  filter?: InputMaybe<AssemblyEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblyLineEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyLineEntityCondition>;
  filter?: InputMaybe<AssemblyLineEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyLineEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblyMultiversEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyMultiversEntityCondition>;
  filter?: InputMaybe<AssemblyMultiversEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyMultiversEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblyPartsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyPartCondition>;
  filter?: InputMaybe<AssemblyPartFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyPartsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblyTypePartsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyTypePartCondition>;
  filter?: InputMaybe<AssemblyTypePartFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyTypePartsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblyTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyTypeCondition>;
  filter?: InputMaybe<AssemblyTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyTypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAssemblyTypesEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyTypesEntityCondition>;
  filter?: InputMaybe<AssemblyTypesEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyTypesEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBesteladviesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BesteladvyCondition>;
  filter?: InputMaybe<BesteladvyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BesteladviesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBieStatusesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BieStatusCondition>;
  filter?: InputMaybe<BieStatusFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BieStatusesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBuildingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BuildingCondition>;
  filter?: InputMaybe<BuildingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BuildingsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCalGasesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CalGasCondition>;
  filter?: InputMaybe<CalGasFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CalGasesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCalgasEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CalgasEntityCondition>;
  filter?: InputMaybe<CalgasEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CalgasEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCatalogGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogGroupCondition>;
  filter?: InputMaybe<CatalogGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCatalogItemFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemFileCondition>;
  filter?: InputMaybe<CatalogItemFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemFilesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCatalogItemRelationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemRelationCondition>;
  filter?: InputMaybe<CatalogItemRelationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemRelationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCatalogItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemCondition>;
  filter?: InputMaybe<CatalogItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCatalogSubGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogSubGroupCondition>;
  filter?: InputMaybe<CatalogSubGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogSubGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCdartikelJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CdartikelJoinCondition>;
  filter?: InputMaybe<CdartikelJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CdartikelJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllChemicalCompoundsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ChemicalCompoundCondition>;
  filter?: InputMaybe<ChemicalCompoundFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChemicalCompoundsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllContactpersoonMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ContactpersoonMvCondition>;
  filter?: InputMaybe<ContactpersoonMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ContactpersoonMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCrediteurMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CrediteurMvCondition>;
  filter?: InputMaybe<CrediteurMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CrediteurMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCrediteursArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CrediteurCondition>;
  filter?: InputMaybe<CrediteurFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CrediteursOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDebiteurMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DebiteurMvCondition>;
  filter?: InputMaybe<DebiteurMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DebiteurMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDebiteursArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DebiteurCondition>;
  filter?: InputMaybe<DebiteurFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DebiteursOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorEntityCondition>;
  filter?: InputMaybe<DetectorEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorIndexCondition>;
  filter?: InputMaybe<DetectorIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorLocationCondition>;
  filter?: InputMaybe<DetectorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorLocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorOrdersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorOrderCondition>;
  filter?: InputMaybe<DetectorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorOrdersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorSensorIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorIndexCondition>;
  filter?: InputMaybe<DetectorSensorIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorSensorLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationCondition>;
  filter?: InputMaybe<DetectorSensorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorSensorLocationsEndUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationsEndUserCondition>;
  filter?: InputMaybe<DetectorSensorLocationsEndUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsEndUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorSensorLocationsIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationsIndexCondition>;
  filter?: InputMaybe<DetectorSensorLocationsIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorSensorTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorTypeCondition>;
  filter?: InputMaybe<DetectorSensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorTypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorSensorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorCondition>;
  filter?: InputMaybe<DetectorSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorTypeCondition>;
  filter?: InputMaybe<DetectorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorTypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorTypesEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorTypesEntityCondition>;
  filter?: InputMaybe<DetectorTypesEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorTypesEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorCondition>;
  filter?: InputMaybe<DetectorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDetectorsChecklistsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorsChecklistCondition>;
  filter?: InputMaybe<DetectorsChecklistFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorsChecklistsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDpCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DpCardCondition>;
  filter?: InputMaybe<DpCardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DpCardsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllElectrolyteEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ElectrolyteEntityCondition>;
  filter?: InputMaybe<ElectrolyteEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ElectrolyteEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllElectrolytesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ElectrolyteCondition>;
  filter?: InputMaybe<ElectrolyteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ElectrolytesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllEndUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EndUserCondition>;
  filter?: InputMaybe<EndUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EndUsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtArtikelExclusionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtArtikelExclusionCondition>;
  filter?: InputMaybe<FactopdrachtArtikelExclusionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtArtikelExclusionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelAmountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelAmountCondition>;
  filter?: InputMaybe<FactopdrachtregelAmountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelAmountsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelAmounts2SArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelAmounts2Condition>;
  filter?: InputMaybe<FactopdrachtregelAmounts2Filter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelAmounts2SOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelFilterViewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelFilterViewCondition>;
  filter?: InputMaybe<FactopdrachtregelFilterViewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelFilterViewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelIndexCondition>;
  filter?: InputMaybe<FactopdrachtregelIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLineDatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineDateCondition>;
  filter?: InputMaybe<FactopdrachtregelLineDateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineDatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLineDatesIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineDatesIndexCondition>;
  filter?: InputMaybe<FactopdrachtregelLineDatesIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineDatesIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLineDatesTotalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineDatesTotalCondition>;
  filter?: InputMaybe<FactopdrachtregelLineDatesTotalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineDatesTotalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLineDatesTotals2SArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineDatesTotals2Condition>;
  filter?: InputMaybe<FactopdrachtregelLineDatesTotals2Filter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineDatesTotals2SOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLineRemarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineRemarkCondition>;
  filter?: InputMaybe<FactopdrachtregelLineRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineRemarksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLineRemarksIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineRemarksIndexCondition>;
  filter?: InputMaybe<FactopdrachtregelLineRemarksIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineRemarksIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLineWeeksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineWeekCondition>;
  filter?: InputMaybe<FactopdrachtregelLineWeekFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineWeeksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLineWeeksIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineWeeksIndexCondition>;
  filter?: InputMaybe<FactopdrachtregelLineWeeksIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineWeeksIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelLinesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineCondition>;
  filter?: InputMaybe<FactopdrachtregelLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLinesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelMvCondition>;
  filter?: InputMaybe<FactopdrachtregelMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelTotalAmountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelTotalAmountCondition>;
  filter?: InputMaybe<FactopdrachtregelTotalAmountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelTotalAmountsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactopdrachtregelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelCondition>;
  filter?: InputMaybe<FactopdrachtregelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactureeropdrachtIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactureeropdrachtIndexCondition>;
  filter?: InputMaybe<FactureeropdrachtIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactureeropdrachtIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactureeropdrachtMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactureeropdrachtMvCondition>;
  filter?: InputMaybe<FactureeropdrachtMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactureeropdrachtMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactureeropdrachtsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactureeropdrachtCondition>;
  filter?: InputMaybe<FactureeropdrachtFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactureeropdrachtsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFactuursArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactuurCondition>;
  filter?: InputMaybe<FactuurFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactuursOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFilterEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FilterEntityCondition>;
  filter?: InputMaybe<FilterEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilterEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFiltersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FilterCondition>;
  filter?: InputMaybe<FilterFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFloorEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FloorEntityCondition>;
  filter?: InputMaybe<FloorEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FloorEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFloorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FloorCondition>;
  filter?: InputMaybe<FloorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FloorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllGasesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GasCondition>;
  filter?: InputMaybe<GasFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GasesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllGroupPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupPermissionCondition>;
  filter?: InputMaybe<GroupPermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupPermissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllGroupRightsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupRightCondition>;
  filter?: InputMaybe<GroupRightFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupRightsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllHardwaresArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<HardwareCondition>;
  filter?: InputMaybe<HardwareFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<HardwaresOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllIncomingDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<IncomingDocumentCondition>;
  filter?: InputMaybe<IncomingDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IncomingDocumentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkoopgegevensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkoopgegevenCondition>;
  filter?: InputMaybe<InkoopgegevenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkoopgegevensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkoopgegevensFactopdrachtregelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkoopgegevensFactopdrachtregelCondition>;
  filter?: InputMaybe<InkoopgegevensFactopdrachtregelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkoopgegevensFactopdrachtregelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkoopgegevensIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkoopgegevensIndexCondition>;
  filter?: InputMaybe<InkoopgegevensIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkoopgegevensIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkoopgegevensLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkoopgegevensLogCondition>;
  filter?: InputMaybe<InkoopgegevensLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkoopgegevensLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkoopgegevensLogsIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkoopgegevensLogsIndexCondition>;
  filter?: InputMaybe<InkoopgegevensLogsIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkoopgegevensLogsIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkoopgegevensMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkoopgegevensMvCondition>;
  filter?: InputMaybe<InkoopgegevensMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkoopgegevensMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderIndexCondition>;
  filter?: InputMaybe<InkooporderIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderMvCondition>;
  filter?: InputMaybe<InkooporderMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderregelFilterViewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderregelFilterViewCondition>;
  filter?: InputMaybe<InkooporderregelFilterViewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderregelFilterViewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderregelLevertijdensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderregelLevertijdenCondition>;
  filter?: InputMaybe<InkooporderregelLevertijdenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderregelLevertijdensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderregelLinesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderregelLineCondition>;
  filter?: InputMaybe<InkooporderregelLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderregelLinesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderregelMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderregelMvCondition>;
  filter?: InputMaybe<InkooporderregelMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderregelMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderregelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderregelCondition>;
  filter?: InputMaybe<InkooporderregelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderregelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderregelsFactopdrachtregelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderregelsFactopdrachtregelCondition>;
  filter?: InputMaybe<InkooporderregelsFactopdrachtregelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderregelsFactopdrachtregelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkooporderregelsIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderregelsIndexCondition>;
  filter?: InputMaybe<InkooporderregelsIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkooporderregelsIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkoopordersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkooporderCondition>;
  filter?: InputMaybe<InkooporderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkoopordersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllInkoopprijsChangesIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InkoopprijsChangesIndexCondition>;
  filter?: InputMaybe<InkoopprijsChangesIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InkoopprijsChangesIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ItemCondition>;
  filter?: InputMaybe<ItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllJobsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllJunctionBoxesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JunctionBoxCondition>;
  filter?: InputMaybe<JunctionBoxFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JunctionBoxesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLandMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LandMvCondition>;
  filter?: InputMaybe<LandMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LandMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLandsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LandCondition>;
  filter?: InputMaybe<LandFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LandsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLeadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LeadCondition>;
  filter?: InputMaybe<LeadFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLevertijdenExcelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LevertijdenExcelCondition>;
  filter?: InputMaybe<LevertijdenExcelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LevertijdenExcelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLevertijdensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LevertijdenCondition>;
  filter?: InputMaybe<LevertijdenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LevertijdensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLicenseCustomersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseCustomerCondition>;
  filter?: InputMaybe<LicenseCustomerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseCustomersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLicenseModulesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseModuleCondition>;
  filter?: InputMaybe<LicenseModuleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseModulesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLicenseOrdersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseOrderCondition>;
  filter?: InputMaybe<LicenseOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseOrdersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLicenseRegistrationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseRegistrationCondition>;
  filter?: InputMaybe<LicenseRegistrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseRegistrationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLicensesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseCondition>;
  filter?: InputMaybe<LicenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicensesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMagazijnMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MagazijnMvCondition>;
  filter?: InputMaybe<MagazijnMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MagazijnMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMagazijnsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MagazijnCondition>;
  filter?: InputMaybe<MagazijnFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MagazijnsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitAreasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitAreaCondition>;
  filter?: InputMaybe<MaintenanceVisitAreaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitAreasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitLinesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitLinesMaintainsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLinesMaintainCondition>;
  filter?: InputMaybe<MaintenanceVisitLinesMaintainFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesMaintainsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitRemarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitRemarkCondition>;
  filter?: InputMaybe<MaintenanceVisitRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitRemarksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitRemarksIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitRemarksIndexCondition>;
  filter?: InputMaybe<MaintenanceVisitRemarksIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitRemarksIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitCondition>;
  filter?: InputMaybe<MaintenanceVisitFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsCalGasMaterialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsCalGasMaterialCondition>;
  filter?: InputMaybe<MaintenanceVisitsCalGasMaterialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsCalGasMaterialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsEditsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsEditCondition>;
  filter?: InputMaybe<MaintenanceVisitsEditFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsEditsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsElectrolyteMaterialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsElectrolyteMaterialCondition>;
  filter?: InputMaybe<MaintenanceVisitsElectrolyteMaterialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsElectrolyteMaterialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsFilterMaterialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsFilterMaterialCondition>;
  filter?: InputMaybe<MaintenanceVisitsFilterMaterialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsFilterMaterialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsIndexCondition>;
  filter?: InputMaybe<MaintenanceVisitsIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsMaterialErrorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsMaterialErrorCondition>;
  filter?: InputMaybe<MaintenanceVisitsMaterialErrorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsMaterialErrorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsMaterialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsMaterialCondition>;
  filter?: InputMaybe<MaintenanceVisitsMaterialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsMaterialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsMembraneMaterialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsMembraneMaterialCondition>;
  filter?: InputMaybe<MaintenanceVisitsMembraneMaterialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsMembraneMaterialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsORingMaterialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsORingMaterialCondition>;
  filter?: InputMaybe<MaintenanceVisitsORingMaterialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsORingMaterialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsPyrolyserMaterialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsPyrolyserMaterialCondition>;
  filter?: InputMaybe<MaintenanceVisitsPyrolyserMaterialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsPyrolyserMaterialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMaintenanceVisitsSensorMaterialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitsSensorMaterialCondition>;
  filter?: InputMaybe<MaintenanceVisitsSensorMaterialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsSensorMaterialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMembraneEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MembraneEntityCondition>;
  filter?: InputMaybe<MembraneEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MembraneEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMembranesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MembraneCondition>;
  filter?: InputMaybe<MembraneFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MembranesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllNotitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotityCondition>;
  filter?: InputMaybe<NotityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllNotitiesMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotitiesMvCondition>;
  filter?: InputMaybe<NotitiesMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotitiesMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllORingEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ORingEntityCondition>;
  filter?: InputMaybe<ORingEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ORingEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllORingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ORingCondition>;
  filter?: InputMaybe<ORingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ORingsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOfferteCsvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OfferteCsvCondition>;
  filter?: InputMaybe<OfferteCsvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OfferteCsvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOfferteMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OfferteMvCondition>;
  filter?: InputMaybe<OfferteMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OfferteMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOfferteRemarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OfferteRemarkCondition>;
  filter?: InputMaybe<OfferteRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OfferteRemarksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOfferteregelMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OfferteregelMvCondition>;
  filter?: InputMaybe<OfferteregelMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OfferteregelMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOfferteregelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OfferteregelCondition>;
  filter?: InputMaybe<OfferteregelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OfferteregelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOffertesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OfferteCondition>;
  filter?: InputMaybe<OfferteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OffertesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOpportunitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OpportunityCondition>;
  filter?: InputMaybe<OpportunityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOvertime2SArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<Overtime2Condition>;
  filter?: InputMaybe<Overtime2Filter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<Overtime2SOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOvertimesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OvertimeCondition>;
  filter?: InputMaybe<OvertimeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OvertimesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionCondition>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPersoonInfoMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PersoonInfoMvCondition>;
  filter?: InputMaybe<PersoonInfoMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersoonInfoMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPersoonInfosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PersoonInfoCondition>;
  filter?: InputMaybe<PersoonInfoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersoonInfosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPersoonMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PersoonMvCondition>;
  filter?: InputMaybe<PersoonMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersoonMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPersoonRolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PersoonRolCondition>;
  filter?: InputMaybe<PersoonRolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersoonRolsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPersoonsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PersoonCondition>;
  filter?: InputMaybe<PersoonFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PersoonsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPlugsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlugCondition>;
  filter?: InputMaybe<PlugFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlugsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPrinciplesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PrincipleCondition>;
  filter?: InputMaybe<PrincipleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PrinciplesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllProductionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ProductionCondition>;
  filter?: InputMaybe<ProductionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProductionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPyrolyserEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PyrolyserEntityCondition>;
  filter?: InputMaybe<PyrolyserEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PyrolyserEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPyrolysersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PyrolyserCondition>;
  filter?: InputMaybe<PyrolyserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PyrolysersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRangesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RangeCondition>;
  filter?: InputMaybe<RangeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RangesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRcCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RcCardCondition>;
  filter?: InputMaybe<RcCardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RcCardsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRefreshTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RefreshTokenCondition>;
  filter?: InputMaybe<RefreshTokenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RefreshTokensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRelatieMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RelatieMvCondition>;
  filter?: InputMaybe<RelatieMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RelatieMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRelatiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RelatieCondition>;
  filter?: InputMaybe<RelatieFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RelatiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllReportDetectorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportDetectorCondition>;
  filter?: InputMaybe<ReportDetectorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportDetectorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllReportItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportItemCondition>;
  filter?: InputMaybe<ReportItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllReportListsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportListCondition>;
  filter?: InputMaybe<ReportListFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportListsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllReportSensorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportSensorCondition>;
  filter?: InputMaybe<ReportSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportSensorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllReportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportCondition>;
  filter?: InputMaybe<ReportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRequestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RequestCondition>;
  filter?: InputMaybe<RequestFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RequestsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllRxCardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RxCardCondition>;
  filter?: InputMaybe<RxCardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RxCardsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSamplePointEntitiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SamplePointEntityCondition>;
  filter?: InputMaybe<SamplePointEntityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SamplePointEntitiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSamplePointsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SamplePointCondition>;
  filter?: InputMaybe<SamplePointFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SamplePointsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorBaseTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorBaseTypeCondition>;
  filter?: InputMaybe<SensorBaseTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorBaseTypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorElementLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementLocationCondition>;
  filter?: InputMaybe<SensorElementLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementLocationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorElementLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementLogCondition>;
  filter?: InputMaybe<SensorElementLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorElementTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementTypeCondition>;
  filter?: InputMaybe<SensorElementTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementTypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorElementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementCondition>;
  filter?: InputMaybe<SensorElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorIndexCondition>;
  filter?: InputMaybe<SensorIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorOrdersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorOrderCondition>;
  filter?: InputMaybe<SensorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorSensorElementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorSensorElementCondition>;
  filter?: InputMaybe<SensorSensorElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorSensorElementsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorSettingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorSettingCondition>;
  filter?: InputMaybe<SensorSettingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorSettingsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorTestResultsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTestResultCondition>;
  filter?: InputMaybe<SensorTestResultFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorTypesChecklistsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypesChecklistCondition>;
  filter?: InputMaybe<SensorTypesChecklistFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesChecklistsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorTypesIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypesIndexCondition>;
  filter?: InputMaybe<SensorTypesIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorCondition>;
  filter?: InputMaybe<SensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSensorsChecklistsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorsChecklistCondition>;
  filter?: InputMaybe<SensorsChecklistFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorsChecklistsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSoftwaresArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SoftwareCondition>;
  filter?: InputMaybe<SoftwareFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SoftwaresOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllStockGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockGroupCondition>;
  filter?: InputMaybe<StockGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllStockItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockItemCondition>;
  filter?: InputMaybe<StockItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllStockSuppliersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockSupplierCondition>;
  filter?: InputMaybe<StockSupplierFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockSuppliersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllStockSuppliersIndexOldsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockSuppliersIndexOldCondition>;
  filter?: InputMaybe<StockSuppliersIndexOldFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockSuppliersIndexOldsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllStockSuppliersIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockSuppliersIndexCondition>;
  filter?: InputMaybe<StockSuppliersIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockSuppliersIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTasksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TaskCondition>;
  filter?: InputMaybe<TaskFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TasksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTempFactopdrachtregelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TempFactopdrachtregelCondition>;
  filter?: InputMaybe<TempFactopdrachtregelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TempFactopdrachtregelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTempLicensesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TempLicenseCondition>;
  filter?: InputMaybe<TempLicenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TempLicensesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTempRegistrationHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TempRegistrationHistoryCondition>;
  filter?: InputMaybe<TempRegistrationHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TempRegistrationHistoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTempRegistrationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TempRegistrationCondition>;
  filter?: InputMaybe<TempRegistrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TempRegistrationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTempRegistrations2SArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TempRegistrations2Condition>;
  filter?: InputMaybe<TempRegistrations2Filter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TempRegistrations2SOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TestCondition>;
  filter?: InputMaybe<TestFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TestsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTztadviesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TztadvyCondition>;
  filter?: InputMaybe<TztadvyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TztadviesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllUserRightsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserRightCondition>;
  filter?: InputMaybe<UserRightFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRightsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllUserTasksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserTaskCondition>;
  filter?: InputMaybe<UserTaskFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserTasksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllUsersGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UsersGroupCondition>;
  filter?: InputMaybe<UsersGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllValutaMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ValutaMvCondition>;
  filter?: InputMaybe<ValutaMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ValutaMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllValutasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ValutaCondition>;
  filter?: InputMaybe<ValutaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ValutasOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllVerrekenprijsChangesIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerrekenprijsChangesIndexCondition>;
  filter?: InputMaybe<VerrekenprijsChangesIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerrekenprijsChangesIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllVerrekenprijsIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerrekenprijsIndexCondition>;
  filter?: InputMaybe<VerrekenprijsIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerrekenprijsIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllVooradenIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VooradenIndexCondition>;
  filter?: InputMaybe<VooradenIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VooradenIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllVoorradenLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VoorradenLogCondition>;
  filter?: InputMaybe<VoorradenLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VoorradenLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllVoorradenLogsIndicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VoorradenLogsIndexCondition>;
  filter?: InputMaybe<VoorradenLogsIndexFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VoorradenLogsIndicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllVoorradenMvsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VoorradenMvCondition>;
  filter?: InputMaybe<VoorradenMvFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VoorradenMvsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllVoorradensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VoorradenCondition>;
  filter?: InputMaybe<VoorradenFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VoorradensOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllWeeklyHourRemarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHourRemarkCondition>;
  filter?: InputMaybe<WeeklyHourRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHourRemarksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllWeeklyHoursArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHourCondition>;
  filter?: InputMaybe<WeeklyHourFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHoursOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllWeeklyHoursWeekTotalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHoursWeekTotalCondition>;
  filter?: InputMaybe<WeeklyHoursWeekTotalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHoursWeekTotalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAreaArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAreaByFloorIdAndNameArgs = {
  floorId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAreaByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAroArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAroByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArosAcoArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArosAcoByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArtikelArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArtikelByCdartikelArgs = {
  cdartikel: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArtikelLogArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArtikelLogByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArtikelomschrArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryArtikelomschrByCdartikelAndCdtaalArgs = {
  cdartikel: Scalars['String']['input'];
  cdtaal: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetRoleArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetRoleByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetRoleClaimArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetRoleClaimByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserClaimArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserClaimByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserLoginArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserLoginByLoginProviderAndProviderKeyArgs = {
  loginProvider: Scalars['String']['input'];
  providerKey: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserRoleArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserRoleByUserIdAndRoleIdArgs = {
  roleId: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserTokenArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAspNetUserTokenByUserIdAndLoginProviderAndNameArgs = {
  loginProvider: Scalars['String']['input'];
  name: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyByCodeArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyPartArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyPartByAssemblyIdAndCdartikelArgs = {
  assemblyId: Scalars['Int']['input'];
  cdartikel: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyPartByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyTypeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyTypeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyTypePartArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyTypePartByAssemblyTypeIdAndCdartikelArgs = {
  assemblyTypeId: Scalars['Int']['input'];
  cdartikel: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAssemblyTypePartByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBuildingArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBuildingByEndUserIdAndNameArgs = {
  endUserId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBuildingByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCalGasArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCalGasByConcentrationAndEngineeringUnitsAndGasIdArgs = {
  concentration: Scalars['Float']['input'];
  engineeringUnits: Scalars['String']['input'];
  gasId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCalGasByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogGroupArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogGroupByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogItemArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogItemByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogItemFileArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogItemFileByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogItemRelationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogItemRelationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogSubGroupArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCatalogSubGroupByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChemicalCompoundArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryChemicalCompoundByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentReadPermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentWritePermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<PermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorBySerialNumberAndDetectorTypeIdArgs = {
  detectorTypeId: Scalars['Int']['input'];
  serialNumber: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorLocationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorLocationByDetectorIdArgs = {
  detectorId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorLocationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorOrderArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorOrderByFactuuropdrachtAndDetectorIdArgs = {
  detectorId: Scalars['Int']['input'];
  factuuropdracht: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorOrderByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorByDetectorIdAndDetectorPositionArgs = {
  detectorId: Scalars['Int']['input'];
  detectorPosition: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorBySensorIdArgs = {
  sensorId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorLocationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorLocationByDetectorSensorIdArgs = {
  detectorSensorId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorLocationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorLocationByLicenseIdAndSimsChannelArgs = {
  licenseId: Scalars['Int']['input'];
  simsChannel: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorTypeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorTypeByDetectorIdAndDetectorPositionArgs = {
  detectorId: Scalars['Int']['input'];
  detectorPosition: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorSensorTypeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorTypeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorTypeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorTypeByPrefixAndCodeAndSuffixArgs = {
  code: Scalars['String']['input'];
  prefix: Scalars['String']['input'];
  suffix: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDetectorTypeByTypeArgs = {
  type?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDpCardArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDpCardByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElectrolyteArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElectrolyteByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElectrolyteByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEndUserArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEndUserByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEndUserByNameAndLocationAndSubLocationArgs = {
  location: Scalars['String']['input'];
  name: Scalars['String']['input'];
  subLocation: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtArtikelExclusionArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikelArgs = {
  cdartikel: Scalars['String']['input'];
  factuuropdracht: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtArtikelExclusionByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtregelLineArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtregelLineByFactopdrRglGuidArgs = {
  factopdrRglGuid: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtregelLineByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtregelLineDateArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtregelLineDateByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtregelLineRemarkArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactopdrachtregelLineRemarkByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactureeropdrachtArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactureeropdrachtByFactuuropdrachtArgs = {
  factuuropdracht: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactuurArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactuurByFactuuropdrachtArgs = {
  factuuropdracht: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFactuurByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFindAreasArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  areaName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  buildingName?: InputMaybe<Scalars['String']['input']>;
  endUserName?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<AreaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  floorName?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  samplePointName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindBuildingsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  areaName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  buildingName?: InputMaybe<Scalars['String']['input']>;
  endUserName?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<BuildingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  floorName?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  samplePointName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindDetectorTypesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DetectorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindDetectorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<DetectorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindEndUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  areaName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  buildingName?: InputMaybe<Scalars['String']['input']>;
  endUserName?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<EndUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  floorName?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  samplePointName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindEngineeringUnitsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<RangeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  gasName?: InputMaybe<Scalars['String']['input']>;
  highEu?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindFloorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  areaName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  buildingName?: InputMaybe<Scalars['String']['input']>;
  endUserName?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<FloorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  floorName?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  samplePointName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindGasNamesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<GasFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  gasName?: InputMaybe<Scalars['String']['input']>;
  highEu?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindHighEusArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<RangeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  gasName?: InputMaybe<Scalars['String']['input']>;
  highEu?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindLowEusArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<RangeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  gasName?: InputMaybe<Scalars['String']['input']>;
  highEu?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindSamplePointNamesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  areaName?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  buildingName?: InputMaybe<Scalars['String']['input']>;
  endUserName?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<SamplePointFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  floorName?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  samplePointName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindSensorSerialNumbersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<SensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  gasName?: InputMaybe<Scalars['String']['input']>;
  highEu?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFindSensorTypeNamesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  gasName?: InputMaybe<Scalars['String']['input']>;
  highEu?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFloorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFloorByBuildingIdAndNameArgs = {
  buildingId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFloorByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGasArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGasByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGasByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGetArtikelByCdartikelArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  cdartikelParam?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ArtikelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupPermissionArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupPermissionByGroupIdArgs = {
  groupId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupPermissionByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupRightArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupRightByGroupIdAndPathArgs = {
  groupId: Scalars['Int']['input'];
  path: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupRightByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryHardwareArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryHardwareByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryIncomingDocumentArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryIncomingDocumentByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInkoopgegevenArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInkoopgegevenByCdartikelAndInkvolgnrArgs = {
  cdartikel: Scalars['String']['input'];
  inkvolgnr: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInkoopgegevensLogArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInkoopgegevensLogByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInkooporderregelLineArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInkooporderregelLineByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInkooporderregelLineByInkopdrRglGuidArgs = {
  inkopdrRglGuid: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItemArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItemByCdartikelAndSerialNumberArgs = {
  cdartikel: Scalars['String']['input'];
  serialNumber: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryItemByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJobByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJunctionBoxArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryJunctionBoxByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLeadArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLeadByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseCustomerArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseCustomerByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseModuleArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseModuleByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseOrderArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseOrderByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseOrderByLicenseIdAndFactuuropdrachtArgs = {
  factuuropdracht: Scalars['String']['input'];
  licenseId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseOrderByLicenseRegistrationIdAndFactuuropdrachtArgs = {
  factuuropdracht: Scalars['String']['input'];
  licenseRegistrationId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseRegistrationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLicenseRegistrationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMaintenanceVisitArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMaintenanceVisitByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMaintenanceVisitLineArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMaintenanceVisitLineByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationIdArgs = {
  detectorSensorLocationId: Scalars['Int']['input'];
  maintenanceVisitId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMaintenanceVisitRemarkArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMaintenanceVisitRemarkByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMaintenanceVisitRemarkByMaintenanceVisitIdAndLineArgs = {
  line: Scalars['Int']['input'];
  maintenanceVisitId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMembraneArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMembraneByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMembraneByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryORingArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryORingByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryORingByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOfferteRemarkArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOfferteRemarkByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOfferteRemarkByOfferteIdArgs = {
  offerteId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOpportunityArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOpportunityByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersoonRolArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPersoonRolByPersoonRolGuidArgs = {
  persoonRolGuid: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlugArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlugByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlugByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPrincipleArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPrincipleByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPrincipleByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductionArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryProductionByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPyrolyserArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPyrolyserArtikelByCdartikelArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  cdartikelParam?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ArtikelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPyrolyserByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPyrolyserByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPyrolysersArtikelByCdartikelArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  cdartikelParam?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<ArtikelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryRangeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRangeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRangeByLowEuAndHighEuAndEngineeringUnitsAndGasIdArgs = {
  engineeringUnits: Scalars['String']['input'];
  gasId: Scalars['Int']['input'];
  highEu: Scalars['Float']['input'];
  lowEu: Scalars['Float']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRcCardArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRcCardByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRefreshTokenArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRefreshTokenByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportByFilenameArgs = {
  filename: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportByTsrNumberAndVersionArgs = {
  tsrNumber: Scalars['String']['input'];
  version: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportDetectorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportDetectorByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportDetectorByReportIdAndDetectorIdArgs = {
  detectorId: Scalars['Int']['input'];
  reportId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportItemArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportItemByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportSensorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportSensorByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReportSensorByReportIdAndSensorIdArgs = {
  reportId: Scalars['Int']['input'];
  sensorId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRequestArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRequestByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRxCardArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRxCardByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySamplePointArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySamplePointByAreaIdAndNameArgs = {
  areaId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySamplePointByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorBaseTypeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorBaseTypeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorBaseTypeByPrefixAndSuffixArgs = {
  prefix: Scalars['String']['input'];
  suffix: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorBySerialNumberAndSensorTypeIdArgs = {
  sensorTypeId: Scalars['Int']['input'];
  serialNumber: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementLocationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementLocationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementLocationBySensorElementIdArgs = {
  sensorElementId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementLogArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementLogByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementTypeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorElementTypeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorOrderArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorOrderByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorOrderBySensorIdAndFactuuropdrachtArgs = {
  factuuropdracht: Scalars['String']['input'];
  sensorId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorSensorElementArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorSensorElementByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorSensorElementBySensorElementIdArgs = {
  sensorElementId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorSensorElementBySensorIdAndSensorPositionArgs = {
  sensorId: Scalars['Int']['input'];
  sensorPosition: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorSettingArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorSettingByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorSettingByTypeTargetArgs = {
  typeTarget: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorTestResultArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorTestResultByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorTypeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorTypeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserIdArgs = {
  code: Scalars['String']['input'];
  model: Scalars['String']['input'];
  pyrolyserId: Scalars['Int']['input'];
  rangeId: Scalars['Int']['input'];
  sensorBaseTypeId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySensorTypeBySensorTypeIdArgs = {
  sensorTypeId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySoftwareArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySoftwareByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStockGroupArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStockGroupByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStockItemArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStockItemByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStockItemByStockGroupIdAndCdartikelArgs = {
  cdartikel: Scalars['String']['input'];
  stockGroupId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStockSupplierArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStockSupplierByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTaskArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTaskByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempFactopdrachtregelArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempFactopdrachtregelByFactuuropdrachtAndFactuurregelArgs = {
  factuuropdracht: Scalars['String']['input'];
  factuurregel: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempFactopdrachtregelByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempLicenseArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempLicenseByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempRegistrationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempRegistrationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempRegistrationHistoryArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempRegistrationHistoryByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempRegistrations2Args = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTempRegistrations2ByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTestArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTestByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserRightArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserRightByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserRightByUserIdAndPathArgs = {
  path: Scalars['String']['input'];
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserTaskArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserTaskByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserTaskByUserIdAndTaskIdArgs = {
  taskId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersGroupArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersGroupByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersGroupByUserIdAndGroupIdArgs = {
  groupId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVoorradenArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVoorradenByCdartikelAndCdmagazijnArgs = {
  cdartikel: Scalars['String']['input'];
  cdmagazijn: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVoorradenLogArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVoorradenLogByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWeeklyHourArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWeeklyHourByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWeeklyHourRemarkArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWeeklyHourRemarkByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryWeeklyHourRemarkByUserIdAndTaskIdAndDateArgs = {
  date: Scalars['Date']['input'];
  taskId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

export type Range = Node & {
  __typename?: 'Range';
  alarm1DirectionUp?: Maybe<Scalars['Boolean']['output']>;
  alarm1Level?: Maybe<Scalars['BigFloat']['output']>;
  alarm2DirectionUp?: Maybe<Scalars['Boolean']['output']>;
  alarm2Level?: Maybe<Scalars['BigFloat']['output']>;
  alarmUnits?: Maybe<Scalars['Boolean']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  engineeringUnits?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Gas` that is related to this `Range`. */
  gasByGasId?: Maybe<Gas>;
  gasId: Scalars['Int']['output'];
  highEu?: Maybe<Scalars['Float']['output']>;
  highEuBackup?: Maybe<Scalars['Float']['output']>;
  highEuNumeric?: Maybe<Scalars['BigFloat']['output']>;
  id: Scalars['Int']['output'];
  lowEu?: Maybe<Scalars['Float']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  precision?: Maybe<Scalars['Int']['output']>;
  range?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SensorElementType`. */
  sensorElementTypesByCalRangeId: SensorElementTypesConnection;
  /** Reads and enables pagination through a set of `SensorElementType`. */
  sensorElementTypesByRangeId: SensorElementTypesConnection;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByRangeId: SensorTypesConnection;
  /** Reads a single `User` that is related to this `Range`. */
  userByOwnerId?: Maybe<User>;
  warning1Level?: Maybe<Scalars['BigFloat']['output']>;
  warning2Level?: Maybe<Scalars['BigFloat']['output']>;
};


export type RangeSensorElementTypesByCalRangeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementTypeCondition>;
  filter?: InputMaybe<SensorElementTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementTypesOrderBy>>;
};


export type RangeSensorElementTypesByRangeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementTypeCondition>;
  filter?: InputMaybe<SensorElementTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementTypesOrderBy>>;
};


export type RangeSensorTypesByRangeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/** A condition to be used against `Range` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RangeCondition = {
  /** Checks for equality with the object’s `alarm1DirectionUp` field. */
  alarm1DirectionUp?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `alarm1Level` field. */
  alarm1Level?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `alarm2DirectionUp` field. */
  alarm2DirectionUp?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `alarm2Level` field. */
  alarm2Level?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `alarmUnits` field. */
  alarmUnits?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gasId` field. */
  gasId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `highEu` field. */
  highEu?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `highEuBackup` field. */
  highEuBackup?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `highEuNumeric` field. */
  highEuNumeric?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lowEu` field. */
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `precision` field. */
  precision?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `warning1Level` field. */
  warning1Level?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `warning2Level` field. */
  warning2Level?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `Range` object types. All fields are combined with a logical ‘and.’ */
export type RangeFilter = {
  /** Filter by the object’s `alarm1DirectionUp` field. */
  alarm1DirectionUp?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `alarm1Level` field. */
  alarm1Level?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `alarm2DirectionUp` field. */
  alarm2DirectionUp?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `alarm2Level` field. */
  alarm2Level?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `alarmUnits` field. */
  alarmUnits?: InputMaybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RangeFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gasByGasId` relation. */
  gasByGasId?: InputMaybe<GasFilter>;
  /** Filter by the object’s `gasId` field. */
  gasId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `highEu` field. */
  highEu?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `highEuBackup` field. */
  highEuBackup?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `highEuNumeric` field. */
  highEuNumeric?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lowEu` field. */
  lowEu?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RangeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RangeFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `precision` field. */
  precision?: InputMaybe<IntFilter>;
  /** Filter by the object’s `range` field. */
  range?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorElementTypesByCalRangeId` relation. */
  sensorElementTypesByCalRangeId?: InputMaybe<RangeToManySensorElementTypeFilter>;
  /** Some related `sensorElementTypesByCalRangeId` exist. */
  sensorElementTypesByCalRangeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementTypesByRangeId` relation. */
  sensorElementTypesByRangeId?: InputMaybe<RangeToManySensorElementTypeFilter>;
  /** Some related `sensorElementTypesByRangeId` exist. */
  sensorElementTypesByRangeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorTypesByRangeId` relation. */
  sensorTypesByRangeId?: InputMaybe<RangeToManySensorTypeFilter>;
  /** Some related `sensorTypesByRangeId` exist. */
  sensorTypesByRangeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `warning1Level` field. */
  warning1Level?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `warning2Level` field. */
  warning2Level?: InputMaybe<BigFloatFilter>;
};

/** An input for mutations affecting `Range` */
export type RangeInput = {
  alarm1DirectionUp?: InputMaybe<Scalars['Boolean']['input']>;
  alarm1Level?: InputMaybe<Scalars['BigFloat']['input']>;
  alarm2DirectionUp?: InputMaybe<Scalars['Boolean']['input']>;
  alarm2Level?: InputMaybe<Scalars['BigFloat']['input']>;
  alarmUnits?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  gasId: Scalars['Int']['input'];
  highEu?: InputMaybe<Scalars['Float']['input']>;
  highEuBackup?: InputMaybe<Scalars['Float']['input']>;
  highEuNumeric?: InputMaybe<Scalars['BigFloat']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  precision?: InputMaybe<Scalars['Int']['input']>;
  warning1Level?: InputMaybe<Scalars['BigFloat']['input']>;
  warning2Level?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** Represents an update to a `Range`. Fields that are set will be updated. */
export type RangePatch = {
  alarm1DirectionUp?: InputMaybe<Scalars['Boolean']['input']>;
  alarm1Level?: InputMaybe<Scalars['BigFloat']['input']>;
  alarm2DirectionUp?: InputMaybe<Scalars['Boolean']['input']>;
  alarm2Level?: InputMaybe<Scalars['BigFloat']['input']>;
  alarmUnits?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  gasId?: InputMaybe<Scalars['Int']['input']>;
  highEu?: InputMaybe<Scalars['Float']['input']>;
  highEuBackup?: InputMaybe<Scalars['Float']['input']>;
  highEuNumeric?: InputMaybe<Scalars['BigFloat']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  precision?: InputMaybe<Scalars['Int']['input']>;
  warning1Level?: InputMaybe<Scalars['BigFloat']['input']>;
  warning2Level?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against many `SensorElementType` object types. All fields are combined with a logical ‘and.’ */
export type RangeToManySensorElementTypeFilter = {
  /** Every related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementTypeFilter>;
  /** No related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementTypeFilter>;
  /** Some related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementTypeFilter>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type RangeToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `Range` values. */
export type RangesConnection = {
  __typename?: 'RangesConnection';
  /** A list of edges which contains the `Range` and cursor to aid in pagination. */
  edges: Array<RangesEdge>;
  /** A list of `Range` objects. */
  nodes: Array<Range>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Range` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Range` edge in the connection. */
export type RangesEdge = {
  __typename?: 'RangesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Range` at the end of the edge. */
  node: Range;
};

/** Methods to use when ordering `Range`. */
export enum RangesOrderBy {
  Alarm_1DirectionUpAsc = 'ALARM_1_DIRECTION_UP_ASC',
  Alarm_1DirectionUpDesc = 'ALARM_1_DIRECTION_UP_DESC',
  Alarm_1LevelAsc = 'ALARM_1_LEVEL_ASC',
  Alarm_1LevelDesc = 'ALARM_1_LEVEL_DESC',
  Alarm_2DirectionUpAsc = 'ALARM_2_DIRECTION_UP_ASC',
  Alarm_2DirectionUpDesc = 'ALARM_2_DIRECTION_UP_DESC',
  Alarm_2LevelAsc = 'ALARM_2_LEVEL_ASC',
  Alarm_2LevelDesc = 'ALARM_2_LEVEL_DESC',
  AlarmUnitsAsc = 'ALARM_UNITS_ASC',
  AlarmUnitsDesc = 'ALARM_UNITS_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EngineeringUnitsAsc = 'ENGINEERING_UNITS_ASC',
  EngineeringUnitsDesc = 'ENGINEERING_UNITS_DESC',
  GasByGasIdChemicalCompoundIdAsc = 'GAS_BY_GAS_ID__CHEMICAL_COMPOUND_ID_ASC',
  GasByGasIdChemicalCompoundIdDesc = 'GAS_BY_GAS_ID__CHEMICAL_COMPOUND_ID_DESC',
  GasByGasIdCreatedAsc = 'GAS_BY_GAS_ID__CREATED_ASC',
  GasByGasIdCreatedDesc = 'GAS_BY_GAS_ID__CREATED_DESC',
  GasByGasIdFormulaAsc = 'GAS_BY_GAS_ID__FORMULA_ASC',
  GasByGasIdFormulaDesc = 'GAS_BY_GAS_ID__FORMULA_DESC',
  GasByGasIdIdAsc = 'GAS_BY_GAS_ID__ID_ASC',
  GasByGasIdIdDesc = 'GAS_BY_GAS_ID__ID_DESC',
  GasByGasIdModifiedAsc = 'GAS_BY_GAS_ID__MODIFIED_ASC',
  GasByGasIdModifiedDesc = 'GAS_BY_GAS_ID__MODIFIED_DESC',
  GasByGasIdNameAsc = 'GAS_BY_GAS_ID__NAME_ASC',
  GasByGasIdNameDesc = 'GAS_BY_GAS_ID__NAME_DESC',
  GasByGasIdOwnerIdAsc = 'GAS_BY_GAS_ID__OWNER_ID_ASC',
  GasByGasIdOwnerIdDesc = 'GAS_BY_GAS_ID__OWNER_ID_DESC',
  GasIdAsc = 'GAS_ID_ASC',
  GasIdDesc = 'GAS_ID_DESC',
  HighEuAsc = 'HIGH_EU_ASC',
  HighEuBackupAsc = 'HIGH_EU_BACKUP_ASC',
  HighEuBackupDesc = 'HIGH_EU_BACKUP_DESC',
  HighEuDesc = 'HIGH_EU_DESC',
  HighEuNumericAsc = 'HIGH_EU_NUMERIC_ASC',
  HighEuNumericDesc = 'HIGH_EU_NUMERIC_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LowEuAsc = 'LOW_EU_ASC',
  LowEuDesc = 'LOW_EU_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrecisionAsc = 'PRECISION_ASC',
  PrecisionDesc = 'PRECISION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorElementTypesByCalRangeIdCountAsc = 'SENSOR_ELEMENT_TYPES_BY_CAL_RANGE_ID__COUNT_ASC',
  SensorElementTypesByCalRangeIdCountDesc = 'SENSOR_ELEMENT_TYPES_BY_CAL_RANGE_ID__COUNT_DESC',
  SensorElementTypesByRangeIdCountAsc = 'SENSOR_ELEMENT_TYPES_BY_RANGE_ID__COUNT_ASC',
  SensorElementTypesByRangeIdCountDesc = 'SENSOR_ELEMENT_TYPES_BY_RANGE_ID__COUNT_DESC',
  SensorTypesByRangeIdCountAsc = 'SENSOR_TYPES_BY_RANGE_ID__COUNT_ASC',
  SensorTypesByRangeIdCountDesc = 'SENSOR_TYPES_BY_RANGE_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  Warning_1LevelAsc = 'WARNING_1_LEVEL_ASC',
  Warning_1LevelDesc = 'WARNING_1_LEVEL_DESC',
  Warning_2LevelAsc = 'WARNING_2_LEVEL_ASC',
  Warning_2LevelDesc = 'WARNING_2_LEVEL_DESC'
}

export type RcCard = Node & {
  __typename?: 'RcCard';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `RcCard`. */
  userByOwnerId?: Maybe<User>;
};

/** A condition to be used against `RcCard` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RcCardCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `RcCard` object types. All fields are combined with a logical ‘and.’ */
export type RcCardFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RcCardFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RcCardFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RcCardFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `RcCard` */
export type RcCardInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `RcCard`. Fields that are set will be updated. */
export type RcCardPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `RcCard` values. */
export type RcCardsConnection = {
  __typename?: 'RcCardsConnection';
  /** A list of edges which contains the `RcCard` and cursor to aid in pagination. */
  edges: Array<RcCardsEdge>;
  /** A list of `RcCard` objects. */
  nodes: Array<RcCard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RcCard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RcCard` edge in the connection. */
export type RcCardsEdge = {
  __typename?: 'RcCardsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `RcCard` at the end of the edge. */
  node: RcCard;
};

/** Methods to use when ordering `RcCard`. */
export enum RcCardsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type RefreshToken = Node & {
  __typename?: 'RefreshToken';
  appUserId: Scalars['String']['output'];
  /** Reads a single `AspNetUser` that is related to this `RefreshToken`. */
  aspNetUserByAppUserId?: Maybe<AspNetUser>;
  expires: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  revoked?: Maybe<Scalars['Datetime']['output']>;
  token: Scalars['String']['output'];
};

/**
 * A condition to be used against `RefreshToken` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type RefreshTokenCondition = {
  /** Checks for equality with the object’s `appUserId` field. */
  appUserId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expires` field. */
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `revoked` field. */
  revoked?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `token` field. */
  token?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `RefreshToken` object types. All fields are combined with a logical ‘and.’ */
export type RefreshTokenFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RefreshTokenFilter>>;
  /** Filter by the object’s `appUserId` field. */
  appUserId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `aspNetUserByAppUserId` relation. */
  aspNetUserByAppUserId?: InputMaybe<AspNetUserFilter>;
  /** Filter by the object’s `expires` field. */
  expires?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RefreshTokenFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RefreshTokenFilter>>;
  /** Filter by the object’s `revoked` field. */
  revoked?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `token` field. */
  token?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `RefreshToken` */
export type RefreshTokenInput = {
  appUserId: Scalars['String']['input'];
  expires: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  revoked?: InputMaybe<Scalars['Datetime']['input']>;
  token: Scalars['String']['input'];
};

/** Represents an update to a `RefreshToken`. Fields that are set will be updated. */
export type RefreshTokenPatch = {
  appUserId?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  revoked?: InputMaybe<Scalars['Datetime']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `RefreshToken` values. */
export type RefreshTokensConnection = {
  __typename?: 'RefreshTokensConnection';
  /** A list of edges which contains the `RefreshToken` and cursor to aid in pagination. */
  edges: Array<RefreshTokensEdge>;
  /** A list of `RefreshToken` objects. */
  nodes: Array<RefreshToken>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RefreshToken` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RefreshToken` edge in the connection. */
export type RefreshTokensEdge = {
  __typename?: 'RefreshTokensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `RefreshToken` at the end of the edge. */
  node: RefreshToken;
};

/** Methods to use when ordering `RefreshToken`. */
export enum RefreshTokensOrderBy {
  AppUserIdAsc = 'APP_USER_ID_ASC',
  AppUserIdDesc = 'APP_USER_ID_DESC',
  AspNetUserByAppUserIdAccessFailedCountAsc = 'ASP_NET_USER_BY_APP_USER_ID__ACCESS_FAILED_COUNT_ASC',
  AspNetUserByAppUserIdAccessFailedCountDesc = 'ASP_NET_USER_BY_APP_USER_ID__ACCESS_FAILED_COUNT_DESC',
  AspNetUserByAppUserIdConcurrencyStampAsc = 'ASP_NET_USER_BY_APP_USER_ID__CONCURRENCY_STAMP_ASC',
  AspNetUserByAppUserIdConcurrencyStampDesc = 'ASP_NET_USER_BY_APP_USER_ID__CONCURRENCY_STAMP_DESC',
  AspNetUserByAppUserIdDisplayNameAsc = 'ASP_NET_USER_BY_APP_USER_ID__DISPLAY_NAME_ASC',
  AspNetUserByAppUserIdDisplayNameDesc = 'ASP_NET_USER_BY_APP_USER_ID__DISPLAY_NAME_DESC',
  AspNetUserByAppUserIdEmailAsc = 'ASP_NET_USER_BY_APP_USER_ID__EMAIL_ASC',
  AspNetUserByAppUserIdEmailConfirmedAsc = 'ASP_NET_USER_BY_APP_USER_ID__EMAIL_CONFIRMED_ASC',
  AspNetUserByAppUserIdEmailConfirmedDesc = 'ASP_NET_USER_BY_APP_USER_ID__EMAIL_CONFIRMED_DESC',
  AspNetUserByAppUserIdEmailDesc = 'ASP_NET_USER_BY_APP_USER_ID__EMAIL_DESC',
  AspNetUserByAppUserIdIdAsc = 'ASP_NET_USER_BY_APP_USER_ID__ID_ASC',
  AspNetUserByAppUserIdIdDesc = 'ASP_NET_USER_BY_APP_USER_ID__ID_DESC',
  AspNetUserByAppUserIdLockoutEnabledAsc = 'ASP_NET_USER_BY_APP_USER_ID__LOCKOUT_ENABLED_ASC',
  AspNetUserByAppUserIdLockoutEnabledDesc = 'ASP_NET_USER_BY_APP_USER_ID__LOCKOUT_ENABLED_DESC',
  AspNetUserByAppUserIdLockoutEndAsc = 'ASP_NET_USER_BY_APP_USER_ID__LOCKOUT_END_ASC',
  AspNetUserByAppUserIdLockoutEndDesc = 'ASP_NET_USER_BY_APP_USER_ID__LOCKOUT_END_DESC',
  AspNetUserByAppUserIdNormalizedEmailAsc = 'ASP_NET_USER_BY_APP_USER_ID__NORMALIZED_EMAIL_ASC',
  AspNetUserByAppUserIdNormalizedEmailDesc = 'ASP_NET_USER_BY_APP_USER_ID__NORMALIZED_EMAIL_DESC',
  AspNetUserByAppUserIdNormalizedUserNameAsc = 'ASP_NET_USER_BY_APP_USER_ID__NORMALIZED_USER_NAME_ASC',
  AspNetUserByAppUserIdNormalizedUserNameDesc = 'ASP_NET_USER_BY_APP_USER_ID__NORMALIZED_USER_NAME_DESC',
  AspNetUserByAppUserIdPasswordHashAsc = 'ASP_NET_USER_BY_APP_USER_ID__PASSWORD_HASH_ASC',
  AspNetUserByAppUserIdPasswordHashDesc = 'ASP_NET_USER_BY_APP_USER_ID__PASSWORD_HASH_DESC',
  AspNetUserByAppUserIdPhoneNumberAsc = 'ASP_NET_USER_BY_APP_USER_ID__PHONE_NUMBER_ASC',
  AspNetUserByAppUserIdPhoneNumberConfirmedAsc = 'ASP_NET_USER_BY_APP_USER_ID__PHONE_NUMBER_CONFIRMED_ASC',
  AspNetUserByAppUserIdPhoneNumberConfirmedDesc = 'ASP_NET_USER_BY_APP_USER_ID__PHONE_NUMBER_CONFIRMED_DESC',
  AspNetUserByAppUserIdPhoneNumberDesc = 'ASP_NET_USER_BY_APP_USER_ID__PHONE_NUMBER_DESC',
  AspNetUserByAppUserIdSecurityStampAsc = 'ASP_NET_USER_BY_APP_USER_ID__SECURITY_STAMP_ASC',
  AspNetUserByAppUserIdSecurityStampDesc = 'ASP_NET_USER_BY_APP_USER_ID__SECURITY_STAMP_DESC',
  AspNetUserByAppUserIdTwoFactorEnabledAsc = 'ASP_NET_USER_BY_APP_USER_ID__TWO_FACTOR_ENABLED_ASC',
  AspNetUserByAppUserIdTwoFactorEnabledDesc = 'ASP_NET_USER_BY_APP_USER_ID__TWO_FACTOR_ENABLED_DESC',
  AspNetUserByAppUserIdUserNameAsc = 'ASP_NET_USER_BY_APP_USER_ID__USER_NAME_ASC',
  AspNetUserByAppUserIdUserNameDesc = 'ASP_NET_USER_BY_APP_USER_ID__USER_NAME_DESC',
  ExpiresAsc = 'EXPIRES_ASC',
  ExpiresDesc = 'EXPIRES_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RevokedAsc = 'REVOKED_ASC',
  RevokedDesc = 'REVOKED_DESC',
  TokenAsc = 'TOKEN_ASC',
  TokenDesc = 'TOKEN_DESC'
}

export type Relatie = {
  __typename?: 'Relatie';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  btwnummer?: Maybe<Scalars['String']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  datumkvk?: Maybe<Scalars['Date']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  datumverif?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  ltstcdcontact?: Maybe<Scalars['Int']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  nummerkvk?: Maybe<Scalars['String']['output']>;
  ondernemersnr?: Maybe<Scalars['String']['output']>;
  overhIdNr?: Maybe<Scalars['String']['output']>;
  plaatskvk?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  vvindustry?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Relatie` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RelatieCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumverif` field. */
  datumverif?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ltstcdcontact` field. */
  ltstcdcontact?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `straat` field. */
  straat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvindustry` field. */
  vvindustry?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Relatie` object types. All fields are combined with a logical ‘and.’ */
export type RelatieFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RelatieFilter>>;
  /** Filter by the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumverif` field. */
  datumverif?: InputMaybe<DateFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ltstcdcontact` field. */
  ltstcdcontact?: InputMaybe<IntFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RelatieFilter>;
  /** Filter by the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RelatieFilter>>;
  /** Filter by the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postcode` field. */
  postcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `straat` field. */
  straat?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvindustry` field. */
  vvindustry?: InputMaybe<StringFilter>;
  /** Filter by the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

export type RelatieMv = {
  __typename?: 'RelatieMv';
  aanmaakdatum?: Maybe<Scalars['Date']['output']>;
  btwnummer?: Maybe<Scalars['String']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  cdvert?: Maybe<Scalars['String']['output']>;
  datumkvk?: Maybe<Scalars['Date']['output']>;
  datumltstewijz?: Maybe<Scalars['Date']['output']>;
  datumverif?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  guidItem?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  ltstcdcontact?: Maybe<Scalars['Int']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  nummerkvk?: Maybe<Scalars['String']['output']>;
  ondernemersnr?: Maybe<Scalars['String']['output']>;
  overhIdNr?: Maybe<Scalars['String']['output']>;
  plaatskvk?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  sysCreate?: Maybe<Scalars['String']['output']>;
  sysUpdate?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  vvindustry?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `RelatieMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type RelatieMvCondition = {
  /** Checks for equality with the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdland` field. */
  cdland?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvert` field. */
  cdvert?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `datumverif` field. */
  datumverif?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `guidItem` field. */
  guidItem?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `homepage` field. */
  homepage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ltstcdcontact` field. */
  ltstcdcontact?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `naam` field. */
  naam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `postcode` field. */
  postcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `straat` field. */
  straat?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefax` field. */
  telefax?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoon` field. */
  telefoon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `vvindustry` field. */
  vvindustry?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `RelatieMv` object types. All fields are combined with a logical ‘and.’ */
export type RelatieMvFilter = {
  /** Filter by the object’s `aanmaakdatum` field. */
  aanmaakdatum?: InputMaybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RelatieMvFilter>>;
  /** Filter by the object’s `btwnummer` field. */
  btwnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdrelatie` field. */
  cdrelatie?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdtaal` field. */
  cdtaal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvert` field. */
  cdvert?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datumkvk` field. */
  datumkvk?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumltstewijz` field. */
  datumltstewijz?: InputMaybe<DateFilter>;
  /** Filter by the object’s `datumverif` field. */
  datumverif?: InputMaybe<DateFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `guidItem` field. */
  guidItem?: InputMaybe<StringFilter>;
  /** Filter by the object’s `homepage` field. */
  homepage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ltstcdcontact` field. */
  ltstcdcontact?: InputMaybe<IntFilter>;
  /** Filter by the object’s `naam` field. */
  naam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `naamstraat` field. */
  naamstraat?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RelatieMvFilter>;
  /** Filter by the object’s `nummerkvk` field. */
  nummerkvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `ondernemersnr` field. */
  ondernemersnr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RelatieMvFilter>>;
  /** Filter by the object’s `overhIdNr` field. */
  overhIdNr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plaatskvk` field. */
  plaatskvk?: InputMaybe<StringFilter>;
  /** Filter by the object’s `postcode` field. */
  postcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `straat` field. */
  straat?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysCreate` field. */
  sysCreate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sysUpdate` field. */
  sysUpdate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefax` field. */
  telefax?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoon` field. */
  telefoon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `telefoonmobiel` field. */
  telefoonmobiel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `vvindustry` field. */
  vvindustry?: InputMaybe<StringFilter>;
  /** Filter by the object’s `woonplaats` field. */
  woonplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `RelatieMv` values. */
export type RelatieMvsConnection = {
  __typename?: 'RelatieMvsConnection';
  /** A list of edges which contains the `RelatieMv` and cursor to aid in pagination. */
  edges: Array<RelatieMvsEdge>;
  /** A list of `RelatieMv` objects. */
  nodes: Array<RelatieMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RelatieMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RelatieMv` edge in the connection. */
export type RelatieMvsEdge = {
  __typename?: 'RelatieMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `RelatieMv` at the end of the edge. */
  node: RelatieMv;
};

/** Methods to use when ordering `RelatieMv`. */
export enum RelatieMvsOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  BtwnummerAsc = 'BTWNUMMER_ASC',
  BtwnummerDesc = 'BTWNUMMER_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  DatumkvkAsc = 'DATUMKVK_ASC',
  DatumkvkDesc = 'DATUMKVK_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  DatumverifAsc = 'DATUMVERIF_ASC',
  DatumverifDesc = 'DATUMVERIF_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  LtstcdcontactAsc = 'LTSTCDCONTACT_ASC',
  LtstcdcontactDesc = 'LTSTCDCONTACT_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  NummerkvkAsc = 'NUMMERKVK_ASC',
  NummerkvkDesc = 'NUMMERKVK_DESC',
  OndernemersnrAsc = 'ONDERNEMERSNR_ASC',
  OndernemersnrDesc = 'ONDERNEMERSNR_DESC',
  OverhIdNrAsc = 'OVERH_ID_NR_ASC',
  OverhIdNrDesc = 'OVERH_ID_NR_DESC',
  PlaatskvkAsc = 'PLAATSKVK_ASC',
  PlaatskvkDesc = 'PLAATSKVK_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  VvindustryAsc = 'VVINDUSTRY_ASC',
  VvindustryDesc = 'VVINDUSTRY_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A connection to a list of `Relatie` values. */
export type RelatiesConnection = {
  __typename?: 'RelatiesConnection';
  /** A list of edges which contains the `Relatie` and cursor to aid in pagination. */
  edges: Array<RelatiesEdge>;
  /** A list of `Relatie` objects. */
  nodes: Array<Relatie>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Relatie` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Relatie` edge in the connection. */
export type RelatiesEdge = {
  __typename?: 'RelatiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Relatie` at the end of the edge. */
  node: Relatie;
};

/** Methods to use when ordering `Relatie`. */
export enum RelatiesOrderBy {
  AanmaakdatumAsc = 'AANMAAKDATUM_ASC',
  AanmaakdatumDesc = 'AANMAAKDATUM_DESC',
  BtwnummerAsc = 'BTWNUMMER_ASC',
  BtwnummerDesc = 'BTWNUMMER_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  CdvertAsc = 'CDVERT_ASC',
  CdvertDesc = 'CDVERT_DESC',
  DatumkvkAsc = 'DATUMKVK_ASC',
  DatumkvkDesc = 'DATUMKVK_DESC',
  DatumltstewijzAsc = 'DATUMLTSTEWIJZ_ASC',
  DatumltstewijzDesc = 'DATUMLTSTEWIJZ_DESC',
  DatumverifAsc = 'DATUMVERIF_ASC',
  DatumverifDesc = 'DATUMVERIF_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  GuidItemAsc = 'GUID_ITEM_ASC',
  GuidItemDesc = 'GUID_ITEM_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  LtstcdcontactAsc = 'LTSTCDCONTACT_ASC',
  LtstcdcontactDesc = 'LTSTCDCONTACT_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  NummerkvkAsc = 'NUMMERKVK_ASC',
  NummerkvkDesc = 'NUMMERKVK_DESC',
  OndernemersnrAsc = 'ONDERNEMERSNR_ASC',
  OndernemersnrDesc = 'ONDERNEMERSNR_DESC',
  OverhIdNrAsc = 'OVERH_ID_NR_ASC',
  OverhIdNrDesc = 'OVERH_ID_NR_DESC',
  PlaatskvkAsc = 'PLAATSKVK_ASC',
  PlaatskvkDesc = 'PLAATSKVK_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  SysCreateAsc = 'SYS_CREATE_ASC',
  SysCreateDesc = 'SYS_CREATE_DESC',
  SysUpdateAsc = 'SYS_UPDATE_ASC',
  SysUpdateDesc = 'SYS_UPDATE_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  VvindustryAsc = 'VVINDUSTRY_ASC',
  VvindustryDesc = 'VVINDUSTRY_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type Report = Node & {
  __typename?: 'Report';
  /** Reads and enables pagination through a set of `Action`. */
  actionsByReportId: ActionsConnection;
  checkedTechcentre?: Maybe<Scalars['Boolean']['output']>;
  closed?: Maybe<Scalars['Boolean']['output']>;
  closedOld?: Maybe<Scalars['Boolean']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  date?: Maybe<Scalars['Date']['output']>;
  destroyed?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `EndUser` that is related to this `Report`. */
  endUserByEndUserId?: Maybe<EndUser>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  extraWork?: Maybe<Scalars['Boolean']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  filename?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  maintenance?: Maybe<Scalars['Boolean']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  other?: Maybe<Scalars['Boolean']['output']>;
  ownerId: Scalars['Int']['output'];
  remarks?: Maybe<Scalars['String']['output']>;
  repair?: Maybe<Scalars['Boolean']['output']>;
  /** Reads and enables pagination through a set of `ReportDetector`. */
  reportDetectorsByReportId: ReportDetectorsConnection;
  /** Reads and enables pagination through a set of `ReportItem`. */
  reportItemsByReportId: ReportItemsConnection;
  /** Reads and enables pagination through a set of `ReportSensor`. */
  reportSensorsByReportId: ReportSensorsConnection;
  startup?: Maybe<Scalars['Boolean']['output']>;
  tsrNumber?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `Report`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Report`. */
  userByUserId?: Maybe<User>;
  userId: Scalars['Int']['output'];
  version: Scalars['String']['output'];
};


export type ReportActionsByReportIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionCondition>;
  filter?: InputMaybe<ActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionsOrderBy>>;
};


export type ReportReportDetectorsByReportIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportDetectorCondition>;
  filter?: InputMaybe<ReportDetectorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportDetectorsOrderBy>>;
};


export type ReportReportItemsByReportIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportItemCondition>;
  filter?: InputMaybe<ReportItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportItemsOrderBy>>;
};


export type ReportReportSensorsByReportIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportSensorCondition>;
  filter?: InputMaybe<ReportSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportSensorsOrderBy>>;
};

/** A condition to be used against `Report` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReportCondition = {
  /** Checks for equality with the object’s `checkedTechcentre` field. */
  checkedTechcentre?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `closed` field. */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `closedOld` field. */
  closedOld?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `destroyed` field. */
  destroyed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `extraWork` field. */
  extraWork?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filename` field. */
  filename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maintenance` field. */
  maintenance?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `other` field. */
  other?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `repair` field. */
  repair?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `startup` field. */
  startup?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `tsrNumber` field. */
  tsrNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `version` field. */
  version?: InputMaybe<Scalars['String']['input']>;
};

export type ReportDetector = Node & {
  __typename?: 'ReportDetector';
  /** Reads a single `Detector` that is related to this `ReportDetector`. */
  detectorByDetectorId?: Maybe<Detector>;
  detectorId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Report` that is related to this `ReportDetector`. */
  reportByReportId?: Maybe<Report>;
  reportId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `ReportDetector` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ReportDetectorCondition = {
  /** Checks for equality with the object’s `detectorId` field. */
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reportId` field. */
  reportId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ReportDetector` object types. All fields are combined with a logical ‘and.’ */
export type ReportDetectorFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReportDetectorFilter>>;
  /** Filter by the object’s `detectorByDetectorId` relation. */
  detectorByDetectorId?: InputMaybe<DetectorFilter>;
  /** A related `detectorByDetectorId` exists. */
  detectorByDetectorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorId` field. */
  detectorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReportDetectorFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReportDetectorFilter>>;
  /** Filter by the object’s `reportByReportId` relation. */
  reportByReportId?: InputMaybe<ReportFilter>;
  /** A related `reportByReportId` exists. */
  reportByReportIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reportId` field. */
  reportId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ReportDetector` */
export type ReportDetectorInput = {
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reportId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `ReportDetector`. Fields that are set will be updated. */
export type ReportDetectorPatch = {
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reportId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ReportDetector` values. */
export type ReportDetectorsConnection = {
  __typename?: 'ReportDetectorsConnection';
  /** A list of edges which contains the `ReportDetector` and cursor to aid in pagination. */
  edges: Array<ReportDetectorsEdge>;
  /** A list of `ReportDetector` objects. */
  nodes: Array<ReportDetector>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReportDetector` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReportDetector` edge in the connection. */
export type ReportDetectorsEdge = {
  __typename?: 'ReportDetectorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReportDetector` at the end of the edge. */
  node: ReportDetector;
};

/** Methods to use when ordering `ReportDetector`. */
export enum ReportDetectorsOrderBy {
  DetectorByDetectorIdCreatedAsc = 'DETECTOR_BY_DETECTOR_ID__CREATED_ASC',
  DetectorByDetectorIdCreatedDesc = 'DETECTOR_BY_DETECTOR_ID__CREATED_DESC',
  DetectorByDetectorIdDetectorTypeIdAsc = 'DETECTOR_BY_DETECTOR_ID__DETECTOR_TYPE_ID_ASC',
  DetectorByDetectorIdDetectorTypeIdDesc = 'DETECTOR_BY_DETECTOR_ID__DETECTOR_TYPE_ID_DESC',
  DetectorByDetectorIdIdAsc = 'DETECTOR_BY_DETECTOR_ID__ID_ASC',
  DetectorByDetectorIdIdDesc = 'DETECTOR_BY_DETECTOR_ID__ID_DESC',
  DetectorByDetectorIdLabelDateAsc = 'DETECTOR_BY_DETECTOR_ID__LABEL_DATE_ASC',
  DetectorByDetectorIdLabelDateDesc = 'DETECTOR_BY_DETECTOR_ID__LABEL_DATE_DESC',
  DetectorByDetectorIdModifiedAsc = 'DETECTOR_BY_DETECTOR_ID__MODIFIED_ASC',
  DetectorByDetectorIdModifiedDesc = 'DETECTOR_BY_DETECTOR_ID__MODIFIED_DESC',
  DetectorByDetectorIdOwnerIdAsc = 'DETECTOR_BY_DETECTOR_ID__OWNER_ID_ASC',
  DetectorByDetectorIdOwnerIdDesc = 'DETECTOR_BY_DETECTOR_ID__OWNER_ID_DESC',
  DetectorByDetectorIdRemarksAsc = 'DETECTOR_BY_DETECTOR_ID__REMARKS_ASC',
  DetectorByDetectorIdRemarksDesc = 'DETECTOR_BY_DETECTOR_ID__REMARKS_DESC',
  DetectorByDetectorIdSerialNumberAsc = 'DETECTOR_BY_DETECTOR_ID__SERIAL_NUMBER_ASC',
  DetectorByDetectorIdSerialNumberDesc = 'DETECTOR_BY_DETECTOR_ID__SERIAL_NUMBER_DESC',
  DetectorIdAsc = 'DETECTOR_ID_ASC',
  DetectorIdDesc = 'DETECTOR_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReportByReportIdCheckedTechcentreAsc = 'REPORT_BY_REPORT_ID__CHECKED_TECHCENTRE_ASC',
  ReportByReportIdCheckedTechcentreDesc = 'REPORT_BY_REPORT_ID__CHECKED_TECHCENTRE_DESC',
  ReportByReportIdClosedAsc = 'REPORT_BY_REPORT_ID__CLOSED_ASC',
  ReportByReportIdClosedDesc = 'REPORT_BY_REPORT_ID__CLOSED_DESC',
  ReportByReportIdClosedOldAsc = 'REPORT_BY_REPORT_ID__CLOSED_OLD_ASC',
  ReportByReportIdClosedOldDesc = 'REPORT_BY_REPORT_ID__CLOSED_OLD_DESC',
  ReportByReportIdCreatedAsc = 'REPORT_BY_REPORT_ID__CREATED_ASC',
  ReportByReportIdCreatedDesc = 'REPORT_BY_REPORT_ID__CREATED_DESC',
  ReportByReportIdDateAsc = 'REPORT_BY_REPORT_ID__DATE_ASC',
  ReportByReportIdDateDesc = 'REPORT_BY_REPORT_ID__DATE_DESC',
  ReportByReportIdDestroyedAsc = 'REPORT_BY_REPORT_ID__DESTROYED_ASC',
  ReportByReportIdDestroyedDesc = 'REPORT_BY_REPORT_ID__DESTROYED_DESC',
  ReportByReportIdEndUserIdAsc = 'REPORT_BY_REPORT_ID__END_USER_ID_ASC',
  ReportByReportIdEndUserIdDesc = 'REPORT_BY_REPORT_ID__END_USER_ID_DESC',
  ReportByReportIdExtraWorkAsc = 'REPORT_BY_REPORT_ID__EXTRA_WORK_ASC',
  ReportByReportIdExtraWorkDesc = 'REPORT_BY_REPORT_ID__EXTRA_WORK_DESC',
  ReportByReportIdFactuuropdrachtAsc = 'REPORT_BY_REPORT_ID__FACTUUROPDRACHT_ASC',
  ReportByReportIdFactuuropdrachtDesc = 'REPORT_BY_REPORT_ID__FACTUUROPDRACHT_DESC',
  ReportByReportIdFilenameAsc = 'REPORT_BY_REPORT_ID__FILENAME_ASC',
  ReportByReportIdFilenameDesc = 'REPORT_BY_REPORT_ID__FILENAME_DESC',
  ReportByReportIdIdAsc = 'REPORT_BY_REPORT_ID__ID_ASC',
  ReportByReportIdIdDesc = 'REPORT_BY_REPORT_ID__ID_DESC',
  ReportByReportIdMaintenanceAsc = 'REPORT_BY_REPORT_ID__MAINTENANCE_ASC',
  ReportByReportIdMaintenanceDesc = 'REPORT_BY_REPORT_ID__MAINTENANCE_DESC',
  ReportByReportIdModifiedAsc = 'REPORT_BY_REPORT_ID__MODIFIED_ASC',
  ReportByReportIdModifiedDesc = 'REPORT_BY_REPORT_ID__MODIFIED_DESC',
  ReportByReportIdOtherAsc = 'REPORT_BY_REPORT_ID__OTHER_ASC',
  ReportByReportIdOtherDesc = 'REPORT_BY_REPORT_ID__OTHER_DESC',
  ReportByReportIdOwnerIdAsc = 'REPORT_BY_REPORT_ID__OWNER_ID_ASC',
  ReportByReportIdOwnerIdDesc = 'REPORT_BY_REPORT_ID__OWNER_ID_DESC',
  ReportByReportIdRemarksAsc = 'REPORT_BY_REPORT_ID__REMARKS_ASC',
  ReportByReportIdRemarksDesc = 'REPORT_BY_REPORT_ID__REMARKS_DESC',
  ReportByReportIdRepairAsc = 'REPORT_BY_REPORT_ID__REPAIR_ASC',
  ReportByReportIdRepairDesc = 'REPORT_BY_REPORT_ID__REPAIR_DESC',
  ReportByReportIdStartupAsc = 'REPORT_BY_REPORT_ID__STARTUP_ASC',
  ReportByReportIdStartupDesc = 'REPORT_BY_REPORT_ID__STARTUP_DESC',
  ReportByReportIdTsrNumberAsc = 'REPORT_BY_REPORT_ID__TSR_NUMBER_ASC',
  ReportByReportIdTsrNumberDesc = 'REPORT_BY_REPORT_ID__TSR_NUMBER_DESC',
  ReportByReportIdTypeAsc = 'REPORT_BY_REPORT_ID__TYPE_ASC',
  ReportByReportIdTypeDesc = 'REPORT_BY_REPORT_ID__TYPE_DESC',
  ReportByReportIdUserIdAsc = 'REPORT_BY_REPORT_ID__USER_ID_ASC',
  ReportByReportIdUserIdDesc = 'REPORT_BY_REPORT_ID__USER_ID_DESC',
  ReportByReportIdVersionAsc = 'REPORT_BY_REPORT_ID__VERSION_ASC',
  ReportByReportIdVersionDesc = 'REPORT_BY_REPORT_ID__VERSION_DESC',
  ReportIdAsc = 'REPORT_ID_ASC',
  ReportIdDesc = 'REPORT_ID_DESC'
}

/** A filter to be used against `Report` object types. All fields are combined with a logical ‘and.’ */
export type ReportFilter = {
  /** Filter by the object’s `actionsByReportId` relation. */
  actionsByReportId?: InputMaybe<ReportToManyActionFilter>;
  /** Some related `actionsByReportId` exist. */
  actionsByReportIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReportFilter>>;
  /** Filter by the object’s `checkedTechcentre` field. */
  checkedTechcentre?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `closed` field. */
  closed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `closedOld` field. */
  closedOld?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Filter by the object’s `destroyed` field. */
  destroyed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `endUserByEndUserId` relation. */
  endUserByEndUserId?: InputMaybe<EndUserFilter>;
  /** A related `endUserByEndUserId` exists. */
  endUserByEndUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `extraWork` field. */
  extraWork?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filename` field. */
  filename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenance` field. */
  maintenance?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReportFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReportFilter>>;
  /** Filter by the object’s `other` field. */
  other?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `repair` field. */
  repair?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `reportDetectorsByReportId` relation. */
  reportDetectorsByReportId?: InputMaybe<ReportToManyReportDetectorFilter>;
  /** Some related `reportDetectorsByReportId` exist. */
  reportDetectorsByReportIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reportItemsByReportId` relation. */
  reportItemsByReportId?: InputMaybe<ReportToManyReportItemFilter>;
  /** Some related `reportItemsByReportId` exist. */
  reportItemsByReportIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reportSensorsByReportId` relation. */
  reportSensorsByReportId?: InputMaybe<ReportToManyReportSensorFilter>;
  /** Some related `reportSensorsByReportId` exist. */
  reportSensorsByReportIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `startup` field. */
  startup?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `tsrNumber` field. */
  tsrNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `version` field. */
  version?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Report` */
export type ReportInput = {
  checkedTechcentre?: InputMaybe<Scalars['Boolean']['input']>;
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  closedOld?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  destroyed?: InputMaybe<Scalars['Boolean']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  extraWork?: InputMaybe<Scalars['Boolean']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  maintenance?: InputMaybe<Scalars['Boolean']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  other?: InputMaybe<Scalars['Boolean']['input']>;
  ownerId: Scalars['Int']['input'];
  remarks?: InputMaybe<Scalars['String']['input']>;
  repair?: InputMaybe<Scalars['Boolean']['input']>;
  startup?: InputMaybe<Scalars['Boolean']['input']>;
  tsrNumber?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
  userId: Scalars['Int']['input'];
  version?: InputMaybe<Scalars['String']['input']>;
};

export type ReportItem = Node & {
  __typename?: 'ReportItem';
  id: Scalars['Int']['output'];
  /** Reads a single `Item` that is related to this `ReportItem`. */
  itemByItemId?: Maybe<Item>;
  itemId: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Report` that is related to this `ReportItem`. */
  reportByReportId?: Maybe<Report>;
  reportId: Scalars['Int']['output'];
};

/**
 * A condition to be used against `ReportItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ReportItemCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `itemId` field. */
  itemId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reportId` field. */
  reportId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ReportItem` object types. All fields are combined with a logical ‘and.’ */
export type ReportItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReportItemFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `itemByItemId` relation. */
  itemByItemId?: InputMaybe<ItemFilter>;
  /** Filter by the object’s `itemId` field. */
  itemId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReportItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReportItemFilter>>;
  /** Filter by the object’s `reportByReportId` relation. */
  reportByReportId?: InputMaybe<ReportFilter>;
  /** Filter by the object’s `reportId` field. */
  reportId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ReportItem` */
export type ReportItemInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  itemId: Scalars['Int']['input'];
  reportId: Scalars['Int']['input'];
};

/** Represents an update to a `ReportItem`. Fields that are set will be updated. */
export type ReportItemPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  itemId?: InputMaybe<Scalars['Int']['input']>;
  reportId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ReportItem` values. */
export type ReportItemsConnection = {
  __typename?: 'ReportItemsConnection';
  /** A list of edges which contains the `ReportItem` and cursor to aid in pagination. */
  edges: Array<ReportItemsEdge>;
  /** A list of `ReportItem` objects. */
  nodes: Array<ReportItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReportItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReportItem` edge in the connection. */
export type ReportItemsEdge = {
  __typename?: 'ReportItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReportItem` at the end of the edge. */
  node: ReportItem;
};

/** Methods to use when ordering `ReportItem`. */
export enum ReportItemsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ItemByItemIdCdartikelAsc = 'ITEM_BY_ITEM_ID__CDARTIKEL_ASC',
  ItemByItemIdCdartikelDesc = 'ITEM_BY_ITEM_ID__CDARTIKEL_DESC',
  ItemByItemIdCreatedAsc = 'ITEM_BY_ITEM_ID__CREATED_ASC',
  ItemByItemIdCreatedDesc = 'ITEM_BY_ITEM_ID__CREATED_DESC',
  ItemByItemIdEndUserIdAsc = 'ITEM_BY_ITEM_ID__END_USER_ID_ASC',
  ItemByItemIdEndUserIdDesc = 'ITEM_BY_ITEM_ID__END_USER_ID_DESC',
  ItemByItemIdIdAsc = 'ITEM_BY_ITEM_ID__ID_ASC',
  ItemByItemIdIdDesc = 'ITEM_BY_ITEM_ID__ID_DESC',
  ItemByItemIdLabelDateAsc = 'ITEM_BY_ITEM_ID__LABEL_DATE_ASC',
  ItemByItemIdLabelDateDesc = 'ITEM_BY_ITEM_ID__LABEL_DATE_DESC',
  ItemByItemIdModifiedAsc = 'ITEM_BY_ITEM_ID__MODIFIED_ASC',
  ItemByItemIdModifiedDesc = 'ITEM_BY_ITEM_ID__MODIFIED_DESC',
  ItemByItemIdOwnerIdAsc = 'ITEM_BY_ITEM_ID__OWNER_ID_ASC',
  ItemByItemIdOwnerIdDesc = 'ITEM_BY_ITEM_ID__OWNER_ID_DESC',
  ItemByItemIdRemarksAsc = 'ITEM_BY_ITEM_ID__REMARKS_ASC',
  ItemByItemIdRemarksDesc = 'ITEM_BY_ITEM_ID__REMARKS_DESC',
  ItemByItemIdSerialNumberAsc = 'ITEM_BY_ITEM_ID__SERIAL_NUMBER_ASC',
  ItemByItemIdSerialNumberDesc = 'ITEM_BY_ITEM_ID__SERIAL_NUMBER_DESC',
  ItemIdAsc = 'ITEM_ID_ASC',
  ItemIdDesc = 'ITEM_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReportByReportIdCheckedTechcentreAsc = 'REPORT_BY_REPORT_ID__CHECKED_TECHCENTRE_ASC',
  ReportByReportIdCheckedTechcentreDesc = 'REPORT_BY_REPORT_ID__CHECKED_TECHCENTRE_DESC',
  ReportByReportIdClosedAsc = 'REPORT_BY_REPORT_ID__CLOSED_ASC',
  ReportByReportIdClosedDesc = 'REPORT_BY_REPORT_ID__CLOSED_DESC',
  ReportByReportIdClosedOldAsc = 'REPORT_BY_REPORT_ID__CLOSED_OLD_ASC',
  ReportByReportIdClosedOldDesc = 'REPORT_BY_REPORT_ID__CLOSED_OLD_DESC',
  ReportByReportIdCreatedAsc = 'REPORT_BY_REPORT_ID__CREATED_ASC',
  ReportByReportIdCreatedDesc = 'REPORT_BY_REPORT_ID__CREATED_DESC',
  ReportByReportIdDateAsc = 'REPORT_BY_REPORT_ID__DATE_ASC',
  ReportByReportIdDateDesc = 'REPORT_BY_REPORT_ID__DATE_DESC',
  ReportByReportIdDestroyedAsc = 'REPORT_BY_REPORT_ID__DESTROYED_ASC',
  ReportByReportIdDestroyedDesc = 'REPORT_BY_REPORT_ID__DESTROYED_DESC',
  ReportByReportIdEndUserIdAsc = 'REPORT_BY_REPORT_ID__END_USER_ID_ASC',
  ReportByReportIdEndUserIdDesc = 'REPORT_BY_REPORT_ID__END_USER_ID_DESC',
  ReportByReportIdExtraWorkAsc = 'REPORT_BY_REPORT_ID__EXTRA_WORK_ASC',
  ReportByReportIdExtraWorkDesc = 'REPORT_BY_REPORT_ID__EXTRA_WORK_DESC',
  ReportByReportIdFactuuropdrachtAsc = 'REPORT_BY_REPORT_ID__FACTUUROPDRACHT_ASC',
  ReportByReportIdFactuuropdrachtDesc = 'REPORT_BY_REPORT_ID__FACTUUROPDRACHT_DESC',
  ReportByReportIdFilenameAsc = 'REPORT_BY_REPORT_ID__FILENAME_ASC',
  ReportByReportIdFilenameDesc = 'REPORT_BY_REPORT_ID__FILENAME_DESC',
  ReportByReportIdIdAsc = 'REPORT_BY_REPORT_ID__ID_ASC',
  ReportByReportIdIdDesc = 'REPORT_BY_REPORT_ID__ID_DESC',
  ReportByReportIdMaintenanceAsc = 'REPORT_BY_REPORT_ID__MAINTENANCE_ASC',
  ReportByReportIdMaintenanceDesc = 'REPORT_BY_REPORT_ID__MAINTENANCE_DESC',
  ReportByReportIdModifiedAsc = 'REPORT_BY_REPORT_ID__MODIFIED_ASC',
  ReportByReportIdModifiedDesc = 'REPORT_BY_REPORT_ID__MODIFIED_DESC',
  ReportByReportIdOtherAsc = 'REPORT_BY_REPORT_ID__OTHER_ASC',
  ReportByReportIdOtherDesc = 'REPORT_BY_REPORT_ID__OTHER_DESC',
  ReportByReportIdOwnerIdAsc = 'REPORT_BY_REPORT_ID__OWNER_ID_ASC',
  ReportByReportIdOwnerIdDesc = 'REPORT_BY_REPORT_ID__OWNER_ID_DESC',
  ReportByReportIdRemarksAsc = 'REPORT_BY_REPORT_ID__REMARKS_ASC',
  ReportByReportIdRemarksDesc = 'REPORT_BY_REPORT_ID__REMARKS_DESC',
  ReportByReportIdRepairAsc = 'REPORT_BY_REPORT_ID__REPAIR_ASC',
  ReportByReportIdRepairDesc = 'REPORT_BY_REPORT_ID__REPAIR_DESC',
  ReportByReportIdStartupAsc = 'REPORT_BY_REPORT_ID__STARTUP_ASC',
  ReportByReportIdStartupDesc = 'REPORT_BY_REPORT_ID__STARTUP_DESC',
  ReportByReportIdTsrNumberAsc = 'REPORT_BY_REPORT_ID__TSR_NUMBER_ASC',
  ReportByReportIdTsrNumberDesc = 'REPORT_BY_REPORT_ID__TSR_NUMBER_DESC',
  ReportByReportIdTypeAsc = 'REPORT_BY_REPORT_ID__TYPE_ASC',
  ReportByReportIdTypeDesc = 'REPORT_BY_REPORT_ID__TYPE_DESC',
  ReportByReportIdUserIdAsc = 'REPORT_BY_REPORT_ID__USER_ID_ASC',
  ReportByReportIdUserIdDesc = 'REPORT_BY_REPORT_ID__USER_ID_DESC',
  ReportByReportIdVersionAsc = 'REPORT_BY_REPORT_ID__VERSION_ASC',
  ReportByReportIdVersionDesc = 'REPORT_BY_REPORT_ID__VERSION_DESC',
  ReportIdAsc = 'REPORT_ID_ASC',
  ReportIdDesc = 'REPORT_ID_DESC'
}

export type ReportList = {
  __typename?: 'ReportList';
  endUserId?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  label?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ReportList` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ReportListCondition = {
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ReportList` object types. All fields are combined with a logical ‘and.’ */
export type ReportListFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReportListFilter>>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReportListFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReportListFilter>>;
};

/** A connection to a list of `ReportList` values. */
export type ReportListsConnection = {
  __typename?: 'ReportListsConnection';
  /** A list of edges which contains the `ReportList` and cursor to aid in pagination. */
  edges: Array<ReportListsEdge>;
  /** A list of `ReportList` objects. */
  nodes: Array<ReportList>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReportList` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReportList` edge in the connection. */
export type ReportListsEdge = {
  __typename?: 'ReportListsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReportList` at the end of the edge. */
  node: ReportList;
};

/** Methods to use when ordering `ReportList`. */
export enum ReportListsOrderBy {
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  Natural = 'NATURAL'
}

/** Represents an update to a `Report`. Fields that are set will be updated. */
export type ReportPatch = {
  checkedTechcentre?: InputMaybe<Scalars['Boolean']['input']>;
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  closedOld?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  destroyed?: InputMaybe<Scalars['Boolean']['input']>;
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  extraWork?: InputMaybe<Scalars['Boolean']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  maintenance?: InputMaybe<Scalars['Boolean']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  other?: InputMaybe<Scalars['Boolean']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  repair?: InputMaybe<Scalars['Boolean']['input']>;
  startup?: InputMaybe<Scalars['Boolean']['input']>;
  tsrNumber?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

export type ReportSensor = Node & {
  __typename?: 'ReportSensor';
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Report` that is related to this `ReportSensor`. */
  reportByReportId?: Maybe<Report>;
  reportId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Sensor` that is related to this `ReportSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
  sensorId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `ReportSensor` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ReportSensorCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reportId` field. */
  reportId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ReportSensor` object types. All fields are combined with a logical ‘and.’ */
export type ReportSensorFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReportSensorFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReportSensorFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReportSensorFilter>>;
  /** Filter by the object’s `reportByReportId` relation. */
  reportByReportId?: InputMaybe<ReportFilter>;
  /** A related `reportByReportId` exists. */
  reportByReportIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reportId` field. */
  reportId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorBySensorId` relation. */
  sensorBySensorId?: InputMaybe<SensorFilter>;
  /** A related `sensorBySensorId` exists. */
  sensorBySensorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ReportSensor` */
export type ReportSensorInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  reportId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `ReportSensor`. Fields that are set will be updated. */
export type ReportSensorPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  reportId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ReportSensor` values. */
export type ReportSensorsConnection = {
  __typename?: 'ReportSensorsConnection';
  /** A list of edges which contains the `ReportSensor` and cursor to aid in pagination. */
  edges: Array<ReportSensorsEdge>;
  /** A list of `ReportSensor` objects. */
  nodes: Array<ReportSensor>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReportSensor` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReportSensor` edge in the connection. */
export type ReportSensorsEdge = {
  __typename?: 'ReportSensorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReportSensor` at the end of the edge. */
  node: ReportSensor;
};

/** Methods to use when ordering `ReportSensor`. */
export enum ReportSensorsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReportByReportIdCheckedTechcentreAsc = 'REPORT_BY_REPORT_ID__CHECKED_TECHCENTRE_ASC',
  ReportByReportIdCheckedTechcentreDesc = 'REPORT_BY_REPORT_ID__CHECKED_TECHCENTRE_DESC',
  ReportByReportIdClosedAsc = 'REPORT_BY_REPORT_ID__CLOSED_ASC',
  ReportByReportIdClosedDesc = 'REPORT_BY_REPORT_ID__CLOSED_DESC',
  ReportByReportIdClosedOldAsc = 'REPORT_BY_REPORT_ID__CLOSED_OLD_ASC',
  ReportByReportIdClosedOldDesc = 'REPORT_BY_REPORT_ID__CLOSED_OLD_DESC',
  ReportByReportIdCreatedAsc = 'REPORT_BY_REPORT_ID__CREATED_ASC',
  ReportByReportIdCreatedDesc = 'REPORT_BY_REPORT_ID__CREATED_DESC',
  ReportByReportIdDateAsc = 'REPORT_BY_REPORT_ID__DATE_ASC',
  ReportByReportIdDateDesc = 'REPORT_BY_REPORT_ID__DATE_DESC',
  ReportByReportIdDestroyedAsc = 'REPORT_BY_REPORT_ID__DESTROYED_ASC',
  ReportByReportIdDestroyedDesc = 'REPORT_BY_REPORT_ID__DESTROYED_DESC',
  ReportByReportIdEndUserIdAsc = 'REPORT_BY_REPORT_ID__END_USER_ID_ASC',
  ReportByReportIdEndUserIdDesc = 'REPORT_BY_REPORT_ID__END_USER_ID_DESC',
  ReportByReportIdExtraWorkAsc = 'REPORT_BY_REPORT_ID__EXTRA_WORK_ASC',
  ReportByReportIdExtraWorkDesc = 'REPORT_BY_REPORT_ID__EXTRA_WORK_DESC',
  ReportByReportIdFactuuropdrachtAsc = 'REPORT_BY_REPORT_ID__FACTUUROPDRACHT_ASC',
  ReportByReportIdFactuuropdrachtDesc = 'REPORT_BY_REPORT_ID__FACTUUROPDRACHT_DESC',
  ReportByReportIdFilenameAsc = 'REPORT_BY_REPORT_ID__FILENAME_ASC',
  ReportByReportIdFilenameDesc = 'REPORT_BY_REPORT_ID__FILENAME_DESC',
  ReportByReportIdIdAsc = 'REPORT_BY_REPORT_ID__ID_ASC',
  ReportByReportIdIdDesc = 'REPORT_BY_REPORT_ID__ID_DESC',
  ReportByReportIdMaintenanceAsc = 'REPORT_BY_REPORT_ID__MAINTENANCE_ASC',
  ReportByReportIdMaintenanceDesc = 'REPORT_BY_REPORT_ID__MAINTENANCE_DESC',
  ReportByReportIdModifiedAsc = 'REPORT_BY_REPORT_ID__MODIFIED_ASC',
  ReportByReportIdModifiedDesc = 'REPORT_BY_REPORT_ID__MODIFIED_DESC',
  ReportByReportIdOtherAsc = 'REPORT_BY_REPORT_ID__OTHER_ASC',
  ReportByReportIdOtherDesc = 'REPORT_BY_REPORT_ID__OTHER_DESC',
  ReportByReportIdOwnerIdAsc = 'REPORT_BY_REPORT_ID__OWNER_ID_ASC',
  ReportByReportIdOwnerIdDesc = 'REPORT_BY_REPORT_ID__OWNER_ID_DESC',
  ReportByReportIdRemarksAsc = 'REPORT_BY_REPORT_ID__REMARKS_ASC',
  ReportByReportIdRemarksDesc = 'REPORT_BY_REPORT_ID__REMARKS_DESC',
  ReportByReportIdRepairAsc = 'REPORT_BY_REPORT_ID__REPAIR_ASC',
  ReportByReportIdRepairDesc = 'REPORT_BY_REPORT_ID__REPAIR_DESC',
  ReportByReportIdStartupAsc = 'REPORT_BY_REPORT_ID__STARTUP_ASC',
  ReportByReportIdStartupDesc = 'REPORT_BY_REPORT_ID__STARTUP_DESC',
  ReportByReportIdTsrNumberAsc = 'REPORT_BY_REPORT_ID__TSR_NUMBER_ASC',
  ReportByReportIdTsrNumberDesc = 'REPORT_BY_REPORT_ID__TSR_NUMBER_DESC',
  ReportByReportIdTypeAsc = 'REPORT_BY_REPORT_ID__TYPE_ASC',
  ReportByReportIdTypeDesc = 'REPORT_BY_REPORT_ID__TYPE_DESC',
  ReportByReportIdUserIdAsc = 'REPORT_BY_REPORT_ID__USER_ID_ASC',
  ReportByReportIdUserIdDesc = 'REPORT_BY_REPORT_ID__USER_ID_DESC',
  ReportByReportIdVersionAsc = 'REPORT_BY_REPORT_ID__VERSION_ASC',
  ReportByReportIdVersionDesc = 'REPORT_BY_REPORT_ID__VERSION_DESC',
  ReportIdAsc = 'REPORT_ID_ASC',
  ReportIdDesc = 'REPORT_ID_DESC',
  SensorBySensorIdCreatedAsc = 'SENSOR_BY_SENSOR_ID__CREATED_ASC',
  SensorBySensorIdCreatedDesc = 'SENSOR_BY_SENSOR_ID__CREATED_DESC',
  SensorBySensorIdIdAsc = 'SENSOR_BY_SENSOR_ID__ID_ASC',
  SensorBySensorIdIdDesc = 'SENSOR_BY_SENSOR_ID__ID_DESC',
  SensorBySensorIdLabelDateAsc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_ASC',
  SensorBySensorIdLabelDateDesc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_DESC',
  SensorBySensorIdModifiedAsc = 'SENSOR_BY_SENSOR_ID__MODIFIED_ASC',
  SensorBySensorIdModifiedDesc = 'SENSOR_BY_SENSOR_ID__MODIFIED_DESC',
  SensorBySensorIdOwnerIdAsc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_ASC',
  SensorBySensorIdOwnerIdDesc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_DESC',
  SensorBySensorIdRemarksAsc = 'SENSOR_BY_SENSOR_ID__REMARKS_ASC',
  SensorBySensorIdRemarksDesc = 'SENSOR_BY_SENSOR_ID__REMARKS_DESC',
  SensorBySensorIdSensorTypeIdAsc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_ASC',
  SensorBySensorIdSensorTypeIdDesc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_DESC',
  SensorBySensorIdSerialNumberAsc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_ASC',
  SensorBySensorIdSerialNumberDesc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC'
}

/** A filter to be used against many `Action` object types. All fields are combined with a logical ‘and.’ */
export type ReportToManyActionFilter = {
  /** Every related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionFilter>;
  /** No related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionFilter>;
  /** Some related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionFilter>;
};

/** A filter to be used against many `ReportDetector` object types. All fields are combined with a logical ‘and.’ */
export type ReportToManyReportDetectorFilter = {
  /** Every related `ReportDetector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReportDetectorFilter>;
  /** No related `ReportDetector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReportDetectorFilter>;
  /** Some related `ReportDetector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReportDetectorFilter>;
};

/** A filter to be used against many `ReportItem` object types. All fields are combined with a logical ‘and.’ */
export type ReportToManyReportItemFilter = {
  /** Every related `ReportItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReportItemFilter>;
  /** No related `ReportItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReportItemFilter>;
  /** Some related `ReportItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReportItemFilter>;
};

/** A filter to be used against many `ReportSensor` object types. All fields are combined with a logical ‘and.’ */
export type ReportToManyReportSensorFilter = {
  /** Every related `ReportSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReportSensorFilter>;
  /** No related `ReportSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReportSensorFilter>;
  /** Some related `ReportSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReportSensorFilter>;
};

/** A connection to a list of `Report` values. */
export type ReportsConnection = {
  __typename?: 'ReportsConnection';
  /** A list of edges which contains the `Report` and cursor to aid in pagination. */
  edges: Array<ReportsEdge>;
  /** A list of `Report` objects. */
  nodes: Array<Report>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Report` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Report` edge in the connection. */
export type ReportsEdge = {
  __typename?: 'ReportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Report` at the end of the edge. */
  node: Report;
};

/** Methods to use when ordering `Report`. */
export enum ReportsOrderBy {
  ActionsByReportIdCountAsc = 'ACTIONS_BY_REPORT_ID__COUNT_ASC',
  ActionsByReportIdCountDesc = 'ACTIONS_BY_REPORT_ID__COUNT_DESC',
  CheckedTechcentreAsc = 'CHECKED_TECHCENTRE_ASC',
  CheckedTechcentreDesc = 'CHECKED_TECHCENTRE_DESC',
  ClosedAsc = 'CLOSED_ASC',
  ClosedDesc = 'CLOSED_DESC',
  ClosedOldAsc = 'CLOSED_OLD_ASC',
  ClosedOldDesc = 'CLOSED_OLD_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DestroyedAsc = 'DESTROYED_ASC',
  DestroyedDesc = 'DESTROYED_DESC',
  EndUserByEndUserIdAddress1Asc = 'END_USER_BY_END_USER_ID__ADDRESS1_ASC',
  EndUserByEndUserIdAddress1Desc = 'END_USER_BY_END_USER_ID__ADDRESS1_DESC',
  EndUserByEndUserIdAddress2Asc = 'END_USER_BY_END_USER_ID__ADDRESS2_ASC',
  EndUserByEndUserIdAddress2Desc = 'END_USER_BY_END_USER_ID__ADDRESS2_DESC',
  EndUserByEndUserIdCityAsc = 'END_USER_BY_END_USER_ID__CITY_ASC',
  EndUserByEndUserIdCityDesc = 'END_USER_BY_END_USER_ID__CITY_DESC',
  EndUserByEndUserIdContactEmailAsc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_ASC',
  EndUserByEndUserIdContactEmailDesc = 'END_USER_BY_END_USER_ID__CONTACT_EMAIL_DESC',
  EndUserByEndUserIdContactNameAsc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_ASC',
  EndUserByEndUserIdContactNameDesc = 'END_USER_BY_END_USER_ID__CONTACT_NAME_DESC',
  EndUserByEndUserIdContactPhoneAsc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_ASC',
  EndUserByEndUserIdContactPhoneDesc = 'END_USER_BY_END_USER_ID__CONTACT_PHONE_DESC',
  EndUserByEndUserIdCountryAsc = 'END_USER_BY_END_USER_ID__COUNTRY_ASC',
  EndUserByEndUserIdCountryDesc = 'END_USER_BY_END_USER_ID__COUNTRY_DESC',
  EndUserByEndUserIdCreatedAsc = 'END_USER_BY_END_USER_ID__CREATED_ASC',
  EndUserByEndUserIdCreatedDesc = 'END_USER_BY_END_USER_ID__CREATED_DESC',
  EndUserByEndUserIdFormerName1Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_ASC',
  EndUserByEndUserIdFormerName1Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME1_DESC',
  EndUserByEndUserIdFormerName2Asc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_ASC',
  EndUserByEndUserIdFormerName2Desc = 'END_USER_BY_END_USER_ID__FORMER_NAME2_DESC',
  EndUserByEndUserIdIdAsc = 'END_USER_BY_END_USER_ID__ID_ASC',
  EndUserByEndUserIdIdDesc = 'END_USER_BY_END_USER_ID__ID_DESC',
  EndUserByEndUserIdLocationAsc = 'END_USER_BY_END_USER_ID__LOCATION_ASC',
  EndUserByEndUserIdLocationDesc = 'END_USER_BY_END_USER_ID__LOCATION_DESC',
  EndUserByEndUserIdModifiedAsc = 'END_USER_BY_END_USER_ID__MODIFIED_ASC',
  EndUserByEndUserIdModifiedDesc = 'END_USER_BY_END_USER_ID__MODIFIED_DESC',
  EndUserByEndUserIdNameAsc = 'END_USER_BY_END_USER_ID__NAME_ASC',
  EndUserByEndUserIdNameDesc = 'END_USER_BY_END_USER_ID__NAME_DESC',
  EndUserByEndUserIdOwnerIdAsc = 'END_USER_BY_END_USER_ID__OWNER_ID_ASC',
  EndUserByEndUserIdOwnerIdDesc = 'END_USER_BY_END_USER_ID__OWNER_ID_DESC',
  EndUserByEndUserIdRegionAsc = 'END_USER_BY_END_USER_ID__REGION_ASC',
  EndUserByEndUserIdRegionDesc = 'END_USER_BY_END_USER_ID__REGION_DESC',
  EndUserByEndUserIdSubLocationAsc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_ASC',
  EndUserByEndUserIdSubLocationDesc = 'END_USER_BY_END_USER_ID__SUB_LOCATION_DESC',
  EndUserByEndUserIdZipCodeAsc = 'END_USER_BY_END_USER_ID__ZIP_CODE_ASC',
  EndUserByEndUserIdZipCodeDesc = 'END_USER_BY_END_USER_ID__ZIP_CODE_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  ExtraWorkAsc = 'EXTRA_WORK_ASC',
  ExtraWorkDesc = 'EXTRA_WORK_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FilenameAsc = 'FILENAME_ASC',
  FilenameDesc = 'FILENAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceAsc = 'MAINTENANCE_ASC',
  MaintenanceDesc = 'MAINTENANCE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OtherAsc = 'OTHER_ASC',
  OtherDesc = 'OTHER_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  RepairAsc = 'REPAIR_ASC',
  RepairDesc = 'REPAIR_DESC',
  ReportDetectorsByReportIdCountAsc = 'REPORT_DETECTORS_BY_REPORT_ID__COUNT_ASC',
  ReportDetectorsByReportIdCountDesc = 'REPORT_DETECTORS_BY_REPORT_ID__COUNT_DESC',
  ReportItemsByReportIdCountAsc = 'REPORT_ITEMS_BY_REPORT_ID__COUNT_ASC',
  ReportItemsByReportIdCountDesc = 'REPORT_ITEMS_BY_REPORT_ID__COUNT_DESC',
  ReportSensorsByReportIdCountAsc = 'REPORT_SENSORS_BY_REPORT_ID__COUNT_ASC',
  ReportSensorsByReportIdCountDesc = 'REPORT_SENSORS_BY_REPORT_ID__COUNT_DESC',
  StartupAsc = 'STARTUP_ASC',
  StartupDesc = 'STARTUP_DESC',
  TsrNumberAsc = 'TSR_NUMBER_ASC',
  TsrNumberDesc = 'TSR_NUMBER_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  VersionAsc = 'VERSION_ASC',
  VersionDesc = 'VERSION_DESC'
}

export type Request = Node & {
  __typename?: 'Request';
  completed?: Maybe<Scalars['Boolean']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  request?: Maybe<Scalars['String']['output']>;
  tableName?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `Request`. */
  userByOwnerId?: Maybe<User>;
};

/** A condition to be used against `Request` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RequestCondition = {
  /** Checks for equality with the object’s `completed` field. */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `request` field. */
  request?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Request` object types. All fields are combined with a logical ‘and.’ */
export type RequestFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RequestFilter>>;
  /** Filter by the object’s `completed` field. */
  completed?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RequestFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RequestFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `request` field. */
  request?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `Request` */
export type RequestInput = {
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  request?: InputMaybe<Scalars['String']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Request`. Fields that are set will be updated. */
export type RequestPatch = {
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  request?: InputMaybe<Scalars['String']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Request` values. */
export type RequestsConnection = {
  __typename?: 'RequestsConnection';
  /** A list of edges which contains the `Request` and cursor to aid in pagination. */
  edges: Array<RequestsEdge>;
  /** A list of `Request` objects. */
  nodes: Array<Request>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Request` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Request` edge in the connection. */
export type RequestsEdge = {
  __typename?: 'RequestsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Request` at the end of the edge. */
  node: Request;
};

/** Methods to use when ordering `Request`. */
export enum RequestsOrderBy {
  CompletedAsc = 'COMPLETED_ASC',
  CompletedDesc = 'COMPLETED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequestAsc = 'REQUEST_ASC',
  RequestDesc = 'REQUEST_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type RxCard = Node & {
  __typename?: 'RxCard';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `RxCard`. */
  userByOwnerId?: Maybe<User>;
};

/** A condition to be used against `RxCard` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type RxCardCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `RxCard` object types. All fields are combined with a logical ‘and.’ */
export type RxCardFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<RxCardFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<RxCardFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<RxCardFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `RxCard` */
export type RxCardInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `RxCard`. Fields that are set will be updated. */
export type RxCardPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `RxCard` values. */
export type RxCardsConnection = {
  __typename?: 'RxCardsConnection';
  /** A list of edges which contains the `RxCard` and cursor to aid in pagination. */
  edges: Array<RxCardsEdge>;
  /** A list of `RxCard` objects. */
  nodes: Array<RxCard>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `RxCard` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `RxCard` edge in the connection. */
export type RxCardsEdge = {
  __typename?: 'RxCardsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `RxCard` at the end of the edge. */
  node: RxCard;
};

/** Methods to use when ordering `RxCard`. */
export enum RxCardsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type SamplePoint = Node & {
  __typename?: 'SamplePoint';
  /** Reads a single `Area` that is related to this `SamplePoint`. */
  areaByAreaId?: Maybe<Area>;
  areaId: Scalars['Int']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DetectorSensorLocation`. */
  detectorSensorLocationsBySamplePointId: DetectorSensorLocationsConnection;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `SamplePoint`. */
  userByOwnerId?: Maybe<User>;
};


export type SamplePointDetectorSensorLocationsBySamplePointIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationCondition>;
  filter?: InputMaybe<DetectorSensorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};

/**
 * A condition to be used against `SamplePoint` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SamplePointCondition = {
  /** Checks for equality with the object’s `areaId` field. */
  areaId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `SamplePointEntity` values. */
export type SamplePointEntitiesConnection = {
  __typename?: 'SamplePointEntitiesConnection';
  /** A list of edges which contains the `SamplePointEntity` and cursor to aid in pagination. */
  edges: Array<SamplePointEntitiesEdge>;
  /** A list of `SamplePointEntity` objects. */
  nodes: Array<SamplePointEntity>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SamplePointEntity` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SamplePointEntity` edge in the connection. */
export type SamplePointEntitiesEdge = {
  __typename?: 'SamplePointEntitiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SamplePointEntity` at the end of the edge. */
  node: SamplePointEntity;
};

/** Methods to use when ordering `SamplePointEntity`. */
export enum SamplePointEntitiesOrderBy {
  AreaIdAsc = 'AREA_ID_ASC',
  AreaIdDesc = 'AREA_ID_DESC',
  AreaNameAsc = 'AREA_NAME_ASC',
  AreaNameDesc = 'AREA_NAME_DESC',
  BuildingIdAsc = 'BUILDING_ID_ASC',
  BuildingIdDesc = 'BUILDING_ID_DESC',
  BuildingNameAsc = 'BUILDING_NAME_ASC',
  BuildingNameDesc = 'BUILDING_NAME_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EndUserIdAsc = 'END_USER_ID_ASC',
  EndUserIdDesc = 'END_USER_ID_DESC',
  EndUserNameAsc = 'END_USER_NAME_ASC',
  EndUserNameDesc = 'END_USER_NAME_DESC',
  FloorIdAsc = 'FLOOR_ID_ASC',
  FloorIdDesc = 'FLOOR_ID_DESC',
  FloorNameAsc = 'FLOOR_NAME_ASC',
  FloorNameDesc = 'FLOOR_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC'
}

export type SamplePointEntity = {
  __typename?: 'SamplePointEntity';
  areaId?: Maybe<Scalars['Int']['output']>;
  areaName?: Maybe<Scalars['String']['output']>;
  buildingId?: Maybe<Scalars['Int']['output']>;
  buildingName?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  endUserId?: Maybe<Scalars['Int']['output']>;
  endUserName?: Maybe<Scalars['String']['output']>;
  floorId?: Maybe<Scalars['Int']['output']>;
  floorName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `SamplePointEntity` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SamplePointEntityCondition = {
  /** Checks for equality with the object’s `areaId` field. */
  areaId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `areaName` field. */
  areaName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `buildingId` field. */
  buildingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `buildingName` field. */
  buildingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `endUserId` field. */
  endUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endUserName` field. */
  endUserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `floorId` field. */
  floorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `floorName` field. */
  floorName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `SamplePointEntity` object types. All fields are combined with a logical ‘and.’ */
export type SamplePointEntityFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SamplePointEntityFilter>>;
  /** Filter by the object’s `areaId` field. */
  areaId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `areaName` field. */
  areaName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `buildingId` field. */
  buildingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `buildingName` field. */
  buildingName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `endUserId` field. */
  endUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endUserName` field. */
  endUserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `floorId` field. */
  floorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `floorName` field. */
  floorName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SamplePointEntityFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SamplePointEntityFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
};

/** A filter to be used against `SamplePoint` object types. All fields are combined with a logical ‘and.’ */
export type SamplePointFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SamplePointFilter>>;
  /** Filter by the object’s `areaByAreaId` relation. */
  areaByAreaId?: InputMaybe<AreaFilter>;
  /** Filter by the object’s `areaId` field. */
  areaId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorSensorLocationsBySamplePointId` relation. */
  detectorSensorLocationsBySamplePointId?: InputMaybe<SamplePointToManyDetectorSensorLocationFilter>;
  /** Some related `detectorSensorLocationsBySamplePointId` exist. */
  detectorSensorLocationsBySamplePointIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SamplePointFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SamplePointFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `SamplePoint` */
export type SamplePointInput = {
  areaId: Scalars['Int']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `SamplePoint`. Fields that are set will be updated. */
export type SamplePointPatch = {
  areaId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `DetectorSensorLocation` object types. All fields are combined with a logical ‘and.’ */
export type SamplePointToManyDetectorSensorLocationFilter = {
  /** Every related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorLocationFilter>;
  /** No related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorLocationFilter>;
  /** Some related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorLocationFilter>;
};

/** A connection to a list of `SamplePoint` values. */
export type SamplePointsConnection = {
  __typename?: 'SamplePointsConnection';
  /** A list of edges which contains the `SamplePoint` and cursor to aid in pagination. */
  edges: Array<SamplePointsEdge>;
  /** A list of `SamplePoint` objects. */
  nodes: Array<SamplePoint>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SamplePoint` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SamplePoint` edge in the connection. */
export type SamplePointsEdge = {
  __typename?: 'SamplePointsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SamplePoint` at the end of the edge. */
  node: SamplePoint;
};

/** Methods to use when ordering `SamplePoint`. */
export enum SamplePointsOrderBy {
  AreaByAreaIdCreatedAsc = 'AREA_BY_AREA_ID__CREATED_ASC',
  AreaByAreaIdCreatedDesc = 'AREA_BY_AREA_ID__CREATED_DESC',
  AreaByAreaIdFloorIdAsc = 'AREA_BY_AREA_ID__FLOOR_ID_ASC',
  AreaByAreaIdFloorIdDesc = 'AREA_BY_AREA_ID__FLOOR_ID_DESC',
  AreaByAreaIdIdAsc = 'AREA_BY_AREA_ID__ID_ASC',
  AreaByAreaIdIdDesc = 'AREA_BY_AREA_ID__ID_DESC',
  AreaByAreaIdModifiedAsc = 'AREA_BY_AREA_ID__MODIFIED_ASC',
  AreaByAreaIdModifiedDesc = 'AREA_BY_AREA_ID__MODIFIED_DESC',
  AreaByAreaIdNameAsc = 'AREA_BY_AREA_ID__NAME_ASC',
  AreaByAreaIdNameDesc = 'AREA_BY_AREA_ID__NAME_DESC',
  AreaByAreaIdOwnerIdAsc = 'AREA_BY_AREA_ID__OWNER_ID_ASC',
  AreaByAreaIdOwnerIdDesc = 'AREA_BY_AREA_ID__OWNER_ID_DESC',
  AreaByAreaIdRemarksAsc = 'AREA_BY_AREA_ID__REMARKS_ASC',
  AreaByAreaIdRemarksDesc = 'AREA_BY_AREA_ID__REMARKS_DESC',
  AreaIdAsc = 'AREA_ID_ASC',
  AreaIdDesc = 'AREA_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorSensorLocationsBySamplePointIdCountAsc = 'DETECTOR_SENSOR_LOCATIONS_BY_SAMPLE_POINT_ID__COUNT_ASC',
  DetectorSensorLocationsBySamplePointIdCountDesc = 'DETECTOR_SENSOR_LOCATIONS_BY_SAMPLE_POINT_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Sensor = Node & {
  __typename?: 'Sensor';
  created: Scalars['Datetime']['output'];
  /** Reads a single `DetectorSensor` that is related to this `Sensor`. */
  detectorSensorBySensorId?: Maybe<DetectorSensor>;
  /**
   * Reads and enables pagination through a set of `DetectorSensor`.
   * @deprecated Please use detectorSensorBySensorId instead
   */
  detectorSensorsBySensorId: DetectorSensorsConnection;
  id: Scalars['Int']['output'];
  labelDate?: Maybe<Scalars['Date']['output']>;
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  maintenanceVisitLinesByOriginalSensorId: MaintenanceVisitLinesConnection;
  /** Reads and enables pagination through a set of `MaintenanceVisitLine`. */
  maintenanceVisitLinesBySensorId: MaintenanceVisitLinesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  remarks?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ReportSensor`. */
  reportSensorsBySensorId: ReportSensorsConnection;
  /** Reads and enables pagination through a set of `SensorElementLog`. */
  sensorElementLogsBySensorId: SensorElementLogsConnection;
  /** Reads and enables pagination through a set of `SensorOrder`. */
  sensorOrdersBySensorId: SensorOrdersConnection;
  /** Reads and enables pagination through a set of `SensorSensorElement`. */
  sensorSensorElementsBySensorId: SensorSensorElementsConnection;
  /** Reads and enables pagination through a set of `SensorTestResult`. */
  sensorTestResultsBySensorId: SensorTestResultsConnection;
  /** Reads a single `SensorType` that is related to this `Sensor`. */
  sensorTypeBySensorTypeId?: Maybe<SensorType>;
  sensorTypeId: Scalars['Int']['output'];
  serialNumber: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `Sensor`. */
  userByOwnerId?: Maybe<User>;
};


export type SensorDetectorSensorsBySensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorCondition>;
  filter?: InputMaybe<DetectorSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};


export type SensorMaintenanceVisitLinesByOriginalSensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};


export type SensorMaintenanceVisitLinesBySensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitLineCondition>;
  filter?: InputMaybe<MaintenanceVisitLineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};


export type SensorReportSensorsBySensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportSensorCondition>;
  filter?: InputMaybe<ReportSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportSensorsOrderBy>>;
};


export type SensorSensorElementLogsBySensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementLogCondition>;
  filter?: InputMaybe<SensorElementLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementLogsOrderBy>>;
};


export type SensorSensorOrdersBySensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorOrderCondition>;
  filter?: InputMaybe<SensorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};


export type SensorSensorSensorElementsBySensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorSensorElementCondition>;
  filter?: InputMaybe<SensorSensorElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorSensorElementsOrderBy>>;
};


export type SensorSensorTestResultsBySensorIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTestResultCondition>;
  filter?: InputMaybe<SensorTestResultFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};

export type SensorBaseType = Node & {
  __typename?: 'SensorBaseType';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  maintenanceIntervalMonths?: Maybe<Scalars['Int']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  prefix?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Principle` that is related to this `SensorBaseType`. */
  principleByPrincipleId?: Maybe<Principle>;
  principleId?: Maybe<Scalars['Int']['output']>;
  quotationIntervalMonths?: Maybe<Scalars['Int']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `SensorElementType`. */
  sensorElementTypesBySensorBaseTypeId: SensorElementTypesConnection;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesBySensorBaseTypeId: SensorTypesConnection;
  series?: Maybe<Scalars['String']['output']>;
  suffix?: Maybe<Scalars['String']['output']>;
  volume?: Maybe<Scalars['Int']['output']>;
};


export type SensorBaseTypeSensorElementTypesBySensorBaseTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementTypeCondition>;
  filter?: InputMaybe<SensorElementTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementTypesOrderBy>>;
};


export type SensorBaseTypeSensorTypesBySensorBaseTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/**
 * A condition to be used against `SensorBaseType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SensorBaseTypeCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maintenanceIntervalMonths` field. */
  maintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prefix` field. */
  prefix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `principleId` field. */
  principleId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `quotationIntervalMonths` field. */
  quotationIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `series` field. */
  series?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `suffix` field. */
  suffix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `volume` field. */
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `SensorBaseType` object types. All fields are combined with a logical ‘and.’ */
export type SensorBaseTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorBaseTypeFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceIntervalMonths` field. */
  maintenanceIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorBaseTypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorBaseTypeFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prefix` field. */
  prefix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `principleByPrincipleId` relation. */
  principleByPrincipleId?: InputMaybe<PrincipleFilter>;
  /** A related `principleByPrincipleId` exists. */
  principleByPrincipleIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `principleId` field. */
  principleId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `quotationIntervalMonths` field. */
  quotationIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorElementTypesBySensorBaseTypeId` relation. */
  sensorElementTypesBySensorBaseTypeId?: InputMaybe<SensorBaseTypeToManySensorElementTypeFilter>;
  /** Some related `sensorElementTypesBySensorBaseTypeId` exist. */
  sensorElementTypesBySensorBaseTypeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorTypesBySensorBaseTypeId` relation. */
  sensorTypesBySensorBaseTypeId?: InputMaybe<SensorBaseTypeToManySensorTypeFilter>;
  /** Some related `sensorTypesBySensorBaseTypeId` exist. */
  sensorTypesBySensorBaseTypeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `series` field. */
  series?: InputMaybe<StringFilter>;
  /** Filter by the object’s `suffix` field. */
  suffix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `volume` field. */
  volume?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `SensorBaseType` */
export type SensorBaseTypeInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  maintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  prefix?: InputMaybe<Scalars['String']['input']>;
  principleId?: InputMaybe<Scalars['Int']['input']>;
  quotationIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  series?: InputMaybe<Scalars['String']['input']>;
  suffix?: InputMaybe<Scalars['String']['input']>;
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `SensorBaseType`. Fields that are set will be updated. */
export type SensorBaseTypePatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  maintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  prefix?: InputMaybe<Scalars['String']['input']>;
  principleId?: InputMaybe<Scalars['Int']['input']>;
  quotationIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  series?: InputMaybe<Scalars['String']['input']>;
  suffix?: InputMaybe<Scalars['String']['input']>;
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `SensorElementType` object types. All fields are combined with a logical ‘and.’ */
export type SensorBaseTypeToManySensorElementTypeFilter = {
  /** Every related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementTypeFilter>;
  /** No related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementTypeFilter>;
  /** Some related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementTypeFilter>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type SensorBaseTypeToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A connection to a list of `SensorBaseType` values. */
export type SensorBaseTypesConnection = {
  __typename?: 'SensorBaseTypesConnection';
  /** A list of edges which contains the `SensorBaseType` and cursor to aid in pagination. */
  edges: Array<SensorBaseTypesEdge>;
  /** A list of `SensorBaseType` objects. */
  nodes: Array<SensorBaseType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorBaseType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorBaseType` edge in the connection. */
export type SensorBaseTypesEdge = {
  __typename?: 'SensorBaseTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorBaseType` at the end of the edge. */
  node: SensorBaseType;
};

/** Methods to use when ordering `SensorBaseType`. */
export enum SensorBaseTypesOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceIntervalMonthsAsc = 'MAINTENANCE_INTERVAL_MONTHS_ASC',
  MaintenanceIntervalMonthsDesc = 'MAINTENANCE_INTERVAL_MONTHS_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrefixAsc = 'PREFIX_ASC',
  PrefixDesc = 'PREFIX_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PrincipleByPrincipleIdCreatedAsc = 'PRINCIPLE_BY_PRINCIPLE_ID__CREATED_ASC',
  PrincipleByPrincipleIdCreatedDesc = 'PRINCIPLE_BY_PRINCIPLE_ID__CREATED_DESC',
  PrincipleByPrincipleIdIdAsc = 'PRINCIPLE_BY_PRINCIPLE_ID__ID_ASC',
  PrincipleByPrincipleIdIdDesc = 'PRINCIPLE_BY_PRINCIPLE_ID__ID_DESC',
  PrincipleByPrincipleIdModifiedAsc = 'PRINCIPLE_BY_PRINCIPLE_ID__MODIFIED_ASC',
  PrincipleByPrincipleIdModifiedDesc = 'PRINCIPLE_BY_PRINCIPLE_ID__MODIFIED_DESC',
  PrincipleByPrincipleIdNameAsc = 'PRINCIPLE_BY_PRINCIPLE_ID__NAME_ASC',
  PrincipleByPrincipleIdNameDesc = 'PRINCIPLE_BY_PRINCIPLE_ID__NAME_DESC',
  PrincipleByPrincipleIdOwnerIdAsc = 'PRINCIPLE_BY_PRINCIPLE_ID__OWNER_ID_ASC',
  PrincipleByPrincipleIdOwnerIdDesc = 'PRINCIPLE_BY_PRINCIPLE_ID__OWNER_ID_DESC',
  PrincipleIdAsc = 'PRINCIPLE_ID_ASC',
  PrincipleIdDesc = 'PRINCIPLE_ID_DESC',
  QuotationIntervalMonthsAsc = 'QUOTATION_INTERVAL_MONTHS_ASC',
  QuotationIntervalMonthsDesc = 'QUOTATION_INTERVAL_MONTHS_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorElementTypesBySensorBaseTypeIdCountAsc = 'SENSOR_ELEMENT_TYPES_BY_SENSOR_BASE_TYPE_ID__COUNT_ASC',
  SensorElementTypesBySensorBaseTypeIdCountDesc = 'SENSOR_ELEMENT_TYPES_BY_SENSOR_BASE_TYPE_ID__COUNT_DESC',
  SensorTypesBySensorBaseTypeIdCountAsc = 'SENSOR_TYPES_BY_SENSOR_BASE_TYPE_ID__COUNT_ASC',
  SensorTypesBySensorBaseTypeIdCountDesc = 'SENSOR_TYPES_BY_SENSOR_BASE_TYPE_ID__COUNT_DESC',
  SeriesAsc = 'SERIES_ASC',
  SeriesDesc = 'SERIES_DESC',
  SuffixAsc = 'SUFFIX_ASC',
  SuffixDesc = 'SUFFIX_DESC',
  VolumeAsc = 'VOLUME_ASC',
  VolumeDesc = 'VOLUME_DESC'
}

/** A condition to be used against `Sensor` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SensorCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `labelDate` field. */
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

export type SensorElement = Node & {
  __typename?: 'SensorElement';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  labelDate?: Maybe<Scalars['Date']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `SensorElementLocation` that is related to this `SensorElement`. */
  sensorElementLocationBySensorElementId?: Maybe<SensorElementLocation>;
  /**
   * Reads and enables pagination through a set of `SensorElementLocation`.
   * @deprecated Please use sensorElementLocationBySensorElementId instead
   */
  sensorElementLocationsBySensorElementId: SensorElementLocationsConnection;
  /** Reads and enables pagination through a set of `SensorElementLog`. */
  sensorElementLogsBySensorElementId: SensorElementLogsConnection;
  /** Reads a single `SensorElementType` that is related to this `SensorElement`. */
  sensorElementTypeBySensorElementTypeId?: Maybe<SensorElementType>;
  sensorElementTypeId: Scalars['Int']['output'];
  /** Reads a single `SensorSensorElement` that is related to this `SensorElement`. */
  sensorSensorElementBySensorElementId?: Maybe<SensorSensorElement>;
  /**
   * Reads and enables pagination through a set of `SensorSensorElement`.
   * @deprecated Please use sensorSensorElementBySensorElementId instead
   */
  sensorSensorElementsBySensorElementId: SensorSensorElementsConnection;
  serialNumber?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `SensorElement`. */
  userByOwnerId?: Maybe<User>;
};


export type SensorElementSensorElementLocationsBySensorElementIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementLocationCondition>;
  filter?: InputMaybe<SensorElementLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementLocationsOrderBy>>;
};


export type SensorElementSensorElementLogsBySensorElementIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementLogCondition>;
  filter?: InputMaybe<SensorElementLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementLogsOrderBy>>;
};


export type SensorElementSensorSensorElementsBySensorElementIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorSensorElementCondition>;
  filter?: InputMaybe<SensorSensorElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorSensorElementsOrderBy>>;
};

/**
 * A condition to be used against `SensorElement` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SensorElementCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `labelDate` field. */
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorElementTypeId` field. */
  sensorElementTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `SensorElement` object types. All fields are combined with a logical ‘and.’ */
export type SensorElementFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorElementFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `labelDate` field. */
  labelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorElementFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorElementFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorElementLocationBySensorElementId` relation. */
  sensorElementLocationBySensorElementId?: InputMaybe<SensorElementLocationFilter>;
  /** A related `sensorElementLocationBySensorElementId` exists. */
  sensorElementLocationBySensorElementIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementLogsBySensorElementId` relation. */
  sensorElementLogsBySensorElementId?: InputMaybe<SensorElementToManySensorElementLogFilter>;
  /** Some related `sensorElementLogsBySensorElementId` exist. */
  sensorElementLogsBySensorElementIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementTypeBySensorElementTypeId` relation. */
  sensorElementTypeBySensorElementTypeId?: InputMaybe<SensorElementTypeFilter>;
  /** Filter by the object’s `sensorElementTypeId` field. */
  sensorElementTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorSensorElementBySensorElementId` relation. */
  sensorSensorElementBySensorElementId?: InputMaybe<SensorSensorElementFilter>;
  /** A related `sensorSensorElementBySensorElementId` exists. */
  sensorSensorElementBySensorElementIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `SensorElement` */
export type SensorElementInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  sensorElementTypeId: Scalars['Int']['input'];
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

export type SensorElementLocation = Node & {
  __typename?: 'SensorElementLocation';
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `DetectorSensorLocation` that is related to this `SensorElementLocation`. */
  detectorSensorLocationByDetectorSensorLocationId?: Maybe<DetectorSensorLocation>;
  detectorSensorLocationId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `SensorElement` that is related to this `SensorElementLocation`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  sensorElementId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `SensorElementLocation`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `SensorElementLocation` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type SensorElementLocationCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorElementId` field. */
  sensorElementId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `SensorElementLocation` object types. All fields are combined with a logical ‘and.’ */
export type SensorElementLocationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorElementLocationFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorSensorLocationByDetectorSensorLocationId` relation. */
  detectorSensorLocationByDetectorSensorLocationId?: InputMaybe<DetectorSensorLocationFilter>;
  /** Filter by the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorElementLocationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorElementLocationFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorElementBySensorElementId` relation. */
  sensorElementBySensorElementId?: InputMaybe<SensorElementFilter>;
  /** A related `sensorElementBySensorElementId` exists. */
  sensorElementBySensorElementIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementId` field. */
  sensorElementId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `SensorElementLocation` */
export type SensorElementLocationInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorSensorLocationId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  sensorElementId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `SensorElementLocation`. Fields that are set will be updated. */
export type SensorElementLocationPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sensorElementId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `SensorElementLocation` values. */
export type SensorElementLocationsConnection = {
  __typename?: 'SensorElementLocationsConnection';
  /** A list of edges which contains the `SensorElementLocation` and cursor to aid in pagination. */
  edges: Array<SensorElementLocationsEdge>;
  /** A list of `SensorElementLocation` objects. */
  nodes: Array<SensorElementLocation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorElementLocation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorElementLocation` edge in the connection. */
export type SensorElementLocationsEdge = {
  __typename?: 'SensorElementLocationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorElementLocation` at the end of the edge. */
  node: SensorElementLocation;
};

/** Methods to use when ordering `SensorElementLocation`. */
export enum SensorElementLocationsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdApplicationIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__APPLICATION_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdApplicationIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__APPLICATION_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdCreatedAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__CREATED_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdCreatedDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__CREATED_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdDetectorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__DETECTOR_LOCATION_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdDetectorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__DETECTOR_LOCATION_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdDetectorSensorIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__DETECTOR_SENSOR_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdDetectorSensorIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__DETECTOR_SENSOR_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdFilterReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__FILTER_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdFilterReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__FILTER_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdLicenseIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__LICENSE_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdLicenseIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__LICENSE_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdModifiedAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__MODIFIED_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdModifiedDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__MODIFIED_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdOwnerIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__OWNER_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdOwnerIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__OWNER_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdPyrolyserReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__PYROLYSER_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdPyrolyserReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__PYROLYSER_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdRemarksAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__REMARKS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdRemarksDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__REMARKS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSamplePointIdAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SAMPLE_POINT_ID_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSamplePointIdDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SAMPLE_POINT_ID_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSensorMaintenanceIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SENSOR_MAINTENANCE_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSensorMaintenanceIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SENSOR_MAINTENANCE_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSensorReplacementIntervalMonthsAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SENSOR_REPLACEMENT_INTERVAL_MONTHS_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSensorReplacementIntervalMonthsDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SENSOR_REPLACEMENT_INTERVAL_MONTHS_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSimsChannelAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SIMS_CHANNEL_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSimsChannelDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SIMS_CHANNEL_DESC',
  DetectorSensorLocationByDetectorSensorLocationIdSimsTagAsc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SIMS_TAG_ASC',
  DetectorSensorLocationByDetectorSensorLocationIdSimsTagDesc = 'DETECTOR_SENSOR_LOCATION_BY_DETECTOR_SENSOR_LOCATION_ID__SIMS_TAG_DESC',
  DetectorSensorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_ID_ASC',
  DetectorSensorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorElementBySensorElementIdCreatedAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__CREATED_ASC',
  SensorElementBySensorElementIdCreatedDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__CREATED_DESC',
  SensorElementBySensorElementIdIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__ID_ASC',
  SensorElementBySensorElementIdIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__ID_DESC',
  SensorElementBySensorElementIdLabelDateAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__LABEL_DATE_ASC',
  SensorElementBySensorElementIdLabelDateDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__LABEL_DATE_DESC',
  SensorElementBySensorElementIdModifiedAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__MODIFIED_ASC',
  SensorElementBySensorElementIdModifiedDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__MODIFIED_DESC',
  SensorElementBySensorElementIdOwnerIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__OWNER_ID_ASC',
  SensorElementBySensorElementIdOwnerIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__OWNER_ID_DESC',
  SensorElementBySensorElementIdSensorElementTypeIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_TYPE_ID_ASC',
  SensorElementBySensorElementIdSensorElementTypeIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_TYPE_ID_DESC',
  SensorElementBySensorElementIdSerialNumberAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SERIAL_NUMBER_ASC',
  SensorElementBySensorElementIdSerialNumberDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SERIAL_NUMBER_DESC',
  SensorElementIdAsc = 'SENSOR_ELEMENT_ID_ASC',
  SensorElementIdDesc = 'SENSOR_ELEMENT_ID_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type SensorElementLog = Node & {
  __typename?: 'SensorElementLog';
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `Sensor` that is related to this `SensorElementLog`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` that is related to this `SensorElementLog`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  sensorElementId: Scalars['Int']['output'];
  sensorId?: Maybe<Scalars['Int']['output']>;
  sensorPosition?: Maybe<Scalars['Int']['output']>;
  time: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `SensorElementLog` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SensorElementLogCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorElementId` field. */
  sensorElementId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorPosition` field. */
  sensorPosition?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `time` field. */
  time?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `SensorElementLog` object types. All fields are combined with a logical ‘and.’ */
export type SensorElementLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorElementLogFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorElementLogFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorElementLogFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorBySensorId` relation. */
  sensorBySensorId?: InputMaybe<SensorFilter>;
  /** A related `sensorBySensorId` exists. */
  sensorBySensorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementBySensorElementId` relation. */
  sensorElementBySensorElementId?: InputMaybe<SensorElementFilter>;
  /** Filter by the object’s `sensorElementId` field. */
  sensorElementId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorPosition` field. */
  sensorPosition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `time` field. */
  time?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `SensorElementLog` */
export type SensorElementLogInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  ownerId: Scalars['Int']['input'];
  sensorElementId: Scalars['Int']['input'];
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  sensorPosition?: InputMaybe<Scalars['Int']['input']>;
  time: Scalars['Datetime']['input'];
};

/** Represents an update to a `SensorElementLog`. Fields that are set will be updated. */
export type SensorElementLogPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sensorElementId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  sensorPosition?: InputMaybe<Scalars['Int']['input']>;
  time?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `SensorElementLog` values. */
export type SensorElementLogsConnection = {
  __typename?: 'SensorElementLogsConnection';
  /** A list of edges which contains the `SensorElementLog` and cursor to aid in pagination. */
  edges: Array<SensorElementLogsEdge>;
  /** A list of `SensorElementLog` objects. */
  nodes: Array<SensorElementLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorElementLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorElementLog` edge in the connection. */
export type SensorElementLogsEdge = {
  __typename?: 'SensorElementLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorElementLog` at the end of the edge. */
  node: SensorElementLog;
};

/** Methods to use when ordering `SensorElementLog`. */
export enum SensorElementLogsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorBySensorIdCreatedAsc = 'SENSOR_BY_SENSOR_ID__CREATED_ASC',
  SensorBySensorIdCreatedDesc = 'SENSOR_BY_SENSOR_ID__CREATED_DESC',
  SensorBySensorIdIdAsc = 'SENSOR_BY_SENSOR_ID__ID_ASC',
  SensorBySensorIdIdDesc = 'SENSOR_BY_SENSOR_ID__ID_DESC',
  SensorBySensorIdLabelDateAsc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_ASC',
  SensorBySensorIdLabelDateDesc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_DESC',
  SensorBySensorIdModifiedAsc = 'SENSOR_BY_SENSOR_ID__MODIFIED_ASC',
  SensorBySensorIdModifiedDesc = 'SENSOR_BY_SENSOR_ID__MODIFIED_DESC',
  SensorBySensorIdOwnerIdAsc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_ASC',
  SensorBySensorIdOwnerIdDesc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_DESC',
  SensorBySensorIdRemarksAsc = 'SENSOR_BY_SENSOR_ID__REMARKS_ASC',
  SensorBySensorIdRemarksDesc = 'SENSOR_BY_SENSOR_ID__REMARKS_DESC',
  SensorBySensorIdSensorTypeIdAsc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_ASC',
  SensorBySensorIdSensorTypeIdDesc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_DESC',
  SensorBySensorIdSerialNumberAsc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_ASC',
  SensorBySensorIdSerialNumberDesc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_DESC',
  SensorElementBySensorElementIdCreatedAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__CREATED_ASC',
  SensorElementBySensorElementIdCreatedDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__CREATED_DESC',
  SensorElementBySensorElementIdIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__ID_ASC',
  SensorElementBySensorElementIdIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__ID_DESC',
  SensorElementBySensorElementIdLabelDateAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__LABEL_DATE_ASC',
  SensorElementBySensorElementIdLabelDateDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__LABEL_DATE_DESC',
  SensorElementBySensorElementIdModifiedAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__MODIFIED_ASC',
  SensorElementBySensorElementIdModifiedDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__MODIFIED_DESC',
  SensorElementBySensorElementIdOwnerIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__OWNER_ID_ASC',
  SensorElementBySensorElementIdOwnerIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__OWNER_ID_DESC',
  SensorElementBySensorElementIdSensorElementTypeIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_TYPE_ID_ASC',
  SensorElementBySensorElementIdSensorElementTypeIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_TYPE_ID_DESC',
  SensorElementBySensorElementIdSerialNumberAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SERIAL_NUMBER_ASC',
  SensorElementBySensorElementIdSerialNumberDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SERIAL_NUMBER_DESC',
  SensorElementIdAsc = 'SENSOR_ELEMENT_ID_ASC',
  SensorElementIdDesc = 'SENSOR_ELEMENT_ID_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  SensorPositionAsc = 'SENSOR_POSITION_ASC',
  SensorPositionDesc = 'SENSOR_POSITION_DESC',
  TimeAsc = 'TIME_ASC',
  TimeDesc = 'TIME_DESC'
}

/** Represents an update to a `SensorElement`. Fields that are set will be updated. */
export type SensorElementPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sensorElementTypeId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `SensorElementLog` object types. All fields are combined with a logical ‘and.’ */
export type SensorElementToManySensorElementLogFilter = {
  /** Every related `SensorElementLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementLogFilter>;
  /** No related `SensorElementLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementLogFilter>;
  /** Some related `SensorElementLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementLogFilter>;
};

export type SensorElementType = Node & {
  __typename?: 'SensorElementType';
  calRangeId: Scalars['Int']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `Range` that is related to this `SensorElementType`. */
  rangeByCalRangeId?: Maybe<Range>;
  /** Reads a single `Range` that is related to this `SensorElementType`. */
  rangeByRangeId?: Maybe<Range>;
  rangeId: Scalars['Int']['output'];
  replacementInterval?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `SensorBaseType` that is related to this `SensorElementType`. */
  sensorBaseTypeBySensorBaseTypeId?: Maybe<SensorBaseType>;
  sensorBaseTypeId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `SensorElement`. */
  sensorElementsBySensorElementTypeId: SensorElementsConnection;
  /** Reads a single `User` that is related to this `SensorElementType`. */
  userByOwnerId?: Maybe<User>;
};


export type SensorElementTypeSensorElementsBySensorElementTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementCondition>;
  filter?: InputMaybe<SensorElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementsOrderBy>>;
};

/**
 * A condition to be used against `SensorElementType` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SensorElementTypeCondition = {
  /** Checks for equality with the object’s `calRangeId` field. */
  calRangeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `rangeId` field. */
  rangeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementInterval` field. */
  replacementInterval?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorBaseTypeId` field. */
  sensorBaseTypeId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `SensorElementType` object types. All fields are combined with a logical ‘and.’ */
export type SensorElementTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorElementTypeFilter>>;
  /** Filter by the object’s `calRangeId` field. */
  calRangeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorElementTypeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorElementTypeFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `rangeByCalRangeId` relation. */
  rangeByCalRangeId?: InputMaybe<RangeFilter>;
  /** Filter by the object’s `rangeByRangeId` relation. */
  rangeByRangeId?: InputMaybe<RangeFilter>;
  /** Filter by the object’s `rangeId` field. */
  rangeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementInterval` field. */
  replacementInterval?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorBaseTypeBySensorBaseTypeId` relation. */
  sensorBaseTypeBySensorBaseTypeId?: InputMaybe<SensorBaseTypeFilter>;
  /** Filter by the object’s `sensorBaseTypeId` field. */
  sensorBaseTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorElementsBySensorElementTypeId` relation. */
  sensorElementsBySensorElementTypeId?: InputMaybe<SensorElementTypeToManySensorElementFilter>;
  /** Some related `sensorElementsBySensorElementTypeId` exist. */
  sensorElementsBySensorElementTypeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `SensorElementType` */
export type SensorElementTypeInput = {
  calRangeId: Scalars['Int']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
  rangeId: Scalars['Int']['input'];
  replacementInterval?: InputMaybe<Scalars['Int']['input']>;
  sensorBaseTypeId: Scalars['Int']['input'];
};

/** Represents an update to a `SensorElementType`. Fields that are set will be updated. */
export type SensorElementTypePatch = {
  calRangeId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  rangeId?: InputMaybe<Scalars['Int']['input']>;
  replacementInterval?: InputMaybe<Scalars['Int']['input']>;
  sensorBaseTypeId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `SensorElement` object types. All fields are combined with a logical ‘and.’ */
export type SensorElementTypeToManySensorElementFilter = {
  /** Every related `SensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementFilter>;
  /** No related `SensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementFilter>;
  /** Some related `SensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementFilter>;
};

/** A connection to a list of `SensorElementType` values. */
export type SensorElementTypesConnection = {
  __typename?: 'SensorElementTypesConnection';
  /** A list of edges which contains the `SensorElementType` and cursor to aid in pagination. */
  edges: Array<SensorElementTypesEdge>;
  /** A list of `SensorElementType` objects. */
  nodes: Array<SensorElementType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorElementType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorElementType` edge in the connection. */
export type SensorElementTypesEdge = {
  __typename?: 'SensorElementTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorElementType` at the end of the edge. */
  node: SensorElementType;
};

/** Methods to use when ordering `SensorElementType`. */
export enum SensorElementTypesOrderBy {
  CalRangeIdAsc = 'CAL_RANGE_ID_ASC',
  CalRangeIdDesc = 'CAL_RANGE_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RangeByCalRangeIdAlarm_1DirectionUpAsc = 'RANGE_BY_CAL_RANGE_ID__ALARM_1_DIRECTION_UP_ASC',
  RangeByCalRangeIdAlarm_1DirectionUpDesc = 'RANGE_BY_CAL_RANGE_ID__ALARM_1_DIRECTION_UP_DESC',
  RangeByCalRangeIdAlarm_1LevelAsc = 'RANGE_BY_CAL_RANGE_ID__ALARM_1_LEVEL_ASC',
  RangeByCalRangeIdAlarm_1LevelDesc = 'RANGE_BY_CAL_RANGE_ID__ALARM_1_LEVEL_DESC',
  RangeByCalRangeIdAlarm_2DirectionUpAsc = 'RANGE_BY_CAL_RANGE_ID__ALARM_2_DIRECTION_UP_ASC',
  RangeByCalRangeIdAlarm_2DirectionUpDesc = 'RANGE_BY_CAL_RANGE_ID__ALARM_2_DIRECTION_UP_DESC',
  RangeByCalRangeIdAlarm_2LevelAsc = 'RANGE_BY_CAL_RANGE_ID__ALARM_2_LEVEL_ASC',
  RangeByCalRangeIdAlarm_2LevelDesc = 'RANGE_BY_CAL_RANGE_ID__ALARM_2_LEVEL_DESC',
  RangeByCalRangeIdAlarmUnitsAsc = 'RANGE_BY_CAL_RANGE_ID__ALARM_UNITS_ASC',
  RangeByCalRangeIdAlarmUnitsDesc = 'RANGE_BY_CAL_RANGE_ID__ALARM_UNITS_DESC',
  RangeByCalRangeIdCreatedAsc = 'RANGE_BY_CAL_RANGE_ID__CREATED_ASC',
  RangeByCalRangeIdCreatedDesc = 'RANGE_BY_CAL_RANGE_ID__CREATED_DESC',
  RangeByCalRangeIdEngineeringUnitsAsc = 'RANGE_BY_CAL_RANGE_ID__ENGINEERING_UNITS_ASC',
  RangeByCalRangeIdEngineeringUnitsDesc = 'RANGE_BY_CAL_RANGE_ID__ENGINEERING_UNITS_DESC',
  RangeByCalRangeIdGasIdAsc = 'RANGE_BY_CAL_RANGE_ID__GAS_ID_ASC',
  RangeByCalRangeIdGasIdDesc = 'RANGE_BY_CAL_RANGE_ID__GAS_ID_DESC',
  RangeByCalRangeIdHighEuAsc = 'RANGE_BY_CAL_RANGE_ID__HIGH_EU_ASC',
  RangeByCalRangeIdHighEuBackupAsc = 'RANGE_BY_CAL_RANGE_ID__HIGH_EU_BACKUP_ASC',
  RangeByCalRangeIdHighEuBackupDesc = 'RANGE_BY_CAL_RANGE_ID__HIGH_EU_BACKUP_DESC',
  RangeByCalRangeIdHighEuDesc = 'RANGE_BY_CAL_RANGE_ID__HIGH_EU_DESC',
  RangeByCalRangeIdHighEuNumericAsc = 'RANGE_BY_CAL_RANGE_ID__HIGH_EU_NUMERIC_ASC',
  RangeByCalRangeIdHighEuNumericDesc = 'RANGE_BY_CAL_RANGE_ID__HIGH_EU_NUMERIC_DESC',
  RangeByCalRangeIdIdAsc = 'RANGE_BY_CAL_RANGE_ID__ID_ASC',
  RangeByCalRangeIdIdDesc = 'RANGE_BY_CAL_RANGE_ID__ID_DESC',
  RangeByCalRangeIdLowEuAsc = 'RANGE_BY_CAL_RANGE_ID__LOW_EU_ASC',
  RangeByCalRangeIdLowEuDesc = 'RANGE_BY_CAL_RANGE_ID__LOW_EU_DESC',
  RangeByCalRangeIdModifiedAsc = 'RANGE_BY_CAL_RANGE_ID__MODIFIED_ASC',
  RangeByCalRangeIdModifiedDesc = 'RANGE_BY_CAL_RANGE_ID__MODIFIED_DESC',
  RangeByCalRangeIdOwnerIdAsc = 'RANGE_BY_CAL_RANGE_ID__OWNER_ID_ASC',
  RangeByCalRangeIdOwnerIdDesc = 'RANGE_BY_CAL_RANGE_ID__OWNER_ID_DESC',
  RangeByCalRangeIdPrecisionAsc = 'RANGE_BY_CAL_RANGE_ID__PRECISION_ASC',
  RangeByCalRangeIdPrecisionDesc = 'RANGE_BY_CAL_RANGE_ID__PRECISION_DESC',
  RangeByCalRangeIdWarning_1LevelAsc = 'RANGE_BY_CAL_RANGE_ID__WARNING_1_LEVEL_ASC',
  RangeByCalRangeIdWarning_1LevelDesc = 'RANGE_BY_CAL_RANGE_ID__WARNING_1_LEVEL_DESC',
  RangeByCalRangeIdWarning_2LevelAsc = 'RANGE_BY_CAL_RANGE_ID__WARNING_2_LEVEL_ASC',
  RangeByCalRangeIdWarning_2LevelDesc = 'RANGE_BY_CAL_RANGE_ID__WARNING_2_LEVEL_DESC',
  RangeByRangeIdAlarm_1DirectionUpAsc = 'RANGE_BY_RANGE_ID__ALARM_1_DIRECTION_UP_ASC',
  RangeByRangeIdAlarm_1DirectionUpDesc = 'RANGE_BY_RANGE_ID__ALARM_1_DIRECTION_UP_DESC',
  RangeByRangeIdAlarm_1LevelAsc = 'RANGE_BY_RANGE_ID__ALARM_1_LEVEL_ASC',
  RangeByRangeIdAlarm_1LevelDesc = 'RANGE_BY_RANGE_ID__ALARM_1_LEVEL_DESC',
  RangeByRangeIdAlarm_2DirectionUpAsc = 'RANGE_BY_RANGE_ID__ALARM_2_DIRECTION_UP_ASC',
  RangeByRangeIdAlarm_2DirectionUpDesc = 'RANGE_BY_RANGE_ID__ALARM_2_DIRECTION_UP_DESC',
  RangeByRangeIdAlarm_2LevelAsc = 'RANGE_BY_RANGE_ID__ALARM_2_LEVEL_ASC',
  RangeByRangeIdAlarm_2LevelDesc = 'RANGE_BY_RANGE_ID__ALARM_2_LEVEL_DESC',
  RangeByRangeIdAlarmUnitsAsc = 'RANGE_BY_RANGE_ID__ALARM_UNITS_ASC',
  RangeByRangeIdAlarmUnitsDesc = 'RANGE_BY_RANGE_ID__ALARM_UNITS_DESC',
  RangeByRangeIdCreatedAsc = 'RANGE_BY_RANGE_ID__CREATED_ASC',
  RangeByRangeIdCreatedDesc = 'RANGE_BY_RANGE_ID__CREATED_DESC',
  RangeByRangeIdEngineeringUnitsAsc = 'RANGE_BY_RANGE_ID__ENGINEERING_UNITS_ASC',
  RangeByRangeIdEngineeringUnitsDesc = 'RANGE_BY_RANGE_ID__ENGINEERING_UNITS_DESC',
  RangeByRangeIdGasIdAsc = 'RANGE_BY_RANGE_ID__GAS_ID_ASC',
  RangeByRangeIdGasIdDesc = 'RANGE_BY_RANGE_ID__GAS_ID_DESC',
  RangeByRangeIdHighEuAsc = 'RANGE_BY_RANGE_ID__HIGH_EU_ASC',
  RangeByRangeIdHighEuBackupAsc = 'RANGE_BY_RANGE_ID__HIGH_EU_BACKUP_ASC',
  RangeByRangeIdHighEuBackupDesc = 'RANGE_BY_RANGE_ID__HIGH_EU_BACKUP_DESC',
  RangeByRangeIdHighEuDesc = 'RANGE_BY_RANGE_ID__HIGH_EU_DESC',
  RangeByRangeIdHighEuNumericAsc = 'RANGE_BY_RANGE_ID__HIGH_EU_NUMERIC_ASC',
  RangeByRangeIdHighEuNumericDesc = 'RANGE_BY_RANGE_ID__HIGH_EU_NUMERIC_DESC',
  RangeByRangeIdIdAsc = 'RANGE_BY_RANGE_ID__ID_ASC',
  RangeByRangeIdIdDesc = 'RANGE_BY_RANGE_ID__ID_DESC',
  RangeByRangeIdLowEuAsc = 'RANGE_BY_RANGE_ID__LOW_EU_ASC',
  RangeByRangeIdLowEuDesc = 'RANGE_BY_RANGE_ID__LOW_EU_DESC',
  RangeByRangeIdModifiedAsc = 'RANGE_BY_RANGE_ID__MODIFIED_ASC',
  RangeByRangeIdModifiedDesc = 'RANGE_BY_RANGE_ID__MODIFIED_DESC',
  RangeByRangeIdOwnerIdAsc = 'RANGE_BY_RANGE_ID__OWNER_ID_ASC',
  RangeByRangeIdOwnerIdDesc = 'RANGE_BY_RANGE_ID__OWNER_ID_DESC',
  RangeByRangeIdPrecisionAsc = 'RANGE_BY_RANGE_ID__PRECISION_ASC',
  RangeByRangeIdPrecisionDesc = 'RANGE_BY_RANGE_ID__PRECISION_DESC',
  RangeByRangeIdWarning_1LevelAsc = 'RANGE_BY_RANGE_ID__WARNING_1_LEVEL_ASC',
  RangeByRangeIdWarning_1LevelDesc = 'RANGE_BY_RANGE_ID__WARNING_1_LEVEL_DESC',
  RangeByRangeIdWarning_2LevelAsc = 'RANGE_BY_RANGE_ID__WARNING_2_LEVEL_ASC',
  RangeByRangeIdWarning_2LevelDesc = 'RANGE_BY_RANGE_ID__WARNING_2_LEVEL_DESC',
  RangeIdAsc = 'RANGE_ID_ASC',
  RangeIdDesc = 'RANGE_ID_DESC',
  ReplacementIntervalAsc = 'REPLACEMENT_INTERVAL_ASC',
  ReplacementIntervalDesc = 'REPLACEMENT_INTERVAL_DESC',
  SensorBaseTypeBySensorBaseTypeIdCreatedAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__CREATED_ASC',
  SensorBaseTypeBySensorBaseTypeIdCreatedDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__CREATED_DESC',
  SensorBaseTypeBySensorBaseTypeIdIdAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__ID_ASC',
  SensorBaseTypeBySensorBaseTypeIdIdDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__ID_DESC',
  SensorBaseTypeBySensorBaseTypeIdMaintenanceIntervalMonthsAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__MAINTENANCE_INTERVAL_MONTHS_ASC',
  SensorBaseTypeBySensorBaseTypeIdMaintenanceIntervalMonthsDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__MAINTENANCE_INTERVAL_MONTHS_DESC',
  SensorBaseTypeBySensorBaseTypeIdModifiedAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__MODIFIED_ASC',
  SensorBaseTypeBySensorBaseTypeIdModifiedDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__MODIFIED_DESC',
  SensorBaseTypeBySensorBaseTypeIdOwnerIdAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__OWNER_ID_ASC',
  SensorBaseTypeBySensorBaseTypeIdOwnerIdDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__OWNER_ID_DESC',
  SensorBaseTypeBySensorBaseTypeIdPrefixAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__PREFIX_ASC',
  SensorBaseTypeBySensorBaseTypeIdPrefixDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__PREFIX_DESC',
  SensorBaseTypeBySensorBaseTypeIdPrincipleIdAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__PRINCIPLE_ID_ASC',
  SensorBaseTypeBySensorBaseTypeIdPrincipleIdDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__PRINCIPLE_ID_DESC',
  SensorBaseTypeBySensorBaseTypeIdQuotationIntervalMonthsAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__QUOTATION_INTERVAL_MONTHS_ASC',
  SensorBaseTypeBySensorBaseTypeIdQuotationIntervalMonthsDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__QUOTATION_INTERVAL_MONTHS_DESC',
  SensorBaseTypeBySensorBaseTypeIdReplacementIntervalMonthsAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  SensorBaseTypeBySensorBaseTypeIdReplacementIntervalMonthsDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorBaseTypeBySensorBaseTypeIdSeriesAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__SERIES_ASC',
  SensorBaseTypeBySensorBaseTypeIdSeriesDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__SERIES_DESC',
  SensorBaseTypeBySensorBaseTypeIdSuffixAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__SUFFIX_ASC',
  SensorBaseTypeBySensorBaseTypeIdSuffixDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__SUFFIX_DESC',
  SensorBaseTypeBySensorBaseTypeIdVolumeAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__VOLUME_ASC',
  SensorBaseTypeBySensorBaseTypeIdVolumeDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__VOLUME_DESC',
  SensorBaseTypeIdAsc = 'SENSOR_BASE_TYPE_ID_ASC',
  SensorBaseTypeIdDesc = 'SENSOR_BASE_TYPE_ID_DESC',
  SensorElementsBySensorElementTypeIdCountAsc = 'SENSOR_ELEMENTS_BY_SENSOR_ELEMENT_TYPE_ID__COUNT_ASC',
  SensorElementsBySensorElementTypeIdCountDesc = 'SENSOR_ELEMENTS_BY_SENSOR_ELEMENT_TYPE_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A connection to a list of `SensorElement` values. */
export type SensorElementsConnection = {
  __typename?: 'SensorElementsConnection';
  /** A list of edges which contains the `SensorElement` and cursor to aid in pagination. */
  edges: Array<SensorElementsEdge>;
  /** A list of `SensorElement` objects. */
  nodes: Array<SensorElement>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorElement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorElement` edge in the connection. */
export type SensorElementsEdge = {
  __typename?: 'SensorElementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorElement` at the end of the edge. */
  node: SensorElement;
};

/** Methods to use when ordering `SensorElement`. */
export enum SensorElementsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelDateAsc = 'LABEL_DATE_ASC',
  LabelDateDesc = 'LABEL_DATE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorElementLocationBySensorElementIdCreatedAsc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__CREATED_ASC',
  SensorElementLocationBySensorElementIdCreatedDesc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__CREATED_DESC',
  SensorElementLocationBySensorElementIdDetectorSensorLocationIdAsc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__DETECTOR_SENSOR_LOCATION_ID_ASC',
  SensorElementLocationBySensorElementIdDetectorSensorLocationIdDesc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__DETECTOR_SENSOR_LOCATION_ID_DESC',
  SensorElementLocationBySensorElementIdIdAsc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__ID_ASC',
  SensorElementLocationBySensorElementIdIdDesc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__ID_DESC',
  SensorElementLocationBySensorElementIdModifiedAsc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__MODIFIED_ASC',
  SensorElementLocationBySensorElementIdModifiedDesc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__MODIFIED_DESC',
  SensorElementLocationBySensorElementIdOwnerIdAsc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__OWNER_ID_ASC',
  SensorElementLocationBySensorElementIdOwnerIdDesc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__OWNER_ID_DESC',
  SensorElementLocationBySensorElementIdSensorElementIdAsc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_ID_ASC',
  SensorElementLocationBySensorElementIdSensorElementIdDesc = 'SENSOR_ELEMENT_LOCATION_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_ID_DESC',
  SensorElementLogsBySensorElementIdCountAsc = 'SENSOR_ELEMENT_LOGS_BY_SENSOR_ELEMENT_ID__COUNT_ASC',
  SensorElementLogsBySensorElementIdCountDesc = 'SENSOR_ELEMENT_LOGS_BY_SENSOR_ELEMENT_ID__COUNT_DESC',
  SensorElementTypeBySensorElementTypeIdCalRangeIdAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__CAL_RANGE_ID_ASC',
  SensorElementTypeBySensorElementTypeIdCalRangeIdDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__CAL_RANGE_ID_DESC',
  SensorElementTypeBySensorElementTypeIdCreatedAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__CREATED_ASC',
  SensorElementTypeBySensorElementTypeIdCreatedDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__CREATED_DESC',
  SensorElementTypeBySensorElementTypeIdIdAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__ID_ASC',
  SensorElementTypeBySensorElementTypeIdIdDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__ID_DESC',
  SensorElementTypeBySensorElementTypeIdModifiedAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__MODIFIED_ASC',
  SensorElementTypeBySensorElementTypeIdModifiedDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__MODIFIED_DESC',
  SensorElementTypeBySensorElementTypeIdNameAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__NAME_ASC',
  SensorElementTypeBySensorElementTypeIdNameDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__NAME_DESC',
  SensorElementTypeBySensorElementTypeIdOwnerIdAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__OWNER_ID_ASC',
  SensorElementTypeBySensorElementTypeIdOwnerIdDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__OWNER_ID_DESC',
  SensorElementTypeBySensorElementTypeIdRangeIdAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__RANGE_ID_ASC',
  SensorElementTypeBySensorElementTypeIdRangeIdDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__RANGE_ID_DESC',
  SensorElementTypeBySensorElementTypeIdReplacementIntervalAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__REPLACEMENT_INTERVAL_ASC',
  SensorElementTypeBySensorElementTypeIdReplacementIntervalDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__REPLACEMENT_INTERVAL_DESC',
  SensorElementTypeBySensorElementTypeIdSensorBaseTypeIdAsc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__SENSOR_BASE_TYPE_ID_ASC',
  SensorElementTypeBySensorElementTypeIdSensorBaseTypeIdDesc = 'SENSOR_ELEMENT_TYPE_BY_SENSOR_ELEMENT_TYPE_ID__SENSOR_BASE_TYPE_ID_DESC',
  SensorElementTypeIdAsc = 'SENSOR_ELEMENT_TYPE_ID_ASC',
  SensorElementTypeIdDesc = 'SENSOR_ELEMENT_TYPE_ID_DESC',
  SensorSensorElementBySensorElementIdCreatedAsc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__CREATED_ASC',
  SensorSensorElementBySensorElementIdCreatedDesc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__CREATED_DESC',
  SensorSensorElementBySensorElementIdIdAsc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__ID_ASC',
  SensorSensorElementBySensorElementIdIdDesc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__ID_DESC',
  SensorSensorElementBySensorElementIdInstalledAsc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__INSTALLED_ASC',
  SensorSensorElementBySensorElementIdInstalledDesc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__INSTALLED_DESC',
  SensorSensorElementBySensorElementIdModifiedAsc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__MODIFIED_ASC',
  SensorSensorElementBySensorElementIdModifiedDesc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__MODIFIED_DESC',
  SensorSensorElementBySensorElementIdOwnerIdAsc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__OWNER_ID_ASC',
  SensorSensorElementBySensorElementIdOwnerIdDesc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__OWNER_ID_DESC',
  SensorSensorElementBySensorElementIdSensorElementIdAsc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_ID_ASC',
  SensorSensorElementBySensorElementIdSensorElementIdDesc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_ID_DESC',
  SensorSensorElementBySensorElementIdSensorIdAsc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ID_ASC',
  SensorSensorElementBySensorElementIdSensorIdDesc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ID_DESC',
  SensorSensorElementBySensorElementIdSensorPositionAsc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_POSITION_ASC',
  SensorSensorElementBySensorElementIdSensorPositionDesc = 'SENSOR_SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_POSITION_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A filter to be used against `Sensor` object types. All fields are combined with a logical ‘and.’ */
export type SensorFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorSensorBySensorId` relation. */
  detectorSensorBySensorId?: InputMaybe<DetectorSensorFilter>;
  /** A related `detectorSensorBySensorId` exists. */
  detectorSensorBySensorIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `labelDate` field. */
  labelDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `maintenanceVisitLinesByOriginalSensorId` relation. */
  maintenanceVisitLinesByOriginalSensorId?: InputMaybe<SensorToManyMaintenanceVisitLineFilter>;
  /** Some related `maintenanceVisitLinesByOriginalSensorId` exist. */
  maintenanceVisitLinesByOriginalSensorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `maintenanceVisitLinesBySensorId` relation. */
  maintenanceVisitLinesBySensorId?: InputMaybe<SensorToManyMaintenanceVisitLineFilter>;
  /** Some related `maintenanceVisitLinesBySensorId` exist. */
  maintenanceVisitLinesBySensorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reportSensorsBySensorId` relation. */
  reportSensorsBySensorId?: InputMaybe<SensorToManyReportSensorFilter>;
  /** Some related `reportSensorsBySensorId` exist. */
  reportSensorsBySensorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementLogsBySensorId` relation. */
  sensorElementLogsBySensorId?: InputMaybe<SensorToManySensorElementLogFilter>;
  /** Some related `sensorElementLogsBySensorId` exist. */
  sensorElementLogsBySensorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorOrdersBySensorId` relation. */
  sensorOrdersBySensorId?: InputMaybe<SensorToManySensorOrderFilter>;
  /** Some related `sensorOrdersBySensorId` exist. */
  sensorOrdersBySensorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorSensorElementsBySensorId` relation. */
  sensorSensorElementsBySensorId?: InputMaybe<SensorToManySensorSensorElementFilter>;
  /** Some related `sensorSensorElementsBySensorId` exist. */
  sensorSensorElementsBySensorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorTestResultsBySensorId` relation. */
  sensorTestResultsBySensorId?: InputMaybe<SensorToManySensorTestResultFilter>;
  /** Some related `sensorTestResultsBySensorId` exist. */
  sensorTestResultsBySensorIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorTypeBySensorTypeId` relation. */
  sensorTypeBySensorTypeId?: InputMaybe<SensorTypeFilter>;
  /** Filter by the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

export type SensorIndex = {
  __typename?: 'SensorIndex';
  createdDate?: Maybe<Scalars['String']['output']>;
  debiteurNaam?: Maybe<Scalars['String']['output']>;
  detectorSensorId?: Maybe<Scalars['Int']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  formattedLabelDate?: Maybe<Scalars['String']['output']>;
  gasName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  range?: Maybe<Scalars['String']['output']>;
  sensorType?: Maybe<Scalars['String']['output']>;
  sensorTypeId?: Maybe<Scalars['Int']['output']>;
  sensorTypeSort?: Maybe<Scalars['String']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `SensorIndex` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SensorIndexCondition = {
  /** Checks for equality with the object’s `createdDate` field. */
  createdDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `debiteurNaam` field. */
  debiteurNaam?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `formattedLabelDate` field. */
  formattedLabelDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gasName` field. */
  gasName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `label` field. */
  label?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `range` field. */
  range?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorType` field. */
  sensorType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorTypeSort` field. */
  sensorTypeSort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `SensorIndex` object types. All fields are combined with a logical ‘and.’ */
export type SensorIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorIndexFilter>>;
  /** Filter by the object’s `createdDate` field. */
  createdDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `debiteurNaam` field. */
  debiteurNaam?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detectorSensorId` field. */
  detectorSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `formattedLabelDate` field. */
  formattedLabelDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gasName` field. */
  gasName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `label` field. */
  label?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorIndexFilter>>;
  /** Filter by the object’s `range` field. */
  range?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorType` field. */
  sensorType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypeSort` field. */
  sensorTypeSort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
};

/** A connection to a list of `SensorIndex` values. */
export type SensorIndicesConnection = {
  __typename?: 'SensorIndicesConnection';
  /** A list of edges which contains the `SensorIndex` and cursor to aid in pagination. */
  edges: Array<SensorIndicesEdge>;
  /** A list of `SensorIndex` objects. */
  nodes: Array<SensorIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorIndex` edge in the connection. */
export type SensorIndicesEdge = {
  __typename?: 'SensorIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorIndex` at the end of the edge. */
  node: SensorIndex;
};

/** Methods to use when ordering `SensorIndex`. */
export enum SensorIndicesOrderBy {
  CreatedDateAsc = 'CREATED_DATE_ASC',
  CreatedDateDesc = 'CREATED_DATE_DESC',
  DebiteurNaamAsc = 'DEBITEUR_NAAM_ASC',
  DebiteurNaamDesc = 'DEBITEUR_NAAM_DESC',
  DetectorSensorIdAsc = 'DETECTOR_SENSOR_ID_ASC',
  DetectorSensorIdDesc = 'DETECTOR_SENSOR_ID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FormattedLabelDateAsc = 'FORMATTED_LABEL_DATE_ASC',
  FormattedLabelDateDesc = 'FORMATTED_LABEL_DATE_DESC',
  GasNameAsc = 'GAS_NAME_ASC',
  GasNameDesc = 'GAS_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelAsc = 'LABEL_ASC',
  LabelDesc = 'LABEL_DESC',
  Natural = 'NATURAL',
  RangeAsc = 'RANGE_ASC',
  RangeDesc = 'RANGE_DESC',
  SensorTypeAsc = 'SENSOR_TYPE_ASC',
  SensorTypeDesc = 'SENSOR_TYPE_DESC',
  SensorTypeIdAsc = 'SENSOR_TYPE_ID_ASC',
  SensorTypeIdDesc = 'SENSOR_TYPE_ID_DESC',
  SensorTypeSortAsc = 'SENSOR_TYPE_SORT_ASC',
  SensorTypeSortDesc = 'SENSOR_TYPE_SORT_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC'
}

export type SensorOrder = Node & {
  __typename?: 'SensorOrder';
  checkedUserId?: Maybe<Scalars['Int']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads a single `Factureeropdracht` that is related to this `SensorOrder`. */
  factureeropdrachtByFactuuropdracht?: Maybe<Factureeropdracht>;
  factuuropdracht: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `Sensor` that is related to this `SensorOrder`. */
  sensorBySensorId?: Maybe<Sensor>;
  sensorId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `SensorTestResult`. */
  sensorTestResultsBySensorOrderId: SensorTestResultsConnection;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByCheckedUserId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByVerifiedUserId?: Maybe<User>;
  verifiedUserId?: Maybe<Scalars['Int']['output']>;
};


export type SensorOrderSensorTestResultsBySensorOrderIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTestResultCondition>;
  filter?: InputMaybe<SensorTestResultFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};

/**
 * A condition to be used against `SensorOrder` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SensorOrderCondition = {
  /** Checks for equality with the object’s `checkedUserId` field. */
  checkedUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `verifiedUserId` field. */
  verifiedUserId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `SensorOrder` object types. All fields are combined with a logical ‘and.’ */
export type SensorOrderFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorOrderFilter>>;
  /** Filter by the object’s `checkedUserId` field. */
  checkedUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `factureeropdrachtByFactuuropdracht` relation. */
  factureeropdrachtByFactuuropdracht?: InputMaybe<FactureeropdrachtFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorOrderFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorOrderFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorBySensorId` relation. */
  sensorBySensorId?: InputMaybe<SensorFilter>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTestResultsBySensorOrderId` relation. */
  sensorTestResultsBySensorOrderId?: InputMaybe<SensorOrderToManySensorTestResultFilter>;
  /** Some related `sensorTestResultsBySensorOrderId` exist. */
  sensorTestResultsBySensorOrderIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByCheckedUserId` relation. */
  userByCheckedUserId?: InputMaybe<UserFilter>;
  /** A related `userByCheckedUserId` exists. */
  userByCheckedUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userByVerifiedUserId` relation. */
  userByVerifiedUserId?: InputMaybe<UserFilter>;
  /** A related `userByVerifiedUserId` exists. */
  userByVerifiedUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `verifiedUserId` field. */
  verifiedUserId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `SensorOrder` */
export type SensorOrderInput = {
  checkedUserId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  factuuropdracht: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  sensorId: Scalars['Int']['input'];
  verifiedUserId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `SensorOrder`. Fields that are set will be updated. */
export type SensorOrderPatch = {
  checkedUserId?: InputMaybe<Scalars['Int']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  verifiedUserId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `SensorTestResult` object types. All fields are combined with a logical ‘and.’ */
export type SensorOrderToManySensorTestResultFilter = {
  /** Every related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTestResultFilter>;
  /** No related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTestResultFilter>;
  /** Some related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTestResultFilter>;
};

/** A connection to a list of `SensorOrder` values. */
export type SensorOrdersConnection = {
  __typename?: 'SensorOrdersConnection';
  /** A list of edges which contains the `SensorOrder` and cursor to aid in pagination. */
  edges: Array<SensorOrdersEdge>;
  /** A list of `SensorOrder` objects. */
  nodes: Array<SensorOrder>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorOrder` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorOrder` edge in the connection. */
export type SensorOrdersEdge = {
  __typename?: 'SensorOrdersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorOrder` at the end of the edge. */
  node: SensorOrder;
};

/** Methods to use when ordering `SensorOrder`. */
export enum SensorOrdersOrderBy {
  CheckedUserIdAsc = 'CHECKED_USER_ID_ASC',
  CheckedUserIdDesc = 'CHECKED_USER_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  FactureeropdrachtByFactuuropdrachtAantalcolliAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AANTALCOLLI_ASC',
  FactureeropdrachtByFactuuropdrachtAantalcolliDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AANTALCOLLI_DESC',
  FactureeropdrachtByFactuuropdrachtAantalpalletsAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AANTALPALLETS_ASC',
  FactureeropdrachtByFactuuropdrachtAantalpalletsDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AANTALPALLETS_DESC',
  FactureeropdrachtByFactuuropdrachtAbonnementAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ABONNEMENT_ASC',
  FactureeropdrachtByFactuuropdrachtAbonnementDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ABONNEMENT_DESC',
  FactureeropdrachtByFactuuropdrachtAdresAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ADRES_ASC',
  FactureeropdrachtByFactuuropdrachtAdresDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ADRES_DESC',
  FactureeropdrachtByFactuuropdrachtAfdruktellerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AFDRUKTELLER_ASC',
  FactureeropdrachtByFactuuropdrachtAfdruktellerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__AFDRUKTELLER_DESC',
  FactureeropdrachtByFactuuropdrachtBehandelddoorAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BEHANDELDDOOR_ASC',
  FactureeropdrachtByFactuuropdrachtBehandelddoorDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BEHANDELDDOOR_DESC',
  FactureeropdrachtByFactuuropdrachtBetaaldbedrag1Asc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETAALDBEDRAG1_ASC',
  FactureeropdrachtByFactuuropdrachtBetaaldbedrag1Desc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETAALDBEDRAG1_DESC',
  FactureeropdrachtByFactuuropdrachtBetaaldbedrag2Asc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETAALDBEDRAG2_ASC',
  FactureeropdrachtByFactuuropdrachtBetaaldbedrag2Desc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETAALDBEDRAG2_DESC',
  FactureeropdrachtByFactuuropdrachtBetkenmerkAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETKENMERK_ASC',
  FactureeropdrachtByFactuuropdrachtBetkenmerkDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETKENMERK_DESC',
  FactureeropdrachtByFactuuropdrachtBetkortpercAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETKORTPERC_ASC',
  FactureeropdrachtByFactuuropdrachtBetkortpercDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BETKORTPERC_DESC',
  FactureeropdrachtByFactuuropdrachtBlokkerenAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BLOKKEREN_ASC',
  FactureeropdrachtByFactuuropdrachtBlokkerenDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BLOKKEREN_DESC',
  FactureeropdrachtByFactuuropdrachtBoekjaarAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BOEKJAAR_ASC',
  FactureeropdrachtByFactuuropdrachtBoekjaarDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BOEKJAAR_DESC',
  FactureeropdrachtByFactuuropdrachtBronAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BRON_ASC',
  FactureeropdrachtByFactuuropdrachtBronDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BRON_DESC',
  FactureeropdrachtByFactuuropdrachtBtwopkredbAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BTWOPKREDB_ASC',
  FactureeropdrachtByFactuuropdrachtBtwopkredbDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BTWOPKREDB_DESC',
  FactureeropdrachtByFactuuropdrachtBtwscenarioAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BTWSCENARIO_ASC',
  FactureeropdrachtByFactuuropdrachtBtwscenarioDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__BTWSCENARIO_DESC',
  FactureeropdrachtByFactuuropdrachtCdadresAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDADRES_ASC',
  FactureeropdrachtByFactuuropdrachtCdadresDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDADRES_DESC',
  FactureeropdrachtByFactuuropdrachtCdbehandelddoorAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBEHANDELDDOOR_ASC',
  FactureeropdrachtByFactuuropdrachtCdbehandelddoorDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBEHANDELDDOOR_DESC',
  FactureeropdrachtByFactuuropdrachtCdbestlandAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBESTLAND_ASC',
  FactureeropdrachtByFactuuropdrachtCdbestlandDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBESTLAND_DESC',
  FactureeropdrachtByFactuuropdrachtCdbetcondAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETCOND_ASC',
  FactureeropdrachtByFactuuropdrachtCdbetcondDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETCOND_DESC',
  FactureeropdrachtByFactuuropdrachtCdbetwijze1Asc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETWIJZE1_ASC',
  FactureeropdrachtByFactuuropdrachtCdbetwijze1Desc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETWIJZE1_DESC',
  FactureeropdrachtByFactuuropdrachtCdbetwijze2Asc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETWIJZE2_ASC',
  FactureeropdrachtByFactuuropdrachtCdbetwijze2Desc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBETWIJZE2_DESC',
  FactureeropdrachtByFactuuropdrachtCdbtwAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBTW_ASC',
  FactureeropdrachtByFactuuropdrachtCdbtwDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDBTW_DESC',
  FactureeropdrachtByFactuuropdrachtCddagboekAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDAGBOEK_ASC',
  FactureeropdrachtByFactuuropdrachtCddagboekDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDAGBOEK_DESC',
  FactureeropdrachtByFactuuropdrachtCddebiteurAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDEBITEUR_ASC',
  FactureeropdrachtByFactuuropdrachtCddebiteurDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDEBITEUR_DESC',
  FactureeropdrachtByFactuuropdrachtCddebiteurFactAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDEBITEUR_FACT_ASC',
  FactureeropdrachtByFactuuropdrachtCddebiteurFactDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDEBITEUR_FACT_DESC',
  FactureeropdrachtByFactuuropdrachtCddossierAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDOSSIER_ASC',
  FactureeropdrachtByFactuuropdrachtCddossierDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDDOSSIER_DESC',
  FactureeropdrachtByFactuuropdrachtCdexpediteurAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDEXPEDITEUR_ASC',
  FactureeropdrachtByFactuuropdrachtCdexpediteurDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDEXPEDITEUR_DESC',
  FactureeropdrachtByFactuuropdrachtCdfactuurAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDFACTUUR_ASC',
  FactureeropdrachtByFactuuropdrachtCdfactuurDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDFACTUUR_DESC',
  FactureeropdrachtByFactuuropdrachtCdfiatteurAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDFIATTEUR_ASC',
  FactureeropdrachtByFactuuropdrachtCdfiatteurDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDFIATTEUR_DESC',
  FactureeropdrachtByFactuuropdrachtCdkostenplaatsAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDKOSTENPLAATS_ASC',
  FactureeropdrachtByFactuuropdrachtCdkostenplaatsDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDKOSTENPLAATS_DESC',
  FactureeropdrachtByFactuuropdrachtCdlevcondAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDLEVCOND_ASC',
  FactureeropdrachtByFactuuropdrachtCdlevcondDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDLEVCOND_DESC',
  FactureeropdrachtByFactuuropdrachtCdloonwerkAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDLOONWERK_ASC',
  FactureeropdrachtByFactuuropdrachtCdloonwerkDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDLOONWERK_DESC',
  FactureeropdrachtByFactuuropdrachtCdpersoonAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDPERSOON_ASC',
  FactureeropdrachtByFactuuropdrachtCdpersoonDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDPERSOON_DESC',
  FactureeropdrachtByFactuuropdrachtCdprojectAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDPROJECT_ASC',
  FactureeropdrachtByFactuuropdrachtCdprojectDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDPROJECT_DESC',
  FactureeropdrachtByFactuuropdrachtCdsoortAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSOORT_ASC',
  FactureeropdrachtByFactuuropdrachtCdsoortDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSOORT_DESC',
  FactureeropdrachtByFactuuropdrachtCdstelselAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSTELSEL_ASC',
  FactureeropdrachtByFactuuropdrachtCdstelselDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSTELSEL_DESC',
  FactureeropdrachtByFactuuropdrachtCdstroomAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSTROOM_ASC',
  FactureeropdrachtByFactuuropdrachtCdstroomDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDSTROOM_DESC',
  FactureeropdrachtByFactuuropdrachtCdtypeAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDTYPE_ASC',
  FactureeropdrachtByFactuuropdrachtCdtypeDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDTYPE_DESC',
  FactureeropdrachtByFactuuropdrachtCdvalutaAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVALUTA_ASC',
  FactureeropdrachtByFactuuropdrachtCdvalutaDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVALUTA_DESC',
  FactureeropdrachtByFactuuropdrachtCdverkeerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERKEER_ASC',
  FactureeropdrachtByFactuuropdrachtCdverkeerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERKEER_DESC',
  FactureeropdrachtByFactuuropdrachtCdvertAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERT_ASC',
  FactureeropdrachtByFactuuropdrachtCdvertDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERT_DESC',
  FactureeropdrachtByFactuuropdrachtCdvervoerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERVOER_ASC',
  FactureeropdrachtByFactuuropdrachtCdvervoerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERVOER_DESC',
  FactureeropdrachtByFactuuropdrachtCdverzamelAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERZAMEL_ASC',
  FactureeropdrachtByFactuuropdrachtCdverzamelDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__CDVERZAMEL_DESC',
  FactureeropdrachtByFactuuropdrachtFacturerenAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUREREN_ASC',
  FactureeropdrachtByFactuuropdrachtFacturerenDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUREREN_DESC',
  FactureeropdrachtByFactuuropdrachtFactuurdatumAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUURDATUM_ASC',
  FactureeropdrachtByFactuuropdrachtFactuurdatumDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUURDATUM_DESC',
  FactureeropdrachtByFactuuropdrachtFactuurnummerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUURNUMMER_ASC',
  FactureeropdrachtByFactuuropdrachtFactuurnummerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUURNUMMER_DESC',
  FactureeropdrachtByFactuuropdrachtFactuuropdrachtAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUUROPDRACHT_ASC',
  FactureeropdrachtByFactuuropdrachtFactuuropdrachtDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__FACTUUROPDRACHT_DESC',
  FactureeropdrachtByFactuuropdrachtGebruikerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GEBRUIKER_ASC',
  FactureeropdrachtByFactuuropdrachtGebruikerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GEBRUIKER_DESC',
  FactureeropdrachtByFactuuropdrachtGefiatteerdAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GEFIATTEERD_ASC',
  FactureeropdrachtByFactuuropdrachtGefiatteerdDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GEFIATTEERD_DESC',
  FactureeropdrachtByFactuuropdrachtGuidItemAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GUID_ITEM_ASC',
  FactureeropdrachtByFactuuropdrachtGuidItemDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__GUID_ITEM_DESC',
  FactureeropdrachtByFactuuropdrachtKortingpercAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KORTINGPERC_ASC',
  FactureeropdrachtByFactuuropdrachtKortingpercDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KORTINGPERC_DESC',
  FactureeropdrachtByFactuuropdrachtKredbeppercAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KREDBEPPERC_ASC',
  FactureeropdrachtByFactuuropdrachtKredbeppercDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KREDBEPPERC_DESC',
  FactureeropdrachtByFactuuropdrachtKvcAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KVC_ASC',
  FactureeropdrachtByFactuuropdrachtKvcDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__KVC_DESC',
  FactureeropdrachtByFactuuropdrachtLidnrBijInkorgAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__LIDNR_BIJ_INKORG_ASC',
  FactureeropdrachtByFactuuropdrachtLidnrBijInkorgDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__LIDNR_BIJ_INKORG_DESC',
  FactureeropdrachtByFactuuropdrachtMagazijnbonAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__MAGAZIJNBON_ASC',
  FactureeropdrachtByFactuuropdrachtMagazijnbonDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__MAGAZIJNBON_DESC',
  FactureeropdrachtByFactuuropdrachtMargeblokkadeAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__MARGEBLOKKADE_ASC',
  FactureeropdrachtByFactuuropdrachtMargeblokkadeDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__MARGEBLOKKADE_DESC',
  FactureeropdrachtByFactuuropdrachtOffertenummerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OFFERTENUMMER_ASC',
  FactureeropdrachtByFactuuropdrachtOffertenummerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OFFERTENUMMER_DESC',
  FactureeropdrachtByFactuuropdrachtOffertevolgnrAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OFFERTEVOLGNR_ASC',
  FactureeropdrachtByFactuuropdrachtOffertevolgnrDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OFFERTEVOLGNR_DESC',
  FactureeropdrachtByFactuuropdrachtOpdrachtdatumAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OPDRACHTDATUM_ASC',
  FactureeropdrachtByFactuuropdrachtOpdrachtdatumDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__OPDRACHTDATUM_DESC',
  FactureeropdrachtByFactuuropdrachtOrdbevtellerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ORDBEVTELLER_ASC',
  FactureeropdrachtByFactuuropdrachtOrdbevtellerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__ORDBEVTELLER_DESC',
  FactureeropdrachtByFactuuropdrachtPakbonAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PAKBON_ASC',
  FactureeropdrachtByFactuuropdrachtPakbonDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PAKBON_DESC',
  FactureeropdrachtByFactuuropdrachtPercgrekAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERCGREK_ASC',
  FactureeropdrachtByFactuuropdrachtPercgrekDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERCGREK_DESC',
  FactureeropdrachtByFactuuropdrachtPeriodeAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERIODE_ASC',
  FactureeropdrachtByFactuuropdrachtPeriodeDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERIODE_DESC',
  FactureeropdrachtByFactuuropdrachtPersoonAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERSOON_ASC',
  FactureeropdrachtByFactuuropdrachtPersoonDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PERSOON_DESC',
  FactureeropdrachtByFactuuropdrachtProjFacturerenAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PROJ_FACTUREREN_ASC',
  FactureeropdrachtByFactuuropdrachtProjFacturerenDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__PROJ_FACTUREREN_DESC',
  FactureeropdrachtByFactuuropdrachtReferentieAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__REFERENTIE_ASC',
  FactureeropdrachtByFactuuropdrachtReferentieDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__REFERENTIE_DESC',
  FactureeropdrachtByFactuuropdrachtStatusAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__STATUS_ASC',
  FactureeropdrachtByFactuuropdrachtStatusDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__STATUS_DESC',
  FactureeropdrachtByFactuuropdrachtSubadresAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SUBADRES_ASC',
  FactureeropdrachtByFactuuropdrachtSubadresDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SUBADRES_DESC',
  FactureeropdrachtByFactuuropdrachtSysCreateAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SYS_CREATE_ASC',
  FactureeropdrachtByFactuuropdrachtSysCreateDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SYS_CREATE_DESC',
  FactureeropdrachtByFactuuropdrachtSysUpdateAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SYS_UPDATE_ASC',
  FactureeropdrachtByFactuuropdrachtSysUpdateDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__SYS_UPDATE_DESC',
  FactureeropdrachtByFactuuropdrachtTransactieAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__TRANSACTIE_ASC',
  FactureeropdrachtByFactuuropdrachtTransactieDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__TRANSACTIE_DESC',
  FactureeropdrachtByFactuuropdrachtVertegenwoordigerAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERTEGENWOORDIGER_ASC',
  FactureeropdrachtByFactuuropdrachtVertegenwoordigerDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERTEGENWOORDIGER_DESC',
  FactureeropdrachtByFactuuropdrachtVervolgopdrachtvanAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERVOLGOPDRACHTVAN_ASC',
  FactureeropdrachtByFactuuropdrachtVervolgopdrachtvanDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERVOLGOPDRACHTVAN_DESC',
  FactureeropdrachtByFactuuropdrachtVerwerktboAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERWERKTBO_ASC',
  FactureeropdrachtByFactuuropdrachtVerwerktboDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERWERKTBO_DESC',
  FactureeropdrachtByFactuuropdrachtVerwerktvrdAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERWERKTVRD_ASC',
  FactureeropdrachtByFactuuropdrachtVerwerktvrdDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VERWERKTVRD_DESC',
  FactureeropdrachtByFactuuropdrachtVrachtgewichtAsc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VRACHTGEWICHT_ASC',
  FactureeropdrachtByFactuuropdrachtVrachtgewichtDesc = 'FACTUREEROPDRACHT_BY_FACTUUROPDRACHT__VRACHTGEWICHT_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorBySensorIdCreatedAsc = 'SENSOR_BY_SENSOR_ID__CREATED_ASC',
  SensorBySensorIdCreatedDesc = 'SENSOR_BY_SENSOR_ID__CREATED_DESC',
  SensorBySensorIdIdAsc = 'SENSOR_BY_SENSOR_ID__ID_ASC',
  SensorBySensorIdIdDesc = 'SENSOR_BY_SENSOR_ID__ID_DESC',
  SensorBySensorIdLabelDateAsc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_ASC',
  SensorBySensorIdLabelDateDesc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_DESC',
  SensorBySensorIdModifiedAsc = 'SENSOR_BY_SENSOR_ID__MODIFIED_ASC',
  SensorBySensorIdModifiedDesc = 'SENSOR_BY_SENSOR_ID__MODIFIED_DESC',
  SensorBySensorIdOwnerIdAsc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_ASC',
  SensorBySensorIdOwnerIdDesc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_DESC',
  SensorBySensorIdRemarksAsc = 'SENSOR_BY_SENSOR_ID__REMARKS_ASC',
  SensorBySensorIdRemarksDesc = 'SENSOR_BY_SENSOR_ID__REMARKS_DESC',
  SensorBySensorIdSensorTypeIdAsc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_ASC',
  SensorBySensorIdSensorTypeIdDesc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_DESC',
  SensorBySensorIdSerialNumberAsc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_ASC',
  SensorBySensorIdSerialNumberDesc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  SensorTestResultsBySensorOrderIdCountAsc = 'SENSOR_TEST_RESULTS_BY_SENSOR_ORDER_ID__COUNT_ASC',
  SensorTestResultsBySensorOrderIdCountDesc = 'SENSOR_TEST_RESULTS_BY_SENSOR_ORDER_ID__COUNT_DESC',
  UserByCheckedUserIdCreatedAsc = 'USER_BY_CHECKED_USER_ID__CREATED_ASC',
  UserByCheckedUserIdCreatedDesc = 'USER_BY_CHECKED_USER_ID__CREATED_DESC',
  UserByCheckedUserIdFullnameAsc = 'USER_BY_CHECKED_USER_ID__FULLNAME_ASC',
  UserByCheckedUserIdFullnameDesc = 'USER_BY_CHECKED_USER_ID__FULLNAME_DESC',
  UserByCheckedUserIdGroupIdAsc = 'USER_BY_CHECKED_USER_ID__GROUP_ID_ASC',
  UserByCheckedUserIdGroupIdDesc = 'USER_BY_CHECKED_USER_ID__GROUP_ID_DESC',
  UserByCheckedUserIdHolidayStartBalanceAsc = 'USER_BY_CHECKED_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByCheckedUserIdHolidayStartBalanceDesc = 'USER_BY_CHECKED_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByCheckedUserIdIdAsc = 'USER_BY_CHECKED_USER_ID__ID_ASC',
  UserByCheckedUserIdIdDesc = 'USER_BY_CHECKED_USER_ID__ID_DESC',
  UserByCheckedUserIdInitialsAsc = 'USER_BY_CHECKED_USER_ID__INITIALS_ASC',
  UserByCheckedUserIdInitialsDesc = 'USER_BY_CHECKED_USER_ID__INITIALS_DESC',
  UserByCheckedUserIdModifiedAsc = 'USER_BY_CHECKED_USER_ID__MODIFIED_ASC',
  UserByCheckedUserIdModifiedDesc = 'USER_BY_CHECKED_USER_ID__MODIFIED_DESC',
  UserByCheckedUserIdOvertimeStartBalanceAsc = 'USER_BY_CHECKED_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByCheckedUserIdOvertimeStartBalanceDesc = 'USER_BY_CHECKED_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByCheckedUserIdPasswordAsc = 'USER_BY_CHECKED_USER_ID__PASSWORD_ASC',
  UserByCheckedUserIdPasswordDesc = 'USER_BY_CHECKED_USER_ID__PASSWORD_DESC',
  UserByCheckedUserIdUrlAsc = 'USER_BY_CHECKED_USER_ID__URL_ASC',
  UserByCheckedUserIdUrlDesc = 'USER_BY_CHECKED_USER_ID__URL_DESC',
  UserByCheckedUserIdUsernameAsc = 'USER_BY_CHECKED_USER_ID__USERNAME_ASC',
  UserByCheckedUserIdUsernameDesc = 'USER_BY_CHECKED_USER_ID__USERNAME_DESC',
  UserByCheckedUserIdWeeklyHoursFullAccessAsc = 'USER_BY_CHECKED_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByCheckedUserIdWeeklyHoursFullAccessDesc = 'USER_BY_CHECKED_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByVerifiedUserIdCreatedAsc = 'USER_BY_VERIFIED_USER_ID__CREATED_ASC',
  UserByVerifiedUserIdCreatedDesc = 'USER_BY_VERIFIED_USER_ID__CREATED_DESC',
  UserByVerifiedUserIdFullnameAsc = 'USER_BY_VERIFIED_USER_ID__FULLNAME_ASC',
  UserByVerifiedUserIdFullnameDesc = 'USER_BY_VERIFIED_USER_ID__FULLNAME_DESC',
  UserByVerifiedUserIdGroupIdAsc = 'USER_BY_VERIFIED_USER_ID__GROUP_ID_ASC',
  UserByVerifiedUserIdGroupIdDesc = 'USER_BY_VERIFIED_USER_ID__GROUP_ID_DESC',
  UserByVerifiedUserIdHolidayStartBalanceAsc = 'USER_BY_VERIFIED_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByVerifiedUserIdHolidayStartBalanceDesc = 'USER_BY_VERIFIED_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByVerifiedUserIdIdAsc = 'USER_BY_VERIFIED_USER_ID__ID_ASC',
  UserByVerifiedUserIdIdDesc = 'USER_BY_VERIFIED_USER_ID__ID_DESC',
  UserByVerifiedUserIdInitialsAsc = 'USER_BY_VERIFIED_USER_ID__INITIALS_ASC',
  UserByVerifiedUserIdInitialsDesc = 'USER_BY_VERIFIED_USER_ID__INITIALS_DESC',
  UserByVerifiedUserIdModifiedAsc = 'USER_BY_VERIFIED_USER_ID__MODIFIED_ASC',
  UserByVerifiedUserIdModifiedDesc = 'USER_BY_VERIFIED_USER_ID__MODIFIED_DESC',
  UserByVerifiedUserIdOvertimeStartBalanceAsc = 'USER_BY_VERIFIED_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByVerifiedUserIdOvertimeStartBalanceDesc = 'USER_BY_VERIFIED_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByVerifiedUserIdPasswordAsc = 'USER_BY_VERIFIED_USER_ID__PASSWORD_ASC',
  UserByVerifiedUserIdPasswordDesc = 'USER_BY_VERIFIED_USER_ID__PASSWORD_DESC',
  UserByVerifiedUserIdUrlAsc = 'USER_BY_VERIFIED_USER_ID__URL_ASC',
  UserByVerifiedUserIdUrlDesc = 'USER_BY_VERIFIED_USER_ID__URL_DESC',
  UserByVerifiedUserIdUsernameAsc = 'USER_BY_VERIFIED_USER_ID__USERNAME_ASC',
  UserByVerifiedUserIdUsernameDesc = 'USER_BY_VERIFIED_USER_ID__USERNAME_DESC',
  UserByVerifiedUserIdWeeklyHoursFullAccessAsc = 'USER_BY_VERIFIED_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByVerifiedUserIdWeeklyHoursFullAccessDesc = 'USER_BY_VERIFIED_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  VerifiedUserIdAsc = 'VERIFIED_USER_ID_ASC',
  VerifiedUserIdDesc = 'VERIFIED_USER_ID_DESC'
}

/** Represents an update to a `Sensor`. Fields that are set will be updated. */
export type SensorPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  labelDate?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
};

export type SensorSensorElement = Node & {
  __typename?: 'SensorSensorElement';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  installed?: Maybe<Scalars['Date']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `Sensor` that is related to this `SensorSensorElement`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` that is related to this `SensorSensorElement`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  sensorElementId: Scalars['Int']['output'];
  sensorId: Scalars['Int']['output'];
  sensorPosition: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `SensorSensorElement`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `SensorSensorElement` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type SensorSensorElementCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `installed` field. */
  installed?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorElementId` field. */
  sensorElementId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorPosition` field. */
  sensorPosition?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `SensorSensorElement` object types. All fields are combined with a logical ‘and.’ */
export type SensorSensorElementFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorSensorElementFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `installed` field. */
  installed?: InputMaybe<DateFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorSensorElementFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorSensorElementFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorBySensorId` relation. */
  sensorBySensorId?: InputMaybe<SensorFilter>;
  /** Filter by the object’s `sensorElementBySensorElementId` relation. */
  sensorElementBySensorElementId?: InputMaybe<SensorElementFilter>;
  /** Filter by the object’s `sensorElementId` field. */
  sensorElementId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorPosition` field. */
  sensorPosition?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `SensorSensorElement` */
export type SensorSensorElementInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  installed?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  sensorElementId: Scalars['Int']['input'];
  sensorId: Scalars['Int']['input'];
  sensorPosition: Scalars['Int']['input'];
};

/** Represents an update to a `SensorSensorElement`. Fields that are set will be updated. */
export type SensorSensorElementPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  installed?: InputMaybe<Scalars['Date']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sensorElementId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  sensorPosition?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `SensorSensorElement` values. */
export type SensorSensorElementsConnection = {
  __typename?: 'SensorSensorElementsConnection';
  /** A list of edges which contains the `SensorSensorElement` and cursor to aid in pagination. */
  edges: Array<SensorSensorElementsEdge>;
  /** A list of `SensorSensorElement` objects. */
  nodes: Array<SensorSensorElement>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorSensorElement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorSensorElement` edge in the connection. */
export type SensorSensorElementsEdge = {
  __typename?: 'SensorSensorElementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorSensorElement` at the end of the edge. */
  node: SensorSensorElement;
};

/** Methods to use when ordering `SensorSensorElement`. */
export enum SensorSensorElementsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InstalledAsc = 'INSTALLED_ASC',
  InstalledDesc = 'INSTALLED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorBySensorIdCreatedAsc = 'SENSOR_BY_SENSOR_ID__CREATED_ASC',
  SensorBySensorIdCreatedDesc = 'SENSOR_BY_SENSOR_ID__CREATED_DESC',
  SensorBySensorIdIdAsc = 'SENSOR_BY_SENSOR_ID__ID_ASC',
  SensorBySensorIdIdDesc = 'SENSOR_BY_SENSOR_ID__ID_DESC',
  SensorBySensorIdLabelDateAsc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_ASC',
  SensorBySensorIdLabelDateDesc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_DESC',
  SensorBySensorIdModifiedAsc = 'SENSOR_BY_SENSOR_ID__MODIFIED_ASC',
  SensorBySensorIdModifiedDesc = 'SENSOR_BY_SENSOR_ID__MODIFIED_DESC',
  SensorBySensorIdOwnerIdAsc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_ASC',
  SensorBySensorIdOwnerIdDesc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_DESC',
  SensorBySensorIdRemarksAsc = 'SENSOR_BY_SENSOR_ID__REMARKS_ASC',
  SensorBySensorIdRemarksDesc = 'SENSOR_BY_SENSOR_ID__REMARKS_DESC',
  SensorBySensorIdSensorTypeIdAsc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_ASC',
  SensorBySensorIdSensorTypeIdDesc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_DESC',
  SensorBySensorIdSerialNumberAsc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_ASC',
  SensorBySensorIdSerialNumberDesc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_DESC',
  SensorElementBySensorElementIdCreatedAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__CREATED_ASC',
  SensorElementBySensorElementIdCreatedDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__CREATED_DESC',
  SensorElementBySensorElementIdIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__ID_ASC',
  SensorElementBySensorElementIdIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__ID_DESC',
  SensorElementBySensorElementIdLabelDateAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__LABEL_DATE_ASC',
  SensorElementBySensorElementIdLabelDateDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__LABEL_DATE_DESC',
  SensorElementBySensorElementIdModifiedAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__MODIFIED_ASC',
  SensorElementBySensorElementIdModifiedDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__MODIFIED_DESC',
  SensorElementBySensorElementIdOwnerIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__OWNER_ID_ASC',
  SensorElementBySensorElementIdOwnerIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__OWNER_ID_DESC',
  SensorElementBySensorElementIdSensorElementTypeIdAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_TYPE_ID_ASC',
  SensorElementBySensorElementIdSensorElementTypeIdDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SENSOR_ELEMENT_TYPE_ID_DESC',
  SensorElementBySensorElementIdSerialNumberAsc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SERIAL_NUMBER_ASC',
  SensorElementBySensorElementIdSerialNumberDesc = 'SENSOR_ELEMENT_BY_SENSOR_ELEMENT_ID__SERIAL_NUMBER_DESC',
  SensorElementIdAsc = 'SENSOR_ELEMENT_ID_ASC',
  SensorElementIdDesc = 'SENSOR_ELEMENT_ID_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  SensorPositionAsc = 'SENSOR_POSITION_ASC',
  SensorPositionDesc = 'SENSOR_POSITION_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type SensorSetting = Node & {
  __typename?: 'SensorSetting';
  alarm1Current?: Maybe<Scalars['Int']['output']>;
  alarm1Direction?: Maybe<Scalars['Int']['output']>;
  alarm1Percentage?: Maybe<Scalars['BigFloat']['output']>;
  alarm1Units?: Maybe<Scalars['BigFloat']['output']>;
  alarm2Current?: Maybe<Scalars['Int']['output']>;
  alarm2Direction?: Maybe<Scalars['Int']['output']>;
  alarm2Percentage?: Maybe<Scalars['BigFloat']['output']>;
  alarm2Units?: Maybe<Scalars['BigFloat']['output']>;
  alarmUnits?: Maybe<Scalars['Int']['output']>;
  battConn?: Maybe<Scalars['String']['output']>;
  battery?: Maybe<Scalars['String']['output']>;
  byPassFlow?: Maybe<Scalars['BigFloat']['output']>;
  calFlow?: Maybe<Scalars['BigFloat']['output']>;
  electrolyte?: Maybe<Scalars['String']['output']>;
  flow?: Maybe<Scalars['BigFloat']['output']>;
  gas?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  max?: Maybe<Scalars['BigFloat']['output']>;
  membrane?: Maybe<Scalars['String']['output']>;
  min?: Maybe<Scalars['BigFloat']['output']>;
  nDec?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  oRing?: Maybe<Scalars['String']['output']>;
  plug?: Maybe<Scalars['String']['output']>;
  pyroType?: Maybe<Scalars['String']['output']>;
  pyroVoltage?: Maybe<Scalars['BigFloat']['output']>;
  restr?: Maybe<Scalars['String']['output']>;
  seal?: Maybe<Scalars['String']['output']>;
  span1K?: Maybe<Scalars['String']['output']>;
  span10K?: Maybe<Scalars['String']['output']>;
  span100K?: Maybe<Scalars['String']['output']>;
  sw4?: Maybe<Scalars['String']['output']>;
  sw5?: Maybe<Scalars['String']['output']>;
  sw6?: Maybe<Scalars['String']['output']>;
  target?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  typeTarget?: Maybe<Scalars['String']['output']>;
  units?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['String']['output']>;
  warningCurrent?: Maybe<Scalars['Int']['output']>;
  warningPercentageA1?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `SensorSetting` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SensorSettingCondition = {
  /** Checks for equality with the object’s `alarm1Current` field. */
  alarm1Current?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `alarm1Direction` field. */
  alarm1Direction?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `alarm1Percentage` field. */
  alarm1Percentage?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `alarm1Units` field. */
  alarm1Units?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `alarm2Current` field. */
  alarm2Current?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `alarm2Direction` field. */
  alarm2Direction?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `alarm2Percentage` field. */
  alarm2Percentage?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `alarm2Units` field. */
  alarm2Units?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `alarmUnits` field. */
  alarmUnits?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `battConn` field. */
  battConn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `battery` field. */
  battery?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `byPassFlow` field. */
  byPassFlow?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `calFlow` field. */
  calFlow?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `electrolyte` field. */
  electrolyte?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `flow` field. */
  flow?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `gas` field. */
  gas?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `max` field. */
  max?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `membrane` field. */
  membrane?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `min` field. */
  min?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `nDec` field. */
  nDec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `oRing` field. */
  oRing?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plug` field. */
  plug?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyroType` field. */
  pyroType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyroVoltage` field. */
  pyroVoltage?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `restr` field. */
  restr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `seal` field. */
  seal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `span1K` field. */
  span1K?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `span10K` field. */
  span10K?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `span100K` field. */
  span100K?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sw4` field. */
  sw4?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sw5` field. */
  sw5?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sw6` field. */
  sw6?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `target` field. */
  target?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `typeTarget` field. */
  typeTarget?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `units` field. */
  units?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `version` field. */
  version?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `warningCurrent` field. */
  warningCurrent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `warningPercentageA1` field. */
  warningPercentageA1?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `SensorSetting` object types. All fields are combined with a logical ‘and.’ */
export type SensorSettingFilter = {
  /** Filter by the object’s `alarm1Current` field. */
  alarm1Current?: InputMaybe<IntFilter>;
  /** Filter by the object’s `alarm1Direction` field. */
  alarm1Direction?: InputMaybe<IntFilter>;
  /** Filter by the object’s `alarm1Percentage` field. */
  alarm1Percentage?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `alarm1Units` field. */
  alarm1Units?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `alarm2Current` field. */
  alarm2Current?: InputMaybe<IntFilter>;
  /** Filter by the object’s `alarm2Direction` field. */
  alarm2Direction?: InputMaybe<IntFilter>;
  /** Filter by the object’s `alarm2Percentage` field. */
  alarm2Percentage?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `alarm2Units` field. */
  alarm2Units?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `alarmUnits` field. */
  alarmUnits?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorSettingFilter>>;
  /** Filter by the object’s `battConn` field. */
  battConn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `battery` field. */
  battery?: InputMaybe<StringFilter>;
  /** Filter by the object’s `byPassFlow` field. */
  byPassFlow?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `calFlow` field. */
  calFlow?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `electrolyte` field. */
  electrolyte?: InputMaybe<StringFilter>;
  /** Filter by the object’s `flow` field. */
  flow?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `gas` field. */
  gas?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `max` field. */
  max?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `membrane` field. */
  membrane?: InputMaybe<StringFilter>;
  /** Filter by the object’s `min` field. */
  min?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `nDec` field. */
  nDec?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorSettingFilter>;
  /** Filter by the object’s `oRing` field. */
  oRing?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorSettingFilter>>;
  /** Filter by the object’s `plug` field. */
  plug?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pyroType` field. */
  pyroType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pyroVoltage` field. */
  pyroVoltage?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `restr` field. */
  restr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `seal` field. */
  seal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `span1K` field. */
  span1K?: InputMaybe<StringFilter>;
  /** Filter by the object’s `span10K` field. */
  span10K?: InputMaybe<StringFilter>;
  /** Filter by the object’s `span100K` field. */
  span100K?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sw4` field. */
  sw4?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sw5` field. */
  sw5?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sw6` field. */
  sw6?: InputMaybe<StringFilter>;
  /** Filter by the object’s `target` field. */
  target?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `typeTarget` field. */
  typeTarget?: InputMaybe<StringFilter>;
  /** Filter by the object’s `units` field. */
  units?: InputMaybe<StringFilter>;
  /** Filter by the object’s `version` field. */
  version?: InputMaybe<StringFilter>;
  /** Filter by the object’s `warningCurrent` field. */
  warningCurrent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `warningPercentageA1` field. */
  warningPercentageA1?: InputMaybe<BigFloatFilter>;
};

/** An input for mutations affecting `SensorSetting` */
export type SensorSettingInput = {
  alarm1Current?: InputMaybe<Scalars['Int']['input']>;
  alarm1Direction?: InputMaybe<Scalars['Int']['input']>;
  alarm1Percentage?: InputMaybe<Scalars['BigFloat']['input']>;
  alarm1Units?: InputMaybe<Scalars['BigFloat']['input']>;
  alarm2Current?: InputMaybe<Scalars['Int']['input']>;
  alarm2Direction?: InputMaybe<Scalars['Int']['input']>;
  alarm2Percentage?: InputMaybe<Scalars['BigFloat']['input']>;
  alarm2Units?: InputMaybe<Scalars['BigFloat']['input']>;
  alarmUnits?: InputMaybe<Scalars['Int']['input']>;
  battConn?: InputMaybe<Scalars['String']['input']>;
  battery?: InputMaybe<Scalars['String']['input']>;
  byPassFlow?: InputMaybe<Scalars['BigFloat']['input']>;
  calFlow?: InputMaybe<Scalars['BigFloat']['input']>;
  electrolyte?: InputMaybe<Scalars['String']['input']>;
  flow?: InputMaybe<Scalars['BigFloat']['input']>;
  gas?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  max?: InputMaybe<Scalars['BigFloat']['input']>;
  membrane?: InputMaybe<Scalars['String']['input']>;
  min?: InputMaybe<Scalars['BigFloat']['input']>;
  nDec?: InputMaybe<Scalars['Int']['input']>;
  oRing?: InputMaybe<Scalars['String']['input']>;
  plug?: InputMaybe<Scalars['String']['input']>;
  pyroType?: InputMaybe<Scalars['String']['input']>;
  pyroVoltage?: InputMaybe<Scalars['BigFloat']['input']>;
  restr?: InputMaybe<Scalars['String']['input']>;
  seal?: InputMaybe<Scalars['String']['input']>;
  span1K?: InputMaybe<Scalars['String']['input']>;
  span10K?: InputMaybe<Scalars['String']['input']>;
  span100K?: InputMaybe<Scalars['String']['input']>;
  sw4?: InputMaybe<Scalars['String']['input']>;
  sw5?: InputMaybe<Scalars['String']['input']>;
  sw6?: InputMaybe<Scalars['String']['input']>;
  target?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  typeTarget?: InputMaybe<Scalars['String']['input']>;
  units?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
  warningCurrent?: InputMaybe<Scalars['Int']['input']>;
  warningPercentageA1?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** Represents an update to a `SensorSetting`. Fields that are set will be updated. */
export type SensorSettingPatch = {
  alarm1Current?: InputMaybe<Scalars['Int']['input']>;
  alarm1Direction?: InputMaybe<Scalars['Int']['input']>;
  alarm1Percentage?: InputMaybe<Scalars['BigFloat']['input']>;
  alarm1Units?: InputMaybe<Scalars['BigFloat']['input']>;
  alarm2Current?: InputMaybe<Scalars['Int']['input']>;
  alarm2Direction?: InputMaybe<Scalars['Int']['input']>;
  alarm2Percentage?: InputMaybe<Scalars['BigFloat']['input']>;
  alarm2Units?: InputMaybe<Scalars['BigFloat']['input']>;
  alarmUnits?: InputMaybe<Scalars['Int']['input']>;
  battConn?: InputMaybe<Scalars['String']['input']>;
  battery?: InputMaybe<Scalars['String']['input']>;
  byPassFlow?: InputMaybe<Scalars['BigFloat']['input']>;
  calFlow?: InputMaybe<Scalars['BigFloat']['input']>;
  electrolyte?: InputMaybe<Scalars['String']['input']>;
  flow?: InputMaybe<Scalars['BigFloat']['input']>;
  gas?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  max?: InputMaybe<Scalars['BigFloat']['input']>;
  membrane?: InputMaybe<Scalars['String']['input']>;
  min?: InputMaybe<Scalars['BigFloat']['input']>;
  nDec?: InputMaybe<Scalars['Int']['input']>;
  oRing?: InputMaybe<Scalars['String']['input']>;
  plug?: InputMaybe<Scalars['String']['input']>;
  pyroType?: InputMaybe<Scalars['String']['input']>;
  pyroVoltage?: InputMaybe<Scalars['BigFloat']['input']>;
  restr?: InputMaybe<Scalars['String']['input']>;
  seal?: InputMaybe<Scalars['String']['input']>;
  span1K?: InputMaybe<Scalars['String']['input']>;
  span10K?: InputMaybe<Scalars['String']['input']>;
  span100K?: InputMaybe<Scalars['String']['input']>;
  sw4?: InputMaybe<Scalars['String']['input']>;
  sw5?: InputMaybe<Scalars['String']['input']>;
  sw6?: InputMaybe<Scalars['String']['input']>;
  target?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  typeTarget?: InputMaybe<Scalars['String']['input']>;
  units?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
  warningCurrent?: InputMaybe<Scalars['Int']['input']>;
  warningPercentageA1?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A connection to a list of `SensorSetting` values. */
export type SensorSettingsConnection = {
  __typename?: 'SensorSettingsConnection';
  /** A list of edges which contains the `SensorSetting` and cursor to aid in pagination. */
  edges: Array<SensorSettingsEdge>;
  /** A list of `SensorSetting` objects. */
  nodes: Array<SensorSetting>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorSetting` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorSetting` edge in the connection. */
export type SensorSettingsEdge = {
  __typename?: 'SensorSettingsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorSetting` at the end of the edge. */
  node: SensorSetting;
};

/** Methods to use when ordering `SensorSetting`. */
export enum SensorSettingsOrderBy {
  Alarm_1CurrentAsc = 'ALARM_1_CURRENT_ASC',
  Alarm_1CurrentDesc = 'ALARM_1_CURRENT_DESC',
  Alarm_1DirectionAsc = 'ALARM_1_DIRECTION_ASC',
  Alarm_1DirectionDesc = 'ALARM_1_DIRECTION_DESC',
  Alarm_1PercentageAsc = 'ALARM_1_PERCENTAGE_ASC',
  Alarm_1PercentageDesc = 'ALARM_1_PERCENTAGE_DESC',
  Alarm_1UnitsAsc = 'ALARM_1_UNITS_ASC',
  Alarm_1UnitsDesc = 'ALARM_1_UNITS_DESC',
  Alarm_2CurrentAsc = 'ALARM_2_CURRENT_ASC',
  Alarm_2CurrentDesc = 'ALARM_2_CURRENT_DESC',
  Alarm_2DirectionAsc = 'ALARM_2_DIRECTION_ASC',
  Alarm_2DirectionDesc = 'ALARM_2_DIRECTION_DESC',
  Alarm_2PercentageAsc = 'ALARM_2_PERCENTAGE_ASC',
  Alarm_2PercentageDesc = 'ALARM_2_PERCENTAGE_DESC',
  Alarm_2UnitsAsc = 'ALARM_2_UNITS_ASC',
  Alarm_2UnitsDesc = 'ALARM_2_UNITS_DESC',
  AlarmUnitsAsc = 'ALARM_UNITS_ASC',
  AlarmUnitsDesc = 'ALARM_UNITS_DESC',
  BatteryAsc = 'BATTERY_ASC',
  BatteryDesc = 'BATTERY_DESC',
  BattConnAsc = 'BATT_CONN_ASC',
  BattConnDesc = 'BATT_CONN_DESC',
  ByPassFlowAsc = 'BY_PASS_FLOW_ASC',
  ByPassFlowDesc = 'BY_PASS_FLOW_DESC',
  CalFlowAsc = 'CAL_FLOW_ASC',
  CalFlowDesc = 'CAL_FLOW_DESC',
  ElectrolyteAsc = 'ELECTROLYTE_ASC',
  ElectrolyteDesc = 'ELECTROLYTE_DESC',
  FlowAsc = 'FLOW_ASC',
  FlowDesc = 'FLOW_DESC',
  GasAsc = 'GAS_ASC',
  GasDesc = 'GAS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaxAsc = 'MAX_ASC',
  MaxDesc = 'MAX_DESC',
  MembraneAsc = 'MEMBRANE_ASC',
  MembraneDesc = 'MEMBRANE_DESC',
  MinAsc = 'MIN_ASC',
  MinDesc = 'MIN_DESC',
  Natural = 'NATURAL',
  NDecAsc = 'N_DEC_ASC',
  NDecDesc = 'N_DEC_DESC',
  ORingAsc = 'O_RING_ASC',
  ORingDesc = 'O_RING_DESC',
  PlugAsc = 'PLUG_ASC',
  PlugDesc = 'PLUG_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PyroTypeAsc = 'PYRO_TYPE_ASC',
  PyroTypeDesc = 'PYRO_TYPE_DESC',
  PyroVoltageAsc = 'PYRO_VOLTAGE_ASC',
  PyroVoltageDesc = 'PYRO_VOLTAGE_DESC',
  RestrAsc = 'RESTR_ASC',
  RestrDesc = 'RESTR_DESC',
  SealAsc = 'SEAL_ASC',
  SealDesc = 'SEAL_DESC',
  Span_1KAsc = 'SPAN_1K_ASC',
  Span_1KDesc = 'SPAN_1K_DESC',
  Span_10KAsc = 'SPAN_10K_ASC',
  Span_10KDesc = 'SPAN_10K_DESC',
  Span_100KAsc = 'SPAN_100K_ASC',
  Span_100KDesc = 'SPAN_100K_DESC',
  Sw4Asc = 'SW4_ASC',
  Sw4Desc = 'SW4_DESC',
  Sw5Asc = 'SW5_ASC',
  Sw5Desc = 'SW5_DESC',
  Sw6Asc = 'SW6_ASC',
  Sw6Desc = 'SW6_DESC',
  TargetAsc = 'TARGET_ASC',
  TargetDesc = 'TARGET_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  TypeTargetAsc = 'TYPE_TARGET_ASC',
  TypeTargetDesc = 'TYPE_TARGET_DESC',
  UnitsAsc = 'UNITS_ASC',
  UnitsDesc = 'UNITS_DESC',
  VersionAsc = 'VERSION_ASC',
  VersionDesc = 'VERSION_DESC',
  WarningCurrentAsc = 'WARNING_CURRENT_ASC',
  WarningCurrentDesc = 'WARNING_CURRENT_DESC',
  WarningPercentageA_1Asc = 'WARNING_PERCENTAGE_A_1_ASC',
  WarningPercentageA_1Desc = 'WARNING_PERCENTAGE_A_1_DESC'
}

export type SensorTestResult = Node & {
  __typename?: 'SensorTestResult';
  /** Reads a single `CalGas` that is related to this `SensorTestResult`. */
  calGasByFsCalGasId?: Maybe<CalGas>;
  created?: Maybe<Scalars['Datetime']['output']>;
  date?: Maybe<Scalars['Date']['output']>;
  factuuropdrachtOld?: Maybe<Scalars['String']['output']>;
  fsCalGasId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads a single `Sensor` that is related to this `SensorTestResult`. */
  sensorBySensorId?: Maybe<Sensor>;
  sensorId: Scalars['Int']['output'];
  /** Reads a single `SensorOrder` that is related to this `SensorTestResult`. */
  sensorOrderBySensorOrderId?: Maybe<SensorOrder>;
  sensorOrderId?: Maybe<Scalars['Int']['output']>;
  spanResponse: Scalars['Float']['output'];
  usedSpanConcentration?: Maybe<Scalars['Float']['output']>;
  /** Reads a single `User` that is related to this `SensorTestResult`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorTestResult`. */
  userByUserId?: Maybe<User>;
  userId: Scalars['Int']['output'];
  zeroResponse: Scalars['Float']['output'];
};

/**
 * A condition to be used against `SensorTestResult` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SensorTestResultCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `factuuropdrachtOld` field. */
  factuuropdrachtOld?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fsCalGasId` field. */
  fsCalGasId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorOrderId` field. */
  sensorOrderId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `spanResponse` field. */
  spanResponse?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `usedSpanConcentration` field. */
  usedSpanConcentration?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `zeroResponse` field. */
  zeroResponse?: InputMaybe<Scalars['Float']['input']>;
};

/** A filter to be used against `SensorTestResult` object types. All fields are combined with a logical ‘and.’ */
export type SensorTestResultFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorTestResultFilter>>;
  /** Filter by the object’s `calGasByFsCalGasId` relation. */
  calGasByFsCalGasId?: InputMaybe<CalGasFilter>;
  /** A related `calGasByFsCalGasId` exists. */
  calGasByFsCalGasIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Filter by the object’s `factuuropdrachtOld` field. */
  factuuropdrachtOld?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fsCalGasId` field. */
  fsCalGasId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorTestResultFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorTestResultFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorBySensorId` relation. */
  sensorBySensorId?: InputMaybe<SensorFilter>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorOrderBySensorOrderId` relation. */
  sensorOrderBySensorOrderId?: InputMaybe<SensorOrderFilter>;
  /** A related `sensorOrderBySensorOrderId` exists. */
  sensorOrderBySensorOrderIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorOrderId` field. */
  sensorOrderId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `spanResponse` field. */
  spanResponse?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `usedSpanConcentration` field. */
  usedSpanConcentration?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `zeroResponse` field. */
  zeroResponse?: InputMaybe<FloatFilter>;
};

/** An input for mutations affecting `SensorTestResult` */
export type SensorTestResultInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  factuuropdrachtOld?: InputMaybe<Scalars['String']['input']>;
  fsCalGasId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  sensorId: Scalars['Int']['input'];
  sensorOrderId?: InputMaybe<Scalars['Int']['input']>;
  spanResponse: Scalars['Float']['input'];
  usedSpanConcentration?: InputMaybe<Scalars['Float']['input']>;
  userId: Scalars['Int']['input'];
  zeroResponse: Scalars['Float']['input'];
};

/** Represents an update to a `SensorTestResult`. Fields that are set will be updated. */
export type SensorTestResultPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  factuuropdrachtOld?: InputMaybe<Scalars['String']['input']>;
  fsCalGasId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  sensorOrderId?: InputMaybe<Scalars['Int']['input']>;
  spanResponse?: InputMaybe<Scalars['Float']['input']>;
  usedSpanConcentration?: InputMaybe<Scalars['Float']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  zeroResponse?: InputMaybe<Scalars['Float']['input']>;
};

/** A connection to a list of `SensorTestResult` values. */
export type SensorTestResultsConnection = {
  __typename?: 'SensorTestResultsConnection';
  /** A list of edges which contains the `SensorTestResult` and cursor to aid in pagination. */
  edges: Array<SensorTestResultsEdge>;
  /** A list of `SensorTestResult` objects. */
  nodes: Array<SensorTestResult>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorTestResult` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorTestResult` edge in the connection. */
export type SensorTestResultsEdge = {
  __typename?: 'SensorTestResultsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorTestResult` at the end of the edge. */
  node: SensorTestResult;
};

/** Methods to use when ordering `SensorTestResult`. */
export enum SensorTestResultsOrderBy {
  CalGasByFsCalGasIdCdartikelAsc = 'CAL_GAS_BY_FS_CAL_GAS_ID__CDARTIKEL_ASC',
  CalGasByFsCalGasIdCdartikelDesc = 'CAL_GAS_BY_FS_CAL_GAS_ID__CDARTIKEL_DESC',
  CalGasByFsCalGasIdConcentrationAsc = 'CAL_GAS_BY_FS_CAL_GAS_ID__CONCENTRATION_ASC',
  CalGasByFsCalGasIdConcentrationDesc = 'CAL_GAS_BY_FS_CAL_GAS_ID__CONCENTRATION_DESC',
  CalGasByFsCalGasIdCreatedAsc = 'CAL_GAS_BY_FS_CAL_GAS_ID__CREATED_ASC',
  CalGasByFsCalGasIdCreatedDesc = 'CAL_GAS_BY_FS_CAL_GAS_ID__CREATED_DESC',
  CalGasByFsCalGasIdEngineeringUnitsAsc = 'CAL_GAS_BY_FS_CAL_GAS_ID__ENGINEERING_UNITS_ASC',
  CalGasByFsCalGasIdEngineeringUnitsDesc = 'CAL_GAS_BY_FS_CAL_GAS_ID__ENGINEERING_UNITS_DESC',
  CalGasByFsCalGasIdGasIdAsc = 'CAL_GAS_BY_FS_CAL_GAS_ID__GAS_ID_ASC',
  CalGasByFsCalGasIdGasIdDesc = 'CAL_GAS_BY_FS_CAL_GAS_ID__GAS_ID_DESC',
  CalGasByFsCalGasIdIdAsc = 'CAL_GAS_BY_FS_CAL_GAS_ID__ID_ASC',
  CalGasByFsCalGasIdIdDesc = 'CAL_GAS_BY_FS_CAL_GAS_ID__ID_DESC',
  CalGasByFsCalGasIdModifiedAsc = 'CAL_GAS_BY_FS_CAL_GAS_ID__MODIFIED_ASC',
  CalGasByFsCalGasIdModifiedDesc = 'CAL_GAS_BY_FS_CAL_GAS_ID__MODIFIED_DESC',
  CalGasByFsCalGasIdOwnerIdAsc = 'CAL_GAS_BY_FS_CAL_GAS_ID__OWNER_ID_ASC',
  CalGasByFsCalGasIdOwnerIdDesc = 'CAL_GAS_BY_FS_CAL_GAS_ID__OWNER_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  FactuuropdrachtOldAsc = 'FACTUUROPDRACHT_OLD_ASC',
  FactuuropdrachtOldDesc = 'FACTUUROPDRACHT_OLD_DESC',
  FsCalGasIdAsc = 'FS_CAL_GAS_ID_ASC',
  FsCalGasIdDesc = 'FS_CAL_GAS_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SensorBySensorIdCreatedAsc = 'SENSOR_BY_SENSOR_ID__CREATED_ASC',
  SensorBySensorIdCreatedDesc = 'SENSOR_BY_SENSOR_ID__CREATED_DESC',
  SensorBySensorIdIdAsc = 'SENSOR_BY_SENSOR_ID__ID_ASC',
  SensorBySensorIdIdDesc = 'SENSOR_BY_SENSOR_ID__ID_DESC',
  SensorBySensorIdLabelDateAsc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_ASC',
  SensorBySensorIdLabelDateDesc = 'SENSOR_BY_SENSOR_ID__LABEL_DATE_DESC',
  SensorBySensorIdModifiedAsc = 'SENSOR_BY_SENSOR_ID__MODIFIED_ASC',
  SensorBySensorIdModifiedDesc = 'SENSOR_BY_SENSOR_ID__MODIFIED_DESC',
  SensorBySensorIdOwnerIdAsc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_ASC',
  SensorBySensorIdOwnerIdDesc = 'SENSOR_BY_SENSOR_ID__OWNER_ID_DESC',
  SensorBySensorIdRemarksAsc = 'SENSOR_BY_SENSOR_ID__REMARKS_ASC',
  SensorBySensorIdRemarksDesc = 'SENSOR_BY_SENSOR_ID__REMARKS_DESC',
  SensorBySensorIdSensorTypeIdAsc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_ASC',
  SensorBySensorIdSensorTypeIdDesc = 'SENSOR_BY_SENSOR_ID__SENSOR_TYPE_ID_DESC',
  SensorBySensorIdSerialNumberAsc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_ASC',
  SensorBySensorIdSerialNumberDesc = 'SENSOR_BY_SENSOR_ID__SERIAL_NUMBER_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  SensorOrderBySensorOrderIdCheckedUserIdAsc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__CHECKED_USER_ID_ASC',
  SensorOrderBySensorOrderIdCheckedUserIdDesc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__CHECKED_USER_ID_DESC',
  SensorOrderBySensorOrderIdCreatedAsc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__CREATED_ASC',
  SensorOrderBySensorOrderIdCreatedDesc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__CREATED_DESC',
  SensorOrderBySensorOrderIdFactuuropdrachtAsc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__FACTUUROPDRACHT_ASC',
  SensorOrderBySensorOrderIdFactuuropdrachtDesc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__FACTUUROPDRACHT_DESC',
  SensorOrderBySensorOrderIdIdAsc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__ID_ASC',
  SensorOrderBySensorOrderIdIdDesc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__ID_DESC',
  SensorOrderBySensorOrderIdModifiedAsc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__MODIFIED_ASC',
  SensorOrderBySensorOrderIdModifiedDesc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__MODIFIED_DESC',
  SensorOrderBySensorOrderIdOwnerIdAsc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__OWNER_ID_ASC',
  SensorOrderBySensorOrderIdOwnerIdDesc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__OWNER_ID_DESC',
  SensorOrderBySensorOrderIdSensorIdAsc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__SENSOR_ID_ASC',
  SensorOrderBySensorOrderIdSensorIdDesc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__SENSOR_ID_DESC',
  SensorOrderBySensorOrderIdVerifiedUserIdAsc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__VERIFIED_USER_ID_ASC',
  SensorOrderBySensorOrderIdVerifiedUserIdDesc = 'SENSOR_ORDER_BY_SENSOR_ORDER_ID__VERIFIED_USER_ID_DESC',
  SensorOrderIdAsc = 'SENSOR_ORDER_ID_ASC',
  SensorOrderIdDesc = 'SENSOR_ORDER_ID_DESC',
  SpanResponseAsc = 'SPAN_RESPONSE_ASC',
  SpanResponseDesc = 'SPAN_RESPONSE_DESC',
  UsedSpanConcentrationAsc = 'USED_SPAN_CONCENTRATION_ASC',
  UsedSpanConcentrationDesc = 'USED_SPAN_CONCENTRATION_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  ZeroResponseAsc = 'ZERO_RESPONSE_ASC',
  ZeroResponseDesc = 'ZERO_RESPONSE_DESC'
}

/** A filter to be used against many `MaintenanceVisitLine` object types. All fields are combined with a logical ‘and.’ */
export type SensorToManyMaintenanceVisitLineFilter = {
  /** Every related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitLineFilter>;
  /** No related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitLineFilter>;
  /** Some related `MaintenanceVisitLine` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitLineFilter>;
};

/** A filter to be used against many `ReportSensor` object types. All fields are combined with a logical ‘and.’ */
export type SensorToManyReportSensorFilter = {
  /** Every related `ReportSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReportSensorFilter>;
  /** No related `ReportSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReportSensorFilter>;
  /** Some related `ReportSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReportSensorFilter>;
};

/** A filter to be used against many `SensorElementLog` object types. All fields are combined with a logical ‘and.’ */
export type SensorToManySensorElementLogFilter = {
  /** Every related `SensorElementLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementLogFilter>;
  /** No related `SensorElementLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementLogFilter>;
  /** Some related `SensorElementLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementLogFilter>;
};

/** A filter to be used against many `SensorOrder` object types. All fields are combined with a logical ‘and.’ */
export type SensorToManySensorOrderFilter = {
  /** Every related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorOrderFilter>;
  /** No related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorOrderFilter>;
  /** Some related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorOrderFilter>;
};

/** A filter to be used against many `SensorSensorElement` object types. All fields are combined with a logical ‘and.’ */
export type SensorToManySensorSensorElementFilter = {
  /** Every related `SensorSensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorSensorElementFilter>;
  /** No related `SensorSensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorSensorElementFilter>;
  /** Some related `SensorSensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorSensorElementFilter>;
};

/** A filter to be used against many `SensorTestResult` object types. All fields are combined with a logical ‘and.’ */
export type SensorToManySensorTestResultFilter = {
  /** Every related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTestResultFilter>;
  /** No related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTestResultFilter>;
  /** Some related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTestResultFilter>;
};

export type SensorType = Node & {
  __typename?: 'SensorType';
  battery?: Maybe<Scalars['Boolean']['output']>;
  biasMv?: Maybe<Scalars['Int']['output']>;
  calFlowRate?: Maybe<Scalars['Float']['output']>;
  /** Reads a single `CalGas` that is related to this `SensorType`. */
  calGasByCalGasId?: Maybe<CalGas>;
  calGasId: Scalars['Int']['output'];
  calResponse: Scalars['Float']['output'];
  cdartikel?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DetectorSensorType`. */
  detectorSensorTypesBySensorTypeId: DetectorSensorTypesConnection;
  direction?: Maybe<Scalars['Boolean']['output']>;
  electrodeCount?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Electrolyte` that is related to this `SensorType`. */
  electrolyteByElectrolyteId?: Maybe<Electrolyte>;
  electrolyteId?: Maybe<Scalars['Int']['output']>;
  elementCount?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Filter` that is related to this `SensorType`. */
  filterByFilterId?: Maybe<Filter>;
  filterId?: Maybe<Scalars['Int']['output']>;
  flowRate?: Maybe<Scalars['Float']['output']>;
  fullType?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  lowElectrolyte?: Maybe<Scalars['Boolean']['output']>;
  maintenanceIntervalMonths?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Membrane` that is related to this `SensorType`. */
  membraneByMembraneId?: Maybe<Membrane>;
  membraneId?: Maybe<Scalars['Int']['output']>;
  membraneSeal?: Maybe<Scalars['Boolean']['output']>;
  model: Scalars['String']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `ORing` that is related to this `SensorType`. */
  oRingByORingId?: Maybe<ORing>;
  oRingId?: Maybe<Scalars['Int']['output']>;
  obsolete?: Maybe<Scalars['Boolean']['output']>;
  ownerId: Scalars['Int']['output'];
  /** Reads a single `Plug` that is related to this `SensorType`. */
  plugByPlugId?: Maybe<Plug>;
  plugId?: Maybe<Scalars['Int']['output']>;
  principleId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Pyrolyser` that is related to this `SensorType`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  pyrolyserId?: Maybe<Scalars['Int']['output']>;
  pyrolyserVoltage?: Maybe<Scalars['Float']['output']>;
  /** Reads a single `Range` that is related to this `SensorType`. */
  rangeByRangeId?: Maybe<Range>;
  rangeId: Scalars['Int']['output'];
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  restrictor?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `SensorBaseType` that is related to this `SensorType`. */
  sensorBaseTypeBySensorBaseTypeId?: Maybe<SensorBaseType>;
  sensorBaseTypeId: Scalars['Int']['output'];
  sensorTypeId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Sensor`. */
  sensorsBySensorTypeId: SensorsConnection;
  siliconeSheet?: Maybe<Scalars['Boolean']['output']>;
  spanResistor?: Maybe<Scalars['BigFloat']['output']>;
  transportSwitch?: Maybe<Scalars['Boolean']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `SensorType`. */
  userByOwnerId?: Maybe<User>;
  volume?: Maybe<Scalars['Int']['output']>;
};


export type SensorTypeDetectorSensorTypesBySensorTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorTypeCondition>;
  filter?: InputMaybe<DetectorSensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorTypesOrderBy>>;
};


export type SensorTypeSensorsBySensorTypeIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorCondition>;
  filter?: InputMaybe<SensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorsOrderBy>>;
};

/**
 * A condition to be used against `SensorType` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SensorTypeCondition = {
  /** Checks for equality with the object’s `battery` field. */
  battery?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `biasMv` field. */
  biasMv?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `calGasId` field. */
  calGasId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `calResponse` field. */
  calResponse?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `direction` field. */
  direction?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `electrodeCount` field. */
  electrodeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `electrolyteId` field. */
  electrolyteId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `elementCount` field. */
  elementCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `filterId` field. */
  filterId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `flowRate` field. */
  flowRate?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lowElectrolyte` field. */
  lowElectrolyte?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `maintenanceIntervalMonths` field. */
  maintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `membraneId` field. */
  membraneId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `membraneSeal` field. */
  membraneSeal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `model` field. */
  model?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `oRingId` field. */
  oRingId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `obsolete` field. */
  obsolete?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `plugId` field. */
  plugId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `principleId` field. */
  principleId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserVoltage` field. */
  pyrolyserVoltage?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `rangeId` field. */
  rangeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `restrictor` field. */
  restrictor?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `sensorBaseTypeId` field. */
  sensorBaseTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `siliconeSheet` field. */
  siliconeSheet?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `spanResistor` field. */
  spanResistor?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `transportSwitch` field. */
  transportSwitch?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `volume` field. */
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type SensorTypeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorTypeFilter>>;
  /** Filter by the object’s `battery` field. */
  battery?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `biasMv` field. */
  biasMv?: InputMaybe<IntFilter>;
  /** Filter by the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `calGasByCalGasId` relation. */
  calGasByCalGasId?: InputMaybe<CalGasFilter>;
  /** Filter by the object’s `calGasId` field. */
  calGasId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `calResponse` field. */
  calResponse?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorSensorTypesBySensorTypeId` relation. */
  detectorSensorTypesBySensorTypeId?: InputMaybe<SensorTypeToManyDetectorSensorTypeFilter>;
  /** Some related `detectorSensorTypesBySensorTypeId` exist. */
  detectorSensorTypesBySensorTypeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `direction` field. */
  direction?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `electrodeCount` field. */
  electrodeCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `electrolyteByElectrolyteId` relation. */
  electrolyteByElectrolyteId?: InputMaybe<ElectrolyteFilter>;
  /** A related `electrolyteByElectrolyteId` exists. */
  electrolyteByElectrolyteIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `electrolyteId` field. */
  electrolyteId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `elementCount` field. */
  elementCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `filterByFilterId` relation. */
  filterByFilterId?: InputMaybe<FilterFilter>;
  /** A related `filterByFilterId` exists. */
  filterByFilterIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `filterId` field. */
  filterId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `flowRate` field. */
  flowRate?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `fullType` field. */
  fullType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lowElectrolyte` field. */
  lowElectrolyte?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `maintenanceIntervalMonths` field. */
  maintenanceIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `membraneByMembraneId` relation. */
  membraneByMembraneId?: InputMaybe<MembraneFilter>;
  /** A related `membraneByMembraneId` exists. */
  membraneByMembraneIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `membraneId` field. */
  membraneId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `membraneSeal` field. */
  membraneSeal?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `model` field. */
  model?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorTypeFilter>;
  /** Filter by the object’s `oRingByORingId` relation. */
  oRingByORingId?: InputMaybe<ORingFilter>;
  /** A related `oRingByORingId` exists. */
  oRingByORingIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `oRingId` field. */
  oRingId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `obsolete` field. */
  obsolete?: InputMaybe<BooleanFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorTypeFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `plugByPlugId` relation. */
  plugByPlugId?: InputMaybe<PlugFilter>;
  /** A related `plugByPlugId` exists. */
  plugByPlugIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `plugId` field. */
  plugId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `principleId` field. */
  principleId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pyrolyserByPyrolyserId` relation. */
  pyrolyserByPyrolyserId?: InputMaybe<PyrolyserFilter>;
  /** A related `pyrolyserByPyrolyserId` exists. */
  pyrolyserByPyrolyserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pyrolyserVoltage` field. */
  pyrolyserVoltage?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `rangeByRangeId` relation. */
  rangeByRangeId?: InputMaybe<RangeFilter>;
  /** Filter by the object’s `rangeId` field. */
  rangeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `restrictor` field. */
  restrictor?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `sensorBaseTypeBySensorBaseTypeId` relation. */
  sensorBaseTypeBySensorBaseTypeId?: InputMaybe<SensorBaseTypeFilter>;
  /** Filter by the object’s `sensorBaseTypeId` field. */
  sensorBaseTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorsBySensorTypeId` relation. */
  sensorsBySensorTypeId?: InputMaybe<SensorTypeToManySensorFilter>;
  /** Some related `sensorsBySensorTypeId` exist. */
  sensorsBySensorTypeIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `siliconeSheet` field. */
  siliconeSheet?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `spanResistor` field. */
  spanResistor?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `transportSwitch` field. */
  transportSwitch?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `volume` field. */
  volume?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `SensorType` */
export type SensorTypeInput = {
  battery?: InputMaybe<Scalars['Boolean']['input']>;
  biasMv?: InputMaybe<Scalars['Int']['input']>;
  calFlowRate?: InputMaybe<Scalars['Float']['input']>;
  calGasId: Scalars['Int']['input'];
  calResponse?: InputMaybe<Scalars['Float']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  direction?: InputMaybe<Scalars['Boolean']['input']>;
  electrodeCount?: InputMaybe<Scalars['Int']['input']>;
  electrolyteId?: InputMaybe<Scalars['Int']['input']>;
  elementCount?: InputMaybe<Scalars['Int']['input']>;
  filterId?: InputMaybe<Scalars['Int']['input']>;
  flowRate?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lowElectrolyte?: InputMaybe<Scalars['Boolean']['input']>;
  maintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  membraneId?: InputMaybe<Scalars['Int']['input']>;
  membraneSeal?: InputMaybe<Scalars['Boolean']['input']>;
  model: Scalars['String']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  oRingId?: InputMaybe<Scalars['Int']['input']>;
  obsolete?: InputMaybe<Scalars['Boolean']['input']>;
  ownerId: Scalars['Int']['input'];
  plugId?: InputMaybe<Scalars['Int']['input']>;
  principleId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserVoltage?: InputMaybe<Scalars['Float']['input']>;
  rangeId: Scalars['Int']['input'];
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  restrictor?: InputMaybe<Scalars['Boolean']['input']>;
  sensorBaseTypeId: Scalars['Int']['input'];
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  siliconeSheet?: InputMaybe<Scalars['Boolean']['input']>;
  spanResistor?: InputMaybe<Scalars['BigFloat']['input']>;
  transportSwitch?: InputMaybe<Scalars['Boolean']['input']>;
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `SensorType`. Fields that are set will be updated. */
export type SensorTypePatch = {
  battery?: InputMaybe<Scalars['Boolean']['input']>;
  biasMv?: InputMaybe<Scalars['Int']['input']>;
  calFlowRate?: InputMaybe<Scalars['Float']['input']>;
  calGasId?: InputMaybe<Scalars['Int']['input']>;
  calResponse?: InputMaybe<Scalars['Float']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  direction?: InputMaybe<Scalars['Boolean']['input']>;
  electrodeCount?: InputMaybe<Scalars['Int']['input']>;
  electrolyteId?: InputMaybe<Scalars['Int']['input']>;
  elementCount?: InputMaybe<Scalars['Int']['input']>;
  filterId?: InputMaybe<Scalars['Int']['input']>;
  flowRate?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lowElectrolyte?: InputMaybe<Scalars['Boolean']['input']>;
  maintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  membraneId?: InputMaybe<Scalars['Int']['input']>;
  membraneSeal?: InputMaybe<Scalars['Boolean']['input']>;
  model?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  oRingId?: InputMaybe<Scalars['Int']['input']>;
  obsolete?: InputMaybe<Scalars['Boolean']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  plugId?: InputMaybe<Scalars['Int']['input']>;
  principleId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserVoltage?: InputMaybe<Scalars['Float']['input']>;
  rangeId?: InputMaybe<Scalars['Int']['input']>;
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  restrictor?: InputMaybe<Scalars['Boolean']['input']>;
  sensorBaseTypeId?: InputMaybe<Scalars['Int']['input']>;
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  siliconeSheet?: InputMaybe<Scalars['Boolean']['input']>;
  spanResistor?: InputMaybe<Scalars['BigFloat']['input']>;
  transportSwitch?: InputMaybe<Scalars['Boolean']['input']>;
  volume?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `DetectorSensorType` object types. All fields are combined with a logical ‘and.’ */
export type SensorTypeToManyDetectorSensorTypeFilter = {
  /** Every related `DetectorSensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorTypeFilter>;
  /** No related `DetectorSensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorTypeFilter>;
  /** Some related `DetectorSensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorTypeFilter>;
};

/** A filter to be used against many `Sensor` object types. All fields are combined with a logical ‘and.’ */
export type SensorTypeToManySensorFilter = {
  /** Every related `Sensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorFilter>;
  /** No related `Sensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorFilter>;
  /** Some related `Sensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorFilter>;
};

export type SensorTypesChecklist = {
  __typename?: 'SensorTypesChecklist';
  battery?: Maybe<Scalars['String']['output']>;
  batteryConnection?: Maybe<Scalars['String']['output']>;
  biasMv?: Maybe<Scalars['Int']['output']>;
  direction?: Maybe<Scalars['Boolean']['output']>;
  electrodeCount?: Maybe<Scalars['Int']['output']>;
  lowElectrolyte?: Maybe<Scalars['Boolean']['output']>;
  pc5109DSw1?: Maybe<Scalars['String']['output']>;
  pc5109DSw2?: Maybe<Scalars['String']['output']>;
  pc5109DSw3?: Maybe<Scalars['String']['output']>;
  pc5109DSw5?: Maybe<Scalars['String']['output']>;
  pc5109DSw6?: Maybe<Scalars['String']['output']>;
  pc5154BS1?: Maybe<Scalars['String']['output']>;
  pc5154BS2?: Maybe<Scalars['String']['output']>;
  pc5155BS1?: Maybe<Scalars['String']['output']>;
  pc5155BS3?: Maybe<Scalars['String']['output']>;
  pc5155BS4?: Maybe<Scalars['String']['output']>;
  pc5155BS5?: Maybe<Scalars['String']['output']>;
  plugName?: Maybe<Scalars['String']['output']>;
  restrictor?: Maybe<Scalars['String']['output']>;
  seal?: Maybe<Scalars['String']['output']>;
  sensorEngineeringUnits?: Maybe<Scalars['String']['output']>;
  sensorHighEu?: Maybe<Scalars['Float']['output']>;
  sensorName?: Maybe<Scalars['String']['output']>;
  sensorType?: Maybe<Scalars['String']['output']>;
  sensorTypeId?: Maybe<Scalars['Int']['output']>;
  spanResistor?: Maybe<Scalars['BigFloat']['output']>;
  transportSwitch?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `SensorTypesChecklist` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type SensorTypesChecklistCondition = {
  /** Checks for equality with the object’s `battery` field. */
  battery?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `batteryConnection` field. */
  batteryConnection?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `biasMv` field. */
  biasMv?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `direction` field. */
  direction?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `electrodeCount` field. */
  electrodeCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lowElectrolyte` field. */
  lowElectrolyte?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `pc5109DSw1` field. */
  pc5109DSw1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5109DSw2` field. */
  pc5109DSw2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5109DSw3` field. */
  pc5109DSw3?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5109DSw5` field. */
  pc5109DSw5?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5109DSw6` field. */
  pc5109DSw6?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5154BS1` field. */
  pc5154BS1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5154BS2` field. */
  pc5154BS2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS1` field. */
  pc5155BS1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS3` field. */
  pc5155BS3?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS4` field. */
  pc5155BS4?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS5` field. */
  pc5155BS5?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plugName` field. */
  plugName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `restrictor` field. */
  restrictor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `seal` field. */
  seal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorEngineeringUnits` field. */
  sensorEngineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorHighEu` field. */
  sensorHighEu?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `sensorName` field. */
  sensorName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorType` field. */
  sensorType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `spanResistor` field. */
  spanResistor?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `transportSwitch` field. */
  transportSwitch?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `SensorTypesChecklist` object types. All fields are combined with a logical ‘and.’ */
export type SensorTypesChecklistFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorTypesChecklistFilter>>;
  /** Filter by the object’s `battery` field. */
  battery?: InputMaybe<StringFilter>;
  /** Filter by the object’s `batteryConnection` field. */
  batteryConnection?: InputMaybe<StringFilter>;
  /** Filter by the object’s `biasMv` field. */
  biasMv?: InputMaybe<IntFilter>;
  /** Filter by the object’s `direction` field. */
  direction?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `electrodeCount` field. */
  electrodeCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lowElectrolyte` field. */
  lowElectrolyte?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorTypesChecklistFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorTypesChecklistFilter>>;
  /** Filter by the object’s `pc5109DSw1` field. */
  pc5109DSw1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5109DSw2` field. */
  pc5109DSw2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5109DSw3` field. */
  pc5109DSw3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5109DSw5` field. */
  pc5109DSw5?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5109DSw6` field. */
  pc5109DSw6?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5154BS1` field. */
  pc5154BS1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5154BS2` field. */
  pc5154BS2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS1` field. */
  pc5155BS1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS3` field. */
  pc5155BS3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS4` field. */
  pc5155BS4?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS5` field. */
  pc5155BS5?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plugName` field. */
  plugName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `restrictor` field. */
  restrictor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `seal` field. */
  seal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorEngineeringUnits` field. */
  sensorEngineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorHighEu` field. */
  sensorHighEu?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `sensorName` field. */
  sensorName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorType` field. */
  sensorType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorTypeId` field. */
  sensorTypeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `spanResistor` field. */
  spanResistor?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `transportSwitch` field. */
  transportSwitch?: InputMaybe<StringFilter>;
};

/** A connection to a list of `SensorTypesChecklist` values. */
export type SensorTypesChecklistsConnection = {
  __typename?: 'SensorTypesChecklistsConnection';
  /** A list of edges which contains the `SensorTypesChecklist` and cursor to aid in pagination. */
  edges: Array<SensorTypesChecklistsEdge>;
  /** A list of `SensorTypesChecklist` objects. */
  nodes: Array<SensorTypesChecklist>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorTypesChecklist` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorTypesChecklist` edge in the connection. */
export type SensorTypesChecklistsEdge = {
  __typename?: 'SensorTypesChecklistsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorTypesChecklist` at the end of the edge. */
  node: SensorTypesChecklist;
};

/** Methods to use when ordering `SensorTypesChecklist`. */
export enum SensorTypesChecklistsOrderBy {
  BatteryAsc = 'BATTERY_ASC',
  BatteryConnectionAsc = 'BATTERY_CONNECTION_ASC',
  BatteryConnectionDesc = 'BATTERY_CONNECTION_DESC',
  BatteryDesc = 'BATTERY_DESC',
  BiasMvAsc = 'BIAS_MV_ASC',
  BiasMvDesc = 'BIAS_MV_DESC',
  DirectionAsc = 'DIRECTION_ASC',
  DirectionDesc = 'DIRECTION_DESC',
  ElectrodeCountAsc = 'ELECTRODE_COUNT_ASC',
  ElectrodeCountDesc = 'ELECTRODE_COUNT_DESC',
  LowElectrolyteAsc = 'LOW_ELECTROLYTE_ASC',
  LowElectrolyteDesc = 'LOW_ELECTROLYTE_DESC',
  Natural = 'NATURAL',
  Pc_5109DSw1Asc = 'PC_5109D_SW1_ASC',
  Pc_5109DSw1Desc = 'PC_5109D_SW1_DESC',
  Pc_5109DSw2Asc = 'PC_5109D_SW2_ASC',
  Pc_5109DSw2Desc = 'PC_5109D_SW2_DESC',
  Pc_5109DSw3Asc = 'PC_5109D_SW3_ASC',
  Pc_5109DSw3Desc = 'PC_5109D_SW3_DESC',
  Pc_5109DSw5Asc = 'PC_5109D_SW5_ASC',
  Pc_5109DSw5Desc = 'PC_5109D_SW5_DESC',
  Pc_5109DSw6Asc = 'PC_5109D_SW6_ASC',
  Pc_5109DSw6Desc = 'PC_5109D_SW6_DESC',
  Pc_5154BS1Asc = 'PC_5154B_S1_ASC',
  Pc_5154BS1Desc = 'PC_5154B_S1_DESC',
  Pc_5154BS2Asc = 'PC_5154B_S2_ASC',
  Pc_5154BS2Desc = 'PC_5154B_S2_DESC',
  Pc_5155BS1Asc = 'PC_5155B_S1_ASC',
  Pc_5155BS1Desc = 'PC_5155B_S1_DESC',
  Pc_5155BS3Asc = 'PC_5155B_S3_ASC',
  Pc_5155BS3Desc = 'PC_5155B_S3_DESC',
  Pc_5155BS4Asc = 'PC_5155B_S4_ASC',
  Pc_5155BS4Desc = 'PC_5155B_S4_DESC',
  Pc_5155BS5Asc = 'PC_5155B_S5_ASC',
  Pc_5155BS5Desc = 'PC_5155B_S5_DESC',
  PlugNameAsc = 'PLUG_NAME_ASC',
  PlugNameDesc = 'PLUG_NAME_DESC',
  RestrictorAsc = 'RESTRICTOR_ASC',
  RestrictorDesc = 'RESTRICTOR_DESC',
  SealAsc = 'SEAL_ASC',
  SealDesc = 'SEAL_DESC',
  SensorEngineeringUnitsAsc = 'SENSOR_ENGINEERING_UNITS_ASC',
  SensorEngineeringUnitsDesc = 'SENSOR_ENGINEERING_UNITS_DESC',
  SensorHighEuAsc = 'SENSOR_HIGH_EU_ASC',
  SensorHighEuDesc = 'SENSOR_HIGH_EU_DESC',
  SensorNameAsc = 'SENSOR_NAME_ASC',
  SensorNameDesc = 'SENSOR_NAME_DESC',
  SensorTypeAsc = 'SENSOR_TYPE_ASC',
  SensorTypeDesc = 'SENSOR_TYPE_DESC',
  SensorTypeIdAsc = 'SENSOR_TYPE_ID_ASC',
  SensorTypeIdDesc = 'SENSOR_TYPE_ID_DESC',
  SpanResistorAsc = 'SPAN_RESISTOR_ASC',
  SpanResistorDesc = 'SPAN_RESISTOR_DESC',
  TransportSwitchAsc = 'TRANSPORT_SWITCH_ASC',
  TransportSwitchDesc = 'TRANSPORT_SWITCH_DESC'
}

/** A connection to a list of `SensorType` values. */
export type SensorTypesConnection = {
  __typename?: 'SensorTypesConnection';
  /** A list of edges which contains the `SensorType` and cursor to aid in pagination. */
  edges: Array<SensorTypesEdge>;
  /** A list of `SensorType` objects. */
  nodes: Array<SensorType>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorType` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorType` edge in the connection. */
export type SensorTypesEdge = {
  __typename?: 'SensorTypesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorType` at the end of the edge. */
  node: SensorType;
};

export type SensorTypesIndex = {
  __typename?: 'SensorTypesIndex';
  battery?: Maybe<Scalars['Boolean']['output']>;
  calEngineeringUnits?: Maybe<Scalars['String']['output']>;
  calFlowRate?: Maybe<Scalars['Float']['output']>;
  calGasConcentration?: Maybe<Scalars['Float']['output']>;
  calGasName?: Maybe<Scalars['String']['output']>;
  calResponse?: Maybe<Scalars['Float']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  createdDate?: Maybe<Scalars['String']['output']>;
  electrolyteCdartikel?: Maybe<Scalars['String']['output']>;
  electrolyteName?: Maybe<Scalars['String']['output']>;
  engineeringUnits?: Maybe<Scalars['String']['output']>;
  filterCdartikel?: Maybe<Scalars['String']['output']>;
  filterName?: Maybe<Scalars['String']['output']>;
  flowRate?: Maybe<Scalars['Float']['output']>;
  highEu?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  maintenanceIntervalMonths?: Maybe<Scalars['Int']['output']>;
  membraneCdartikel?: Maybe<Scalars['String']['output']>;
  membraneName?: Maybe<Scalars['String']['output']>;
  membraneSeal?: Maybe<Scalars['Boolean']['output']>;
  model?: Maybe<Scalars['String']['output']>;
  oRingCdartikel?: Maybe<Scalars['String']['output']>;
  oRingName?: Maybe<Scalars['String']['output']>;
  prefix?: Maybe<Scalars['String']['output']>;
  principleName?: Maybe<Scalars['String']['output']>;
  pyrolyserCdartikel?: Maybe<Scalars['String']['output']>;
  pyrolyserName?: Maybe<Scalars['String']['output']>;
  replacementIntervalMonths?: Maybe<Scalars['Int']['output']>;
  restrictor?: Maybe<Scalars['Boolean']['output']>;
  sensorTypeArtikelOmschr?: Maybe<Scalars['String']['output']>;
  sensorTypeCdartikel?: Maybe<Scalars['String']['output']>;
  siliconeSheet?: Maybe<Scalars['Boolean']['output']>;
  suffix?: Maybe<Scalars['String']['output']>;
  target?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `SensorTypesIndex` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SensorTypesIndexCondition = {
  /** Checks for equality with the object’s `battery` field. */
  battery?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `calEngineeringUnits` field. */
  calEngineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `calGasConcentration` field. */
  calGasConcentration?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `calGasName` field. */
  calGasName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calResponse` field. */
  calResponse?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdDate` field. */
  createdDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `electrolyteCdartikel` field. */
  electrolyteCdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterCdartikel` field. */
  filterCdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterName` field. */
  filterName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `flowRate` field. */
  flowRate?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `highEu` field. */
  highEu?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `maintenanceIntervalMonths` field. */
  maintenanceIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `membraneCdartikel` field. */
  membraneCdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `membraneName` field. */
  membraneName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `membraneSeal` field. */
  membraneSeal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `model` field. */
  model?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `oRingCdartikel` field. */
  oRingCdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `oRingName` field. */
  oRingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prefix` field. */
  prefix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `principleName` field. */
  principleName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyrolyserCdartikel` field. */
  pyrolyserCdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pyrolyserName` field. */
  pyrolyserName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `restrictor` field. */
  restrictor?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `sensorTypeArtikelOmschr` field. */
  sensorTypeArtikelOmschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypeCdartikel` field. */
  sensorTypeCdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `siliconeSheet` field. */
  siliconeSheet?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `suffix` field. */
  suffix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `target` field. */
  target?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `SensorTypesIndex` object types. All fields are combined with a logical ‘and.’ */
export type SensorTypesIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorTypesIndexFilter>>;
  /** Filter by the object’s `battery` field. */
  battery?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `calEngineeringUnits` field. */
  calEngineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `calGasConcentration` field. */
  calGasConcentration?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `calGasName` field. */
  calGasName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calResponse` field. */
  calResponse?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdDate` field. */
  createdDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `electrolyteCdartikel` field. */
  electrolyteCdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterCdartikel` field. */
  filterCdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterName` field. */
  filterName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `flowRate` field. */
  flowRate?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `highEu` field. */
  highEu?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `maintenanceIntervalMonths` field. */
  maintenanceIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `membraneCdartikel` field. */
  membraneCdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `membraneName` field. */
  membraneName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `membraneSeal` field. */
  membraneSeal?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `model` field. */
  model?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorTypesIndexFilter>;
  /** Filter by the object’s `oRingCdartikel` field. */
  oRingCdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `oRingName` field. */
  oRingName?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorTypesIndexFilter>>;
  /** Filter by the object’s `prefix` field. */
  prefix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `principleName` field. */
  principleName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pyrolyserCdartikel` field. */
  pyrolyserCdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pyrolyserName` field. */
  pyrolyserName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `replacementIntervalMonths` field. */
  replacementIntervalMonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `restrictor` field. */
  restrictor?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `sensorTypeArtikelOmschr` field. */
  sensorTypeArtikelOmschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorTypeCdartikel` field. */
  sensorTypeCdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `siliconeSheet` field. */
  siliconeSheet?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `suffix` field. */
  suffix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `target` field. */
  target?: InputMaybe<StringFilter>;
};

/** A connection to a list of `SensorTypesIndex` values. */
export type SensorTypesIndicesConnection = {
  __typename?: 'SensorTypesIndicesConnection';
  /** A list of edges which contains the `SensorTypesIndex` and cursor to aid in pagination. */
  edges: Array<SensorTypesIndicesEdge>;
  /** A list of `SensorTypesIndex` objects. */
  nodes: Array<SensorTypesIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorTypesIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorTypesIndex` edge in the connection. */
export type SensorTypesIndicesEdge = {
  __typename?: 'SensorTypesIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorTypesIndex` at the end of the edge. */
  node: SensorTypesIndex;
};

/** Methods to use when ordering `SensorTypesIndex`. */
export enum SensorTypesIndicesOrderBy {
  BatteryAsc = 'BATTERY_ASC',
  BatteryDesc = 'BATTERY_DESC',
  CalEngineeringUnitsAsc = 'CAL_ENGINEERING_UNITS_ASC',
  CalEngineeringUnitsDesc = 'CAL_ENGINEERING_UNITS_DESC',
  CalFlowRateAsc = 'CAL_FLOW_RATE_ASC',
  CalFlowRateDesc = 'CAL_FLOW_RATE_DESC',
  CalGasConcentrationAsc = 'CAL_GAS_CONCENTRATION_ASC',
  CalGasConcentrationDesc = 'CAL_GAS_CONCENTRATION_DESC',
  CalGasNameAsc = 'CAL_GAS_NAME_ASC',
  CalGasNameDesc = 'CAL_GAS_NAME_DESC',
  CalResponseAsc = 'CAL_RESPONSE_ASC',
  CalResponseDesc = 'CAL_RESPONSE_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CreatedDateAsc = 'CREATED_DATE_ASC',
  CreatedDateDesc = 'CREATED_DATE_DESC',
  ElectrolyteCdartikelAsc = 'ELECTROLYTE_CDARTIKEL_ASC',
  ElectrolyteCdartikelDesc = 'ELECTROLYTE_CDARTIKEL_DESC',
  ElectrolyteNameAsc = 'ELECTROLYTE_NAME_ASC',
  ElectrolyteNameDesc = 'ELECTROLYTE_NAME_DESC',
  EngineeringUnitsAsc = 'ENGINEERING_UNITS_ASC',
  EngineeringUnitsDesc = 'ENGINEERING_UNITS_DESC',
  FilterCdartikelAsc = 'FILTER_CDARTIKEL_ASC',
  FilterCdartikelDesc = 'FILTER_CDARTIKEL_DESC',
  FilterNameAsc = 'FILTER_NAME_ASC',
  FilterNameDesc = 'FILTER_NAME_DESC',
  FlowRateAsc = 'FLOW_RATE_ASC',
  FlowRateDesc = 'FLOW_RATE_DESC',
  HighEuAsc = 'HIGH_EU_ASC',
  HighEuDesc = 'HIGH_EU_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MaintenanceIntervalMonthsAsc = 'MAINTENANCE_INTERVAL_MONTHS_ASC',
  MaintenanceIntervalMonthsDesc = 'MAINTENANCE_INTERVAL_MONTHS_DESC',
  MembraneCdartikelAsc = 'MEMBRANE_CDARTIKEL_ASC',
  MembraneCdartikelDesc = 'MEMBRANE_CDARTIKEL_DESC',
  MembraneNameAsc = 'MEMBRANE_NAME_ASC',
  MembraneNameDesc = 'MEMBRANE_NAME_DESC',
  MembraneSealAsc = 'MEMBRANE_SEAL_ASC',
  MembraneSealDesc = 'MEMBRANE_SEAL_DESC',
  ModelAsc = 'MODEL_ASC',
  ModelDesc = 'MODEL_DESC',
  Natural = 'NATURAL',
  ORingCdartikelAsc = 'O_RING_CDARTIKEL_ASC',
  ORingCdartikelDesc = 'O_RING_CDARTIKEL_DESC',
  ORingNameAsc = 'O_RING_NAME_ASC',
  ORingNameDesc = 'O_RING_NAME_DESC',
  PrefixAsc = 'PREFIX_ASC',
  PrefixDesc = 'PREFIX_DESC',
  PrincipleNameAsc = 'PRINCIPLE_NAME_ASC',
  PrincipleNameDesc = 'PRINCIPLE_NAME_DESC',
  PyrolyserCdartikelAsc = 'PYROLYSER_CDARTIKEL_ASC',
  PyrolyserCdartikelDesc = 'PYROLYSER_CDARTIKEL_DESC',
  PyrolyserNameAsc = 'PYROLYSER_NAME_ASC',
  PyrolyserNameDesc = 'PYROLYSER_NAME_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  RestrictorAsc = 'RESTRICTOR_ASC',
  RestrictorDesc = 'RESTRICTOR_DESC',
  SensorTypeArtikelOmschrAsc = 'SENSOR_TYPE_ARTIKEL_OMSCHR_ASC',
  SensorTypeArtikelOmschrDesc = 'SENSOR_TYPE_ARTIKEL_OMSCHR_DESC',
  SensorTypeCdartikelAsc = 'SENSOR_TYPE_CDARTIKEL_ASC',
  SensorTypeCdartikelDesc = 'SENSOR_TYPE_CDARTIKEL_DESC',
  SiliconeSheetAsc = 'SILICONE_SHEET_ASC',
  SiliconeSheetDesc = 'SILICONE_SHEET_DESC',
  SuffixAsc = 'SUFFIX_ASC',
  SuffixDesc = 'SUFFIX_DESC',
  TargetAsc = 'TARGET_ASC',
  TargetDesc = 'TARGET_DESC'
}

/** Methods to use when ordering `SensorType`. */
export enum SensorTypesOrderBy {
  BatteryAsc = 'BATTERY_ASC',
  BatteryDesc = 'BATTERY_DESC',
  BiasMvAsc = 'BIAS_MV_ASC',
  BiasMvDesc = 'BIAS_MV_DESC',
  CalFlowRateAsc = 'CAL_FLOW_RATE_ASC',
  CalFlowRateDesc = 'CAL_FLOW_RATE_DESC',
  CalGasByCalGasIdCdartikelAsc = 'CAL_GAS_BY_CAL_GAS_ID__CDARTIKEL_ASC',
  CalGasByCalGasIdCdartikelDesc = 'CAL_GAS_BY_CAL_GAS_ID__CDARTIKEL_DESC',
  CalGasByCalGasIdConcentrationAsc = 'CAL_GAS_BY_CAL_GAS_ID__CONCENTRATION_ASC',
  CalGasByCalGasIdConcentrationDesc = 'CAL_GAS_BY_CAL_GAS_ID__CONCENTRATION_DESC',
  CalGasByCalGasIdCreatedAsc = 'CAL_GAS_BY_CAL_GAS_ID__CREATED_ASC',
  CalGasByCalGasIdCreatedDesc = 'CAL_GAS_BY_CAL_GAS_ID__CREATED_DESC',
  CalGasByCalGasIdEngineeringUnitsAsc = 'CAL_GAS_BY_CAL_GAS_ID__ENGINEERING_UNITS_ASC',
  CalGasByCalGasIdEngineeringUnitsDesc = 'CAL_GAS_BY_CAL_GAS_ID__ENGINEERING_UNITS_DESC',
  CalGasByCalGasIdGasIdAsc = 'CAL_GAS_BY_CAL_GAS_ID__GAS_ID_ASC',
  CalGasByCalGasIdGasIdDesc = 'CAL_GAS_BY_CAL_GAS_ID__GAS_ID_DESC',
  CalGasByCalGasIdIdAsc = 'CAL_GAS_BY_CAL_GAS_ID__ID_ASC',
  CalGasByCalGasIdIdDesc = 'CAL_GAS_BY_CAL_GAS_ID__ID_DESC',
  CalGasByCalGasIdModifiedAsc = 'CAL_GAS_BY_CAL_GAS_ID__MODIFIED_ASC',
  CalGasByCalGasIdModifiedDesc = 'CAL_GAS_BY_CAL_GAS_ID__MODIFIED_DESC',
  CalGasByCalGasIdOwnerIdAsc = 'CAL_GAS_BY_CAL_GAS_ID__OWNER_ID_ASC',
  CalGasByCalGasIdOwnerIdDesc = 'CAL_GAS_BY_CAL_GAS_ID__OWNER_ID_DESC',
  CalGasIdAsc = 'CAL_GAS_ID_ASC',
  CalGasIdDesc = 'CAL_GAS_ID_DESC',
  CalResponseAsc = 'CAL_RESPONSE_ASC',
  CalResponseDesc = 'CAL_RESPONSE_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorSensorTypesBySensorTypeIdCountAsc = 'DETECTOR_SENSOR_TYPES_BY_SENSOR_TYPE_ID__COUNT_ASC',
  DetectorSensorTypesBySensorTypeIdCountDesc = 'DETECTOR_SENSOR_TYPES_BY_SENSOR_TYPE_ID__COUNT_DESC',
  DirectionAsc = 'DIRECTION_ASC',
  DirectionDesc = 'DIRECTION_DESC',
  ElectrodeCountAsc = 'ELECTRODE_COUNT_ASC',
  ElectrodeCountDesc = 'ELECTRODE_COUNT_DESC',
  ElectrolyteByElectrolyteIdCdartikelAsc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__CDARTIKEL_ASC',
  ElectrolyteByElectrolyteIdCdartikelDesc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__CDARTIKEL_DESC',
  ElectrolyteByElectrolyteIdCreatedAsc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__CREATED_ASC',
  ElectrolyteByElectrolyteIdCreatedDesc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__CREATED_DESC',
  ElectrolyteByElectrolyteIdIdAsc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__ID_ASC',
  ElectrolyteByElectrolyteIdIdDesc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__ID_DESC',
  ElectrolyteByElectrolyteIdModifiedAsc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__MODIFIED_ASC',
  ElectrolyteByElectrolyteIdModifiedDesc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__MODIFIED_DESC',
  ElectrolyteByElectrolyteIdNameAsc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__NAME_ASC',
  ElectrolyteByElectrolyteIdNameDesc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__NAME_DESC',
  ElectrolyteByElectrolyteIdOwnerIdAsc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__OWNER_ID_ASC',
  ElectrolyteByElectrolyteIdOwnerIdDesc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__OWNER_ID_DESC',
  ElectrolyteByElectrolyteIdReplacementIntervalMonthsAsc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  ElectrolyteByElectrolyteIdReplacementIntervalMonthsDesc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  ElectrolyteByElectrolyteIdVolumeAsc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__VOLUME_ASC',
  ElectrolyteByElectrolyteIdVolumeDesc = 'ELECTROLYTE_BY_ELECTROLYTE_ID__VOLUME_DESC',
  ElectrolyteIdAsc = 'ELECTROLYTE_ID_ASC',
  ElectrolyteIdDesc = 'ELECTROLYTE_ID_DESC',
  ElementCountAsc = 'ELEMENT_COUNT_ASC',
  ElementCountDesc = 'ELEMENT_COUNT_DESC',
  FilterByFilterIdCdartikelAsc = 'FILTER_BY_FILTER_ID__CDARTIKEL_ASC',
  FilterByFilterIdCdartikelDesc = 'FILTER_BY_FILTER_ID__CDARTIKEL_DESC',
  FilterByFilterIdConsumableAsc = 'FILTER_BY_FILTER_ID__CONSUMABLE_ASC',
  FilterByFilterIdConsumableDesc = 'FILTER_BY_FILTER_ID__CONSUMABLE_DESC',
  FilterByFilterIdCreatedAsc = 'FILTER_BY_FILTER_ID__CREATED_ASC',
  FilterByFilterIdCreatedDesc = 'FILTER_BY_FILTER_ID__CREATED_DESC',
  FilterByFilterIdIdAsc = 'FILTER_BY_FILTER_ID__ID_ASC',
  FilterByFilterIdIdDesc = 'FILTER_BY_FILTER_ID__ID_DESC',
  FilterByFilterIdModifiedAsc = 'FILTER_BY_FILTER_ID__MODIFIED_ASC',
  FilterByFilterIdModifiedDesc = 'FILTER_BY_FILTER_ID__MODIFIED_DESC',
  FilterByFilterIdNameAsc = 'FILTER_BY_FILTER_ID__NAME_ASC',
  FilterByFilterIdNameDesc = 'FILTER_BY_FILTER_ID__NAME_DESC',
  FilterByFilterIdOwnerIdAsc = 'FILTER_BY_FILTER_ID__OWNER_ID_ASC',
  FilterByFilterIdOwnerIdDesc = 'FILTER_BY_FILTER_ID__OWNER_ID_DESC',
  FilterByFilterIdReplacementIntervalMonthsAsc = 'FILTER_BY_FILTER_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  FilterByFilterIdReplacementIntervalMonthsDesc = 'FILTER_BY_FILTER_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  FilterIdAsc = 'FILTER_ID_ASC',
  FilterIdDesc = 'FILTER_ID_DESC',
  FlowRateAsc = 'FLOW_RATE_ASC',
  FlowRateDesc = 'FLOW_RATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LowElectrolyteAsc = 'LOW_ELECTROLYTE_ASC',
  LowElectrolyteDesc = 'LOW_ELECTROLYTE_DESC',
  MaintenanceIntervalMonthsAsc = 'MAINTENANCE_INTERVAL_MONTHS_ASC',
  MaintenanceIntervalMonthsDesc = 'MAINTENANCE_INTERVAL_MONTHS_DESC',
  MembraneByMembraneIdCdartikelAsc = 'MEMBRANE_BY_MEMBRANE_ID__CDARTIKEL_ASC',
  MembraneByMembraneIdCdartikelDesc = 'MEMBRANE_BY_MEMBRANE_ID__CDARTIKEL_DESC',
  MembraneByMembraneIdCreatedAsc = 'MEMBRANE_BY_MEMBRANE_ID__CREATED_ASC',
  MembraneByMembraneIdCreatedDesc = 'MEMBRANE_BY_MEMBRANE_ID__CREATED_DESC',
  MembraneByMembraneIdIdAsc = 'MEMBRANE_BY_MEMBRANE_ID__ID_ASC',
  MembraneByMembraneIdIdDesc = 'MEMBRANE_BY_MEMBRANE_ID__ID_DESC',
  MembraneByMembraneIdModifiedAsc = 'MEMBRANE_BY_MEMBRANE_ID__MODIFIED_ASC',
  MembraneByMembraneIdModifiedDesc = 'MEMBRANE_BY_MEMBRANE_ID__MODIFIED_DESC',
  MembraneByMembraneIdNameAsc = 'MEMBRANE_BY_MEMBRANE_ID__NAME_ASC',
  MembraneByMembraneIdNameDesc = 'MEMBRANE_BY_MEMBRANE_ID__NAME_DESC',
  MembraneByMembraneIdOwnerIdAsc = 'MEMBRANE_BY_MEMBRANE_ID__OWNER_ID_ASC',
  MembraneByMembraneIdOwnerIdDesc = 'MEMBRANE_BY_MEMBRANE_ID__OWNER_ID_DESC',
  MembraneByMembraneIdQuantityAsc = 'MEMBRANE_BY_MEMBRANE_ID__QUANTITY_ASC',
  MembraneByMembraneIdQuantityDesc = 'MEMBRANE_BY_MEMBRANE_ID__QUANTITY_DESC',
  MembraneByMembraneIdReplacementIntervalMonthsAsc = 'MEMBRANE_BY_MEMBRANE_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  MembraneByMembraneIdReplacementIntervalMonthsDesc = 'MEMBRANE_BY_MEMBRANE_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  MembraneIdAsc = 'MEMBRANE_ID_ASC',
  MembraneIdDesc = 'MEMBRANE_ID_DESC',
  MembraneSealAsc = 'MEMBRANE_SEAL_ASC',
  MembraneSealDesc = 'MEMBRANE_SEAL_DESC',
  ModelAsc = 'MODEL_ASC',
  ModelDesc = 'MODEL_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  ObsoleteAsc = 'OBSOLETE_ASC',
  ObsoleteDesc = 'OBSOLETE_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  ORingByORingIdCdartikelAsc = 'O_RING_BY_O_RING_ID__CDARTIKEL_ASC',
  ORingByORingIdCdartikelDesc = 'O_RING_BY_O_RING_ID__CDARTIKEL_DESC',
  ORingByORingIdCreatedAsc = 'O_RING_BY_O_RING_ID__CREATED_ASC',
  ORingByORingIdCreatedDesc = 'O_RING_BY_O_RING_ID__CREATED_DESC',
  ORingByORingIdIdAsc = 'O_RING_BY_O_RING_ID__ID_ASC',
  ORingByORingIdIdDesc = 'O_RING_BY_O_RING_ID__ID_DESC',
  ORingByORingIdModifiedAsc = 'O_RING_BY_O_RING_ID__MODIFIED_ASC',
  ORingByORingIdModifiedDesc = 'O_RING_BY_O_RING_ID__MODIFIED_DESC',
  ORingByORingIdNameAsc = 'O_RING_BY_O_RING_ID__NAME_ASC',
  ORingByORingIdNameDesc = 'O_RING_BY_O_RING_ID__NAME_DESC',
  ORingByORingIdOwnerIdAsc = 'O_RING_BY_O_RING_ID__OWNER_ID_ASC',
  ORingByORingIdOwnerIdDesc = 'O_RING_BY_O_RING_ID__OWNER_ID_DESC',
  ORingByORingIdQuantityAsc = 'O_RING_BY_O_RING_ID__QUANTITY_ASC',
  ORingByORingIdQuantityDesc = 'O_RING_BY_O_RING_ID__QUANTITY_DESC',
  ORingByORingIdReplacementIntervalMonthsAsc = 'O_RING_BY_O_RING_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  ORingByORingIdReplacementIntervalMonthsDesc = 'O_RING_BY_O_RING_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  ORingIdAsc = 'O_RING_ID_ASC',
  ORingIdDesc = 'O_RING_ID_DESC',
  PlugByPlugIdCreatedAsc = 'PLUG_BY_PLUG_ID__CREATED_ASC',
  PlugByPlugIdCreatedDesc = 'PLUG_BY_PLUG_ID__CREATED_DESC',
  PlugByPlugIdIdAsc = 'PLUG_BY_PLUG_ID__ID_ASC',
  PlugByPlugIdIdDesc = 'PLUG_BY_PLUG_ID__ID_DESC',
  PlugByPlugIdModifiedAsc = 'PLUG_BY_PLUG_ID__MODIFIED_ASC',
  PlugByPlugIdModifiedDesc = 'PLUG_BY_PLUG_ID__MODIFIED_DESC',
  PlugByPlugIdNameAsc = 'PLUG_BY_PLUG_ID__NAME_ASC',
  PlugByPlugIdNameDesc = 'PLUG_BY_PLUG_ID__NAME_DESC',
  PlugByPlugIdOwnerIdAsc = 'PLUG_BY_PLUG_ID__OWNER_ID_ASC',
  PlugByPlugIdOwnerIdDesc = 'PLUG_BY_PLUG_ID__OWNER_ID_DESC',
  PlugIdAsc = 'PLUG_ID_ASC',
  PlugIdDesc = 'PLUG_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PrincipleIdAsc = 'PRINCIPLE_ID_ASC',
  PrincipleIdDesc = 'PRINCIPLE_ID_DESC',
  PyrolyserByPyrolyserIdCdartikelAsc = 'PYROLYSER_BY_PYROLYSER_ID__CDARTIKEL_ASC',
  PyrolyserByPyrolyserIdCdartikelDesc = 'PYROLYSER_BY_PYROLYSER_ID__CDARTIKEL_DESC',
  PyrolyserByPyrolyserIdCreatedAsc = 'PYROLYSER_BY_PYROLYSER_ID__CREATED_ASC',
  PyrolyserByPyrolyserIdCreatedDesc = 'PYROLYSER_BY_PYROLYSER_ID__CREATED_DESC',
  PyrolyserByPyrolyserIdIdAsc = 'PYROLYSER_BY_PYROLYSER_ID__ID_ASC',
  PyrolyserByPyrolyserIdIdDesc = 'PYROLYSER_BY_PYROLYSER_ID__ID_DESC',
  PyrolyserByPyrolyserIdModifiedAsc = 'PYROLYSER_BY_PYROLYSER_ID__MODIFIED_ASC',
  PyrolyserByPyrolyserIdModifiedDesc = 'PYROLYSER_BY_PYROLYSER_ID__MODIFIED_DESC',
  PyrolyserByPyrolyserIdNameAsc = 'PYROLYSER_BY_PYROLYSER_ID__NAME_ASC',
  PyrolyserByPyrolyserIdNameDesc = 'PYROLYSER_BY_PYROLYSER_ID__NAME_DESC',
  PyrolyserByPyrolyserIdOwnerIdAsc = 'PYROLYSER_BY_PYROLYSER_ID__OWNER_ID_ASC',
  PyrolyserByPyrolyserIdOwnerIdDesc = 'PYROLYSER_BY_PYROLYSER_ID__OWNER_ID_DESC',
  PyrolyserByPyrolyserIdReplacementIntervalMonthsAsc = 'PYROLYSER_BY_PYROLYSER_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  PyrolyserByPyrolyserIdReplacementIntervalMonthsDesc = 'PYROLYSER_BY_PYROLYSER_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  PyrolyserIdAsc = 'PYROLYSER_ID_ASC',
  PyrolyserIdDesc = 'PYROLYSER_ID_DESC',
  PyrolyserVoltageAsc = 'PYROLYSER_VOLTAGE_ASC',
  PyrolyserVoltageDesc = 'PYROLYSER_VOLTAGE_DESC',
  RangeByRangeIdAlarm_1DirectionUpAsc = 'RANGE_BY_RANGE_ID__ALARM_1_DIRECTION_UP_ASC',
  RangeByRangeIdAlarm_1DirectionUpDesc = 'RANGE_BY_RANGE_ID__ALARM_1_DIRECTION_UP_DESC',
  RangeByRangeIdAlarm_1LevelAsc = 'RANGE_BY_RANGE_ID__ALARM_1_LEVEL_ASC',
  RangeByRangeIdAlarm_1LevelDesc = 'RANGE_BY_RANGE_ID__ALARM_1_LEVEL_DESC',
  RangeByRangeIdAlarm_2DirectionUpAsc = 'RANGE_BY_RANGE_ID__ALARM_2_DIRECTION_UP_ASC',
  RangeByRangeIdAlarm_2DirectionUpDesc = 'RANGE_BY_RANGE_ID__ALARM_2_DIRECTION_UP_DESC',
  RangeByRangeIdAlarm_2LevelAsc = 'RANGE_BY_RANGE_ID__ALARM_2_LEVEL_ASC',
  RangeByRangeIdAlarm_2LevelDesc = 'RANGE_BY_RANGE_ID__ALARM_2_LEVEL_DESC',
  RangeByRangeIdAlarmUnitsAsc = 'RANGE_BY_RANGE_ID__ALARM_UNITS_ASC',
  RangeByRangeIdAlarmUnitsDesc = 'RANGE_BY_RANGE_ID__ALARM_UNITS_DESC',
  RangeByRangeIdCreatedAsc = 'RANGE_BY_RANGE_ID__CREATED_ASC',
  RangeByRangeIdCreatedDesc = 'RANGE_BY_RANGE_ID__CREATED_DESC',
  RangeByRangeIdEngineeringUnitsAsc = 'RANGE_BY_RANGE_ID__ENGINEERING_UNITS_ASC',
  RangeByRangeIdEngineeringUnitsDesc = 'RANGE_BY_RANGE_ID__ENGINEERING_UNITS_DESC',
  RangeByRangeIdGasIdAsc = 'RANGE_BY_RANGE_ID__GAS_ID_ASC',
  RangeByRangeIdGasIdDesc = 'RANGE_BY_RANGE_ID__GAS_ID_DESC',
  RangeByRangeIdHighEuAsc = 'RANGE_BY_RANGE_ID__HIGH_EU_ASC',
  RangeByRangeIdHighEuBackupAsc = 'RANGE_BY_RANGE_ID__HIGH_EU_BACKUP_ASC',
  RangeByRangeIdHighEuBackupDesc = 'RANGE_BY_RANGE_ID__HIGH_EU_BACKUP_DESC',
  RangeByRangeIdHighEuDesc = 'RANGE_BY_RANGE_ID__HIGH_EU_DESC',
  RangeByRangeIdHighEuNumericAsc = 'RANGE_BY_RANGE_ID__HIGH_EU_NUMERIC_ASC',
  RangeByRangeIdHighEuNumericDesc = 'RANGE_BY_RANGE_ID__HIGH_EU_NUMERIC_DESC',
  RangeByRangeIdIdAsc = 'RANGE_BY_RANGE_ID__ID_ASC',
  RangeByRangeIdIdDesc = 'RANGE_BY_RANGE_ID__ID_DESC',
  RangeByRangeIdLowEuAsc = 'RANGE_BY_RANGE_ID__LOW_EU_ASC',
  RangeByRangeIdLowEuDesc = 'RANGE_BY_RANGE_ID__LOW_EU_DESC',
  RangeByRangeIdModifiedAsc = 'RANGE_BY_RANGE_ID__MODIFIED_ASC',
  RangeByRangeIdModifiedDesc = 'RANGE_BY_RANGE_ID__MODIFIED_DESC',
  RangeByRangeIdOwnerIdAsc = 'RANGE_BY_RANGE_ID__OWNER_ID_ASC',
  RangeByRangeIdOwnerIdDesc = 'RANGE_BY_RANGE_ID__OWNER_ID_DESC',
  RangeByRangeIdPrecisionAsc = 'RANGE_BY_RANGE_ID__PRECISION_ASC',
  RangeByRangeIdPrecisionDesc = 'RANGE_BY_RANGE_ID__PRECISION_DESC',
  RangeByRangeIdWarning_1LevelAsc = 'RANGE_BY_RANGE_ID__WARNING_1_LEVEL_ASC',
  RangeByRangeIdWarning_1LevelDesc = 'RANGE_BY_RANGE_ID__WARNING_1_LEVEL_DESC',
  RangeByRangeIdWarning_2LevelAsc = 'RANGE_BY_RANGE_ID__WARNING_2_LEVEL_ASC',
  RangeByRangeIdWarning_2LevelDesc = 'RANGE_BY_RANGE_ID__WARNING_2_LEVEL_DESC',
  RangeIdAsc = 'RANGE_ID_ASC',
  RangeIdDesc = 'RANGE_ID_DESC',
  ReplacementIntervalMonthsAsc = 'REPLACEMENT_INTERVAL_MONTHS_ASC',
  ReplacementIntervalMonthsDesc = 'REPLACEMENT_INTERVAL_MONTHS_DESC',
  RestrictorAsc = 'RESTRICTOR_ASC',
  RestrictorDesc = 'RESTRICTOR_DESC',
  SensorsBySensorTypeIdCountAsc = 'SENSORS_BY_SENSOR_TYPE_ID__COUNT_ASC',
  SensorsBySensorTypeIdCountDesc = 'SENSORS_BY_SENSOR_TYPE_ID__COUNT_DESC',
  SensorBaseTypeBySensorBaseTypeIdCreatedAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__CREATED_ASC',
  SensorBaseTypeBySensorBaseTypeIdCreatedDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__CREATED_DESC',
  SensorBaseTypeBySensorBaseTypeIdIdAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__ID_ASC',
  SensorBaseTypeBySensorBaseTypeIdIdDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__ID_DESC',
  SensorBaseTypeBySensorBaseTypeIdMaintenanceIntervalMonthsAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__MAINTENANCE_INTERVAL_MONTHS_ASC',
  SensorBaseTypeBySensorBaseTypeIdMaintenanceIntervalMonthsDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__MAINTENANCE_INTERVAL_MONTHS_DESC',
  SensorBaseTypeBySensorBaseTypeIdModifiedAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__MODIFIED_ASC',
  SensorBaseTypeBySensorBaseTypeIdModifiedDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__MODIFIED_DESC',
  SensorBaseTypeBySensorBaseTypeIdOwnerIdAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__OWNER_ID_ASC',
  SensorBaseTypeBySensorBaseTypeIdOwnerIdDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__OWNER_ID_DESC',
  SensorBaseTypeBySensorBaseTypeIdPrefixAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__PREFIX_ASC',
  SensorBaseTypeBySensorBaseTypeIdPrefixDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__PREFIX_DESC',
  SensorBaseTypeBySensorBaseTypeIdPrincipleIdAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__PRINCIPLE_ID_ASC',
  SensorBaseTypeBySensorBaseTypeIdPrincipleIdDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__PRINCIPLE_ID_DESC',
  SensorBaseTypeBySensorBaseTypeIdQuotationIntervalMonthsAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__QUOTATION_INTERVAL_MONTHS_ASC',
  SensorBaseTypeBySensorBaseTypeIdQuotationIntervalMonthsDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__QUOTATION_INTERVAL_MONTHS_DESC',
  SensorBaseTypeBySensorBaseTypeIdReplacementIntervalMonthsAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  SensorBaseTypeBySensorBaseTypeIdReplacementIntervalMonthsDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorBaseTypeBySensorBaseTypeIdSeriesAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__SERIES_ASC',
  SensorBaseTypeBySensorBaseTypeIdSeriesDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__SERIES_DESC',
  SensorBaseTypeBySensorBaseTypeIdSuffixAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__SUFFIX_ASC',
  SensorBaseTypeBySensorBaseTypeIdSuffixDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__SUFFIX_DESC',
  SensorBaseTypeBySensorBaseTypeIdVolumeAsc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__VOLUME_ASC',
  SensorBaseTypeBySensorBaseTypeIdVolumeDesc = 'SENSOR_BASE_TYPE_BY_SENSOR_BASE_TYPE_ID__VOLUME_DESC',
  SensorBaseTypeIdAsc = 'SENSOR_BASE_TYPE_ID_ASC',
  SensorBaseTypeIdDesc = 'SENSOR_BASE_TYPE_ID_DESC',
  SensorTypeIdAsc = 'SENSOR_TYPE_ID_ASC',
  SensorTypeIdDesc = 'SENSOR_TYPE_ID_DESC',
  SiliconeSheetAsc = 'SILICONE_SHEET_ASC',
  SiliconeSheetDesc = 'SILICONE_SHEET_DESC',
  SpanResistorAsc = 'SPAN_RESISTOR_ASC',
  SpanResistorDesc = 'SPAN_RESISTOR_DESC',
  TransportSwitchAsc = 'TRANSPORT_SWITCH_ASC',
  TransportSwitchDesc = 'TRANSPORT_SWITCH_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  VolumeAsc = 'VOLUME_ASC',
  VolumeDesc = 'VOLUME_DESC'
}

export type SensorsChecklist = {
  __typename?: 'SensorsChecklist';
  alarm1DirectionUp?: Maybe<Scalars['Boolean']['output']>;
  alarm1LevelCurrent?: Maybe<Scalars['Int']['output']>;
  alarm1LevelPercentage?: Maybe<Scalars['Float']['output']>;
  alarm1LevelUnits?: Maybe<Scalars['Float']['output']>;
  alarm2DirectionUp?: Maybe<Scalars['Boolean']['output']>;
  alarm2LevelCurrent?: Maybe<Scalars['Int']['output']>;
  alarm2LevelPercentage?: Maybe<Scalars['Float']['output']>;
  alarm2LevelUnits?: Maybe<Scalars['Float']['output']>;
  alarmUnits?: Maybe<Scalars['Boolean']['output']>;
  battery?: Maybe<Scalars['String']['output']>;
  batteryConnection?: Maybe<Scalars['String']['output']>;
  calFlowRate?: Maybe<Scalars['Float']['output']>;
  calGas?: Maybe<Scalars['String']['output']>;
  calReading?: Maybe<Scalars['String']['output']>;
  electrolyteName?: Maybe<Scalars['String']['output']>;
  engineeringUnits?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  highEu?: Maybe<Scalars['String']['output']>;
  longDate?: Maybe<Scalars['String']['output']>;
  lowEu?: Maybe<Scalars['String']['output']>;
  membraneName?: Maybe<Scalars['String']['output']>;
  oRingName?: Maybe<Scalars['String']['output']>;
  origAlarm1DirectionUp?: Maybe<Scalars['Int']['output']>;
  origAlarm1LevelCurrent?: Maybe<Scalars['Int']['output']>;
  origAlarm1LevelPercentage?: Maybe<Scalars['Float']['output']>;
  origAlarm1LevelUnits?: Maybe<Scalars['Float']['output']>;
  origAlarm2DirectionUp?: Maybe<Scalars['Int']['output']>;
  origAlarm2LevelCurrent?: Maybe<Scalars['Int']['output']>;
  origAlarm2LevelPercentage?: Maybe<Scalars['Float']['output']>;
  origAlarm2LevelUnits?: Maybe<Scalars['Float']['output']>;
  origAlarmUnits?: Maybe<Scalars['Int']['output']>;
  origBattery?: Maybe<Scalars['String']['output']>;
  origBatteryConnection?: Maybe<Scalars['String']['output']>;
  origCalFlowRate?: Maybe<Scalars['Float']['output']>;
  origCalGas?: Maybe<Scalars['String']['output']>;
  origElectrolyteName?: Maybe<Scalars['String']['output']>;
  origEngineeringUnits?: Maybe<Scalars['String']['output']>;
  origMembraneName?: Maybe<Scalars['String']['output']>;
  origORingName?: Maybe<Scalars['String']['output']>;
  origPc5109DS1?: Maybe<Scalars['String']['output']>;
  origPc5109DS2?: Maybe<Scalars['String']['output']>;
  origPc5109DS3?: Maybe<Scalars['String']['output']>;
  origPc5109DS5?: Maybe<Scalars['String']['output']>;
  origPc5109DS6?: Maybe<Scalars['String']['output']>;
  origPlugName?: Maybe<Scalars['String']['output']>;
  origPrecision?: Maybe<Scalars['Int']['output']>;
  origRestrictor?: Maybe<Scalars['String']['output']>;
  origSeal?: Maybe<Scalars['String']['output']>;
  origSensorRange?: Maybe<Scalars['String']['output']>;
  origSensorRange2?: Maybe<Scalars['String']['output']>;
  origSensorShortType?: Maybe<Scalars['String']['output']>;
  origSensorType?: Maybe<Scalars['String']['output']>;
  origSensorTypeSuffix?: Maybe<Scalars['String']['output']>;
  origTarget?: Maybe<Scalars['String']['output']>;
  origTransportSwitch?: Maybe<Scalars['String']['output']>;
  origWarning1LevelCurrent?: Maybe<Scalars['Int']['output']>;
  origWarning1LevelPercentage?: Maybe<Scalars['Float']['output']>;
  pc5109DS1?: Maybe<Scalars['String']['output']>;
  pc5109DS2?: Maybe<Scalars['String']['output']>;
  pc5109DS3?: Maybe<Scalars['String']['output']>;
  pc5109DS5?: Maybe<Scalars['String']['output']>;
  pc5109DS6?: Maybe<Scalars['String']['output']>;
  pc5154BS1?: Maybe<Scalars['String']['output']>;
  pc5154BS2?: Maybe<Scalars['String']['output']>;
  pc5155BS1?: Maybe<Scalars['String']['output']>;
  pc5155BS3?: Maybe<Scalars['String']['output']>;
  pc5155BS4?: Maybe<Scalars['String']['output']>;
  pc5155BS5?: Maybe<Scalars['String']['output']>;
  plugName?: Maybe<Scalars['String']['output']>;
  precision?: Maybe<Scalars['Int']['output']>;
  pyrolyserId?: Maybe<Scalars['Int']['output']>;
  restrictor?: Maybe<Scalars['String']['output']>;
  seal?: Maybe<Scalars['String']['output']>;
  sensorRange?: Maybe<Scalars['String']['output']>;
  sensorRange2?: Maybe<Scalars['String']['output']>;
  sensorSerialNumber?: Maybe<Scalars['String']['output']>;
  sensorShortType?: Maybe<Scalars['String']['output']>;
  sensorType?: Maybe<Scalars['String']['output']>;
  sensorTypeCode?: Maybe<Scalars['String']['output']>;
  sensorTypePrefix?: Maybe<Scalars['String']['output']>;
  sensorTypeSuffix?: Maybe<Scalars['String']['output']>;
  shortDate?: Maybe<Scalars['String']['output']>;
  target?: Maybe<Scalars['String']['output']>;
  transportSwitch?: Maybe<Scalars['String']['output']>;
  warning1LevelCurrent?: Maybe<Scalars['Int']['output']>;
  warning1LevelPercentage?: Maybe<Scalars['Float']['output']>;
  warning2LevelCurrent?: Maybe<Scalars['Int']['output']>;
  warning2LevelPercentage?: Maybe<Scalars['Float']['output']>;
};

/**
 * A condition to be used against `SensorsChecklist` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SensorsChecklistCondition = {
  /** Checks for equality with the object’s `alarm1DirectionUp` field. */
  alarm1DirectionUp?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `alarm1LevelCurrent` field. */
  alarm1LevelCurrent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `alarm1LevelPercentage` field. */
  alarm1LevelPercentage?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `alarm1LevelUnits` field. */
  alarm1LevelUnits?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `alarm2DirectionUp` field. */
  alarm2DirectionUp?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `alarm2LevelCurrent` field. */
  alarm2LevelCurrent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `alarm2LevelPercentage` field. */
  alarm2LevelPercentage?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `alarm2LevelUnits` field. */
  alarm2LevelUnits?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `alarmUnits` field. */
  alarmUnits?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `battery` field. */
  battery?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `batteryConnection` field. */
  batteryConnection?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `calGas` field. */
  calGas?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `calReading` field. */
  calReading?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `highEu` field. */
  highEu?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `longDate` field. */
  longDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lowEu` field. */
  lowEu?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `membraneName` field. */
  membraneName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `oRingName` field. */
  oRingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origAlarm1DirectionUp` field. */
  origAlarm1DirectionUp?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `origAlarm1LevelCurrent` field. */
  origAlarm1LevelCurrent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `origAlarm1LevelPercentage` field. */
  origAlarm1LevelPercentage?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `origAlarm1LevelUnits` field. */
  origAlarm1LevelUnits?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `origAlarm2DirectionUp` field. */
  origAlarm2DirectionUp?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `origAlarm2LevelCurrent` field. */
  origAlarm2LevelCurrent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `origAlarm2LevelPercentage` field. */
  origAlarm2LevelPercentage?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `origAlarm2LevelUnits` field. */
  origAlarm2LevelUnits?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `origAlarmUnits` field. */
  origAlarmUnits?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `origBattery` field. */
  origBattery?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origBatteryConnection` field. */
  origBatteryConnection?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origCalFlowRate` field. */
  origCalFlowRate?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `origCalGas` field. */
  origCalGas?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origElectrolyteName` field. */
  origElectrolyteName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origEngineeringUnits` field. */
  origEngineeringUnits?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origMembraneName` field. */
  origMembraneName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origORingName` field. */
  origORingName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origPc5109DS1` field. */
  origPc5109DS1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origPc5109DS2` field. */
  origPc5109DS2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origPc5109DS3` field. */
  origPc5109DS3?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origPc5109DS5` field. */
  origPc5109DS5?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origPc5109DS6` field. */
  origPc5109DS6?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origPlugName` field. */
  origPlugName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origPrecision` field. */
  origPrecision?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `origRestrictor` field. */
  origRestrictor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origSeal` field. */
  origSeal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origSensorRange` field. */
  origSensorRange?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origSensorRange2` field. */
  origSensorRange2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origSensorShortType` field. */
  origSensorShortType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origSensorType` field. */
  origSensorType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origSensorTypeSuffix` field. */
  origSensorTypeSuffix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origTarget` field. */
  origTarget?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origTransportSwitch` field. */
  origTransportSwitch?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origWarning1LevelCurrent` field. */
  origWarning1LevelCurrent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `origWarning1LevelPercentage` field. */
  origWarning1LevelPercentage?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `pc5109DS1` field. */
  pc5109DS1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5109DS2` field. */
  pc5109DS2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5109DS3` field. */
  pc5109DS3?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5109DS5` field. */
  pc5109DS5?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5109DS6` field. */
  pc5109DS6?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5154BS1` field. */
  pc5154BS1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5154BS2` field. */
  pc5154BS2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS1` field. */
  pc5155BS1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS3` field. */
  pc5155BS3?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS4` field. */
  pc5155BS4?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pc5155BS5` field. */
  pc5155BS5?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plugName` field. */
  plugName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `precision` field. */
  precision?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `restrictor` field. */
  restrictor?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `seal` field. */
  seal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorRange` field. */
  sensorRange?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorRange2` field. */
  sensorRange2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorShortType` field. */
  sensorShortType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorType` field. */
  sensorType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypeCode` field. */
  sensorTypeCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypePrefix` field. */
  sensorTypePrefix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sensorTypeSuffix` field. */
  sensorTypeSuffix?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shortDate` field. */
  shortDate?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `target` field. */
  target?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `transportSwitch` field. */
  transportSwitch?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `warning1LevelCurrent` field. */
  warning1LevelCurrent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `warning1LevelPercentage` field. */
  warning1LevelPercentage?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `warning2LevelCurrent` field. */
  warning2LevelCurrent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `warning2LevelPercentage` field. */
  warning2LevelPercentage?: InputMaybe<Scalars['Float']['input']>;
};

/** A filter to be used against `SensorsChecklist` object types. All fields are combined with a logical ‘and.’ */
export type SensorsChecklistFilter = {
  /** Filter by the object’s `alarm1DirectionUp` field. */
  alarm1DirectionUp?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `alarm1LevelCurrent` field. */
  alarm1LevelCurrent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `alarm1LevelPercentage` field. */
  alarm1LevelPercentage?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `alarm1LevelUnits` field. */
  alarm1LevelUnits?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `alarm2DirectionUp` field. */
  alarm2DirectionUp?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `alarm2LevelCurrent` field. */
  alarm2LevelCurrent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `alarm2LevelPercentage` field. */
  alarm2LevelPercentage?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `alarm2LevelUnits` field. */
  alarm2LevelUnits?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `alarmUnits` field. */
  alarmUnits?: InputMaybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SensorsChecklistFilter>>;
  /** Filter by the object’s `battery` field. */
  battery?: InputMaybe<StringFilter>;
  /** Filter by the object’s `batteryConnection` field. */
  batteryConnection?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calFlowRate` field. */
  calFlowRate?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `calGas` field. */
  calGas?: InputMaybe<StringFilter>;
  /** Filter by the object’s `calReading` field. */
  calReading?: InputMaybe<StringFilter>;
  /** Filter by the object’s `electrolyteName` field. */
  electrolyteName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `engineeringUnits` field. */
  engineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `highEu` field. */
  highEu?: InputMaybe<StringFilter>;
  /** Filter by the object’s `longDate` field. */
  longDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lowEu` field. */
  lowEu?: InputMaybe<StringFilter>;
  /** Filter by the object’s `membraneName` field. */
  membraneName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SensorsChecklistFilter>;
  /** Filter by the object’s `oRingName` field. */
  oRingName?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SensorsChecklistFilter>>;
  /** Filter by the object’s `origAlarm1DirectionUp` field. */
  origAlarm1DirectionUp?: InputMaybe<IntFilter>;
  /** Filter by the object’s `origAlarm1LevelCurrent` field. */
  origAlarm1LevelCurrent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `origAlarm1LevelPercentage` field. */
  origAlarm1LevelPercentage?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `origAlarm1LevelUnits` field. */
  origAlarm1LevelUnits?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `origAlarm2DirectionUp` field. */
  origAlarm2DirectionUp?: InputMaybe<IntFilter>;
  /** Filter by the object’s `origAlarm2LevelCurrent` field. */
  origAlarm2LevelCurrent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `origAlarm2LevelPercentage` field. */
  origAlarm2LevelPercentage?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `origAlarm2LevelUnits` field. */
  origAlarm2LevelUnits?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `origAlarmUnits` field. */
  origAlarmUnits?: InputMaybe<IntFilter>;
  /** Filter by the object’s `origBattery` field. */
  origBattery?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origBatteryConnection` field. */
  origBatteryConnection?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origCalFlowRate` field. */
  origCalFlowRate?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `origCalGas` field. */
  origCalGas?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origElectrolyteName` field. */
  origElectrolyteName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origEngineeringUnits` field. */
  origEngineeringUnits?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origMembraneName` field. */
  origMembraneName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origORingName` field. */
  origORingName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origPc5109DS1` field. */
  origPc5109DS1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origPc5109DS2` field. */
  origPc5109DS2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origPc5109DS3` field. */
  origPc5109DS3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origPc5109DS5` field. */
  origPc5109DS5?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origPc5109DS6` field. */
  origPc5109DS6?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origPlugName` field. */
  origPlugName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origPrecision` field. */
  origPrecision?: InputMaybe<IntFilter>;
  /** Filter by the object’s `origRestrictor` field. */
  origRestrictor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origSeal` field. */
  origSeal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origSensorRange` field. */
  origSensorRange?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origSensorRange2` field. */
  origSensorRange2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origSensorShortType` field. */
  origSensorShortType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origSensorType` field. */
  origSensorType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origSensorTypeSuffix` field. */
  origSensorTypeSuffix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origTarget` field. */
  origTarget?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origTransportSwitch` field. */
  origTransportSwitch?: InputMaybe<StringFilter>;
  /** Filter by the object’s `origWarning1LevelCurrent` field. */
  origWarning1LevelCurrent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `origWarning1LevelPercentage` field. */
  origWarning1LevelPercentage?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `pc5109DS1` field. */
  pc5109DS1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5109DS2` field. */
  pc5109DS2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5109DS3` field. */
  pc5109DS3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5109DS5` field. */
  pc5109DS5?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5109DS6` field. */
  pc5109DS6?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5154BS1` field. */
  pc5154BS1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5154BS2` field. */
  pc5154BS2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS1` field. */
  pc5155BS1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS3` field. */
  pc5155BS3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS4` field. */
  pc5155BS4?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pc5155BS5` field. */
  pc5155BS5?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plugName` field. */
  plugName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `precision` field. */
  precision?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `restrictor` field. */
  restrictor?: InputMaybe<StringFilter>;
  /** Filter by the object’s `seal` field. */
  seal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorRange` field. */
  sensorRange?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorRange2` field. */
  sensorRange2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorSerialNumber` field. */
  sensorSerialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorShortType` field. */
  sensorShortType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorType` field. */
  sensorType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorTypeCode` field. */
  sensorTypeCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorTypePrefix` field. */
  sensorTypePrefix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sensorTypeSuffix` field. */
  sensorTypeSuffix?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shortDate` field. */
  shortDate?: InputMaybe<StringFilter>;
  /** Filter by the object’s `target` field. */
  target?: InputMaybe<StringFilter>;
  /** Filter by the object’s `transportSwitch` field. */
  transportSwitch?: InputMaybe<StringFilter>;
  /** Filter by the object’s `warning1LevelCurrent` field. */
  warning1LevelCurrent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `warning1LevelPercentage` field. */
  warning1LevelPercentage?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `warning2LevelCurrent` field. */
  warning2LevelCurrent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `warning2LevelPercentage` field. */
  warning2LevelPercentage?: InputMaybe<FloatFilter>;
};

/** A connection to a list of `SensorsChecklist` values. */
export type SensorsChecklistsConnection = {
  __typename?: 'SensorsChecklistsConnection';
  /** A list of edges which contains the `SensorsChecklist` and cursor to aid in pagination. */
  edges: Array<SensorsChecklistsEdge>;
  /** A list of `SensorsChecklist` objects. */
  nodes: Array<SensorsChecklist>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SensorsChecklist` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SensorsChecklist` edge in the connection. */
export type SensorsChecklistsEdge = {
  __typename?: 'SensorsChecklistsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SensorsChecklist` at the end of the edge. */
  node: SensorsChecklist;
};

/** Methods to use when ordering `SensorsChecklist`. */
export enum SensorsChecklistsOrderBy {
  Alarm_1DirectionUpAsc = 'ALARM_1_DIRECTION_UP_ASC',
  Alarm_1DirectionUpDesc = 'ALARM_1_DIRECTION_UP_DESC',
  Alarm_1LevelCurrentAsc = 'ALARM_1_LEVEL_CURRENT_ASC',
  Alarm_1LevelCurrentDesc = 'ALARM_1_LEVEL_CURRENT_DESC',
  Alarm_1LevelPercentageAsc = 'ALARM_1_LEVEL_PERCENTAGE_ASC',
  Alarm_1LevelPercentageDesc = 'ALARM_1_LEVEL_PERCENTAGE_DESC',
  Alarm_1LevelUnitsAsc = 'ALARM_1_LEVEL_UNITS_ASC',
  Alarm_1LevelUnitsDesc = 'ALARM_1_LEVEL_UNITS_DESC',
  Alarm_2DirectionUpAsc = 'ALARM_2_DIRECTION_UP_ASC',
  Alarm_2DirectionUpDesc = 'ALARM_2_DIRECTION_UP_DESC',
  Alarm_2LevelCurrentAsc = 'ALARM_2_LEVEL_CURRENT_ASC',
  Alarm_2LevelCurrentDesc = 'ALARM_2_LEVEL_CURRENT_DESC',
  Alarm_2LevelPercentageAsc = 'ALARM_2_LEVEL_PERCENTAGE_ASC',
  Alarm_2LevelPercentageDesc = 'ALARM_2_LEVEL_PERCENTAGE_DESC',
  Alarm_2LevelUnitsAsc = 'ALARM_2_LEVEL_UNITS_ASC',
  Alarm_2LevelUnitsDesc = 'ALARM_2_LEVEL_UNITS_DESC',
  AlarmUnitsAsc = 'ALARM_UNITS_ASC',
  AlarmUnitsDesc = 'ALARM_UNITS_DESC',
  BatteryAsc = 'BATTERY_ASC',
  BatteryConnectionAsc = 'BATTERY_CONNECTION_ASC',
  BatteryConnectionDesc = 'BATTERY_CONNECTION_DESC',
  BatteryDesc = 'BATTERY_DESC',
  CalFlowRateAsc = 'CAL_FLOW_RATE_ASC',
  CalFlowRateDesc = 'CAL_FLOW_RATE_DESC',
  CalGasAsc = 'CAL_GAS_ASC',
  CalGasDesc = 'CAL_GAS_DESC',
  CalReadingAsc = 'CAL_READING_ASC',
  CalReadingDesc = 'CAL_READING_DESC',
  ElectrolyteNameAsc = 'ELECTROLYTE_NAME_ASC',
  ElectrolyteNameDesc = 'ELECTROLYTE_NAME_DESC',
  EngineeringUnitsAsc = 'ENGINEERING_UNITS_ASC',
  EngineeringUnitsDesc = 'ENGINEERING_UNITS_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  HighEuAsc = 'HIGH_EU_ASC',
  HighEuDesc = 'HIGH_EU_DESC',
  LongDateAsc = 'LONG_DATE_ASC',
  LongDateDesc = 'LONG_DATE_DESC',
  LowEuAsc = 'LOW_EU_ASC',
  LowEuDesc = 'LOW_EU_DESC',
  MembraneNameAsc = 'MEMBRANE_NAME_ASC',
  MembraneNameDesc = 'MEMBRANE_NAME_DESC',
  Natural = 'NATURAL',
  OrigAlarm_1DirectionUpAsc = 'ORIG_ALARM_1_DIRECTION_UP_ASC',
  OrigAlarm_1DirectionUpDesc = 'ORIG_ALARM_1_DIRECTION_UP_DESC',
  OrigAlarm_1LevelCurrentAsc = 'ORIG_ALARM_1_LEVEL_CURRENT_ASC',
  OrigAlarm_1LevelCurrentDesc = 'ORIG_ALARM_1_LEVEL_CURRENT_DESC',
  OrigAlarm_1LevelPercentageAsc = 'ORIG_ALARM_1_LEVEL_PERCENTAGE_ASC',
  OrigAlarm_1LevelPercentageDesc = 'ORIG_ALARM_1_LEVEL_PERCENTAGE_DESC',
  OrigAlarm_1LevelUnitsAsc = 'ORIG_ALARM_1_LEVEL_UNITS_ASC',
  OrigAlarm_1LevelUnitsDesc = 'ORIG_ALARM_1_LEVEL_UNITS_DESC',
  OrigAlarm_2DirectionUpAsc = 'ORIG_ALARM_2_DIRECTION_UP_ASC',
  OrigAlarm_2DirectionUpDesc = 'ORIG_ALARM_2_DIRECTION_UP_DESC',
  OrigAlarm_2LevelCurrentAsc = 'ORIG_ALARM_2_LEVEL_CURRENT_ASC',
  OrigAlarm_2LevelCurrentDesc = 'ORIG_ALARM_2_LEVEL_CURRENT_DESC',
  OrigAlarm_2LevelPercentageAsc = 'ORIG_ALARM_2_LEVEL_PERCENTAGE_ASC',
  OrigAlarm_2LevelPercentageDesc = 'ORIG_ALARM_2_LEVEL_PERCENTAGE_DESC',
  OrigAlarm_2LevelUnitsAsc = 'ORIG_ALARM_2_LEVEL_UNITS_ASC',
  OrigAlarm_2LevelUnitsDesc = 'ORIG_ALARM_2_LEVEL_UNITS_DESC',
  OrigAlarmUnitsAsc = 'ORIG_ALARM_UNITS_ASC',
  OrigAlarmUnitsDesc = 'ORIG_ALARM_UNITS_DESC',
  OrigBatteryAsc = 'ORIG_BATTERY_ASC',
  OrigBatteryConnectionAsc = 'ORIG_BATTERY_CONNECTION_ASC',
  OrigBatteryConnectionDesc = 'ORIG_BATTERY_CONNECTION_DESC',
  OrigBatteryDesc = 'ORIG_BATTERY_DESC',
  OrigCalFlowRateAsc = 'ORIG_CAL_FLOW_RATE_ASC',
  OrigCalFlowRateDesc = 'ORIG_CAL_FLOW_RATE_DESC',
  OrigCalGasAsc = 'ORIG_CAL_GAS_ASC',
  OrigCalGasDesc = 'ORIG_CAL_GAS_DESC',
  OrigElectrolyteNameAsc = 'ORIG_ELECTROLYTE_NAME_ASC',
  OrigElectrolyteNameDesc = 'ORIG_ELECTROLYTE_NAME_DESC',
  OrigEngineeringUnitsAsc = 'ORIG_ENGINEERING_UNITS_ASC',
  OrigEngineeringUnitsDesc = 'ORIG_ENGINEERING_UNITS_DESC',
  OrigMembraneNameAsc = 'ORIG_MEMBRANE_NAME_ASC',
  OrigMembraneNameDesc = 'ORIG_MEMBRANE_NAME_DESC',
  OrigORingNameAsc = 'ORIG_O_RING_NAME_ASC',
  OrigORingNameDesc = 'ORIG_O_RING_NAME_DESC',
  OrigPc_5109DS1Asc = 'ORIG_PC_5109D_S1_ASC',
  OrigPc_5109DS1Desc = 'ORIG_PC_5109D_S1_DESC',
  OrigPc_5109DS2Asc = 'ORIG_PC_5109D_S2_ASC',
  OrigPc_5109DS2Desc = 'ORIG_PC_5109D_S2_DESC',
  OrigPc_5109DS3Asc = 'ORIG_PC_5109D_S3_ASC',
  OrigPc_5109DS3Desc = 'ORIG_PC_5109D_S3_DESC',
  OrigPc_5109DS5Asc = 'ORIG_PC_5109D_S5_ASC',
  OrigPc_5109DS5Desc = 'ORIG_PC_5109D_S5_DESC',
  OrigPc_5109DS6Asc = 'ORIG_PC_5109D_S6_ASC',
  OrigPc_5109DS6Desc = 'ORIG_PC_5109D_S6_DESC',
  OrigPlugNameAsc = 'ORIG_PLUG_NAME_ASC',
  OrigPlugNameDesc = 'ORIG_PLUG_NAME_DESC',
  OrigPrecisionAsc = 'ORIG_PRECISION_ASC',
  OrigPrecisionDesc = 'ORIG_PRECISION_DESC',
  OrigRestrictorAsc = 'ORIG_RESTRICTOR_ASC',
  OrigRestrictorDesc = 'ORIG_RESTRICTOR_DESC',
  OrigSealAsc = 'ORIG_SEAL_ASC',
  OrigSealDesc = 'ORIG_SEAL_DESC',
  OrigSensorRange_2Asc = 'ORIG_SENSOR_RANGE_2_ASC',
  OrigSensorRange_2Desc = 'ORIG_SENSOR_RANGE_2_DESC',
  OrigSensorRangeAsc = 'ORIG_SENSOR_RANGE_ASC',
  OrigSensorRangeDesc = 'ORIG_SENSOR_RANGE_DESC',
  OrigSensorShortTypeAsc = 'ORIG_SENSOR_SHORT_TYPE_ASC',
  OrigSensorShortTypeDesc = 'ORIG_SENSOR_SHORT_TYPE_DESC',
  OrigSensorTypeAsc = 'ORIG_SENSOR_TYPE_ASC',
  OrigSensorTypeDesc = 'ORIG_SENSOR_TYPE_DESC',
  OrigSensorTypeSuffixAsc = 'ORIG_SENSOR_TYPE_SUFFIX_ASC',
  OrigSensorTypeSuffixDesc = 'ORIG_SENSOR_TYPE_SUFFIX_DESC',
  OrigTargetAsc = 'ORIG_TARGET_ASC',
  OrigTargetDesc = 'ORIG_TARGET_DESC',
  OrigTransportSwitchAsc = 'ORIG_TRANSPORT_SWITCH_ASC',
  OrigTransportSwitchDesc = 'ORIG_TRANSPORT_SWITCH_DESC',
  OrigWarning_1LevelCurrentAsc = 'ORIG_WARNING_1_LEVEL_CURRENT_ASC',
  OrigWarning_1LevelCurrentDesc = 'ORIG_WARNING_1_LEVEL_CURRENT_DESC',
  OrigWarning_1LevelPercentageAsc = 'ORIG_WARNING_1_LEVEL_PERCENTAGE_ASC',
  OrigWarning_1LevelPercentageDesc = 'ORIG_WARNING_1_LEVEL_PERCENTAGE_DESC',
  ORingNameAsc = 'O_RING_NAME_ASC',
  ORingNameDesc = 'O_RING_NAME_DESC',
  Pc_5109DS1Asc = 'PC_5109D_S1_ASC',
  Pc_5109DS1Desc = 'PC_5109D_S1_DESC',
  Pc_5109DS2Asc = 'PC_5109D_S2_ASC',
  Pc_5109DS2Desc = 'PC_5109D_S2_DESC',
  Pc_5109DS3Asc = 'PC_5109D_S3_ASC',
  Pc_5109DS3Desc = 'PC_5109D_S3_DESC',
  Pc_5109DS5Asc = 'PC_5109D_S5_ASC',
  Pc_5109DS5Desc = 'PC_5109D_S5_DESC',
  Pc_5109DS6Asc = 'PC_5109D_S6_ASC',
  Pc_5109DS6Desc = 'PC_5109D_S6_DESC',
  Pc_5154BS1Asc = 'PC_5154B_S1_ASC',
  Pc_5154BS1Desc = 'PC_5154B_S1_DESC',
  Pc_5154BS2Asc = 'PC_5154B_S2_ASC',
  Pc_5154BS2Desc = 'PC_5154B_S2_DESC',
  Pc_5155BS1Asc = 'PC_5155B_S1_ASC',
  Pc_5155BS1Desc = 'PC_5155B_S1_DESC',
  Pc_5155BS3Asc = 'PC_5155B_S3_ASC',
  Pc_5155BS3Desc = 'PC_5155B_S3_DESC',
  Pc_5155BS4Asc = 'PC_5155B_S4_ASC',
  Pc_5155BS4Desc = 'PC_5155B_S4_DESC',
  Pc_5155BS5Asc = 'PC_5155B_S5_ASC',
  Pc_5155BS5Desc = 'PC_5155B_S5_DESC',
  PlugNameAsc = 'PLUG_NAME_ASC',
  PlugNameDesc = 'PLUG_NAME_DESC',
  PrecisionAsc = 'PRECISION_ASC',
  PrecisionDesc = 'PRECISION_DESC',
  PyrolyserIdAsc = 'PYROLYSER_ID_ASC',
  PyrolyserIdDesc = 'PYROLYSER_ID_DESC',
  RestrictorAsc = 'RESTRICTOR_ASC',
  RestrictorDesc = 'RESTRICTOR_DESC',
  SealAsc = 'SEAL_ASC',
  SealDesc = 'SEAL_DESC',
  SensorRange_2Asc = 'SENSOR_RANGE_2_ASC',
  SensorRange_2Desc = 'SENSOR_RANGE_2_DESC',
  SensorRangeAsc = 'SENSOR_RANGE_ASC',
  SensorRangeDesc = 'SENSOR_RANGE_DESC',
  SensorSerialNumberAsc = 'SENSOR_SERIAL_NUMBER_ASC',
  SensorSerialNumberDesc = 'SENSOR_SERIAL_NUMBER_DESC',
  SensorShortTypeAsc = 'SENSOR_SHORT_TYPE_ASC',
  SensorShortTypeDesc = 'SENSOR_SHORT_TYPE_DESC',
  SensorTypeAsc = 'SENSOR_TYPE_ASC',
  SensorTypeCodeAsc = 'SENSOR_TYPE_CODE_ASC',
  SensorTypeCodeDesc = 'SENSOR_TYPE_CODE_DESC',
  SensorTypeDesc = 'SENSOR_TYPE_DESC',
  SensorTypePrefixAsc = 'SENSOR_TYPE_PREFIX_ASC',
  SensorTypePrefixDesc = 'SENSOR_TYPE_PREFIX_DESC',
  SensorTypeSuffixAsc = 'SENSOR_TYPE_SUFFIX_ASC',
  SensorTypeSuffixDesc = 'SENSOR_TYPE_SUFFIX_DESC',
  ShortDateAsc = 'SHORT_DATE_ASC',
  ShortDateDesc = 'SHORT_DATE_DESC',
  TargetAsc = 'TARGET_ASC',
  TargetDesc = 'TARGET_DESC',
  TransportSwitchAsc = 'TRANSPORT_SWITCH_ASC',
  TransportSwitchDesc = 'TRANSPORT_SWITCH_DESC',
  Warning_1LevelCurrentAsc = 'WARNING_1_LEVEL_CURRENT_ASC',
  Warning_1LevelCurrentDesc = 'WARNING_1_LEVEL_CURRENT_DESC',
  Warning_1LevelPercentageAsc = 'WARNING_1_LEVEL_PERCENTAGE_ASC',
  Warning_1LevelPercentageDesc = 'WARNING_1_LEVEL_PERCENTAGE_DESC',
  Warning_2LevelCurrentAsc = 'WARNING_2_LEVEL_CURRENT_ASC',
  Warning_2LevelCurrentDesc = 'WARNING_2_LEVEL_CURRENT_DESC',
  Warning_2LevelPercentageAsc = 'WARNING_2_LEVEL_PERCENTAGE_ASC',
  Warning_2LevelPercentageDesc = 'WARNING_2_LEVEL_PERCENTAGE_DESC'
}

/** A connection to a list of `Sensor` values. */
export type SensorsConnection = {
  __typename?: 'SensorsConnection';
  /** A list of edges which contains the `Sensor` and cursor to aid in pagination. */
  edges: Array<SensorsEdge>;
  /** A list of `Sensor` objects. */
  nodes: Array<Sensor>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Sensor` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Sensor` edge in the connection. */
export type SensorsEdge = {
  __typename?: 'SensorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Sensor` at the end of the edge. */
  node: Sensor;
};

/** Methods to use when ordering `Sensor`. */
export enum SensorsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorSensorBySensorIdCreatedAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__CREATED_ASC',
  DetectorSensorBySensorIdCreatedDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__CREATED_DESC',
  DetectorSensorBySensorIdDetectorIdAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__DETECTOR_ID_ASC',
  DetectorSensorBySensorIdDetectorIdDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__DETECTOR_ID_DESC',
  DetectorSensorBySensorIdDetectorPositionAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__DETECTOR_POSITION_ASC',
  DetectorSensorBySensorIdDetectorPositionDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__DETECTOR_POSITION_DESC',
  DetectorSensorBySensorIdFilterIdAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__FILTER_ID_ASC',
  DetectorSensorBySensorIdFilterIdDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__FILTER_ID_DESC',
  DetectorSensorBySensorIdIdAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__ID_ASC',
  DetectorSensorBySensorIdIdDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__ID_DESC',
  DetectorSensorBySensorIdModifiedAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__MODIFIED_ASC',
  DetectorSensorBySensorIdModifiedDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__MODIFIED_DESC',
  DetectorSensorBySensorIdOwnerIdAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__OWNER_ID_ASC',
  DetectorSensorBySensorIdOwnerIdDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__OWNER_ID_DESC',
  DetectorSensorBySensorIdPyrolyserIdAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__PYROLYSER_ID_ASC',
  DetectorSensorBySensorIdPyrolyserIdDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__PYROLYSER_ID_DESC',
  DetectorSensorBySensorIdSensorIdAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID__SENSOR_ID_ASC',
  DetectorSensorBySensorIdSensorIdDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID__SENSOR_ID_DESC',
  DetectorSensorBySensorIdFilterLabelDateAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID___FILTER_LABEL_DATE_ASC',
  DetectorSensorBySensorIdFilterLabelDateDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID___FILTER_LABEL_DATE_DESC',
  DetectorSensorBySensorIdPyrolyserLabelDateAsc = 'DETECTOR_SENSOR_BY_SENSOR_ID___PYROLYSER_LABEL_DATE_ASC',
  DetectorSensorBySensorIdPyrolyserLabelDateDesc = 'DETECTOR_SENSOR_BY_SENSOR_ID___PYROLYSER_LABEL_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LabelDateAsc = 'LABEL_DATE_ASC',
  LabelDateDesc = 'LABEL_DATE_DESC',
  MaintenanceVisitLinesByOriginalSensorIdCountAsc = 'MAINTENANCE_VISIT_LINES_BY_ORIGINAL_SENSOR_ID__COUNT_ASC',
  MaintenanceVisitLinesByOriginalSensorIdCountDesc = 'MAINTENANCE_VISIT_LINES_BY_ORIGINAL_SENSOR_ID__COUNT_DESC',
  MaintenanceVisitLinesBySensorIdCountAsc = 'MAINTENANCE_VISIT_LINES_BY_SENSOR_ID__COUNT_ASC',
  MaintenanceVisitLinesBySensorIdCountDesc = 'MAINTENANCE_VISIT_LINES_BY_SENSOR_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  ReportSensorsBySensorIdCountAsc = 'REPORT_SENSORS_BY_SENSOR_ID__COUNT_ASC',
  ReportSensorsBySensorIdCountDesc = 'REPORT_SENSORS_BY_SENSOR_ID__COUNT_DESC',
  SensorElementLogsBySensorIdCountAsc = 'SENSOR_ELEMENT_LOGS_BY_SENSOR_ID__COUNT_ASC',
  SensorElementLogsBySensorIdCountDesc = 'SENSOR_ELEMENT_LOGS_BY_SENSOR_ID__COUNT_DESC',
  SensorOrdersBySensorIdCountAsc = 'SENSOR_ORDERS_BY_SENSOR_ID__COUNT_ASC',
  SensorOrdersBySensorIdCountDesc = 'SENSOR_ORDERS_BY_SENSOR_ID__COUNT_DESC',
  SensorSensorElementsBySensorIdCountAsc = 'SENSOR_SENSOR_ELEMENTS_BY_SENSOR_ID__COUNT_ASC',
  SensorSensorElementsBySensorIdCountDesc = 'SENSOR_SENSOR_ELEMENTS_BY_SENSOR_ID__COUNT_DESC',
  SensorTestResultsBySensorIdCountAsc = 'SENSOR_TEST_RESULTS_BY_SENSOR_ID__COUNT_ASC',
  SensorTestResultsBySensorIdCountDesc = 'SENSOR_TEST_RESULTS_BY_SENSOR_ID__COUNT_DESC',
  SensorTypeBySensorTypeIdBatteryAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__BATTERY_ASC',
  SensorTypeBySensorTypeIdBatteryDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__BATTERY_DESC',
  SensorTypeBySensorTypeIdBiasMvAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__BIAS_MV_ASC',
  SensorTypeBySensorTypeIdBiasMvDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__BIAS_MV_DESC',
  SensorTypeBySensorTypeIdCalFlowRateAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_FLOW_RATE_ASC',
  SensorTypeBySensorTypeIdCalFlowRateDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_FLOW_RATE_DESC',
  SensorTypeBySensorTypeIdCalGasIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_GAS_ID_ASC',
  SensorTypeBySensorTypeIdCalGasIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_GAS_ID_DESC',
  SensorTypeBySensorTypeIdCalResponseAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_RESPONSE_ASC',
  SensorTypeBySensorTypeIdCalResponseDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CAL_RESPONSE_DESC',
  SensorTypeBySensorTypeIdCdartikelAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CDARTIKEL_ASC',
  SensorTypeBySensorTypeIdCdartikelDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CDARTIKEL_DESC',
  SensorTypeBySensorTypeIdCodeAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CODE_ASC',
  SensorTypeBySensorTypeIdCodeDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CODE_DESC',
  SensorTypeBySensorTypeIdCreatedAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CREATED_ASC',
  SensorTypeBySensorTypeIdCreatedDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__CREATED_DESC',
  SensorTypeBySensorTypeIdDirectionAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__DIRECTION_ASC',
  SensorTypeBySensorTypeIdDirectionDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__DIRECTION_DESC',
  SensorTypeBySensorTypeIdElectrodeCountAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELECTRODE_COUNT_ASC',
  SensorTypeBySensorTypeIdElectrodeCountDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELECTRODE_COUNT_DESC',
  SensorTypeBySensorTypeIdElectrolyteIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELECTROLYTE_ID_ASC',
  SensorTypeBySensorTypeIdElectrolyteIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELECTROLYTE_ID_DESC',
  SensorTypeBySensorTypeIdElementCountAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELEMENT_COUNT_ASC',
  SensorTypeBySensorTypeIdElementCountDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ELEMENT_COUNT_DESC',
  SensorTypeBySensorTypeIdFilterIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__FILTER_ID_ASC',
  SensorTypeBySensorTypeIdFilterIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__FILTER_ID_DESC',
  SensorTypeBySensorTypeIdFlowRateAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__FLOW_RATE_ASC',
  SensorTypeBySensorTypeIdFlowRateDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__FLOW_RATE_DESC',
  SensorTypeBySensorTypeIdIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ID_ASC',
  SensorTypeBySensorTypeIdIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__ID_DESC',
  SensorTypeBySensorTypeIdLowElectrolyteAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__LOW_ELECTROLYTE_ASC',
  SensorTypeBySensorTypeIdLowElectrolyteDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__LOW_ELECTROLYTE_DESC',
  SensorTypeBySensorTypeIdMaintenanceIntervalMonthsAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MAINTENANCE_INTERVAL_MONTHS_ASC',
  SensorTypeBySensorTypeIdMaintenanceIntervalMonthsDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MAINTENANCE_INTERVAL_MONTHS_DESC',
  SensorTypeBySensorTypeIdMembraneIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MEMBRANE_ID_ASC',
  SensorTypeBySensorTypeIdMembraneIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MEMBRANE_ID_DESC',
  SensorTypeBySensorTypeIdMembraneSealAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MEMBRANE_SEAL_ASC',
  SensorTypeBySensorTypeIdMembraneSealDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MEMBRANE_SEAL_DESC',
  SensorTypeBySensorTypeIdModelAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MODEL_ASC',
  SensorTypeBySensorTypeIdModelDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MODEL_DESC',
  SensorTypeBySensorTypeIdModifiedAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MODIFIED_ASC',
  SensorTypeBySensorTypeIdModifiedDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__MODIFIED_DESC',
  SensorTypeBySensorTypeIdObsoleteAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__OBSOLETE_ASC',
  SensorTypeBySensorTypeIdObsoleteDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__OBSOLETE_DESC',
  SensorTypeBySensorTypeIdOwnerIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__OWNER_ID_ASC',
  SensorTypeBySensorTypeIdOwnerIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__OWNER_ID_DESC',
  SensorTypeBySensorTypeIdORingIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__O_RING_ID_ASC',
  SensorTypeBySensorTypeIdORingIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__O_RING_ID_DESC',
  SensorTypeBySensorTypeIdPlugIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PLUG_ID_ASC',
  SensorTypeBySensorTypeIdPlugIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PLUG_ID_DESC',
  SensorTypeBySensorTypeIdPrincipleIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PRINCIPLE_ID_ASC',
  SensorTypeBySensorTypeIdPrincipleIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PRINCIPLE_ID_DESC',
  SensorTypeBySensorTypeIdPyrolyserIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PYROLYSER_ID_ASC',
  SensorTypeBySensorTypeIdPyrolyserIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PYROLYSER_ID_DESC',
  SensorTypeBySensorTypeIdPyrolyserVoltageAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PYROLYSER_VOLTAGE_ASC',
  SensorTypeBySensorTypeIdPyrolyserVoltageDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__PYROLYSER_VOLTAGE_DESC',
  SensorTypeBySensorTypeIdRangeIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__RANGE_ID_ASC',
  SensorTypeBySensorTypeIdRangeIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__RANGE_ID_DESC',
  SensorTypeBySensorTypeIdReplacementIntervalMonthsAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__REPLACEMENT_INTERVAL_MONTHS_ASC',
  SensorTypeBySensorTypeIdReplacementIntervalMonthsDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__REPLACEMENT_INTERVAL_MONTHS_DESC',
  SensorTypeBySensorTypeIdRestrictorAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__RESTRICTOR_ASC',
  SensorTypeBySensorTypeIdRestrictorDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__RESTRICTOR_DESC',
  SensorTypeBySensorTypeIdSensorBaseTypeIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SENSOR_BASE_TYPE_ID_ASC',
  SensorTypeBySensorTypeIdSensorBaseTypeIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SENSOR_BASE_TYPE_ID_DESC',
  SensorTypeBySensorTypeIdSensorTypeIdAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SENSOR_TYPE_ID_ASC',
  SensorTypeBySensorTypeIdSensorTypeIdDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SENSOR_TYPE_ID_DESC',
  SensorTypeBySensorTypeIdSiliconeSheetAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SILICONE_SHEET_ASC',
  SensorTypeBySensorTypeIdSiliconeSheetDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SILICONE_SHEET_DESC',
  SensorTypeBySensorTypeIdSpanResistorAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SPAN_RESISTOR_ASC',
  SensorTypeBySensorTypeIdSpanResistorDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__SPAN_RESISTOR_DESC',
  SensorTypeBySensorTypeIdTransportSwitchAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__TRANSPORT_SWITCH_ASC',
  SensorTypeBySensorTypeIdTransportSwitchDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__TRANSPORT_SWITCH_DESC',
  SensorTypeBySensorTypeIdVolumeAsc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__VOLUME_ASC',
  SensorTypeBySensorTypeIdVolumeDesc = 'SENSOR_TYPE_BY_SENSOR_TYPE_ID__VOLUME_DESC',
  SensorTypeIdAsc = 'SENSOR_TYPE_ID_ASC',
  SensorTypeIdDesc = 'SENSOR_TYPE_ID_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type Software = Node & {
  __typename?: 'Software';
  activationCode?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Hardware` that is related to this `Software`. */
  hardwareByHardwareId?: Maybe<Hardware>;
  hardwareId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  login?: Maybe<Scalars['String']['output']>;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  password?: Maybe<Scalars['String']['output']>;
  purchaseDate?: Maybe<Scalars['Date']['output']>;
  registrationCode?: Maybe<Scalars['String']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
  serialNumber?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  /** Reads a single `User` that is related to this `Software`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `Software` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SoftwareCondition = {
  /** Checks for equality with the object’s `activationCode` field. */
  activationCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `hardwareId` field. */
  hardwareId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `login` field. */
  login?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `password` field. */
  password?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `purchaseDate` field. */
  purchaseDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `registrationCode` field. */
  registrationCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Software` object types. All fields are combined with a logical ‘and.’ */
export type SoftwareFilter = {
  /** Filter by the object’s `activationCode` field. */
  activationCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SoftwareFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `hardwareByHardwareId` relation. */
  hardwareByHardwareId?: InputMaybe<HardwareFilter>;
  /** A related `hardwareByHardwareId` exists. */
  hardwareByHardwareIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `hardwareId` field. */
  hardwareId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `login` field. */
  login?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SoftwareFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SoftwareFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `password` field. */
  password?: InputMaybe<StringFilter>;
  /** Filter by the object’s `purchaseDate` field. */
  purchaseDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `registrationCode` field. */
  registrationCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
  /** Filter by the object’s `serialNumber` field. */
  serialNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Software` */
export type SoftwareInput = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  hardwareId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  purchaseDate?: InputMaybe<Scalars['Date']['input']>;
  registrationCode?: InputMaybe<Scalars['String']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};

/** Represents an update to a `Software`. Fields that are set will be updated. */
export type SoftwarePatch = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  hardwareId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  purchaseDate?: InputMaybe<Scalars['Date']['input']>;
  registrationCode?: InputMaybe<Scalars['String']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Software` values. */
export type SoftwaresConnection = {
  __typename?: 'SoftwaresConnection';
  /** A list of edges which contains the `Software` and cursor to aid in pagination. */
  edges: Array<SoftwaresEdge>;
  /** A list of `Software` objects. */
  nodes: Array<Software>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Software` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Software` edge in the connection. */
export type SoftwaresEdge = {
  __typename?: 'SoftwaresEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Software` at the end of the edge. */
  node: Software;
};

/** Methods to use when ordering `Software`. */
export enum SoftwaresOrderBy {
  ActivationCodeAsc = 'ACTIVATION_CODE_ASC',
  ActivationCodeDesc = 'ACTIVATION_CODE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  HardwareByHardwareIdCreatedAsc = 'HARDWARE_BY_HARDWARE_ID__CREATED_ASC',
  HardwareByHardwareIdCreatedDesc = 'HARDWARE_BY_HARDWARE_ID__CREATED_DESC',
  HardwareByHardwareIdIdAsc = 'HARDWARE_BY_HARDWARE_ID__ID_ASC',
  HardwareByHardwareIdIdDesc = 'HARDWARE_BY_HARDWARE_ID__ID_DESC',
  HardwareByHardwareIdIpAddressAsc = 'HARDWARE_BY_HARDWARE_ID__IP_ADDRESS_ASC',
  HardwareByHardwareIdIpAddressDesc = 'HARDWARE_BY_HARDWARE_ID__IP_ADDRESS_DESC',
  HardwareByHardwareIdMacAddressAsc = 'HARDWARE_BY_HARDWARE_ID__MAC_ADDRESS_ASC',
  HardwareByHardwareIdMacAddressDesc = 'HARDWARE_BY_HARDWARE_ID__MAC_ADDRESS_DESC',
  HardwareByHardwareIdModelAsc = 'HARDWARE_BY_HARDWARE_ID__MODEL_ASC',
  HardwareByHardwareIdModelDesc = 'HARDWARE_BY_HARDWARE_ID__MODEL_DESC',
  HardwareByHardwareIdModifiedAsc = 'HARDWARE_BY_HARDWARE_ID__MODIFIED_ASC',
  HardwareByHardwareIdModifiedDesc = 'HARDWARE_BY_HARDWARE_ID__MODIFIED_DESC',
  HardwareByHardwareIdOperatingSystemAsc = 'HARDWARE_BY_HARDWARE_ID__OPERATING_SYSTEM_ASC',
  HardwareByHardwareIdOperatingSystemDesc = 'HARDWARE_BY_HARDWARE_ID__OPERATING_SYSTEM_DESC',
  HardwareByHardwareIdOrdernummerAsc = 'HARDWARE_BY_HARDWARE_ID__ORDERNUMMER_ASC',
  HardwareByHardwareIdOrdernummerDesc = 'HARDWARE_BY_HARDWARE_ID__ORDERNUMMER_DESC',
  HardwareByHardwareIdOwnerIdAsc = 'HARDWARE_BY_HARDWARE_ID__OWNER_ID_ASC',
  HardwareByHardwareIdOwnerIdDesc = 'HARDWARE_BY_HARDWARE_ID__OWNER_ID_DESC',
  HardwareByHardwareIdPrijsAsc = 'HARDWARE_BY_HARDWARE_ID__PRIJS_ASC',
  HardwareByHardwareIdPrijsDesc = 'HARDWARE_BY_HARDWARE_ID__PRIJS_DESC',
  HardwareByHardwareIdPurchaseDateAsc = 'HARDWARE_BY_HARDWARE_ID__PURCHASE_DATE_ASC',
  HardwareByHardwareIdPurchaseDateDesc = 'HARDWARE_BY_HARDWARE_ID__PURCHASE_DATE_DESC',
  HardwareByHardwareIdRemarksAsc = 'HARDWARE_BY_HARDWARE_ID__REMARKS_ASC',
  HardwareByHardwareIdRemarksDesc = 'HARDWARE_BY_HARDWARE_ID__REMARKS_DESC',
  HardwareByHardwareIdSerialNumberAsc = 'HARDWARE_BY_HARDWARE_ID__SERIAL_NUMBER_ASC',
  HardwareByHardwareIdSerialNumberDesc = 'HARDWARE_BY_HARDWARE_ID__SERIAL_NUMBER_DESC',
  HardwareByHardwareIdSpecsAsc = 'HARDWARE_BY_HARDWARE_ID__SPECS_ASC',
  HardwareByHardwareIdSpecsDesc = 'HARDWARE_BY_HARDWARE_ID__SPECS_DESC',
  HardwareByHardwareIdTypeAsc = 'HARDWARE_BY_HARDWARE_ID__TYPE_ASC',
  HardwareByHardwareIdTypeDesc = 'HARDWARE_BY_HARDWARE_ID__TYPE_DESC',
  HardwareByHardwareIdUserIdAsc = 'HARDWARE_BY_HARDWARE_ID__USER_ID_ASC',
  HardwareByHardwareIdUserIdDesc = 'HARDWARE_BY_HARDWARE_ID__USER_ID_DESC',
  HardwareIdAsc = 'HARDWARE_ID_ASC',
  HardwareIdDesc = 'HARDWARE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LoginAsc = 'LOGIN_ASC',
  LoginDesc = 'LOGIN_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PasswordAsc = 'PASSWORD_ASC',
  PasswordDesc = 'PASSWORD_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PurchaseDateAsc = 'PURCHASE_DATE_ASC',
  PurchaseDateDesc = 'PURCHASE_DATE_DESC',
  RegistrationCodeAsc = 'REGISTRATION_CODE_ASC',
  RegistrationCodeDesc = 'REGISTRATION_CODE_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC',
  SerialNumberAsc = 'SERIAL_NUMBER_ASC',
  SerialNumberDesc = 'SERIAL_NUMBER_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type StockGroup = Node & {
  __typename?: 'StockGroup';
  created: Scalars['Datetime']['output'];
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `StockItem`. */
  stockItemsByStockGroupId: StockItemsConnection;
  /** Reads a single `User` that is related to this `StockGroup`. */
  userByOwnerId?: Maybe<User>;
};


export type StockGroupStockItemsByStockGroupIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockItemCondition>;
  filter?: InputMaybe<StockItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockItemsOrderBy>>;
};

/**
 * A condition to be used against `StockGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type StockGroupCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `StockGroup` object types. All fields are combined with a logical ‘and.’ */
export type StockGroupFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<StockGroupFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<StockGroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<StockGroupFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stockItemsByStockGroupId` relation. */
  stockItemsByStockGroupId?: InputMaybe<StockGroupToManyStockItemFilter>;
  /** Some related `stockItemsByStockGroupId` exist. */
  stockItemsByStockGroupIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `StockGroup` */
export type StockGroupInput = {
  created: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
};

/** Represents an update to a `StockGroup`. Fields that are set will be updated. */
export type StockGroupPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against many `StockItem` object types. All fields are combined with a logical ‘and.’ */
export type StockGroupToManyStockItemFilter = {
  /** Every related `StockItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<StockItemFilter>;
  /** No related `StockItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<StockItemFilter>;
  /** Some related `StockItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<StockItemFilter>;
};

/** A connection to a list of `StockGroup` values. */
export type StockGroupsConnection = {
  __typename?: 'StockGroupsConnection';
  /** A list of edges which contains the `StockGroup` and cursor to aid in pagination. */
  edges: Array<StockGroupsEdge>;
  /** A list of `StockGroup` objects. */
  nodes: Array<StockGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StockGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `StockGroup` edge in the connection. */
export type StockGroupsEdge = {
  __typename?: 'StockGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StockGroup` at the end of the edge. */
  node: StockGroup;
};

/** Methods to use when ordering `StockGroup`. */
export enum StockGroupsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StockItemsByStockGroupIdCountAsc = 'STOCK_ITEMS_BY_STOCK_GROUP_ID__COUNT_ASC',
  StockItemsByStockGroupIdCountDesc = 'STOCK_ITEMS_BY_STOCK_GROUP_ID__COUNT_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type StockItem = Node & {
  __typename?: 'StockItem';
  action?: Maybe<Scalars['String']['output']>;
  cdartikel: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  prijsper?: Maybe<Scalars['Float']['output']>;
  /** Reads a single `StockGroup` that is related to this `StockItem`. */
  stockGroupByStockGroupId?: Maybe<StockGroup>;
  stockGroupId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `StockItem`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `StockItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type StockItemCondition = {
  /** Checks for equality with the object’s `action` field. */
  action?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `stockGroupId` field. */
  stockGroupId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `StockItem` object types. All fields are combined with a logical ‘and.’ */
export type StockItemFilter = {
  /** Filter by the object’s `action` field. */
  action?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<StockItemFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<StockItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<StockItemFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `stockGroupByStockGroupId` relation. */
  stockGroupByStockGroupId?: InputMaybe<StockGroupFilter>;
  /** Filter by the object’s `stockGroupId` field. */
  stockGroupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `StockItem` */
export type StockItemInput = {
  action?: InputMaybe<Scalars['String']['input']>;
  cdartikel: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId: Scalars['Int']['input'];
  prijsper?: InputMaybe<Scalars['Float']['input']>;
  stockGroupId: Scalars['Int']['input'];
};

/** Represents an update to a `StockItem`. Fields that are set will be updated. */
export type StockItemPatch = {
  action?: InputMaybe<Scalars['String']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  prijsper?: InputMaybe<Scalars['Float']['input']>;
  stockGroupId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `StockItem` values. */
export type StockItemsConnection = {
  __typename?: 'StockItemsConnection';
  /** A list of edges which contains the `StockItem` and cursor to aid in pagination. */
  edges: Array<StockItemsEdge>;
  /** A list of `StockItem` objects. */
  nodes: Array<StockItem>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StockItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `StockItem` edge in the connection. */
export type StockItemsEdge = {
  __typename?: 'StockItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StockItem` at the end of the edge. */
  node: StockItem;
};

/** Methods to use when ordering `StockItem`. */
export enum StockItemsOrderBy {
  ActionAsc = 'ACTION_ASC',
  ActionDesc = 'ACTION_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StockGroupByStockGroupIdCreatedAsc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__CREATED_ASC',
  StockGroupByStockGroupIdCreatedDesc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__CREATED_DESC',
  StockGroupByStockGroupIdIdAsc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__ID_ASC',
  StockGroupByStockGroupIdIdDesc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__ID_DESC',
  StockGroupByStockGroupIdModifiedAsc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__MODIFIED_ASC',
  StockGroupByStockGroupIdModifiedDesc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__MODIFIED_DESC',
  StockGroupByStockGroupIdNameAsc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__NAME_ASC',
  StockGroupByStockGroupIdNameDesc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__NAME_DESC',
  StockGroupByStockGroupIdOwnerIdAsc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__OWNER_ID_ASC',
  StockGroupByStockGroupIdOwnerIdDesc = 'STOCK_GROUP_BY_STOCK_GROUP_ID__OWNER_ID_DESC',
  StockGroupIdAsc = 'STOCK_GROUP_ID_ASC',
  StockGroupIdDesc = 'STOCK_GROUP_ID_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

export type StockSupplier = Node & {
  __typename?: 'StockSupplier';
  cdcrediteur: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId: Scalars['Int']['output'];
  shipmentDay?: Maybe<Scalars['Int']['output']>;
  shipmentDays: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `StockSupplier`. */
  userByOwnerId?: Maybe<User>;
};

/**
 * A condition to be used against `StockSupplier` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StockSupplierCondition = {
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `shipmentDay` field. */
  shipmentDay?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `shipmentDays` field. */
  shipmentDays?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `StockSupplier` object types. All fields are combined with a logical ‘and.’ */
export type StockSupplierFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<StockSupplierFilter>>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<StockSupplierFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<StockSupplierFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `shipmentDay` field. */
  shipmentDay?: InputMaybe<IntFilter>;
  /** Filter by the object’s `shipmentDays` field. */
  shipmentDays?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
};

/** An input for mutations affecting `StockSupplier` */
export type StockSupplierInput = {
  cdcrediteur: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['Int']['input'];
  shipmentDay?: InputMaybe<Scalars['Int']['input']>;
  shipmentDays?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `StockSupplier`. Fields that are set will be updated. */
export type StockSupplierPatch = {
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  shipmentDay?: InputMaybe<Scalars['Int']['input']>;
  shipmentDays?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `StockSupplier` values. */
export type StockSuppliersConnection = {
  __typename?: 'StockSuppliersConnection';
  /** A list of edges which contains the `StockSupplier` and cursor to aid in pagination. */
  edges: Array<StockSuppliersEdge>;
  /** A list of `StockSupplier` objects. */
  nodes: Array<StockSupplier>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StockSupplier` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `StockSupplier` edge in the connection. */
export type StockSuppliersEdge = {
  __typename?: 'StockSuppliersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StockSupplier` at the end of the edge. */
  node: StockSupplier;
};

export type StockSuppliersIndex = {
  __typename?: 'StockSuppliersIndex';
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  totalAdvice?: Maybe<Scalars['BigInt']['output']>;
  totalPoVvp?: Maybe<Scalars['BigFloat']['output']>;
  totalReservedVvp?: Maybe<Scalars['BigFloat']['output']>;
  totalStockVvp?: Maybe<Scalars['BigFloat']['output']>;
  tztAdvice?: Maybe<Scalars['BigInt']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `StockSuppliersIndex` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type StockSuppliersIndexCondition = {
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalAdvice` field. */
  totalAdvice?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `totalPoVvp` field. */
  totalPoVvp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalReservedVvp` field. */
  totalReservedVvp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalStockVvp` field. */
  totalStockVvp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `tztAdvice` field. */
  tztAdvice?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `StockSuppliersIndex` object types. All fields are combined with a logical ‘and.’ */
export type StockSuppliersIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<StockSuppliersIndexFilter>>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<StockSuppliersIndexFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<StockSuppliersIndexFilter>>;
  /** Filter by the object’s `totalAdvice` field. */
  totalAdvice?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `totalPoVvp` field. */
  totalPoVvp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalReservedVvp` field. */
  totalReservedVvp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalStockVvp` field. */
  totalStockVvp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `tztAdvice` field. */
  tztAdvice?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

export type StockSuppliersIndexOld = {
  __typename?: 'StockSuppliersIndexOld';
  advice?: Maybe<Scalars['BigFloat']['output']>;
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  besthoeveelheid?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdcrediteur?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  inkoopprijs?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  isovaluta?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  poVvp?: Maybe<Scalars['BigFloat']['output']>;
  reservedVvp?: Maybe<Scalars['BigFloat']['output']>;
  stockVvp?: Maybe<Scalars['BigFloat']['output']>;
  voorkeur?: Maybe<Scalars['String']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vrij?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `StockSuppliersIndexOld` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type StockSuppliersIndexOldCondition = {
  /** Checks for equality with the object’s `advice` field. */
  advice?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `poVvp` field. */
  poVvp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `reservedVvp` field. */
  reservedVvp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `stockVvp` field. */
  stockVvp?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vrij` field. */
  vrij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `StockSuppliersIndexOld` object types. All fields are combined with a logical ‘and.’ */
export type StockSuppliersIndexOldFilter = {
  /** Filter by the object’s `advice` field. */
  advice?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<StockSuppliersIndexOldFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdcrediteur` field. */
  cdcrediteur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<StockSuppliersIndexOldFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<StockSuppliersIndexOldFilter>>;
  /** Filter by the object’s `poVvp` field. */
  poVvp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `reservedVvp` field. */
  reservedVvp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `stockVvp` field. */
  stockVvp?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorkeur` field. */
  voorkeur?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vrij` field. */
  vrij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `StockSuppliersIndexOld` values. */
export type StockSuppliersIndexOldsConnection = {
  __typename?: 'StockSuppliersIndexOldsConnection';
  /** A list of edges which contains the `StockSuppliersIndexOld` and cursor to aid in pagination. */
  edges: Array<StockSuppliersIndexOldsEdge>;
  /** A list of `StockSuppliersIndexOld` objects. */
  nodes: Array<StockSuppliersIndexOld>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StockSuppliersIndexOld` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `StockSuppliersIndexOld` edge in the connection. */
export type StockSuppliersIndexOldsEdge = {
  __typename?: 'StockSuppliersIndexOldsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StockSuppliersIndexOld` at the end of the edge. */
  node: StockSuppliersIndexOld;
};

/** Methods to use when ordering `StockSuppliersIndexOld`. */
export enum StockSuppliersIndexOldsOrderBy {
  AdviceAsc = 'ADVICE_ASC',
  AdviceDesc = 'ADVICE_DESC',
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  BesthoeveelheidAsc = 'BESTHOEVEELHEID_ASC',
  BesthoeveelheidDesc = 'BESTHOEVEELHEID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  InkoopprijsAsc = 'INKOOPPRIJS_ASC',
  InkoopprijsDesc = 'INKOOPPRIJS_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  IsovalutaAsc = 'ISOVALUTA_ASC',
  IsovalutaDesc = 'ISOVALUTA_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PoVvpAsc = 'PO_VVP_ASC',
  PoVvpDesc = 'PO_VVP_DESC',
  ReservedVvpAsc = 'RESERVED_VVP_ASC',
  ReservedVvpDesc = 'RESERVED_VVP_DESC',
  StockVvpAsc = 'STOCK_VVP_ASC',
  StockVvpDesc = 'STOCK_VVP_DESC',
  VoorkeurAsc = 'VOORKEUR_ASC',
  VoorkeurDesc = 'VOORKEUR_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VrijAsc = 'VRIJ_ASC',
  VrijDesc = 'VRIJ_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** A connection to a list of `StockSuppliersIndex` values. */
export type StockSuppliersIndicesConnection = {
  __typename?: 'StockSuppliersIndicesConnection';
  /** A list of edges which contains the `StockSuppliersIndex` and cursor to aid in pagination. */
  edges: Array<StockSuppliersIndicesEdge>;
  /** A list of `StockSuppliersIndex` objects. */
  nodes: Array<StockSuppliersIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `StockSuppliersIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `StockSuppliersIndex` edge in the connection. */
export type StockSuppliersIndicesEdge = {
  __typename?: 'StockSuppliersIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `StockSuppliersIndex` at the end of the edge. */
  node: StockSuppliersIndex;
};

/** Methods to use when ordering `StockSuppliersIndex`. */
export enum StockSuppliersIndicesOrderBy {
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  TotalAdviceAsc = 'TOTAL_ADVICE_ASC',
  TotalAdviceDesc = 'TOTAL_ADVICE_DESC',
  TotalPoVvpAsc = 'TOTAL_PO_VVP_ASC',
  TotalPoVvpDesc = 'TOTAL_PO_VVP_DESC',
  TotalReservedVvpAsc = 'TOTAL_RESERVED_VVP_ASC',
  TotalReservedVvpDesc = 'TOTAL_RESERVED_VVP_DESC',
  TotalStockVvpAsc = 'TOTAL_STOCK_VVP_ASC',
  TotalStockVvpDesc = 'TOTAL_STOCK_VVP_DESC',
  TztAdviceAsc = 'TZT_ADVICE_ASC',
  TztAdviceDesc = 'TZT_ADVICE_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** Methods to use when ordering `StockSupplier`. */
export enum StockSuppliersOrderBy {
  CdcrediteurAsc = 'CDCREDITEUR_ASC',
  CdcrediteurDesc = 'CDCREDITEUR_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShipmentDaysAsc = 'SHIPMENT_DAYS_ASC',
  ShipmentDaysDesc = 'SHIPMENT_DAYS_DESC',
  ShipmentDayAsc = 'SHIPMENT_DAY_ASC',
  ShipmentDayDesc = 'SHIPMENT_DAY_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

export type Task = Node & {
  __typename?: 'Task';
  code?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  groupCode?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  sortCode?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `Task`. */
  userByOwnerId?: Maybe<User>;
  /** Reads and enables pagination through a set of `UserTask`. */
  userTasksByTaskId: UserTasksConnection;
  wbsoEndDate?: Maybe<Scalars['Date']['output']>;
  wbsoStartDate?: Maybe<Scalars['Date']['output']>;
  /** Reads and enables pagination through a set of `WeeklyHourRemark`. */
  weeklyHourRemarksByTaskId: WeeklyHourRemarksConnection;
  /** Reads and enables pagination through a set of `WeeklyHour`. */
  weeklyHoursByTaskId: WeeklyHoursConnection;
};


export type TaskUserTasksByTaskIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserTaskCondition>;
  filter?: InputMaybe<UserTaskFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserTasksOrderBy>>;
};


export type TaskWeeklyHourRemarksByTaskIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHourRemarkCondition>;
  filter?: InputMaybe<WeeklyHourRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHourRemarksOrderBy>>;
};


export type TaskWeeklyHoursByTaskIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHourCondition>;
  filter?: InputMaybe<WeeklyHourFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHoursOrderBy>>;
};

/** A condition to be used against `Task` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TaskCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `groupCode` field. */
  groupCode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sortCode` field. */
  sortCode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `wbsoEndDate` field. */
  wbsoEndDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `wbsoStartDate` field. */
  wbsoStartDate?: InputMaybe<Scalars['Date']['input']>;
};

/** A filter to be used against `Task` object types. All fields are combined with a logical ‘and.’ */
export type TaskFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TaskFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `groupCode` field. */
  groupCode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TaskFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TaskFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sortCode` field. */
  sortCode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userTasksByTaskId` relation. */
  userTasksByTaskId?: InputMaybe<TaskToManyUserTaskFilter>;
  /** Some related `userTasksByTaskId` exist. */
  userTasksByTaskIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `wbsoEndDate` field. */
  wbsoEndDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `wbsoStartDate` field. */
  wbsoStartDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `weeklyHourRemarksByTaskId` relation. */
  weeklyHourRemarksByTaskId?: InputMaybe<TaskToManyWeeklyHourRemarkFilter>;
  /** Some related `weeklyHourRemarksByTaskId` exist. */
  weeklyHourRemarksByTaskIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `weeklyHoursByTaskId` relation. */
  weeklyHoursByTaskId?: InputMaybe<TaskToManyWeeklyHourFilter>;
  /** Some related `weeklyHoursByTaskId` exist. */
  weeklyHoursByTaskIdExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Task` */
export type TaskInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  groupCode?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sortCode?: InputMaybe<Scalars['Int']['input']>;
  wbsoEndDate?: InputMaybe<Scalars['Date']['input']>;
  wbsoStartDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Represents an update to a `Task`. Fields that are set will be updated. */
export type TaskPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  groupCode?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  sortCode?: InputMaybe<Scalars['Int']['input']>;
  wbsoEndDate?: InputMaybe<Scalars['Date']['input']>;
  wbsoStartDate?: InputMaybe<Scalars['Date']['input']>;
};

/** A filter to be used against many `UserTask` object types. All fields are combined with a logical ‘and.’ */
export type TaskToManyUserTaskFilter = {
  /** Every related `UserTask` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserTaskFilter>;
  /** No related `UserTask` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserTaskFilter>;
  /** Some related `UserTask` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserTaskFilter>;
};

/** A filter to be used against many `WeeklyHour` object types. All fields are combined with a logical ‘and.’ */
export type TaskToManyWeeklyHourFilter = {
  /** Every related `WeeklyHour` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<WeeklyHourFilter>;
  /** No related `WeeklyHour` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<WeeklyHourFilter>;
  /** Some related `WeeklyHour` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<WeeklyHourFilter>;
};

/** A filter to be used against many `WeeklyHourRemark` object types. All fields are combined with a logical ‘and.’ */
export type TaskToManyWeeklyHourRemarkFilter = {
  /** Every related `WeeklyHourRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<WeeklyHourRemarkFilter>;
  /** No related `WeeklyHourRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<WeeklyHourRemarkFilter>;
  /** Some related `WeeklyHourRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<WeeklyHourRemarkFilter>;
};

/** A connection to a list of `Task` values. */
export type TasksConnection = {
  __typename?: 'TasksConnection';
  /** A list of edges which contains the `Task` and cursor to aid in pagination. */
  edges: Array<TasksEdge>;
  /** A list of `Task` objects. */
  nodes: Array<Task>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Task` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Task` edge in the connection. */
export type TasksEdge = {
  __typename?: 'TasksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Task` at the end of the edge. */
  node: Task;
};

/** Methods to use when ordering `Task`. */
export enum TasksOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GroupCodeAsc = 'GROUP_CODE_ASC',
  GroupCodeDesc = 'GROUP_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SortCodeAsc = 'SORT_CODE_ASC',
  SortCodeDesc = 'SORT_CODE_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserTasksByTaskIdCountAsc = 'USER_TASKS_BY_TASK_ID__COUNT_ASC',
  UserTasksByTaskIdCountDesc = 'USER_TASKS_BY_TASK_ID__COUNT_DESC',
  WbsoEndDateAsc = 'WBSO_END_DATE_ASC',
  WbsoEndDateDesc = 'WBSO_END_DATE_DESC',
  WbsoStartDateAsc = 'WBSO_START_DATE_ASC',
  WbsoStartDateDesc = 'WBSO_START_DATE_DESC',
  WeeklyHoursByTaskIdCountAsc = 'WEEKLY_HOURS_BY_TASK_ID__COUNT_ASC',
  WeeklyHoursByTaskIdCountDesc = 'WEEKLY_HOURS_BY_TASK_ID__COUNT_DESC',
  WeeklyHourRemarksByTaskIdCountAsc = 'WEEKLY_HOUR_REMARKS_BY_TASK_ID__COUNT_ASC',
  WeeklyHourRemarksByTaskIdCountDesc = 'WEEKLY_HOUR_REMARKS_BY_TASK_ID__COUNT_DESC'
}

export type TempFactopdrachtregel = Node & {
  __typename?: 'TempFactopdrachtregel';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  aantaldec?: Maybe<Scalars['Int']['output']>;
  aantalgeleverd?: Maybe<Scalars['BigFloat']['output']>;
  aantalgereserv?: Maybe<Scalars['BigFloat']['output']>;
  aantalleveren?: Maybe<Scalars['BigFloat']['output']>;
  aantalnaleveren?: Maybe<Scalars['BigFloat']['output']>;
  bonnummer?: Maybe<Scalars['String']['output']>;
  btwcode?: Maybe<Scalars['Int']['output']>;
  btwperc?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cddeelproject?: Maybe<Scalars['String']['output']>;
  cddossier?: Maybe<Scalars['String']['output']>;
  cdgrbdekking?: Maybe<Scalars['String']['output']>;
  cdgrbkostprijs?: Maybe<Scalars['String']['output']>;
  cdgrbrekening?: Maybe<Scalars['String']['output']>;
  cdgrbrekkort?: Maybe<Scalars['String']['output']>;
  cdgrbrekomzvj?: Maybe<Scalars['String']['output']>;
  cdkostenplaats?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  cdstatus?: Maybe<Scalars['String']['output']>;
  cdtermijn?: Maybe<Scalars['Int']['output']>;
  cdwerknemer?: Maybe<Scalars['String']['output']>;
  datum?: Maybe<Scalars['Date']['output']>;
  declarabel?: Maybe<Scalars['String']['output']>;
  eenheid?: Maybe<Scalars['String']['output']>;
  factbedragexcl?: Maybe<Scalars['BigFloat']['output']>;
  factbedragexclvj?: Maybe<Scalars['BigFloat']['output']>;
  factbedragincl?: Maybe<Scalars['BigFloat']['output']>;
  factopdrRglGuid?: Maybe<Scalars['String']['output']>;
  factuuropdracht: Scalars['String']['output'];
  factuurregel: Scalars['Int']['output'];
  hoofdregel?: Maybe<Scalars['Int']['output']>;
  id: Scalars['String']['output'];
  koppelMetInkoop?: Maybe<Scalars['String']['output']>;
  kortingperc?: Maybe<Scalars['BigFloat']['output']>;
  kostprijs?: Maybe<Scalars['BigFloat']['output']>;
  kvc?: Maybe<Scalars['String']['output']>;
  nettoomzet?: Maybe<Scalars['BigFloat']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  omschr?: Maybe<Scalars['String']['output']>;
  prijs?: Maybe<Scalars['BigFloat']['output']>;
  prijsper?: Maybe<Scalars['BigFloat']['output']>;
  projMutsoort?: Maybe<Scalars['String']['output']>;
  samVersie?: Maybe<Scalars['String']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  statcode?: Maybe<Scalars['String']['output']>;
  tekstmagb?: Maybe<Scalars['String']['output']>;
  voorschot?: Maybe<Scalars['Int']['output']>;
  vvvrijvelda?: Maybe<Scalars['String']['output']>;
  weeknummer?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `TempFactopdrachtregel` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type TempFactopdrachtregelCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `aantalgeleverd` field. */
  aantalgeleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalleveren` field. */
  aantalleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `aantalnaleveren` field. */
  aantalnaleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bonnummer` field. */
  bonnummer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `btwcode` field. */
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `btwperc` field. */
  btwperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cddossier` field. */
  cddossier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbdekking` field. */
  cdgrbdekking?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbkostprijs` field. */
  cdgrbkostprijs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdgrbrekomzvj` field. */
  cdgrbrekomzvj?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdtermijn` field. */
  cdtermijn?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `cdwerknemer` field. */
  cdwerknemer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `datum` field. */
  datum?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `declarabel` field. */
  declarabel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eenheid` field. */
  eenheid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factbedragexcl` field. */
  factbedragexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factbedragexclvj` field. */
  factbedragexclvj?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factbedragincl` field. */
  factbedragincl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuurregel` field. */
  factuurregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `hoofdregel` field. */
  hoofdregel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `koppelMetInkoop` field. */
  koppelMetInkoop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kostprijs` field. */
  kostprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `kvc` field. */
  kvc?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nettoomzet` field. */
  nettoomzet?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijs` field. */
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `prijsper` field. */
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `samVersie` field. */
  samVersie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `statcode` field. */
  statcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tekstmagb` field. */
  tekstmagb?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorschot` field. */
  voorschot?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `weeknummer` field. */
  weeknummer?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `TempFactopdrachtregel` object types. All fields are combined with a logical ‘and.’ */
export type TempFactopdrachtregelFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantaldec` field. */
  aantaldec?: InputMaybe<IntFilter>;
  /** Filter by the object’s `aantalgeleverd` field. */
  aantalgeleverd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalgereserv` field. */
  aantalgereserv?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalleveren` field. */
  aantalleveren?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `aantalnaleveren` field. */
  aantalnaleveren?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TempFactopdrachtregelFilter>>;
  /** Filter by the object’s `bonnummer` field. */
  bonnummer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `btwcode` field. */
  btwcode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `btwperc` field. */
  btwperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddeelproject` field. */
  cddeelproject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cddossier` field. */
  cddossier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbdekking` field. */
  cdgrbdekking?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbkostprijs` field. */
  cdgrbkostprijs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekening` field. */
  cdgrbrekening?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekkort` field. */
  cdgrbrekkort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdgrbrekomzvj` field. */
  cdgrbrekomzvj?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdkostenplaats` field. */
  cdkostenplaats?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdstatus` field. */
  cdstatus?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdtermijn` field. */
  cdtermijn?: InputMaybe<IntFilter>;
  /** Filter by the object’s `cdwerknemer` field. */
  cdwerknemer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `datum` field. */
  datum?: InputMaybe<DateFilter>;
  /** Filter by the object’s `declarabel` field. */
  declarabel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eenheid` field. */
  eenheid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factbedragexcl` field. */
  factbedragexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factbedragexclvj` field. */
  factbedragexclvj?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factbedragincl` field. */
  factbedragincl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `factopdrRglGuid` field. */
  factopdrRglGuid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuurregel` field. */
  factuurregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `hoofdregel` field. */
  hoofdregel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `koppelMetInkoop` field. */
  koppelMetInkoop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `kortingperc` field. */
  kortingperc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kostprijs` field. */
  kostprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `kvc` field. */
  kvc?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nettoomzet` field. */
  nettoomzet?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TempFactopdrachtregelFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TempFactopdrachtregelFilter>>;
  /** Filter by the object’s `prijs` field. */
  prijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `prijsper` field. */
  prijsper?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `projMutsoort` field. */
  projMutsoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `samVersie` field. */
  samVersie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `statcode` field. */
  statcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tekstmagb` field. */
  tekstmagb?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voorschot` field. */
  voorschot?: InputMaybe<IntFilter>;
  /** Filter by the object’s `vvvrijvelda` field. */
  vvvrijvelda?: InputMaybe<StringFilter>;
  /** Filter by the object’s `weeknummer` field. */
  weeknummer?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `TempFactopdrachtregel` */
export type TempFactopdrachtregelInput = {
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  aantalgeleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  aantalgereserv?: InputMaybe<Scalars['BigFloat']['input']>;
  aantalleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  aantalnaleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  bonnummer?: InputMaybe<Scalars['String']['input']>;
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  btwperc?: InputMaybe<Scalars['BigFloat']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  cddeelproject?: InputMaybe<Scalars['String']['input']>;
  cddossier?: InputMaybe<Scalars['String']['input']>;
  cdgrbdekking?: InputMaybe<Scalars['String']['input']>;
  cdgrbkostprijs?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekomzvj?: InputMaybe<Scalars['String']['input']>;
  cdkostenplaats?: InputMaybe<Scalars['String']['input']>;
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  cdstatus?: InputMaybe<Scalars['String']['input']>;
  cdtermijn?: InputMaybe<Scalars['Int']['input']>;
  cdwerknemer?: InputMaybe<Scalars['String']['input']>;
  datum?: InputMaybe<Scalars['Date']['input']>;
  declarabel?: InputMaybe<Scalars['String']['input']>;
  eenheid?: InputMaybe<Scalars['String']['input']>;
  factbedragexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  factbedragexclvj?: InputMaybe<Scalars['BigFloat']['input']>;
  factbedragincl?: InputMaybe<Scalars['BigFloat']['input']>;
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  factuurregel: Scalars['Int']['input'];
  hoofdregel?: InputMaybe<Scalars['Int']['input']>;
  id: Scalars['String']['input'];
  koppelMetInkoop?: InputMaybe<Scalars['String']['input']>;
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  kostprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  kvc?: InputMaybe<Scalars['String']['input']>;
  nettoomzet?: InputMaybe<Scalars['BigFloat']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  samVersie?: InputMaybe<Scalars['String']['input']>;
  soort?: InputMaybe<Scalars['String']['input']>;
  statcode?: InputMaybe<Scalars['String']['input']>;
  tekstmagb?: InputMaybe<Scalars['String']['input']>;
  voorschot?: InputMaybe<Scalars['Int']['input']>;
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
  weeknummer?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `TempFactopdrachtregel`. Fields that are set will be updated. */
export type TempFactopdrachtregelPatch = {
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  aantaldec?: InputMaybe<Scalars['Int']['input']>;
  aantalgeleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  aantalgereserv?: InputMaybe<Scalars['BigFloat']['input']>;
  aantalleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  aantalnaleveren?: InputMaybe<Scalars['BigFloat']['input']>;
  bonnummer?: InputMaybe<Scalars['String']['input']>;
  btwcode?: InputMaybe<Scalars['Int']['input']>;
  btwperc?: InputMaybe<Scalars['BigFloat']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  cddeelproject?: InputMaybe<Scalars['String']['input']>;
  cddossier?: InputMaybe<Scalars['String']['input']>;
  cdgrbdekking?: InputMaybe<Scalars['String']['input']>;
  cdgrbkostprijs?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekening?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekkort?: InputMaybe<Scalars['String']['input']>;
  cdgrbrekomzvj?: InputMaybe<Scalars['String']['input']>;
  cdkostenplaats?: InputMaybe<Scalars['String']['input']>;
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  cdstatus?: InputMaybe<Scalars['String']['input']>;
  cdtermijn?: InputMaybe<Scalars['Int']['input']>;
  cdwerknemer?: InputMaybe<Scalars['String']['input']>;
  datum?: InputMaybe<Scalars['Date']['input']>;
  declarabel?: InputMaybe<Scalars['String']['input']>;
  eenheid?: InputMaybe<Scalars['String']['input']>;
  factbedragexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  factbedragexclvj?: InputMaybe<Scalars['BigFloat']['input']>;
  factbedragincl?: InputMaybe<Scalars['BigFloat']['input']>;
  factopdrRglGuid?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  factuurregel?: InputMaybe<Scalars['Int']['input']>;
  hoofdregel?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  koppelMetInkoop?: InputMaybe<Scalars['String']['input']>;
  kortingperc?: InputMaybe<Scalars['BigFloat']['input']>;
  kostprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  kvc?: InputMaybe<Scalars['String']['input']>;
  nettoomzet?: InputMaybe<Scalars['BigFloat']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  prijs?: InputMaybe<Scalars['BigFloat']['input']>;
  prijsper?: InputMaybe<Scalars['BigFloat']['input']>;
  projMutsoort?: InputMaybe<Scalars['String']['input']>;
  samVersie?: InputMaybe<Scalars['String']['input']>;
  soort?: InputMaybe<Scalars['String']['input']>;
  statcode?: InputMaybe<Scalars['String']['input']>;
  tekstmagb?: InputMaybe<Scalars['String']['input']>;
  voorschot?: InputMaybe<Scalars['Int']['input']>;
  vvvrijvelda?: InputMaybe<Scalars['String']['input']>;
  weeknummer?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `TempFactopdrachtregel` values. */
export type TempFactopdrachtregelsConnection = {
  __typename?: 'TempFactopdrachtregelsConnection';
  /** A list of edges which contains the `TempFactopdrachtregel` and cursor to aid in pagination. */
  edges: Array<TempFactopdrachtregelsEdge>;
  /** A list of `TempFactopdrachtregel` objects. */
  nodes: Array<TempFactopdrachtregel>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TempFactopdrachtregel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TempFactopdrachtregel` edge in the connection. */
export type TempFactopdrachtregelsEdge = {
  __typename?: 'TempFactopdrachtregelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TempFactopdrachtregel` at the end of the edge. */
  node: TempFactopdrachtregel;
};

/** Methods to use when ordering `TempFactopdrachtregel`. */
export enum TempFactopdrachtregelsOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  AantaldecAsc = 'AANTALDEC_ASC',
  AantaldecDesc = 'AANTALDEC_DESC',
  AantalgeleverdAsc = 'AANTALGELEVERD_ASC',
  AantalgeleverdDesc = 'AANTALGELEVERD_DESC',
  AantalgereservAsc = 'AANTALGERESERV_ASC',
  AantalgereservDesc = 'AANTALGERESERV_DESC',
  AantalleverenAsc = 'AANTALLEVEREN_ASC',
  AantalleverenDesc = 'AANTALLEVEREN_DESC',
  AantalnaleverenAsc = 'AANTALNALEVEREN_ASC',
  AantalnaleverenDesc = 'AANTALNALEVEREN_DESC',
  BonnummerAsc = 'BONNUMMER_ASC',
  BonnummerDesc = 'BONNUMMER_DESC',
  BtwcodeAsc = 'BTWCODE_ASC',
  BtwcodeDesc = 'BTWCODE_DESC',
  BtwpercAsc = 'BTWPERC_ASC',
  BtwpercDesc = 'BTWPERC_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CddeelprojectAsc = 'CDDEELPROJECT_ASC',
  CddeelprojectDesc = 'CDDEELPROJECT_DESC',
  CddossierAsc = 'CDDOSSIER_ASC',
  CddossierDesc = 'CDDOSSIER_DESC',
  CdgrbdekkingAsc = 'CDGRBDEKKING_ASC',
  CdgrbdekkingDesc = 'CDGRBDEKKING_DESC',
  CdgrbkostprijsAsc = 'CDGRBKOSTPRIJS_ASC',
  CdgrbkostprijsDesc = 'CDGRBKOSTPRIJS_DESC',
  CdgrbrekeningAsc = 'CDGRBREKENING_ASC',
  CdgrbrekeningDesc = 'CDGRBREKENING_DESC',
  CdgrbrekkortAsc = 'CDGRBREKKORT_ASC',
  CdgrbrekkortDesc = 'CDGRBREKKORT_DESC',
  CdgrbrekomzvjAsc = 'CDGRBREKOMZVJ_ASC',
  CdgrbrekomzvjDesc = 'CDGRBREKOMZVJ_DESC',
  CdkostenplaatsAsc = 'CDKOSTENPLAATS_ASC',
  CdkostenplaatsDesc = 'CDKOSTENPLAATS_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  CdstatusAsc = 'CDSTATUS_ASC',
  CdstatusDesc = 'CDSTATUS_DESC',
  CdtermijnAsc = 'CDTERMIJN_ASC',
  CdtermijnDesc = 'CDTERMIJN_DESC',
  CdwerknemerAsc = 'CDWERKNEMER_ASC',
  CdwerknemerDesc = 'CDWERKNEMER_DESC',
  DatumAsc = 'DATUM_ASC',
  DatumDesc = 'DATUM_DESC',
  DeclarabelAsc = 'DECLARABEL_ASC',
  DeclarabelDesc = 'DECLARABEL_DESC',
  EenheidAsc = 'EENHEID_ASC',
  EenheidDesc = 'EENHEID_DESC',
  FactbedragexclvjAsc = 'FACTBEDRAGEXCLVJ_ASC',
  FactbedragexclvjDesc = 'FACTBEDRAGEXCLVJ_DESC',
  FactbedragexclAsc = 'FACTBEDRAGEXCL_ASC',
  FactbedragexclDesc = 'FACTBEDRAGEXCL_DESC',
  FactbedraginclAsc = 'FACTBEDRAGINCL_ASC',
  FactbedraginclDesc = 'FACTBEDRAGINCL_DESC',
  FactopdrRglGuidAsc = 'FACTOPDR_RGL_GUID_ASC',
  FactopdrRglGuidDesc = 'FACTOPDR_RGL_GUID_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  FactuurregelAsc = 'FACTUURREGEL_ASC',
  FactuurregelDesc = 'FACTUURREGEL_DESC',
  HoofdregelAsc = 'HOOFDREGEL_ASC',
  HoofdregelDesc = 'HOOFDREGEL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KoppelMetInkoopAsc = 'KOPPEL_MET_INKOOP_ASC',
  KoppelMetInkoopDesc = 'KOPPEL_MET_INKOOP_DESC',
  KortingpercAsc = 'KORTINGPERC_ASC',
  KortingpercDesc = 'KORTINGPERC_DESC',
  KostprijsAsc = 'KOSTPRIJS_ASC',
  KostprijsDesc = 'KOSTPRIJS_DESC',
  KvcAsc = 'KVC_ASC',
  KvcDesc = 'KVC_DESC',
  Natural = 'NATURAL',
  NettoomzetAsc = 'NETTOOMZET_ASC',
  NettoomzetDesc = 'NETTOOMZET_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsperAsc = 'PRIJSPER_ASC',
  PrijsperDesc = 'PRIJSPER_DESC',
  PrijsAsc = 'PRIJS_ASC',
  PrijsDesc = 'PRIJS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProjMutsoortAsc = 'PROJ_MUTSOORT_ASC',
  ProjMutsoortDesc = 'PROJ_MUTSOORT_DESC',
  SamVersieAsc = 'SAM_VERSIE_ASC',
  SamVersieDesc = 'SAM_VERSIE_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  StatcodeAsc = 'STATCODE_ASC',
  StatcodeDesc = 'STATCODE_DESC',
  TekstmagbAsc = 'TEKSTMAGB_ASC',
  TekstmagbDesc = 'TEKSTMAGB_DESC',
  VoorschotAsc = 'VOORSCHOT_ASC',
  VoorschotDesc = 'VOORSCHOT_DESC',
  VvvrijveldaAsc = 'VVVRIJVELDA_ASC',
  VvvrijveldaDesc = 'VVVRIJVELDA_DESC',
  WeeknummerAsc = 'WEEKNUMMER_ASC',
  WeeknummerDesc = 'WEEKNUMMER_DESC'
}

export type TempLicense = Node & {
  __typename?: 'TempLicense';
  activate?: Maybe<Scalars['Int']['output']>;
  creationtime?: Maybe<Scalars['Datetime']['output']>;
  customerkey?: Maybe<Scalars['Int']['output']>;
  durationdays?: Maybe<Scalars['Int']['output']>;
  durationmonths?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  licensecode?: Maybe<Scalars['String']['output']>;
  licenseid?: Maybe<Scalars['Int']['output']>;
  moduledata?: Maybe<Scalars['String']['output']>;
  moduletype?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ordercode?: Maybe<Scalars['Int']['output']>;
  remarks?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `TempLicense` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TempLicenseCondition = {
  /** Checks for equality with the object’s `activate` field. */
  activate?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `creationtime` field. */
  creationtime?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `customerkey` field. */
  customerkey?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `durationdays` field. */
  durationdays?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `durationmonths` field. */
  durationmonths?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `licensecode` field. */
  licensecode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `licenseid` field. */
  licenseid?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `moduledata` field. */
  moduledata?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `moduletype` field. */
  moduletype?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `ordercode` field. */
  ordercode?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remarks` field. */
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TempLicense` object types. All fields are combined with a logical ‘and.’ */
export type TempLicenseFilter = {
  /** Filter by the object’s `activate` field. */
  activate?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TempLicenseFilter>>;
  /** Filter by the object’s `creationtime` field. */
  creationtime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customerkey` field. */
  customerkey?: InputMaybe<IntFilter>;
  /** Filter by the object’s `durationdays` field. */
  durationdays?: InputMaybe<IntFilter>;
  /** Filter by the object’s `durationmonths` field. */
  durationmonths?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `licensecode` field. */
  licensecode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `licenseid` field. */
  licenseid?: InputMaybe<IntFilter>;
  /** Filter by the object’s `moduledata` field. */
  moduledata?: InputMaybe<StringFilter>;
  /** Filter by the object’s `moduletype` field. */
  moduletype?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TempLicenseFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TempLicenseFilter>>;
  /** Filter by the object’s `ordercode` field. */
  ordercode?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remarks` field. */
  remarks?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `TempLicense` */
export type TempLicenseInput = {
  activate?: InputMaybe<Scalars['Int']['input']>;
  creationtime?: InputMaybe<Scalars['Datetime']['input']>;
  customerkey?: InputMaybe<Scalars['Int']['input']>;
  durationdays?: InputMaybe<Scalars['Int']['input']>;
  durationmonths?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  licensecode?: InputMaybe<Scalars['String']['input']>;
  licenseid?: InputMaybe<Scalars['Int']['input']>;
  moduledata?: InputMaybe<Scalars['String']['input']>;
  moduletype?: InputMaybe<Scalars['Int']['input']>;
  ordercode?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `TempLicense`. Fields that are set will be updated. */
export type TempLicensePatch = {
  activate?: InputMaybe<Scalars['Int']['input']>;
  creationtime?: InputMaybe<Scalars['Datetime']['input']>;
  customerkey?: InputMaybe<Scalars['Int']['input']>;
  durationdays?: InputMaybe<Scalars['Int']['input']>;
  durationmonths?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  licensecode?: InputMaybe<Scalars['String']['input']>;
  licenseid?: InputMaybe<Scalars['Int']['input']>;
  moduledata?: InputMaybe<Scalars['String']['input']>;
  moduletype?: InputMaybe<Scalars['Int']['input']>;
  ordercode?: InputMaybe<Scalars['Int']['input']>;
  remarks?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `TempLicense` values. */
export type TempLicensesConnection = {
  __typename?: 'TempLicensesConnection';
  /** A list of edges which contains the `TempLicense` and cursor to aid in pagination. */
  edges: Array<TempLicensesEdge>;
  /** A list of `TempLicense` objects. */
  nodes: Array<TempLicense>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TempLicense` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TempLicense` edge in the connection. */
export type TempLicensesEdge = {
  __typename?: 'TempLicensesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TempLicense` at the end of the edge. */
  node: TempLicense;
};

/** Methods to use when ordering `TempLicense`. */
export enum TempLicensesOrderBy {
  ActivateAsc = 'ACTIVATE_ASC',
  ActivateDesc = 'ACTIVATE_DESC',
  CreationtimeAsc = 'CREATIONTIME_ASC',
  CreationtimeDesc = 'CREATIONTIME_DESC',
  CustomerkeyAsc = 'CUSTOMERKEY_ASC',
  CustomerkeyDesc = 'CUSTOMERKEY_DESC',
  DurationdaysAsc = 'DURATIONDAYS_ASC',
  DurationdaysDesc = 'DURATIONDAYS_DESC',
  DurationmonthsAsc = 'DURATIONMONTHS_ASC',
  DurationmonthsDesc = 'DURATIONMONTHS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LicensecodeAsc = 'LICENSECODE_ASC',
  LicensecodeDesc = 'LICENSECODE_DESC',
  LicenseidAsc = 'LICENSEID_ASC',
  LicenseidDesc = 'LICENSEID_DESC',
  ModuledataAsc = 'MODULEDATA_ASC',
  ModuledataDesc = 'MODULEDATA_DESC',
  ModuletypeAsc = 'MODULETYPE_ASC',
  ModuletypeDesc = 'MODULETYPE_DESC',
  Natural = 'NATURAL',
  OrdercodeAsc = 'ORDERCODE_ASC',
  OrdercodeDesc = 'ORDERCODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarksAsc = 'REMARKS_ASC',
  RemarksDesc = 'REMARKS_DESC'
}

export type TempRegistration = Node & {
  __typename?: 'TempRegistration';
  activationCode?: Maybe<Scalars['String']['output']>;
  computerName?: Maybe<Scalars['String']['output']>;
  expirationDate?: Maybe<Scalars['Date']['output']>;
  hwCode?: Maybe<Scalars['String']['output']>;
  hwType?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  ipAddress?: Maybe<Scalars['String']['output']>;
  licenseId?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  orderCode?: Maybe<Scalars['String']['output']>;
  registrationCode?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `TempRegistration` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TempRegistrationCondition = {
  /** Checks for equality with the object’s `activationCode` field. */
  activationCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `computerName` field. */
  computerName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `hwCode` field. */
  hwCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `hwType` field. */
  hwType?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `licenseId` field. */
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orderCode` field. */
  orderCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationCode` field. */
  registrationCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TempRegistration` object types. All fields are combined with a logical ‘and.’ */
export type TempRegistrationFilter = {
  /** Filter by the object’s `activationCode` field. */
  activationCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TempRegistrationFilter>>;
  /** Filter by the object’s `computerName` field. */
  computerName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `hwCode` field. */
  hwCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `hwType` field. */
  hwType?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `licenseId` field. */
  licenseId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TempRegistrationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TempRegistrationFilter>>;
  /** Filter by the object’s `orderCode` field. */
  orderCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationCode` field. */
  registrationCode?: InputMaybe<StringFilter>;
};

/** A connection to a list of `TempRegistrationHistory` values. */
export type TempRegistrationHistoriesConnection = {
  __typename?: 'TempRegistrationHistoriesConnection';
  /** A list of edges which contains the `TempRegistrationHistory` and cursor to aid in pagination. */
  edges: Array<TempRegistrationHistoriesEdge>;
  /** A list of `TempRegistrationHistory` objects. */
  nodes: Array<TempRegistrationHistory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TempRegistrationHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TempRegistrationHistory` edge in the connection. */
export type TempRegistrationHistoriesEdge = {
  __typename?: 'TempRegistrationHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TempRegistrationHistory` at the end of the edge. */
  node: TempRegistrationHistory;
};

/** Methods to use when ordering `TempRegistrationHistory`. */
export enum TempRegistrationHistoriesOrderBy {
  ActivationCodeAsc = 'ACTIVATION_CODE_ASC',
  ActivationCodeDesc = 'ACTIVATION_CODE_DESC',
  ExpirationDateAsc = 'EXPIRATION_DATE_ASC',
  ExpirationDateDesc = 'EXPIRATION_DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrderCodeAsc = 'ORDER_CODE_ASC',
  OrderCodeDesc = 'ORDER_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RegistrationIdAsc = 'REGISTRATION_ID_ASC',
  RegistrationIdDesc = 'REGISTRATION_ID_DESC'
}

export type TempRegistrationHistory = Node & {
  __typename?: 'TempRegistrationHistory';
  activationCode?: Maybe<Scalars['String']['output']>;
  expirationDate?: Maybe<Scalars['Date']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  orderCode?: Maybe<Scalars['String']['output']>;
  registrationId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `TempRegistrationHistory` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type TempRegistrationHistoryCondition = {
  /** Checks for equality with the object’s `activationCode` field. */
  activationCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orderCode` field. */
  orderCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationId` field. */
  registrationId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `TempRegistrationHistory` object types. All fields are combined with a logical ‘and.’ */
export type TempRegistrationHistoryFilter = {
  /** Filter by the object’s `activationCode` field. */
  activationCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TempRegistrationHistoryFilter>>;
  /** Filter by the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TempRegistrationHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TempRegistrationHistoryFilter>>;
  /** Filter by the object’s `orderCode` field. */
  orderCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationId` field. */
  registrationId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `TempRegistrationHistory` */
export type TempRegistrationHistoryInput = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orderCode?: InputMaybe<Scalars['String']['input']>;
  registrationId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `TempRegistrationHistory`. Fields that are set will be updated. */
export type TempRegistrationHistoryPatch = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orderCode?: InputMaybe<Scalars['String']['input']>;
  registrationId?: InputMaybe<Scalars['Int']['input']>;
};

/** An input for mutations affecting `TempRegistration` */
export type TempRegistrationInput = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  computerName?: InputMaybe<Scalars['String']['input']>;
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  hwCode?: InputMaybe<Scalars['String']['input']>;
  hwType?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  orderCode?: InputMaybe<Scalars['String']['input']>;
  registrationCode?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `TempRegistration`. Fields that are set will be updated. */
export type TempRegistrationPatch = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  computerName?: InputMaybe<Scalars['String']['input']>;
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  hwCode?: InputMaybe<Scalars['String']['input']>;
  hwType?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  orderCode?: InputMaybe<Scalars['String']['input']>;
  registrationCode?: InputMaybe<Scalars['String']['input']>;
};

export type TempRegistrations2 = Node & {
  __typename?: 'TempRegistrations2';
  activationCode?: Maybe<Scalars['String']['output']>;
  computerName?: Maybe<Scalars['String']['output']>;
  expirationDate?: Maybe<Scalars['Date']['output']>;
  hwCode?: Maybe<Scalars['String']['output']>;
  hwType?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  ipAddress?: Maybe<Scalars['String']['output']>;
  licenseId?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  orderCode?: Maybe<Scalars['String']['output']>;
  registrationCode?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `TempRegistrations2` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TempRegistrations2Condition = {
  /** Checks for equality with the object’s `activationCode` field. */
  activationCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `computerName` field. */
  computerName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `hwCode` field. */
  hwCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `hwType` field. */
  hwType?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `licenseId` field. */
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orderCode` field. */
  orderCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationCode` field. */
  registrationCode?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TempRegistrations2` object types. All fields are combined with a logical ‘and.’ */
export type TempRegistrations2Filter = {
  /** Filter by the object’s `activationCode` field. */
  activationCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TempRegistrations2Filter>>;
  /** Filter by the object’s `computerName` field. */
  computerName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expirationDate` field. */
  expirationDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `hwCode` field. */
  hwCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `hwType` field. */
  hwType?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `ipAddress` field. */
  ipAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `licenseId` field. */
  licenseId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TempRegistrations2Filter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TempRegistrations2Filter>>;
  /** Filter by the object’s `orderCode` field. */
  orderCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationCode` field. */
  registrationCode?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `TempRegistrations2` */
export type TempRegistrations2Input = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  computerName?: InputMaybe<Scalars['String']['input']>;
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  hwCode?: InputMaybe<Scalars['String']['input']>;
  hwType?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  orderCode?: InputMaybe<Scalars['String']['input']>;
  registrationCode?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `TempRegistrations2`. Fields that are set will be updated. */
export type TempRegistrations2Patch = {
  activationCode?: InputMaybe<Scalars['String']['input']>;
  computerName?: InputMaybe<Scalars['String']['input']>;
  expirationDate?: InputMaybe<Scalars['Date']['input']>;
  hwCode?: InputMaybe<Scalars['String']['input']>;
  hwType?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ipAddress?: InputMaybe<Scalars['String']['input']>;
  licenseId?: InputMaybe<Scalars['Int']['input']>;
  orderCode?: InputMaybe<Scalars['String']['input']>;
  registrationCode?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `TempRegistrations2` values. */
export type TempRegistrations2SConnection = {
  __typename?: 'TempRegistrations2SConnection';
  /** A list of edges which contains the `TempRegistrations2` and cursor to aid in pagination. */
  edges: Array<TempRegistrations2SEdge>;
  /** A list of `TempRegistrations2` objects. */
  nodes: Array<TempRegistrations2>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TempRegistrations2` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TempRegistrations2` edge in the connection. */
export type TempRegistrations2SEdge = {
  __typename?: 'TempRegistrations2SEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TempRegistrations2` at the end of the edge. */
  node: TempRegistrations2;
};

/** Methods to use when ordering `TempRegistrations2`. */
export enum TempRegistrations2SOrderBy {
  ActivationCodeAsc = 'ACTIVATION_CODE_ASC',
  ActivationCodeDesc = 'ACTIVATION_CODE_DESC',
  ComputerNameAsc = 'COMPUTER_NAME_ASC',
  ComputerNameDesc = 'COMPUTER_NAME_DESC',
  ExpirationDateAsc = 'EXPIRATION_DATE_ASC',
  ExpirationDateDesc = 'EXPIRATION_DATE_DESC',
  HwCodeAsc = 'HW_CODE_ASC',
  HwCodeDesc = 'HW_CODE_DESC',
  HwTypeAsc = 'HW_TYPE_ASC',
  HwTypeDesc = 'HW_TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IpAddressAsc = 'IP_ADDRESS_ASC',
  IpAddressDesc = 'IP_ADDRESS_DESC',
  LicenseIdAsc = 'LICENSE_ID_ASC',
  LicenseIdDesc = 'LICENSE_ID_DESC',
  Natural = 'NATURAL',
  OrderCodeAsc = 'ORDER_CODE_ASC',
  OrderCodeDesc = 'ORDER_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RegistrationCodeAsc = 'REGISTRATION_CODE_ASC',
  RegistrationCodeDesc = 'REGISTRATION_CODE_DESC'
}

/** A connection to a list of `TempRegistration` values. */
export type TempRegistrationsConnection = {
  __typename?: 'TempRegistrationsConnection';
  /** A list of edges which contains the `TempRegistration` and cursor to aid in pagination. */
  edges: Array<TempRegistrationsEdge>;
  /** A list of `TempRegistration` objects. */
  nodes: Array<TempRegistration>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TempRegistration` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TempRegistration` edge in the connection. */
export type TempRegistrationsEdge = {
  __typename?: 'TempRegistrationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TempRegistration` at the end of the edge. */
  node: TempRegistration;
};

/** Methods to use when ordering `TempRegistration`. */
export enum TempRegistrationsOrderBy {
  ActivationCodeAsc = 'ACTIVATION_CODE_ASC',
  ActivationCodeDesc = 'ACTIVATION_CODE_DESC',
  ComputerNameAsc = 'COMPUTER_NAME_ASC',
  ComputerNameDesc = 'COMPUTER_NAME_DESC',
  ExpirationDateAsc = 'EXPIRATION_DATE_ASC',
  ExpirationDateDesc = 'EXPIRATION_DATE_DESC',
  HwCodeAsc = 'HW_CODE_ASC',
  HwCodeDesc = 'HW_CODE_DESC',
  HwTypeAsc = 'HW_TYPE_ASC',
  HwTypeDesc = 'HW_TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IpAddressAsc = 'IP_ADDRESS_ASC',
  IpAddressDesc = 'IP_ADDRESS_DESC',
  LicenseIdAsc = 'LICENSE_ID_ASC',
  LicenseIdDesc = 'LICENSE_ID_DESC',
  Natural = 'NATURAL',
  OrderCodeAsc = 'ORDER_CODE_ASC',
  OrderCodeDesc = 'ORDER_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RegistrationCodeAsc = 'REGISTRATION_CODE_ASC',
  RegistrationCodeDesc = 'REGISTRATION_CODE_DESC'
}

export type Test = Node & {
  __typename?: 'Test';
  date?: Maybe<Scalars['Datetime']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  detectorSensorLocationId: Scalars['Int']['output'];
  filterId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  originalSensorId?: Maybe<Scalars['Int']['output']>;
  pyrolyserId?: Maybe<Scalars['Int']['output']>;
  sensorId?: Maybe<Scalars['Int']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** A condition to be used against `Test` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TestCondition = {
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `day` field. */
  day?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `filterId` field. */
  filterId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `originalSensorId` field. */
  originalSensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sensorId` field. */
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `success` field. */
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A filter to be used against `Test` object types. All fields are combined with a logical ‘and.’ */
export type TestFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TestFilter>>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `day` field. */
  day?: InputMaybe<IntFilter>;
  /** Filter by the object’s `detectorSensorLocationId` field. */
  detectorSensorLocationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `filterId` field. */
  filterId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TestFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TestFilter>>;
  /** Filter by the object’s `originalSensorId` field. */
  originalSensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `pyrolyserId` field. */
  pyrolyserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sensorId` field. */
  sensorId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `success` field. */
  success?: InputMaybe<BooleanFilter>;
};

/** An input for mutations affecting `Test` */
export type TestInput = {
  date?: InputMaybe<Scalars['Datetime']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  detectorSensorLocationId: Scalars['Int']['input'];
  filterId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  originalSensorId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents an update to a `Test`. Fields that are set will be updated. */
export type TestPatch = {
  date?: InputMaybe<Scalars['Datetime']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  detectorSensorLocationId?: InputMaybe<Scalars['Int']['input']>;
  filterId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  originalSensorId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A connection to a list of `Test` values. */
export type TestsConnection = {
  __typename?: 'TestsConnection';
  /** A list of edges which contains the `Test` and cursor to aid in pagination. */
  edges: Array<TestsEdge>;
  /** A list of `Test` objects. */
  nodes: Array<Test>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Test` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Test` edge in the connection. */
export type TestsEdge = {
  __typename?: 'TestsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Test` at the end of the edge. */
  node: Test;
};

/** Methods to use when ordering `Test`. */
export enum TestsOrderBy {
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DayAsc = 'DAY_ASC',
  DayDesc = 'DAY_DESC',
  DetectorSensorLocationIdAsc = 'DETECTOR_SENSOR_LOCATION_ID_ASC',
  DetectorSensorLocationIdDesc = 'DETECTOR_SENSOR_LOCATION_ID_DESC',
  FilterIdAsc = 'FILTER_ID_ASC',
  FilterIdDesc = 'FILTER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OriginalSensorIdAsc = 'ORIGINAL_SENSOR_ID_ASC',
  OriginalSensorIdDesc = 'ORIGINAL_SENSOR_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PyrolyserIdAsc = 'PYROLYSER_ID_ASC',
  PyrolyserIdDesc = 'PYROLYSER_ID_DESC',
  SensorIdAsc = 'SENSOR_ID_ASC',
  SensorIdDesc = 'SENSOR_ID_DESC',
  SuccessAsc = 'SUCCESS_ASC',
  SuccessDesc = 'SUCCESS_DESC'
}

/** A connection to a list of `Tztadvy` values. */
export type TztadviesConnection = {
  __typename?: 'TztadviesConnection';
  /** A list of edges which contains the `Tztadvy` and cursor to aid in pagination. */
  edges: Array<TztadviesEdge>;
  /** A list of `Tztadvy` objects. */
  nodes: Array<Tztadvy>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tztadvy` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Tztadvy` edge in the connection. */
export type TztadviesEdge = {
  __typename?: 'TztadviesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Tztadvy` at the end of the edge. */
  node: Tztadvy;
};

/** Methods to use when ordering `Tztadvy`. */
export enum TztadviesOrderBy {
  AantalbesteldAsc = 'AANTALBESTELD_ASC',
  AantalbesteldDesc = 'AANTALBESTELD_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  BesthoeveelheidAsc = 'BESTHOEVEELHEID_ASC',
  BesthoeveelheidDesc = 'BESTHOEVEELHEID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  FactuuropdrachtAsc = 'FACTUUROPDRACHT_ASC',
  FactuuropdrachtDesc = 'FACTUUROPDRACHT_DESC',
  InkoopprijsAsc = 'INKOOPPRIJS_ASC',
  InkoopprijsDesc = 'INKOOPPRIJS_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  StockSupplierIdAsc = 'STOCK_SUPPLIER_ID_ASC',
  StockSupplierIdDesc = 'STOCK_SUPPLIER_ID_DESC'
}

export type Tztadvy = {
  __typename?: 'Tztadvy';
  aantalbesteld?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  besthoeveelheid?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  factuuropdracht?: Maybe<Scalars['String']['output']>;
  inkoopprijs?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  stockSupplierId?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `Tztadvy` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TztadvyCondition = {
  /** Checks for equality with the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stockSupplierId` field. */
  stockSupplierId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Tztadvy` object types. All fields are combined with a logical ‘and.’ */
export type TztadvyFilter = {
  /** Filter by the object’s `aantalbesteld` field. */
  aantalbesteld?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TztadvyFilter>>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `factuuropdracht` field. */
  factuuropdracht?: InputMaybe<StringFilter>;
  /** Filter by the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TztadvyFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TztadvyFilter>>;
  /** Filter by the object’s `stockSupplierId` field. */
  stockSupplierId?: InputMaybe<IntFilter>;
};

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Included in the specified list -unless list is empty in which case this operator is not applied. */
  inExpansive?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

/** All input for the `updateAcoById` mutation. */
export type UpdateAcoByIdInput = {
  /** An object where the defined keys will be set on the `Aco` being updated. */
  acoPatch: AcoPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAco` mutation. */
export type UpdateAcoInput = {
  /** An object where the defined keys will be set on the `Aco` being updated. */
  acoPatch: AcoPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Aco` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Aco` mutation. */
export type UpdateAcoPayload = {
  __typename?: 'UpdateAcoPayload';
  /** The `Aco` that was updated by this mutation. */
  aco?: Maybe<Aco>;
  /** An edge for our `Aco`. May be used by Relay 1. */
  acoEdge?: Maybe<AcosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Aco` mutation. */
export type UpdateAcoPayloadAcoEdgeArgs = {
  orderBy?: InputMaybe<Array<AcosOrderBy>>;
};

/** All input for the `updateActionById` mutation. */
export type UpdateActionByIdInput = {
  /** An object where the defined keys will be set on the `Action` being updated. */
  actionPatch: ActionPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAction` mutation. */
export type UpdateActionInput = {
  /** An object where the defined keys will be set on the `Action` being updated. */
  actionPatch: ActionPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Action` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Action` mutation. */
export type UpdateActionPayload = {
  __typename?: 'UpdateActionPayload';
  /** The `Action` that was updated by this mutation. */
  action?: Maybe<Action>;
  /** An edge for our `Action`. May be used by Relay 1. */
  actionEdge?: Maybe<ActionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `Action`. */
  groupByGroupId?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `Action`. */
  reportByReportId?: Maybe<Report>;
  /** Reads a single `User` that is related to this `Action`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Action`. */
  userByUserId?: Maybe<User>;
};


/** The output of our update `Action` mutation. */
export type UpdateActionPayloadActionEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionsOrderBy>>;
};

/** All input for the `updateAdreByAdresGuid` mutation. */
export type UpdateAdreByAdresGuidInput = {
  /** An object where the defined keys will be set on the `_Adre` being updated. */
  _adrePatch: _AdrePatch;
  adresGuid: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `updateAdre` mutation. */
export type UpdateAdreInput = {
  /** An object where the defined keys will be set on the `_Adre` being updated. */
  _adrePatch: _AdrePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `_Adre` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `_Adre` mutation. */
export type UpdateAdrePayload = {
  __typename?: 'UpdateAdrePayload';
  /** The `_Adre` that was updated by this mutation. */
  _adre?: Maybe<_Adre>;
  /** An edge for our `_Adre`. May be used by Relay 1. */
  _adreEdge?: Maybe<_AdresEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `_Adre` mutation. */
export type UpdateAdrePayload_AdreEdgeArgs = {
  orderBy?: InputMaybe<Array<_AdresOrderBy>>;
};

/** All input for the `updateApplicationById` mutation. */
export type UpdateApplicationByIdInput = {
  /** An object where the defined keys will be set on the `Application` being updated. */
  applicationPatch: ApplicationPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateApplicationByName` mutation. */
export type UpdateApplicationByNameInput = {
  /** An object where the defined keys will be set on the `Application` being updated. */
  applicationPatch: ApplicationPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `updateApplication` mutation. */
export type UpdateApplicationInput = {
  /** An object where the defined keys will be set on the `Application` being updated. */
  applicationPatch: ApplicationPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Application` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Application` mutation. */
export type UpdateApplicationPayload = {
  __typename?: 'UpdateApplicationPayload';
  /** The `Application` that was updated by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Application`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Application` mutation. */
export type UpdateApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the `updateAreaByFloorIdAndName` mutation. */
export type UpdateAreaByFloorIdAndNameInput = {
  /** An object where the defined keys will be set on the `Area` being updated. */
  areaPatch: AreaPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  floorId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

/** All input for the `updateAreaById` mutation. */
export type UpdateAreaByIdInput = {
  /** An object where the defined keys will be set on the `Area` being updated. */
  areaPatch: AreaPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateArea` mutation. */
export type UpdateAreaInput = {
  /** An object where the defined keys will be set on the `Area` being updated. */
  areaPatch: AreaPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Area` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Area` mutation. */
export type UpdateAreaPayload = {
  __typename?: 'UpdateAreaPayload';
  /** The `Area` that was updated by this mutation. */
  area?: Maybe<Area>;
  /** An edge for our `Area`. May be used by Relay 1. */
  areaEdge?: Maybe<AreasEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Floor` that is related to this `Area`. */
  floorByFloorId?: Maybe<Floor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Area`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Area` mutation. */
export type UpdateAreaPayloadAreaEdgeArgs = {
  orderBy?: InputMaybe<Array<AreasOrderBy>>;
};

/** All input for the `updateAroById` mutation. */
export type UpdateAroByIdInput = {
  /** An object where the defined keys will be set on the `Aro` being updated. */
  aroPatch: AroPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAro` mutation. */
export type UpdateAroInput = {
  /** An object where the defined keys will be set on the `Aro` being updated. */
  aroPatch: AroPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Aro` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Aro` mutation. */
export type UpdateAroPayload = {
  __typename?: 'UpdateAroPayload';
  /** The `Aro` that was updated by this mutation. */
  aro?: Maybe<Aro>;
  /** An edge for our `Aro`. May be used by Relay 1. */
  aroEdge?: Maybe<ArosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Aro` mutation. */
export type UpdateAroPayloadAroEdgeArgs = {
  orderBy?: InputMaybe<Array<ArosOrderBy>>;
};

/** All input for the `updateArosAcoById` mutation. */
export type UpdateArosAcoByIdInput = {
  /** An object where the defined keys will be set on the `ArosAco` being updated. */
  arosAcoPatch: ArosAcoPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateArosAco` mutation. */
export type UpdateArosAcoInput = {
  /** An object where the defined keys will be set on the `ArosAco` being updated. */
  arosAcoPatch: ArosAcoPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ArosAco` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `ArosAco` mutation. */
export type UpdateArosAcoPayload = {
  __typename?: 'UpdateArosAcoPayload';
  /** The `ArosAco` that was updated by this mutation. */
  arosAco?: Maybe<ArosAco>;
  /** An edge for our `ArosAco`. May be used by Relay 1. */
  arosAcoEdge?: Maybe<ArosAcosEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ArosAco` mutation. */
export type UpdateArosAcoPayloadArosAcoEdgeArgs = {
  orderBy?: InputMaybe<Array<ArosAcosOrderBy>>;
};

/** All input for the `updateArtikelByCdartikel` mutation. */
export type UpdateArtikelByCdartikelInput = {
  /** An object where the defined keys will be set on the `Artikel` being updated. */
  artikelPatch: ArtikelPatch;
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `updateArtikel` mutation. */
export type UpdateArtikelInput = {
  /** An object where the defined keys will be set on the `Artikel` being updated. */
  artikelPatch: ArtikelPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Artikel` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `updateArtikelLogById` mutation. */
export type UpdateArtikelLogByIdInput = {
  /** An object where the defined keys will be set on the `ArtikelLog` being updated. */
  artikelLogPatch: ArtikelLogPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateArtikelLog` mutation. */
export type UpdateArtikelLogInput = {
  /** An object where the defined keys will be set on the `ArtikelLog` being updated. */
  artikelLogPatch: ArtikelLogPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ArtikelLog` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `ArtikelLog` mutation. */
export type UpdateArtikelLogPayload = {
  __typename?: 'UpdateArtikelLogPayload';
  /** The `ArtikelLog` that was updated by this mutation. */
  artikelLog?: Maybe<ArtikelLog>;
  /** An edge for our `ArtikelLog`. May be used by Relay 1. */
  artikelLogEdge?: Maybe<ArtikelLogsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ArtikelLog` mutation. */
export type UpdateArtikelLogPayloadArtikelLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelLogsOrderBy>>;
};

/** The output of our update `Artikel` mutation. */
export type UpdateArtikelPayload = {
  __typename?: 'UpdateArtikelPayload';
  /** The `Artikel` that was updated by this mutation. */
  artikel?: Maybe<Artikel>;
  /** An edge for our `Artikel`. May be used by Relay 1. */
  artikelEdge?: Maybe<ArtikelsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Artikel` mutation. */
export type UpdateArtikelPayloadArtikelEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelsOrderBy>>;
};

/** All input for the `updateArtikelomschrByCdartikelAndCdtaal` mutation. */
export type UpdateArtikelomschrByCdartikelAndCdtaalInput = {
  /** An object where the defined keys will be set on the `Artikelomschr` being updated. */
  artikelomschrPatch: ArtikelomschrPatch;
  cdartikel: Scalars['String']['input'];
  cdtaal: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `updateArtikelomschr` mutation. */
export type UpdateArtikelomschrInput = {
  /** An object where the defined keys will be set on the `Artikelomschr` being updated. */
  artikelomschrPatch: ArtikelomschrPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Artikelomschr` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Artikelomschr` mutation. */
export type UpdateArtikelomschrPayload = {
  __typename?: 'UpdateArtikelomschrPayload';
  /** The `Artikelomschr` that was updated by this mutation. */
  artikelomschr?: Maybe<Artikelomschr>;
  /** An edge for our `Artikelomschr`. May be used by Relay 1. */
  artikelomschrEdge?: Maybe<ArtikelomschrsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Artikelomschr` mutation. */
export type UpdateArtikelomschrPayloadArtikelomschrEdgeArgs = {
  orderBy?: InputMaybe<Array<ArtikelomschrsOrderBy>>;
};

/** All input for the `updateAspNetRoleById` mutation. */
export type UpdateAspNetRoleByIdInput = {
  /** An object where the defined keys will be set on the `AspNetRole` being updated. */
  aspNetRolePatch: AspNetRolePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** All input for the `updateAspNetRoleClaimById` mutation. */
export type UpdateAspNetRoleClaimByIdInput = {
  /** An object where the defined keys will be set on the `AspNetRoleClaim` being updated. */
  aspNetRoleClaimPatch: AspNetRoleClaimPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAspNetRoleClaim` mutation. */
export type UpdateAspNetRoleClaimInput = {
  /** An object where the defined keys will be set on the `AspNetRoleClaim` being updated. */
  aspNetRoleClaimPatch: AspNetRoleClaimPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetRoleClaim` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `AspNetRoleClaim` mutation. */
export type UpdateAspNetRoleClaimPayload = {
  __typename?: 'UpdateAspNetRoleClaimPayload';
  /** Reads a single `AspNetRole` that is related to this `AspNetRoleClaim`. */
  aspNetRoleByRoleId?: Maybe<AspNetRole>;
  /** The `AspNetRoleClaim` that was updated by this mutation. */
  aspNetRoleClaim?: Maybe<AspNetRoleClaim>;
  /** An edge for our `AspNetRoleClaim`. May be used by Relay 1. */
  aspNetRoleClaimEdge?: Maybe<AspNetRoleClaimsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `AspNetRoleClaim` mutation. */
export type UpdateAspNetRoleClaimPayloadAspNetRoleClaimEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetRoleClaimsOrderBy>>;
};

/** All input for the `updateAspNetRole` mutation. */
export type UpdateAspNetRoleInput = {
  /** An object where the defined keys will be set on the `AspNetRole` being updated. */
  aspNetRolePatch: AspNetRolePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetRole` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `AspNetRole` mutation. */
export type UpdateAspNetRolePayload = {
  __typename?: 'UpdateAspNetRolePayload';
  /** The `AspNetRole` that was updated by this mutation. */
  aspNetRole?: Maybe<AspNetRole>;
  /** An edge for our `AspNetRole`. May be used by Relay 1. */
  aspNetRoleEdge?: Maybe<AspNetRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `AspNetRole` mutation. */
export type UpdateAspNetRolePayloadAspNetRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetRolesOrderBy>>;
};

/** All input for the `updateAspNetUserById` mutation. */
export type UpdateAspNetUserByIdInput = {
  /** An object where the defined keys will be set on the `AspNetUser` being updated. */
  aspNetUserPatch: AspNetUserPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
};

/** All input for the `updateAspNetUserClaimById` mutation. */
export type UpdateAspNetUserClaimByIdInput = {
  /** An object where the defined keys will be set on the `AspNetUserClaim` being updated. */
  aspNetUserClaimPatch: AspNetUserClaimPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAspNetUserClaim` mutation. */
export type UpdateAspNetUserClaimInput = {
  /** An object where the defined keys will be set on the `AspNetUserClaim` being updated. */
  aspNetUserClaimPatch: AspNetUserClaimPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUserClaim` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `AspNetUserClaim` mutation. */
export type UpdateAspNetUserClaimPayload = {
  __typename?: 'UpdateAspNetUserClaimPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserClaim`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserClaim` that was updated by this mutation. */
  aspNetUserClaim?: Maybe<AspNetUserClaim>;
  /** An edge for our `AspNetUserClaim`. May be used by Relay 1. */
  aspNetUserClaimEdge?: Maybe<AspNetUserClaimsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `AspNetUserClaim` mutation. */
export type UpdateAspNetUserClaimPayloadAspNetUserClaimEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserClaimsOrderBy>>;
};

/** All input for the `updateAspNetUser` mutation. */
export type UpdateAspNetUserInput = {
  /** An object where the defined keys will be set on the `AspNetUser` being updated. */
  aspNetUserPatch: AspNetUserPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUser` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `updateAspNetUserLoginByLoginProviderAndProviderKey` mutation. */
export type UpdateAspNetUserLoginByLoginProviderAndProviderKeyInput = {
  /** An object where the defined keys will be set on the `AspNetUserLogin` being updated. */
  aspNetUserLoginPatch: AspNetUserLoginPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  loginProvider: Scalars['String']['input'];
  providerKey: Scalars['String']['input'];
};

/** All input for the `updateAspNetUserLogin` mutation. */
export type UpdateAspNetUserLoginInput = {
  /** An object where the defined keys will be set on the `AspNetUserLogin` being updated. */
  aspNetUserLoginPatch: AspNetUserLoginPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUserLogin` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `AspNetUserLogin` mutation. */
export type UpdateAspNetUserLoginPayload = {
  __typename?: 'UpdateAspNetUserLoginPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserLogin`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserLogin` that was updated by this mutation. */
  aspNetUserLogin?: Maybe<AspNetUserLogin>;
  /** An edge for our `AspNetUserLogin`. May be used by Relay 1. */
  aspNetUserLoginEdge?: Maybe<AspNetUserLoginsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `AspNetUserLogin` mutation. */
export type UpdateAspNetUserLoginPayloadAspNetUserLoginEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserLoginsOrderBy>>;
};

/** The output of our update `AspNetUser` mutation. */
export type UpdateAspNetUserPayload = {
  __typename?: 'UpdateAspNetUserPayload';
  /** The `AspNetUser` that was updated by this mutation. */
  aspNetUser?: Maybe<AspNetUser>;
  /** An edge for our `AspNetUser`. May be used by Relay 1. */
  aspNetUserEdge?: Maybe<AspNetUsersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `AspNetUser` mutation. */
export type UpdateAspNetUserPayloadAspNetUserEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUsersOrderBy>>;
};

/** All input for the `updateAspNetUserRoleByUserIdAndRoleId` mutation. */
export type UpdateAspNetUserRoleByUserIdAndRoleIdInput = {
  /** An object where the defined keys will be set on the `AspNetUserRole` being updated. */
  aspNetUserRolePatch: AspNetUserRolePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  roleId: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};

/** All input for the `updateAspNetUserRole` mutation. */
export type UpdateAspNetUserRoleInput = {
  /** An object where the defined keys will be set on the `AspNetUserRole` being updated. */
  aspNetUserRolePatch: AspNetUserRolePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUserRole` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `AspNetUserRole` mutation. */
export type UpdateAspNetUserRolePayload = {
  __typename?: 'UpdateAspNetUserRolePayload';
  /** Reads a single `AspNetRole` that is related to this `AspNetUserRole`. */
  aspNetRoleByRoleId?: Maybe<AspNetRole>;
  /** Reads a single `AspNetUser` that is related to this `AspNetUserRole`. */
  aspNetUserByAppUserId?: Maybe<AspNetUser>;
  /** Reads a single `AspNetUser` that is related to this `AspNetUserRole`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserRole` that was updated by this mutation. */
  aspNetUserRole?: Maybe<AspNetUserRole>;
  /** An edge for our `AspNetUserRole`. May be used by Relay 1. */
  aspNetUserRoleEdge?: Maybe<AspNetUserRolesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `AspNetUserRole` mutation. */
export type UpdateAspNetUserRolePayloadAspNetUserRoleEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserRolesOrderBy>>;
};

/** All input for the `updateAspNetUserTokenByUserIdAndLoginProviderAndName` mutation. */
export type UpdateAspNetUserTokenByUserIdAndLoginProviderAndNameInput = {
  /** An object where the defined keys will be set on the `AspNetUserToken` being updated. */
  aspNetUserTokenPatch: AspNetUserTokenPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  loginProvider: Scalars['String']['input'];
  name: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};

/** All input for the `updateAspNetUserToken` mutation. */
export type UpdateAspNetUserTokenInput = {
  /** An object where the defined keys will be set on the `AspNetUserToken` being updated. */
  aspNetUserTokenPatch: AspNetUserTokenPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AspNetUserToken` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `AspNetUserToken` mutation. */
export type UpdateAspNetUserTokenPayload = {
  __typename?: 'UpdateAspNetUserTokenPayload';
  /** Reads a single `AspNetUser` that is related to this `AspNetUserToken`. */
  aspNetUserByUserId?: Maybe<AspNetUser>;
  /** The `AspNetUserToken` that was updated by this mutation. */
  aspNetUserToken?: Maybe<AspNetUserToken>;
  /** An edge for our `AspNetUserToken`. May be used by Relay 1. */
  aspNetUserTokenEdge?: Maybe<AspNetUserTokensEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `AspNetUserToken` mutation. */
export type UpdateAspNetUserTokenPayloadAspNetUserTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<AspNetUserTokensOrderBy>>;
};

/** All input for the `updateAssemblyByCode` mutation. */
export type UpdateAssemblyByCodeInput = {
  /** An object where the defined keys will be set on the `Assembly` being updated. */
  assemblyPatch: AssemblyPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** All input for the `updateAssemblyById` mutation. */
export type UpdateAssemblyByIdInput = {
  /** An object where the defined keys will be set on the `Assembly` being updated. */
  assemblyPatch: AssemblyPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAssembly` mutation. */
export type UpdateAssemblyInput = {
  /** An object where the defined keys will be set on the `Assembly` being updated. */
  assemblyPatch: AssemblyPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Assembly` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `updateAssemblyPartByAssemblyIdAndCdartikel` mutation. */
export type UpdateAssemblyPartByAssemblyIdAndCdartikelInput = {
  assemblyId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `AssemblyPart` being updated. */
  assemblyPartPatch: AssemblyPartPatch;
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `updateAssemblyPartById` mutation. */
export type UpdateAssemblyPartByIdInput = {
  /** An object where the defined keys will be set on the `AssemblyPart` being updated. */
  assemblyPartPatch: AssemblyPartPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAssemblyPart` mutation. */
export type UpdateAssemblyPartInput = {
  /** An object where the defined keys will be set on the `AssemblyPart` being updated. */
  assemblyPartPatch: AssemblyPartPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AssemblyPart` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `AssemblyPart` mutation. */
export type UpdateAssemblyPartPayload = {
  __typename?: 'UpdateAssemblyPartPayload';
  /** The `AssemblyPart` that was updated by this mutation. */
  assemblyPart?: Maybe<AssemblyPart>;
  /** An edge for our `AssemblyPart`. May be used by Relay 1. */
  assemblyPartEdge?: Maybe<AssemblyPartsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyPart`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `AssemblyPart` mutation. */
export type UpdateAssemblyPartPayloadAssemblyPartEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyPartsOrderBy>>;
};

/** The output of our update `Assembly` mutation. */
export type UpdateAssemblyPayload = {
  __typename?: 'UpdateAssemblyPayload';
  /** The `Assembly` that was updated by this mutation. */
  assembly?: Maybe<Assembly>;
  /** An edge for our `Assembly`. May be used by Relay 1. */
  assemblyEdge?: Maybe<AssembliesEdge>;
  /** Reads a single `AssemblyType` that is related to this `Assembly`. */
  assemblyTypeByAssemblyTypeId?: Maybe<AssemblyType>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Assembly`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Assembly` mutation. */
export type UpdateAssemblyPayloadAssemblyEdgeArgs = {
  orderBy?: InputMaybe<Array<AssembliesOrderBy>>;
};

/** All input for the `updateAssemblyTypeById` mutation. */
export type UpdateAssemblyTypeByIdInput = {
  /** An object where the defined keys will be set on the `AssemblyType` being updated. */
  assemblyTypePatch: AssemblyTypePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAssemblyType` mutation. */
export type UpdateAssemblyTypeInput = {
  /** An object where the defined keys will be set on the `AssemblyType` being updated. */
  assemblyTypePatch: AssemblyTypePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AssemblyType` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `updateAssemblyTypePartByAssemblyTypeIdAndCdartikel` mutation. */
export type UpdateAssemblyTypePartByAssemblyTypeIdAndCdartikelInput = {
  assemblyTypeId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `AssemblyTypePart` being updated. */
  assemblyTypePartPatch: AssemblyTypePartPatch;
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `updateAssemblyTypePartById` mutation. */
export type UpdateAssemblyTypePartByIdInput = {
  /** An object where the defined keys will be set on the `AssemblyTypePart` being updated. */
  assemblyTypePartPatch: AssemblyTypePartPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateAssemblyTypePart` mutation. */
export type UpdateAssemblyTypePartInput = {
  /** An object where the defined keys will be set on the `AssemblyTypePart` being updated. */
  assemblyTypePartPatch: AssemblyTypePartPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `AssemblyTypePart` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `AssemblyTypePart` mutation. */
export type UpdateAssemblyTypePartPayload = {
  __typename?: 'UpdateAssemblyTypePartPayload';
  /** Reads a single `AssemblyType` that is related to this `AssemblyTypePart`. */
  assemblyTypeByAssemblyTypeId?: Maybe<AssemblyType>;
  /** The `AssemblyTypePart` that was updated by this mutation. */
  assemblyTypePart?: Maybe<AssemblyTypePart>;
  /** An edge for our `AssemblyTypePart`. May be used by Relay 1. */
  assemblyTypePartEdge?: Maybe<AssemblyTypePartsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyTypePart`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `AssemblyTypePart` mutation. */
export type UpdateAssemblyTypePartPayloadAssemblyTypePartEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyTypePartsOrderBy>>;
};

/** The output of our update `AssemblyType` mutation. */
export type UpdateAssemblyTypePayload = {
  __typename?: 'UpdateAssemblyTypePayload';
  /** Reads a single `Artikel` that is related to this `AssemblyType`. */
  artikelByCdartikel?: Maybe<Artikel>;
  /** The `AssemblyType` that was updated by this mutation. */
  assemblyType?: Maybe<AssemblyType>;
  /** An edge for our `AssemblyType`. May be used by Relay 1. */
  assemblyTypeEdge?: Maybe<AssemblyTypesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `AssemblyType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `AssemblyType` mutation. */
export type UpdateAssemblyTypePayloadAssemblyTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<AssemblyTypesOrderBy>>;
};

/** All input for the `updateBuildingByEndUserIdAndName` mutation. */
export type UpdateBuildingByEndUserIdAndNameInput = {
  /** An object where the defined keys will be set on the `Building` being updated. */
  buildingPatch: BuildingPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  endUserId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

/** All input for the `updateBuildingById` mutation. */
export type UpdateBuildingByIdInput = {
  /** An object where the defined keys will be set on the `Building` being updated. */
  buildingPatch: BuildingPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateBuilding` mutation. */
export type UpdateBuildingInput = {
  /** An object where the defined keys will be set on the `Building` being updated. */
  buildingPatch: BuildingPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Building` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Building` mutation. */
export type UpdateBuildingPayload = {
  __typename?: 'UpdateBuildingPayload';
  /** The `Building` that was updated by this mutation. */
  building?: Maybe<Building>;
  /** An edge for our `Building`. May be used by Relay 1. */
  buildingEdge?: Maybe<BuildingsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `Building`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Building`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Building` mutation. */
export type UpdateBuildingPayloadBuildingEdgeArgs = {
  orderBy?: InputMaybe<Array<BuildingsOrderBy>>;
};

/** All input for the `updateCalGasByConcentrationAndEngineeringUnitsAndGasId` mutation. */
export type UpdateCalGasByConcentrationAndEngineeringUnitsAndGasIdInput = {
  /** An object where the defined keys will be set on the `CalGas` being updated. */
  calGasPatch: CalGasPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  concentration: Scalars['Float']['input'];
  engineeringUnits: Scalars['String']['input'];
  gasId: Scalars['Int']['input'];
};

/** All input for the `updateCalGasById` mutation. */
export type UpdateCalGasByIdInput = {
  /** An object where the defined keys will be set on the `CalGas` being updated. */
  calGasPatch: CalGasPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateCalGas` mutation. */
export type UpdateCalGasInput = {
  /** An object where the defined keys will be set on the `CalGas` being updated. */
  calGasPatch: CalGasPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CalGas` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `CalGas` mutation. */
export type UpdateCalGasPayload = {
  __typename?: 'UpdateCalGasPayload';
  /** The `CalGas` that was updated by this mutation. */
  calGas?: Maybe<CalGas>;
  /** An edge for our `CalGas`. May be used by Relay 1. */
  calGasEdge?: Maybe<CalGasesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Gas` that is related to this `CalGas`. */
  gasByGasId?: Maybe<Gas>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CalGas`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `CalGas` mutation. */
export type UpdateCalGasPayloadCalGasEdgeArgs = {
  orderBy?: InputMaybe<Array<CalGasesOrderBy>>;
};

/** All input for the `updateCatalogGroupById` mutation. */
export type UpdateCatalogGroupByIdInput = {
  /** An object where the defined keys will be set on the `CatalogGroup` being updated. */
  catalogGroupPatch: CatalogGroupPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateCatalogGroup` mutation. */
export type UpdateCatalogGroupInput = {
  /** An object where the defined keys will be set on the `CatalogGroup` being updated. */
  catalogGroupPatch: CatalogGroupPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogGroup` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `CatalogGroup` mutation. */
export type UpdateCatalogGroupPayload = {
  __typename?: 'UpdateCatalogGroupPayload';
  /** The `CatalogGroup` that was updated by this mutation. */
  catalogGroup?: Maybe<CatalogGroup>;
  /** An edge for our `CatalogGroup`. May be used by Relay 1. */
  catalogGroupEdge?: Maybe<CatalogGroupsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `CatalogGroup` mutation. */
export type UpdateCatalogGroupPayloadCatalogGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogGroupsOrderBy>>;
};

/** All input for the `updateCatalogItemById` mutation. */
export type UpdateCatalogItemByIdInput = {
  /** An object where the defined keys will be set on the `CatalogItem` being updated. */
  catalogItemPatch: CatalogItemPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateCatalogItemFileById` mutation. */
export type UpdateCatalogItemFileByIdInput = {
  /** An object where the defined keys will be set on the `CatalogItemFile` being updated. */
  catalogItemFilePatch: CatalogItemFilePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateCatalogItemFile` mutation. */
export type UpdateCatalogItemFileInput = {
  /** An object where the defined keys will be set on the `CatalogItemFile` being updated. */
  catalogItemFilePatch: CatalogItemFilePatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogItemFile` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `CatalogItemFile` mutation. */
export type UpdateCatalogItemFilePayload = {
  __typename?: 'UpdateCatalogItemFilePayload';
  /** Reads a single `CatalogItem` that is related to this `CatalogItemFile`. */
  catalogItemByCatalogItemId?: Maybe<CatalogItem>;
  /** The `CatalogItemFile` that was updated by this mutation. */
  catalogItemFile?: Maybe<CatalogItemFile>;
  /** An edge for our `CatalogItemFile`. May be used by Relay 1. */
  catalogItemFileEdge?: Maybe<CatalogItemFilesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogItemFile`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `CatalogItemFile` mutation. */
export type UpdateCatalogItemFilePayloadCatalogItemFileEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemFilesOrderBy>>;
};

/** All input for the `updateCatalogItem` mutation. */
export type UpdateCatalogItemInput = {
  /** An object where the defined keys will be set on the `CatalogItem` being updated. */
  catalogItemPatch: CatalogItemPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogItem` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `CatalogItem` mutation. */
export type UpdateCatalogItemPayload = {
  __typename?: 'UpdateCatalogItemPayload';
  /** The `CatalogItem` that was updated by this mutation. */
  catalogItem?: Maybe<CatalogItem>;
  /** An edge for our `CatalogItem`. May be used by Relay 1. */
  catalogItemEdge?: Maybe<CatalogItemsEdge>;
  /** Reads a single `CatalogSubGroup` that is related to this `CatalogItem`. */
  catalogSubGroupByCatalogSubGroupId?: Maybe<CatalogSubGroup>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogItem`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `CatalogItem` mutation. */
export type UpdateCatalogItemPayloadCatalogItemEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemsOrderBy>>;
};

/** All input for the `updateCatalogItemRelationById` mutation. */
export type UpdateCatalogItemRelationByIdInput = {
  /** An object where the defined keys will be set on the `CatalogItemRelation` being updated. */
  catalogItemRelationPatch: CatalogItemRelationPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateCatalogItemRelation` mutation. */
export type UpdateCatalogItemRelationInput = {
  /** An object where the defined keys will be set on the `CatalogItemRelation` being updated. */
  catalogItemRelationPatch: CatalogItemRelationPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogItemRelation` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `CatalogItemRelation` mutation. */
export type UpdateCatalogItemRelationPayload = {
  __typename?: 'UpdateCatalogItemRelationPayload';
  /** Reads a single `CatalogItem` that is related to this `CatalogItemRelation`. */
  catalogItemByChildCatalogItemId?: Maybe<CatalogItem>;
  /** Reads a single `CatalogItem` that is related to this `CatalogItemRelation`. */
  catalogItemByParentCatalogItemId?: Maybe<CatalogItem>;
  /** The `CatalogItemRelation` that was updated by this mutation. */
  catalogItemRelation?: Maybe<CatalogItemRelation>;
  /** An edge for our `CatalogItemRelation`. May be used by Relay 1. */
  catalogItemRelationEdge?: Maybe<CatalogItemRelationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `CatalogItemRelation` mutation. */
export type UpdateCatalogItemRelationPayloadCatalogItemRelationEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogItemRelationsOrderBy>>;
};

/** All input for the `updateCatalogSubGroupById` mutation. */
export type UpdateCatalogSubGroupByIdInput = {
  /** An object where the defined keys will be set on the `CatalogSubGroup` being updated. */
  catalogSubGroupPatch: CatalogSubGroupPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateCatalogSubGroup` mutation. */
export type UpdateCatalogSubGroupInput = {
  /** An object where the defined keys will be set on the `CatalogSubGroup` being updated. */
  catalogSubGroupPatch: CatalogSubGroupPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `CatalogSubGroup` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `CatalogSubGroup` mutation. */
export type UpdateCatalogSubGroupPayload = {
  __typename?: 'UpdateCatalogSubGroupPayload';
  /** Reads a single `CatalogGroup` that is related to this `CatalogSubGroup`. */
  catalogGroupByCatalogGroupId?: Maybe<CatalogGroup>;
  /** The `CatalogSubGroup` that was updated by this mutation. */
  catalogSubGroup?: Maybe<CatalogSubGroup>;
  /** An edge for our `CatalogSubGroup`. May be used by Relay 1. */
  catalogSubGroupEdge?: Maybe<CatalogSubGroupsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `CatalogSubGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `CatalogSubGroup` mutation. */
export type UpdateCatalogSubGroupPayloadCatalogSubGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogSubGroupsOrderBy>>;
};

/** All input for the `updateChemicalCompoundById` mutation. */
export type UpdateChemicalCompoundByIdInput = {
  /** An object where the defined keys will be set on the `ChemicalCompound` being updated. */
  chemicalCompoundPatch: ChemicalCompoundPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `updateChemicalCompound` mutation. */
export type UpdateChemicalCompoundInput = {
  /** An object where the defined keys will be set on the `ChemicalCompound` being updated. */
  chemicalCompoundPatch: ChemicalCompoundPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ChemicalCompound` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `ChemicalCompound` mutation. */
export type UpdateChemicalCompoundPayload = {
  __typename?: 'UpdateChemicalCompoundPayload';
  /** The `ChemicalCompound` that was updated by this mutation. */
  chemicalCompound?: Maybe<ChemicalCompound>;
  /** An edge for our `ChemicalCompound`. May be used by Relay 1. */
  chemicalCompoundEdge?: Maybe<ChemicalCompoundsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ChemicalCompound`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `ChemicalCompound` mutation. */
export type UpdateChemicalCompoundPayloadChemicalCompoundEdgeArgs = {
  orderBy?: InputMaybe<Array<ChemicalCompoundsOrderBy>>;
};

/** All input for the `updateDetectorAndSensors` mutation. */
export type UpdateDetectorAndSensorsInput = {
  address?: InputMaybe<Scalars['Int']['input']>;
  areaName?: InputMaybe<Scalars['String']['input']>;
  buildingName?: InputMaybe<Scalars['String']['input']>;
  bus?: InputMaybe<Scalars['Int']['input']>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  endUserLocation?: InputMaybe<Scalars['String']['input']>;
  endUserName?: InputMaybe<Scalars['String']['input']>;
  endUserSubLocation?: InputMaybe<Scalars['String']['input']>;
  floorName?: InputMaybe<Scalars['String']['input']>;
  sensors?: InputMaybe<Array<InputMaybe<UpdateDetectorAndSensorsSensorInput>>>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `updateDetectorAndSensors` mutation. */
export type UpdateDetectorAndSensorsPayload = {
  __typename?: 'UpdateDetectorAndSensorsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  detector?: Maybe<Detector>;
  /** An edge for our `Detector`. May be used by Relay 1. */
  detectorEdge?: Maybe<DetectorsEdge>;
  /** Reads a single `DetectorType` that is related to this `Detector`. */
  detectorTypeByDetectorTypeId?: Maybe<DetectorType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Detector`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our `updateDetectorAndSensors` mutation. */
export type UpdateDetectorAndSensorsPayloadDetectorEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorsOrderBy>>;
};

/** An input for mutations affecting `UpdateDetectorAndSensorsSensor` */
export type UpdateDetectorAndSensorsSensorInput = {
  areaName?: InputMaybe<Scalars['String']['input']>;
  buildingName?: InputMaybe<Scalars['String']['input']>;
  endUserLocation?: InputMaybe<Scalars['String']['input']>;
  endUserName?: InputMaybe<Scalars['String']['input']>;
  endUserSubLocation?: InputMaybe<Scalars['String']['input']>;
  engineeringUnits?: InputMaybe<Scalars['String']['input']>;
  filterName?: InputMaybe<Scalars['String']['input']>;
  floorName?: InputMaybe<Scalars['String']['input']>;
  gasName?: InputMaybe<Scalars['String']['input']>;
  highEu?: InputMaybe<Scalars['Float']['input']>;
  lowEu?: InputMaybe<Scalars['Float']['input']>;
  pyrolyserName?: InputMaybe<Scalars['String']['input']>;
  samplePointName?: InputMaybe<Scalars['String']['input']>;
  serialNumber?: InputMaybe<Scalars['String']['input']>;
  simsChannel?: InputMaybe<Scalars['Int']['input']>;
  simsTag?: InputMaybe<Scalars['String']['input']>;
  typeName?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `updateDetectorById` mutation. */
export type UpdateDetectorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Detector` being updated. */
  detectorPatch: DetectorPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateDetectorBySerialNumberAndDetectorTypeId` mutation. */
export type UpdateDetectorBySerialNumberAndDetectorTypeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Detector` being updated. */
  detectorPatch: DetectorPatch;
  detectorTypeId: Scalars['Int']['input'];
  serialNumber: Scalars['String']['input'];
};

/** All input for the `updateDetector` mutation. */
export type UpdateDetectorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Detector` being updated. */
  detectorPatch: DetectorPatch;
  /** The globally unique `ID` which will identify a single `Detector` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `updateDetectorLocationByDetectorId` mutation. */
export type UpdateDetectorLocationByDetectorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DetectorLocation` being updated. */
  detectorLocationPatch: DetectorLocationPatch;
};

/** All input for the `updateDetectorLocationById` mutation. */
export type UpdateDetectorLocationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorLocation` being updated. */
  detectorLocationPatch: DetectorLocationPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateDetectorLocation` mutation. */
export type UpdateDetectorLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorLocation` being updated. */
  detectorLocationPatch: DetectorLocationPatch;
  /** The globally unique `ID` which will identify a single `DetectorLocation` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `DetectorLocation` mutation. */
export type UpdateDetectorLocationPayload = {
  __typename?: 'UpdateDetectorLocationPayload';
  /** Reads a single `Area` that is related to this `DetectorLocation`. */
  areaByAreaId?: Maybe<Area>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorLocation`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorLocation` that was updated by this mutation. */
  detectorLocation?: Maybe<DetectorLocation>;
  /** An edge for our `DetectorLocation`. May be used by Relay 1. */
  detectorLocationEdge?: Maybe<DetectorLocationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `DetectorLocation` mutation. */
export type UpdateDetectorLocationPayloadDetectorLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorLocationsOrderBy>>;
};

/** All input for the `updateDetectorOrderByFactuuropdrachtAndDetectorId` mutation. */
export type UpdateDetectorOrderByFactuuropdrachtAndDetectorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DetectorOrder` being updated. */
  detectorOrderPatch: DetectorOrderPatch;
  factuuropdracht: Scalars['String']['input'];
};

/** All input for the `updateDetectorOrderById` mutation. */
export type UpdateDetectorOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorOrder` being updated. */
  detectorOrderPatch: DetectorOrderPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateDetectorOrder` mutation. */
export type UpdateDetectorOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorOrder` being updated. */
  detectorOrderPatch: DetectorOrderPatch;
  /** The globally unique `ID` which will identify a single `DetectorOrder` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `DetectorOrder` mutation. */
export type UpdateDetectorOrderPayload = {
  __typename?: 'UpdateDetectorOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorOrder`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorOrder` that was updated by this mutation. */
  detectorOrder?: Maybe<DetectorOrder>;
  /** An edge for our `DetectorOrder`. May be used by Relay 1. */
  detectorOrderEdge?: Maybe<DetectorOrdersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorOrder`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `DetectorOrder` mutation. */
export type UpdateDetectorOrderPayloadDetectorOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorOrdersOrderBy>>;
};

/** The output of our update `Detector` mutation. */
export type UpdateDetectorPayload = {
  __typename?: 'UpdateDetectorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Detector` that was updated by this mutation. */
  detector?: Maybe<Detector>;
  /** An edge for our `Detector`. May be used by Relay 1. */
  detectorEdge?: Maybe<DetectorsEdge>;
  /** Reads a single `DetectorType` that is related to this `Detector`. */
  detectorTypeByDetectorTypeId?: Maybe<DetectorType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Detector`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Detector` mutation. */
export type UpdateDetectorPayloadDetectorEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorsOrderBy>>;
};

/** All input for the `updateDetectorSensorByDetectorIdAndDetectorPosition` mutation. */
export type UpdateDetectorSensorByDetectorIdAndDetectorPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  detectorPosition: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DetectorSensor` being updated. */
  detectorSensorPatch: DetectorSensorPatch;
};

/** All input for the `updateDetectorSensorById` mutation. */
export type UpdateDetectorSensorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorSensor` being updated. */
  detectorSensorPatch: DetectorSensorPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateDetectorSensorBySensorId` mutation. */
export type UpdateDetectorSensorBySensorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorSensor` being updated. */
  detectorSensorPatch: DetectorSensorPatch;
  sensorId: Scalars['Int']['input'];
};

/** All input for the `updateDetectorSensor` mutation. */
export type UpdateDetectorSensorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorSensor` being updated. */
  detectorSensorPatch: DetectorSensorPatch;
  /** The globally unique `ID` which will identify a single `DetectorSensor` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `updateDetectorSensorLocationByDetectorSensorId` mutation. */
export type UpdateDetectorSensorLocationByDetectorSensorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorSensorId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DetectorSensorLocation` being updated. */
  detectorSensorLocationPatch: DetectorSensorLocationPatch;
};

/** All input for the `updateDetectorSensorLocationById` mutation. */
export type UpdateDetectorSensorLocationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorSensorLocation` being updated. */
  detectorSensorLocationPatch: DetectorSensorLocationPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateDetectorSensorLocationByLicenseIdAndSimsChannel` mutation. */
export type UpdateDetectorSensorLocationByLicenseIdAndSimsChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorSensorLocation` being updated. */
  detectorSensorLocationPatch: DetectorSensorLocationPatch;
  licenseId: Scalars['Int']['input'];
  simsChannel: Scalars['Int']['input'];
};

/** All input for the `updateDetectorSensorLocation` mutation. */
export type UpdateDetectorSensorLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorSensorLocation` being updated. */
  detectorSensorLocationPatch: DetectorSensorLocationPatch;
  /** The globally unique `ID` which will identify a single `DetectorSensorLocation` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `DetectorSensorLocation` mutation. */
export type UpdateDetectorSensorLocationPayload = {
  __typename?: 'UpdateDetectorSensorLocationPayload';
  /** Reads a single `Application` that is related to this `DetectorSensorLocation`. */
  applicationByApplicationId?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DetectorLocation` that is related to this `DetectorSensorLocation`. */
  detectorLocationByDetectorLocationId?: Maybe<DetectorLocation>;
  /** Reads a single `DetectorSensor` that is related to this `DetectorSensorLocation`. */
  detectorSensorByDetectorSensorId?: Maybe<DetectorSensor>;
  /** The `DetectorSensorLocation` that was updated by this mutation. */
  detectorSensorLocation?: Maybe<DetectorSensorLocation>;
  /** An edge for our `DetectorSensorLocation`. May be used by Relay 1. */
  detectorSensorLocationEdge?: Maybe<DetectorSensorLocationsEdge>;
  /** Reads a single `License` that is related to this `DetectorSensorLocation`. */
  licenseByLicenseId?: Maybe<License>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SamplePoint` that is related to this `DetectorSensorLocation`. */
  samplePointBySamplePointId?: Maybe<SamplePoint>;
  /** Reads a single `User` that is related to this `DetectorSensorLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `DetectorSensorLocation` mutation. */
export type UpdateDetectorSensorLocationPayloadDetectorSensorLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};

/** The output of our update `DetectorSensor` mutation. */
export type UpdateDetectorSensorPayload = {
  __typename?: 'UpdateDetectorSensorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorSensor`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** The `DetectorSensor` that was updated by this mutation. */
  detectorSensor?: Maybe<DetectorSensor>;
  /** An edge for our `DetectorSensor`. May be used by Relay 1. */
  detectorSensorEdge?: Maybe<DetectorSensorsEdge>;
  /** Reads a single `Filter` that is related to this `DetectorSensor`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `Pyrolyser` that is related to this `DetectorSensor`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `DetectorSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `User` that is related to this `DetectorSensor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `DetectorSensor` mutation. */
export type UpdateDetectorSensorPayloadDetectorSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};

/** All input for the `updateDetectorSensorTypeByDetectorIdAndDetectorPosition` mutation. */
export type UpdateDetectorSensorTypeByDetectorIdAndDetectorPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  detectorPosition: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DetectorSensorType` being updated. */
  detectorSensorTypePatch: DetectorSensorTypePatch;
};

/** All input for the `updateDetectorSensorTypeById` mutation. */
export type UpdateDetectorSensorTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorSensorType` being updated. */
  detectorSensorTypePatch: DetectorSensorTypePatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateDetectorSensorType` mutation. */
export type UpdateDetectorSensorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorSensorType` being updated. */
  detectorSensorTypePatch: DetectorSensorTypePatch;
  /** The globally unique `ID` which will identify a single `DetectorSensorType` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `DetectorSensorType` mutation. */
export type UpdateDetectorSensorTypePayload = {
  __typename?: 'UpdateDetectorSensorTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DetectorSensorType` that was updated by this mutation. */
  detectorSensorType?: Maybe<DetectorSensorType>;
  /** An edge for our `DetectorSensorType`. May be used by Relay 1. */
  detectorSensorTypeEdge?: Maybe<DetectorSensorTypesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SensorType` that is related to this `DetectorSensorType`. */
  sensorTypeBySensorTypeId?: Maybe<SensorType>;
  /** Reads a single `User` that is related to this `DetectorSensorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `DetectorSensorType` mutation. */
export type UpdateDetectorSensorTypePayloadDetectorSensorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorTypesOrderBy>>;
};

/** All input for the `updateDetectorTypeById` mutation. */
export type UpdateDetectorTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorType` being updated. */
  detectorTypePatch: DetectorTypePatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateDetectorTypeByPrefixAndCodeAndSuffix` mutation. */
export type UpdateDetectorTypeByPrefixAndCodeAndSuffixInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `DetectorType` being updated. */
  detectorTypePatch: DetectorTypePatch;
  prefix: Scalars['String']['input'];
  suffix: Scalars['String']['input'];
};

/** All input for the `updateDetectorType` mutation. */
export type UpdateDetectorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DetectorType` being updated. */
  detectorTypePatch: DetectorTypePatch;
  /** The globally unique `ID` which will identify a single `DetectorType` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `DetectorType` mutation. */
export type UpdateDetectorTypePayload = {
  __typename?: 'UpdateDetectorTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DetectorType` that was updated by this mutation. */
  detectorType?: Maybe<DetectorType>;
  /** An edge for our `DetectorType`. May be used by Relay 1. */
  detectorTypeEdge?: Maybe<DetectorTypesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DetectorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `DetectorType` mutation. */
export type UpdateDetectorTypePayloadDetectorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorTypesOrderBy>>;
};

/** All input for the `updateDpCardById` mutation. */
export type UpdateDpCardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DpCard` being updated. */
  dpCardPatch: DpCardPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateDpCard` mutation. */
export type UpdateDpCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DpCard` being updated. */
  dpCardPatch: DpCardPatch;
  /** The globally unique `ID` which will identify a single `DpCard` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `DpCard` mutation. */
export type UpdateDpCardPayload = {
  __typename?: 'UpdateDpCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DpCard` that was updated by this mutation. */
  dpCard?: Maybe<DpCard>;
  /** An edge for our `DpCard`. May be used by Relay 1. */
  dpCardEdge?: Maybe<DpCardsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `DpCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `DpCard` mutation. */
export type UpdateDpCardPayloadDpCardEdgeArgs = {
  orderBy?: InputMaybe<Array<DpCardsOrderBy>>;
};

/** All input for the `updateElectrolyteById` mutation. */
export type UpdateElectrolyteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Electrolyte` being updated. */
  electrolytePatch: ElectrolytePatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateElectrolyteByName` mutation. */
export type UpdateElectrolyteByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Electrolyte` being updated. */
  electrolytePatch: ElectrolytePatch;
  name: Scalars['String']['input'];
};

/** All input for the `updateElectrolyte` mutation. */
export type UpdateElectrolyteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Electrolyte` being updated. */
  electrolytePatch: ElectrolytePatch;
  /** The globally unique `ID` which will identify a single `Electrolyte` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Electrolyte` mutation. */
export type UpdateElectrolytePayload = {
  __typename?: 'UpdateElectrolytePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Electrolyte` that was updated by this mutation. */
  electrolyte?: Maybe<Electrolyte>;
  /** An edge for our `Electrolyte`. May be used by Relay 1. */
  electrolyteEdge?: Maybe<ElectrolytesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Electrolyte`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Electrolyte` mutation. */
export type UpdateElectrolytePayloadElectrolyteEdgeArgs = {
  orderBy?: InputMaybe<Array<ElectrolytesOrderBy>>;
};

/** All input for the `updateEndUserById` mutation. */
export type UpdateEndUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `EndUser` being updated. */
  endUserPatch: EndUserPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateEndUserByNameAndLocationAndSubLocation` mutation. */
export type UpdateEndUserByNameAndLocationAndSubLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `EndUser` being updated. */
  endUserPatch: EndUserPatch;
  location: Scalars['String']['input'];
  name: Scalars['String']['input'];
  subLocation: Scalars['String']['input'];
};

/** All input for the `updateEndUser` mutation. */
export type UpdateEndUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `EndUser` being updated. */
  endUserPatch: EndUserPatch;
  /** The globally unique `ID` which will identify a single `EndUser` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `EndUser` mutation. */
export type UpdateEndUserPayload = {
  __typename?: 'UpdateEndUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `EndUser` that was updated by this mutation. */
  endUser?: Maybe<EndUser>;
  /** An edge for our `EndUser`. May be used by Relay 1. */
  endUserEdge?: Maybe<EndUsersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `EndUser`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `EndUser` mutation. */
export type UpdateEndUserPayloadEndUserEdgeArgs = {
  orderBy?: InputMaybe<Array<EndUsersOrderBy>>;
};

/** All input for the `updateFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikel` mutation. */
export type UpdateFactopdrachtArtikelExclusionByFactuuropdrachtAndCdartikelInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtArtikelExclusion` being updated. */
  factopdrachtArtikelExclusionPatch: FactopdrachtArtikelExclusionPatch;
  factuuropdracht: Scalars['String']['input'];
};

/** All input for the `updateFactopdrachtArtikelExclusionById` mutation. */
export type UpdateFactopdrachtArtikelExclusionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtArtikelExclusion` being updated. */
  factopdrachtArtikelExclusionPatch: FactopdrachtArtikelExclusionPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateFactopdrachtArtikelExclusion` mutation. */
export type UpdateFactopdrachtArtikelExclusionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtArtikelExclusion` being updated. */
  factopdrachtArtikelExclusionPatch: FactopdrachtArtikelExclusionPatch;
  /** The globally unique `ID` which will identify a single `FactopdrachtArtikelExclusion` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `FactopdrachtArtikelExclusion` mutation. */
export type UpdateFactopdrachtArtikelExclusionPayload = {
  __typename?: 'UpdateFactopdrachtArtikelExclusionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtArtikelExclusion` that was updated by this mutation. */
  factopdrachtArtikelExclusion?: Maybe<FactopdrachtArtikelExclusion>;
  /** An edge for our `FactopdrachtArtikelExclusion`. May be used by Relay 1. */
  factopdrachtArtikelExclusionEdge?: Maybe<FactopdrachtArtikelExclusionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FactopdrachtArtikelExclusion` mutation. */
export type UpdateFactopdrachtArtikelExclusionPayloadFactopdrachtArtikelExclusionEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtArtikelExclusionsOrderBy>>;
};

/** All input for the `updateFactopdrachtregelLineByFactopdrRglGuid` mutation. */
export type UpdateFactopdrachtregelLineByFactopdrRglGuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factopdrRglGuid: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `FactopdrachtregelLine` being updated. */
  factopdrachtregelLinePatch: FactopdrachtregelLinePatch;
};

/** All input for the `updateFactopdrachtregelLineById` mutation. */
export type UpdateFactopdrachtregelLineByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtregelLine` being updated. */
  factopdrachtregelLinePatch: FactopdrachtregelLinePatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateFactopdrachtregelLineDateById` mutation. */
export type UpdateFactopdrachtregelLineDateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtregelLineDate` being updated. */
  factopdrachtregelLineDatePatch: FactopdrachtregelLineDatePatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateFactopdrachtregelLineDate` mutation. */
export type UpdateFactopdrachtregelLineDateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtregelLineDate` being updated. */
  factopdrachtregelLineDatePatch: FactopdrachtregelLineDatePatch;
  /** The globally unique `ID` which will identify a single `FactopdrachtregelLineDate` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `FactopdrachtregelLineDate` mutation. */
export type UpdateFactopdrachtregelLineDatePayload = {
  __typename?: 'UpdateFactopdrachtregelLineDatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtregelLineDate` that was updated by this mutation. */
  factopdrachtregelLineDate?: Maybe<FactopdrachtregelLineDate>;
  /** An edge for our `FactopdrachtregelLineDate`. May be used by Relay 1. */
  factopdrachtregelLineDateEdge?: Maybe<FactopdrachtregelLineDatesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FactopdrachtregelLineDate` mutation. */
export type UpdateFactopdrachtregelLineDatePayloadFactopdrachtregelLineDateEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLineDatesOrderBy>>;
};

/** All input for the `updateFactopdrachtregelLine` mutation. */
export type UpdateFactopdrachtregelLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtregelLine` being updated. */
  factopdrachtregelLinePatch: FactopdrachtregelLinePatch;
  /** The globally unique `ID` which will identify a single `FactopdrachtregelLine` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `FactopdrachtregelLine` mutation. */
export type UpdateFactopdrachtregelLinePayload = {
  __typename?: 'UpdateFactopdrachtregelLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtregelLine` that was updated by this mutation. */
  factopdrachtregelLine?: Maybe<FactopdrachtregelLine>;
  /** An edge for our `FactopdrachtregelLine`. May be used by Relay 1. */
  factopdrachtregelLineEdge?: Maybe<FactopdrachtregelLinesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FactopdrachtregelLine` mutation. */
export type UpdateFactopdrachtregelLinePayloadFactopdrachtregelLineEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLinesOrderBy>>;
};

/** All input for the `updateFactopdrachtregelLineRemarkById` mutation. */
export type UpdateFactopdrachtregelLineRemarkByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtregelLineRemark` being updated. */
  factopdrachtregelLineRemarkPatch: FactopdrachtregelLineRemarkPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateFactopdrachtregelLineRemark` mutation. */
export type UpdateFactopdrachtregelLineRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `FactopdrachtregelLineRemark` being updated. */
  factopdrachtregelLineRemarkPatch: FactopdrachtregelLineRemarkPatch;
  /** The globally unique `ID` which will identify a single `FactopdrachtregelLineRemark` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `FactopdrachtregelLineRemark` mutation. */
export type UpdateFactopdrachtregelLineRemarkPayload = {
  __typename?: 'UpdateFactopdrachtregelLineRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FactopdrachtregelLineRemark` that was updated by this mutation. */
  factopdrachtregelLineRemark?: Maybe<FactopdrachtregelLineRemark>;
  /** An edge for our `FactopdrachtregelLineRemark`. May be used by Relay 1. */
  factopdrachtregelLineRemarkEdge?: Maybe<FactopdrachtregelLineRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `FactopdrachtregelLineRemark`. */
  userByUserId?: Maybe<User>;
};


/** The output of our update `FactopdrachtregelLineRemark` mutation. */
export type UpdateFactopdrachtregelLineRemarkPayloadFactopdrachtregelLineRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<FactopdrachtregelLineRemarksOrderBy>>;
};

/** All input for the `updateFactuurByFactuuropdracht` mutation. */
export type UpdateFactuurByFactuuropdrachtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Factuur` being updated. */
  factuurPatch: FactuurPatch;
  factuuropdracht: Scalars['String']['input'];
};

/** All input for the `updateFactuurById` mutation. */
export type UpdateFactuurByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Factuur` being updated. */
  factuurPatch: FactuurPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateFactuur` mutation. */
export type UpdateFactuurInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Factuur` being updated. */
  factuurPatch: FactuurPatch;
  /** The globally unique `ID` which will identify a single `Factuur` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Factuur` mutation. */
export type UpdateFactuurPayload = {
  __typename?: 'UpdateFactuurPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Factuur` that was updated by this mutation. */
  factuur?: Maybe<Factuur>;
  /** An edge for our `Factuur`. May be used by Relay 1. */
  factuurEdge?: Maybe<FactuursEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userByCheckedId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Factuur`. */
  userBySentId?: Maybe<User>;
};


/** The output of our update `Factuur` mutation. */
export type UpdateFactuurPayloadFactuurEdgeArgs = {
  orderBy?: InputMaybe<Array<FactuursOrderBy>>;
};

/** All input for the `updateFilterById` mutation. */
export type UpdateFilterByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Filter` being updated. */
  filterPatch: FilterPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateFilterByName` mutation. */
export type UpdateFilterByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Filter` being updated. */
  filterPatch: FilterPatch;
  name: Scalars['String']['input'];
};

/** All input for the `updateFilter` mutation. */
export type UpdateFilterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Filter` being updated. */
  filterPatch: FilterPatch;
  /** The globally unique `ID` which will identify a single `Filter` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Filter` mutation. */
export type UpdateFilterPayload = {
  __typename?: 'UpdateFilterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Filter` that was updated by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Filter`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Filter` mutation. */
export type UpdateFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the `updateFloorByBuildingIdAndName` mutation. */
export type UpdateFloorByBuildingIdAndNameInput = {
  buildingId: Scalars['Int']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Floor` being updated. */
  floorPatch: FloorPatch;
  name: Scalars['String']['input'];
};

/** All input for the `updateFloorById` mutation. */
export type UpdateFloorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Floor` being updated. */
  floorPatch: FloorPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateFloor` mutation. */
export type UpdateFloorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Floor` being updated. */
  floorPatch: FloorPatch;
  /** The globally unique `ID` which will identify a single `Floor` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Floor` mutation. */
export type UpdateFloorPayload = {
  __typename?: 'UpdateFloorPayload';
  /** Reads a single `Building` that is related to this `Floor`. */
  buildingByBuildingId?: Maybe<Building>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Floor` that was updated by this mutation. */
  floor?: Maybe<Floor>;
  /** An edge for our `Floor`. May be used by Relay 1. */
  floorEdge?: Maybe<FloorsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Floor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Floor` mutation. */
export type UpdateFloorPayloadFloorEdgeArgs = {
  orderBy?: InputMaybe<Array<FloorsOrderBy>>;
};

/** All input for the `updateGasById` mutation. */
export type UpdateGasByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Gas` being updated. */
  gasPatch: GasPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateGasByName` mutation. */
export type UpdateGasByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Gas` being updated. */
  gasPatch: GasPatch;
  name: Scalars['String']['input'];
};

/** All input for the `updateGas` mutation. */
export type UpdateGasInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Gas` being updated. */
  gasPatch: GasPatch;
  /** The globally unique `ID` which will identify a single `Gas` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Gas` mutation. */
export type UpdateGasPayload = {
  __typename?: 'UpdateGasPayload';
  /** Reads a single `ChemicalCompound` that is related to this `Gas`. */
  chemicalCompoundByChemicalCompoundId?: Maybe<ChemicalCompound>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Gas` that was updated by this mutation. */
  gas?: Maybe<Gas>;
  /** An edge for our `Gas`. May be used by Relay 1. */
  gasEdge?: Maybe<GasesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Gas`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Gas` mutation. */
export type UpdateGasPayloadGasEdgeArgs = {
  orderBy?: InputMaybe<Array<GasesOrderBy>>;
};

/** All input for the `updateGroupById` mutation. */
export type UpdateGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  groupPatch: GroupPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  groupPatch: GroupPatch;
  /** The globally unique `ID` which will identify a single `Group` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Group` that was updated by this mutation. */
  group?: Maybe<Group>;
  /** An edge for our `Group`. May be used by Relay 1. */
  groupEdge?: Maybe<GroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Group`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Group` mutation. */
export type UpdateGroupPayloadGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};

/** All input for the `updateGroupPermissionByGroupId` mutation. */
export type UpdateGroupPermissionByGroupIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `GroupPermission` being updated. */
  groupPermissionPatch: GroupPermissionPatch;
};

/** All input for the `updateGroupPermissionById` mutation. */
export type UpdateGroupPermissionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `GroupPermission` being updated. */
  groupPermissionPatch: GroupPermissionPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateGroupPermission` mutation. */
export type UpdateGroupPermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `GroupPermission` being updated. */
  groupPermissionPatch: GroupPermissionPatch;
  /** The globally unique `ID` which will identify a single `GroupPermission` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `GroupPermission` mutation. */
export type UpdateGroupPermissionPayload = {
  __typename?: 'UpdateGroupPermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `GroupPermission`. */
  groupByGroupId?: Maybe<Group>;
  /** The `GroupPermission` that was updated by this mutation. */
  groupPermission?: Maybe<GroupPermission>;
  /** An edge for our `GroupPermission`. May be used by Relay 1. */
  groupPermissionEdge?: Maybe<GroupPermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `GroupPermission` mutation. */
export type UpdateGroupPermissionPayloadGroupPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupPermissionsOrderBy>>;
};

/** All input for the `updateGroupRightByGroupIdAndPath` mutation. */
export type UpdateGroupRightByGroupIdAndPathInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `GroupRight` being updated. */
  groupRightPatch: GroupRightPatch;
  path: Scalars['String']['input'];
};

/** All input for the `updateGroupRightById` mutation. */
export type UpdateGroupRightByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `GroupRight` being updated. */
  groupRightPatch: GroupRightPatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateGroupRight` mutation. */
export type UpdateGroupRightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `GroupRight` being updated. */
  groupRightPatch: GroupRightPatch;
  /** The globally unique `ID` which will identify a single `GroupRight` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `GroupRight` mutation. */
export type UpdateGroupRightPayload = {
  __typename?: 'UpdateGroupRightPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `GroupRight`. */
  groupByGroupId?: Maybe<Group>;
  /** The `GroupRight` that was updated by this mutation. */
  groupRight?: Maybe<GroupRight>;
  /** An edge for our `GroupRight`. May be used by Relay 1. */
  groupRightEdge?: Maybe<GroupRightsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `GroupRight` mutation. */
export type UpdateGroupRightPayloadGroupRightEdgeArgs = {
  orderBy?: InputMaybe<Array<GroupRightsOrderBy>>;
};

/** All input for the `updateHardwareById` mutation. */
export type UpdateHardwareByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Hardware` being updated. */
  hardwarePatch: HardwarePatch;
  id: Scalars['Int']['input'];
};

/** All input for the `updateHardware` mutation. */
export type UpdateHardwareInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Hardware` being updated. */
  hardwarePatch: HardwarePatch;
  /** The globally unique `ID` which will identify a single `Hardware` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Hardware` mutation. */
export type UpdateHardwarePayload = {
  __typename?: 'UpdateHardwarePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Hardware` that was updated by this mutation. */
  hardware?: Maybe<Hardware>;
  /** An edge for our `Hardware`. May be used by Relay 1. */
  hardwareEdge?: Maybe<HardwaresEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Hardware`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Hardware`. */
  userByUserId?: Maybe<User>;
};


/** The output of our update `Hardware` mutation. */
export type UpdateHardwarePayloadHardwareEdgeArgs = {
  orderBy?: InputMaybe<Array<HardwaresOrderBy>>;
};

/** All input for the `updateIncomingDocumentById` mutation. */
export type UpdateIncomingDocumentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `IncomingDocument` being updated. */
  incomingDocumentPatch: IncomingDocumentPatch;
};

/** All input for the `updateIncomingDocument` mutation. */
export type UpdateIncomingDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `IncomingDocument` being updated. */
  incomingDocumentPatch: IncomingDocumentPatch;
  /** The globally unique `ID` which will identify a single `IncomingDocument` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `IncomingDocument` mutation. */
export type UpdateIncomingDocumentPayload = {
  __typename?: 'UpdateIncomingDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `IncomingDocument` that was updated by this mutation. */
  incomingDocument?: Maybe<IncomingDocument>;
  /** An edge for our `IncomingDocument`. May be used by Relay 1. */
  incomingDocumentEdge?: Maybe<IncomingDocumentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `IncomingDocument`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `IncomingDocument`. */
  userByUserId?: Maybe<User>;
};


/** The output of our update `IncomingDocument` mutation. */
export type UpdateIncomingDocumentPayloadIncomingDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<IncomingDocumentsOrderBy>>;
};

/** All input for the `updateInkoopgegevenByCdartikelAndInkvolgnr` mutation. */
export type UpdateInkoopgegevenByCdartikelAndInkvolgnrInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Inkoopgegeven` being updated. */
  inkoopgegevenPatch: InkoopgegevenPatch;
  inkvolgnr: Scalars['Int']['input'];
};

/** All input for the `updateInkoopgegeven` mutation. */
export type UpdateInkoopgegevenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Inkoopgegeven` being updated. */
  inkoopgegevenPatch: InkoopgegevenPatch;
  /** The globally unique `ID` which will identify a single `Inkoopgegeven` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Inkoopgegeven` mutation. */
export type UpdateInkoopgegevenPayload = {
  __typename?: 'UpdateInkoopgegevenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Inkoopgegeven` that was updated by this mutation. */
  inkoopgegeven?: Maybe<Inkoopgegeven>;
  /** An edge for our `Inkoopgegeven`. May be used by Relay 1. */
  inkoopgegevenEdge?: Maybe<InkoopgegevensEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Inkoopgegeven` mutation. */
export type UpdateInkoopgegevenPayloadInkoopgegevenEdgeArgs = {
  orderBy?: InputMaybe<Array<InkoopgegevensOrderBy>>;
};

/** All input for the `updateInkoopgegevensLogById` mutation. */
export type UpdateInkoopgegevensLogByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `InkoopgegevensLog` being updated. */
  inkoopgegevensLogPatch: InkoopgegevensLogPatch;
};

/** All input for the `updateInkoopgegevensLog` mutation. */
export type UpdateInkoopgegevensLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `InkoopgegevensLog` being updated. */
  inkoopgegevensLogPatch: InkoopgegevensLogPatch;
  /** The globally unique `ID` which will identify a single `InkoopgegevensLog` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `InkoopgegevensLog` mutation. */
export type UpdateInkoopgegevensLogPayload = {
  __typename?: 'UpdateInkoopgegevensLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `InkoopgegevensLog` that was updated by this mutation. */
  inkoopgegevensLog?: Maybe<InkoopgegevensLog>;
  /** An edge for our `InkoopgegevensLog`. May be used by Relay 1. */
  inkoopgegevensLogEdge?: Maybe<InkoopgegevensLogsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `InkoopgegevensLog` mutation. */
export type UpdateInkoopgegevensLogPayloadInkoopgegevensLogEdgeArgs = {
  orderBy?: InputMaybe<Array<InkoopgegevensLogsOrderBy>>;
};

/** All input for the `updateInkooporderregelLineById` mutation. */
export type UpdateInkooporderregelLineByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `InkooporderregelLine` being updated. */
  inkooporderregelLinePatch: InkooporderregelLinePatch;
};

/** All input for the `updateInkooporderregelLineByInkopdrRglGuid` mutation. */
export type UpdateInkooporderregelLineByInkopdrRglGuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `InkooporderregelLine` being updated. */
  inkooporderregelLinePatch: InkooporderregelLinePatch;
  inkopdrRglGuid: Scalars['String']['input'];
};

/** All input for the `updateInkooporderregelLine` mutation. */
export type UpdateInkooporderregelLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `InkooporderregelLine` being updated. */
  inkooporderregelLinePatch: InkooporderregelLinePatch;
  /** The globally unique `ID` which will identify a single `InkooporderregelLine` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `InkooporderregelLine` mutation. */
export type UpdateInkooporderregelLinePayload = {
  __typename?: 'UpdateInkooporderregelLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `InkooporderregelLine` that was updated by this mutation. */
  inkooporderregelLine?: Maybe<InkooporderregelLine>;
  /** An edge for our `InkooporderregelLine`. May be used by Relay 1. */
  inkooporderregelLineEdge?: Maybe<InkooporderregelLinesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `InkooporderregelLine` mutation. */
export type UpdateInkooporderregelLinePayloadInkooporderregelLineEdgeArgs = {
  orderBy?: InputMaybe<Array<InkooporderregelLinesOrderBy>>;
};

/** All input for the `updateItemByCdartikelAndSerialNumber` mutation. */
export type UpdateItemByCdartikelAndSerialNumberInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Item` being updated. */
  itemPatch: ItemPatch;
  serialNumber: Scalars['String']['input'];
};

/** All input for the `updateItemById` mutation. */
export type UpdateItemByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Item` being updated. */
  itemPatch: ItemPatch;
};

/** All input for the `updateItem` mutation. */
export type UpdateItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Item` being updated. */
  itemPatch: ItemPatch;
  /** The globally unique `ID` which will identify a single `Item` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Item` mutation. */
export type UpdateItemPayload = {
  __typename?: 'UpdateItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `Item`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `Item` that was updated by this mutation. */
  item?: Maybe<Item>;
  /** An edge for our `Item`. May be used by Relay 1. */
  itemEdge?: Maybe<ItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Item`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Item` mutation. */
export type UpdateItemPayloadItemEdgeArgs = {
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
};

/** All input for the `updateJobById` mutation. */
export type UpdateJobByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Job` being updated. */
  jobPatch: JobPatch;
};

/** All input for the `updateJob` mutation. */
export type UpdateJobInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Job` being updated. */
  jobPatch: JobPatch;
  /** The globally unique `ID` which will identify a single `Job` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Job` mutation. */
export type UpdateJobPayload = {
  __typename?: 'UpdateJobPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `Job`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `Job` that was updated by this mutation. */
  job?: Maybe<Job>;
  /** An edge for our `Job`. May be used by Relay 1. */
  jobEdge?: Maybe<JobsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Job`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Job` mutation. */
export type UpdateJobPayloadJobEdgeArgs = {
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};

/** All input for the `updateJunctionBoxById` mutation. */
export type UpdateJunctionBoxByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `JunctionBox` being updated. */
  junctionBoxPatch: JunctionBoxPatch;
};

/** All input for the `updateJunctionBox` mutation. */
export type UpdateJunctionBoxInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `JunctionBox` being updated. */
  junctionBoxPatch: JunctionBoxPatch;
  /** The globally unique `ID` which will identify a single `JunctionBox` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `JunctionBox` mutation. */
export type UpdateJunctionBoxPayload = {
  __typename?: 'UpdateJunctionBoxPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `JunctionBox` that was updated by this mutation. */
  junctionBox?: Maybe<JunctionBox>;
  /** An edge for our `JunctionBox`. May be used by Relay 1. */
  junctionBoxEdge?: Maybe<JunctionBoxesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `JunctionBox`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `JunctionBox` mutation. */
export type UpdateJunctionBoxPayloadJunctionBoxEdgeArgs = {
  orderBy?: InputMaybe<Array<JunctionBoxesOrderBy>>;
};

/** All input for the `updateLandByCdland` mutation. */
export type UpdateLandByCdlandInput = {
  /** An object where the defined keys will be set on the `_Land` being updated. */
  _landPatch: _LandPatch;
  cdland: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `updateLand` mutation. */
export type UpdateLandInput = {
  /** An object where the defined keys will be set on the `_Land` being updated. */
  _landPatch: _LandPatch;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `_Land` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `_Land` mutation. */
export type UpdateLandPayload = {
  __typename?: 'UpdateLandPayload';
  /** The `_Land` that was updated by this mutation. */
  _land?: Maybe<_Land>;
  /** An edge for our `_Land`. May be used by Relay 1. */
  _landEdge?: Maybe<_LandsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `_Land` mutation. */
export type UpdateLandPayload_LandEdgeArgs = {
  orderBy?: InputMaybe<Array<_LandsOrderBy>>;
};

/** All input for the `updateLeadById` mutation. */
export type UpdateLeadByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Lead` being updated. */
  leadPatch: LeadPatch;
};

/** All input for the `updateLead` mutation. */
export type UpdateLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Lead` being updated. */
  leadPatch: LeadPatch;
  /** The globally unique `ID` which will identify a single `Lead` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Lead` mutation. */
export type UpdateLeadPayload = {
  __typename?: 'UpdateLeadPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Lead` that was updated by this mutation. */
  lead?: Maybe<Lead>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Lead`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Lead` mutation. */
export type UpdateLeadPayloadLeadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the `updateLicenseById` mutation. */
export type UpdateLicenseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `License` being updated. */
  licensePatch: LicensePatch;
};

/** All input for the `updateLicenseCustomerById` mutation. */
export type UpdateLicenseCustomerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `LicenseCustomer` being updated. */
  licenseCustomerPatch: LicenseCustomerPatch;
};

/** All input for the `updateLicenseCustomer` mutation. */
export type UpdateLicenseCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `LicenseCustomer` being updated. */
  licenseCustomerPatch: LicenseCustomerPatch;
  /** The globally unique `ID` which will identify a single `LicenseCustomer` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `LicenseCustomer` mutation. */
export type UpdateLicenseCustomerPayload = {
  __typename?: 'UpdateLicenseCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `LicenseCustomer` that was updated by this mutation. */
  licenseCustomer?: Maybe<LicenseCustomer>;
  /** An edge for our `LicenseCustomer`. May be used by Relay 1. */
  licenseCustomerEdge?: Maybe<LicenseCustomersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseCustomer`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `LicenseCustomer` mutation. */
export type UpdateLicenseCustomerPayloadLicenseCustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseCustomersOrderBy>>;
};

/** All input for the `updateLicense` mutation. */
export type UpdateLicenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `License` being updated. */
  licensePatch: LicensePatch;
  /** The globally unique `ID` which will identify a single `License` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `updateLicenseModuleById` mutation. */
export type UpdateLicenseModuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `LicenseModule` being updated. */
  licenseModulePatch: LicenseModulePatch;
};

/** All input for the `updateLicenseModule` mutation. */
export type UpdateLicenseModuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `LicenseModule` being updated. */
  licenseModulePatch: LicenseModulePatch;
  /** The globally unique `ID` which will identify a single `LicenseModule` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `LicenseModule` mutation. */
export type UpdateLicenseModulePayload = {
  __typename?: 'UpdateLicenseModulePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `LicenseModule` that was updated by this mutation. */
  licenseModule?: Maybe<LicenseModule>;
  /** An edge for our `LicenseModule`. May be used by Relay 1. */
  licenseModuleEdge?: Maybe<LicenseModulesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseModule`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `LicenseModule` mutation. */
export type UpdateLicenseModulePayloadLicenseModuleEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseModulesOrderBy>>;
};

/** All input for the `updateLicenseOrderById` mutation. */
export type UpdateLicenseOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `LicenseOrder` being updated. */
  licenseOrderPatch: LicenseOrderPatch;
};

/** All input for the `updateLicenseOrderByLicenseIdAndFactuuropdracht` mutation. */
export type UpdateLicenseOrderByLicenseIdAndFactuuropdrachtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  licenseId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `LicenseOrder` being updated. */
  licenseOrderPatch: LicenseOrderPatch;
};

/** All input for the `updateLicenseOrderByLicenseRegistrationIdAndFactuuropdracht` mutation. */
export type UpdateLicenseOrderByLicenseRegistrationIdAndFactuuropdrachtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `LicenseOrder` being updated. */
  licenseOrderPatch: LicenseOrderPatch;
  licenseRegistrationId: Scalars['Int']['input'];
};

/** All input for the `updateLicenseOrder` mutation. */
export type UpdateLicenseOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `LicenseOrder` being updated. */
  licenseOrderPatch: LicenseOrderPatch;
  /** The globally unique `ID` which will identify a single `LicenseOrder` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `LicenseOrder` mutation. */
export type UpdateLicenseOrderPayload = {
  __typename?: 'UpdateLicenseOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `License` that is related to this `LicenseOrder`. */
  licenseByLicenseId?: Maybe<License>;
  /** The `LicenseOrder` that was updated by this mutation. */
  licenseOrder?: Maybe<LicenseOrder>;
  /** An edge for our `LicenseOrder`. May be used by Relay 1. */
  licenseOrderEdge?: Maybe<LicenseOrdersEdge>;
  /** Reads a single `LicenseRegistration` that is related to this `LicenseOrder`. */
  licenseRegistrationByLicenseRegistrationId?: Maybe<LicenseRegistration>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseOrder`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `LicenseOrder` mutation. */
export type UpdateLicenseOrderPayloadLicenseOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseOrdersOrderBy>>;
};

/** The output of our update `License` mutation. */
export type UpdateLicensePayload = {
  __typename?: 'UpdateLicensePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `License`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `License` that was updated by this mutation. */
  license?: Maybe<License>;
  /** Reads a single `LicenseCustomer` that is related to this `License`. */
  licenseCustomerByLicenseCustomerId?: Maybe<LicenseCustomer>;
  /** An edge for our `License`. May be used by Relay 1. */
  licenseEdge?: Maybe<LicensesEdge>;
  /** Reads a single `LicenseModule` that is related to this `License`. */
  licenseModuleByLicenseModuleId?: Maybe<LicenseModule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `License`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `License` mutation. */
export type UpdateLicensePayloadLicenseEdgeArgs = {
  orderBy?: InputMaybe<Array<LicensesOrderBy>>;
};

/** All input for the `updateLicenseRegistrationById` mutation. */
export type UpdateLicenseRegistrationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `LicenseRegistration` being updated. */
  licenseRegistrationPatch: LicenseRegistrationPatch;
};

/** All input for the `updateLicenseRegistration` mutation. */
export type UpdateLicenseRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `LicenseRegistration` being updated. */
  licenseRegistrationPatch: LicenseRegistrationPatch;
  /** The globally unique `ID` which will identify a single `LicenseRegistration` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `LicenseRegistration` mutation. */
export type UpdateLicenseRegistrationPayload = {
  __typename?: 'UpdateLicenseRegistrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `License` that is related to this `LicenseRegistration`. */
  licenseByLicenseId?: Maybe<License>;
  /** The `LicenseRegistration` that was updated by this mutation. */
  licenseRegistration?: Maybe<LicenseRegistration>;
  /** An edge for our `LicenseRegistration`. May be used by Relay 1. */
  licenseRegistrationEdge?: Maybe<LicenseRegistrationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `LicenseRegistration`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `LicenseRegistration` mutation. */
export type UpdateLicenseRegistrationPayloadLicenseRegistrationEdgeArgs = {
  orderBy?: InputMaybe<Array<LicenseRegistrationsOrderBy>>;
};

/** All input for the `updateMaintenanceVisitById` mutation. */
export type UpdateMaintenanceVisitByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `MaintenanceVisit` being updated. */
  maintenanceVisitPatch: MaintenanceVisitPatch;
};

/** All input for the `updateMaintenanceVisit` mutation. */
export type UpdateMaintenanceVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `MaintenanceVisit` being updated. */
  maintenanceVisitPatch: MaintenanceVisitPatch;
  /** The globally unique `ID` which will identify a single `MaintenanceVisit` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `updateMaintenanceVisitLineById` mutation. */
export type UpdateMaintenanceVisitLineByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `MaintenanceVisitLine` being updated. */
  maintenanceVisitLinePatch: MaintenanceVisitLinePatch;
};

/** All input for the `updateMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationId` mutation. */
export type UpdateMaintenanceVisitLineByMaintenanceVisitIdAndDetectorSensorLocationIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorSensorLocationId: Scalars['Int']['input'];
  maintenanceVisitId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `MaintenanceVisitLine` being updated. */
  maintenanceVisitLinePatch: MaintenanceVisitLinePatch;
};

/** All input for the `updateMaintenanceVisitLine` mutation. */
export type UpdateMaintenanceVisitLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `MaintenanceVisitLine` being updated. */
  maintenanceVisitLinePatch: MaintenanceVisitLinePatch;
  /** The globally unique `ID` which will identify a single `MaintenanceVisitLine` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `MaintenanceVisitLine` mutation. */
export type UpdateMaintenanceVisitLinePayload = {
  __typename?: 'UpdateMaintenanceVisitLinePayload';
  /** Reads a single `CalGas` that is related to this `MaintenanceVisitLine`. */
  calGasByCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DetectorSensor` that is related to this `MaintenanceVisitLine`. */
  detectorSensorByDetectorSensorId?: Maybe<DetectorSensor>;
  /** Reads a single `DetectorSensorLocation` that is related to this `MaintenanceVisitLine`. */
  detectorSensorLocationByDetectorSensorLocationId?: Maybe<DetectorSensorLocation>;
  /** Reads a single `Filter` that is related to this `MaintenanceVisitLine`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `MaintenanceVisit` that is related to this `MaintenanceVisitLine`. */
  maintenanceVisitByMaintenanceVisitId?: Maybe<MaintenanceVisit>;
  /** The `MaintenanceVisitLine` that was updated by this mutation. */
  maintenanceVisitLine?: Maybe<MaintenanceVisitLine>;
  /** An edge for our `MaintenanceVisitLine`. May be used by Relay 1. */
  maintenanceVisitLineEdge?: Maybe<MaintenanceVisitLinesEdge>;
  /** Reads a single `Pyrolyser` that is related to this `MaintenanceVisitLine`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `MaintenanceVisitLine`. */
  sensorByOriginalSensorId?: Maybe<Sensor>;
  /** Reads a single `Sensor` that is related to this `MaintenanceVisitLine`. */
  sensorBySensorId?: Maybe<Sensor>;
};


/** The output of our update `MaintenanceVisitLine` mutation. */
export type UpdateMaintenanceVisitLinePayloadMaintenanceVisitLineEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitLinesOrderBy>>;
};

/** The output of our update `MaintenanceVisit` mutation. */
export type UpdateMaintenanceVisitPayload = {
  __typename?: 'UpdateMaintenanceVisitPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `MaintenanceVisit`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** The `MaintenanceVisit` that was updated by this mutation. */
  maintenanceVisit?: Maybe<MaintenanceVisit>;
  /** An edge for our `MaintenanceVisit`. May be used by Relay 1. */
  maintenanceVisitEdge?: Maybe<MaintenanceVisitsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `MaintenanceVisit`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `MaintenanceVisit`. */
  userByUserId?: Maybe<User>;
};


/** The output of our update `MaintenanceVisit` mutation. */
export type UpdateMaintenanceVisitPayloadMaintenanceVisitEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitsOrderBy>>;
};

/** All input for the `updateMaintenanceVisitRemarkById` mutation. */
export type UpdateMaintenanceVisitRemarkByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `MaintenanceVisitRemark` being updated. */
  maintenanceVisitRemarkPatch: MaintenanceVisitRemarkPatch;
};

/** All input for the `updateMaintenanceVisitRemarkByMaintenanceVisitIdAndLine` mutation. */
export type UpdateMaintenanceVisitRemarkByMaintenanceVisitIdAndLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  line: Scalars['Int']['input'];
  maintenanceVisitId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `MaintenanceVisitRemark` being updated. */
  maintenanceVisitRemarkPatch: MaintenanceVisitRemarkPatch;
};

/** All input for the `updateMaintenanceVisitRemark` mutation. */
export type UpdateMaintenanceVisitRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `MaintenanceVisitRemark` being updated. */
  maintenanceVisitRemarkPatch: MaintenanceVisitRemarkPatch;
  /** The globally unique `ID` which will identify a single `MaintenanceVisitRemark` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `MaintenanceVisitRemark` mutation. */
export type UpdateMaintenanceVisitRemarkPayload = {
  __typename?: 'UpdateMaintenanceVisitRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MaintenanceVisit` that is related to this `MaintenanceVisitRemark`. */
  maintenanceVisitByMaintenanceVisitId?: Maybe<MaintenanceVisit>;
  /** The `MaintenanceVisitRemark` that was updated by this mutation. */
  maintenanceVisitRemark?: Maybe<MaintenanceVisitRemark>;
  /** An edge for our `MaintenanceVisitRemark`. May be used by Relay 1. */
  maintenanceVisitRemarkEdge?: Maybe<MaintenanceVisitRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `MaintenanceVisitRemark` mutation. */
export type UpdateMaintenanceVisitRemarkPayloadMaintenanceVisitRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<MaintenanceVisitRemarksOrderBy>>;
};

/** All input for the `updateMembraneById` mutation. */
export type UpdateMembraneByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Membrane` being updated. */
  membranePatch: MembranePatch;
};

/** All input for the `updateMembraneByName` mutation. */
export type UpdateMembraneByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Membrane` being updated. */
  membranePatch: MembranePatch;
  name: Scalars['String']['input'];
};

/** All input for the `updateMembrane` mutation. */
export type UpdateMembraneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Membrane` being updated. */
  membranePatch: MembranePatch;
  /** The globally unique `ID` which will identify a single `Membrane` to be updated. */
  nodeId: Scalars['ID']['input'];
};

/** The output of our update `Membrane` mutation. */
export type UpdateMembranePayload = {
  __typename?: 'UpdateMembranePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Membrane` that was updated by this mutation. */
  membrane?: Maybe<Membrane>;
  /** An edge for our `Membrane`. May be used by Relay 1. */
  membraneEdge?: Maybe<MembranesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Membrane`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Membrane` mutation. */
export type UpdateMembranePayloadMembraneEdgeArgs = {
  orderBy?: InputMaybe<Array<MembranesOrderBy>>;
};

/** All input for the `updateORingById` mutation. */
export type UpdateORingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ORing` being updated. */
  oRingPatch: ORingPatch;
};

/** All input for the `updateORingByName` mutation. */
export type UpdateORingByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `ORing` being updated. */
  oRingPatch: ORingPatch;
};

/** All input for the `updateORing` mutation. */
export type UpdateORingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ORing` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ORing` being updated. */
  oRingPatch: ORingPatch;
};

/** The output of our update `ORing` mutation. */
export type UpdateORingPayload = {
  __typename?: 'UpdateORingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ORing` that was updated by this mutation. */
  oRing?: Maybe<ORing>;
  /** An edge for our `ORing`. May be used by Relay 1. */
  oRingEdge?: Maybe<ORingsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ORing`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `ORing` mutation. */
export type UpdateORingPayloadORingEdgeArgs = {
  orderBy?: InputMaybe<Array<ORingsOrderBy>>;
};

/** All input for the `updateOfferteRemarkById` mutation. */
export type UpdateOfferteRemarkByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `OfferteRemark` being updated. */
  offerteRemarkPatch: OfferteRemarkPatch;
};

/** All input for the `updateOfferteRemarkByOfferteId` mutation. */
export type UpdateOfferteRemarkByOfferteIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  offerteId: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `OfferteRemark` being updated. */
  offerteRemarkPatch: OfferteRemarkPatch;
};

/** All input for the `updateOfferteRemark` mutation. */
export type UpdateOfferteRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OfferteRemark` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `OfferteRemark` being updated. */
  offerteRemarkPatch: OfferteRemarkPatch;
};

/** The output of our update `OfferteRemark` mutation. */
export type UpdateOfferteRemarkPayload = {
  __typename?: 'UpdateOfferteRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `OfferteRemark` that was updated by this mutation. */
  offerteRemark?: Maybe<OfferteRemark>;
  /** An edge for our `OfferteRemark`. May be used by Relay 1. */
  offerteRemarkEdge?: Maybe<OfferteRemarksEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `OfferteRemark`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `OfferteRemark` mutation. */
export type UpdateOfferteRemarkPayloadOfferteRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<OfferteRemarksOrderBy>>;
};

/** All input for the `updateOpportunityById` mutation. */
export type UpdateOpportunityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Opportunity` being updated. */
  opportunityPatch: OpportunityPatch;
};

/** All input for the `updateOpportunity` mutation. */
export type UpdateOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Opportunity` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Opportunity` being updated. */
  opportunityPatch: OpportunityPatch;
};

/** The output of our update `Opportunity` mutation. */
export type UpdateOpportunityPayload = {
  __typename?: 'UpdateOpportunityPayload';
  /** Reads a single `_Land` that is related to this `Opportunity`. */
  _landByCdland?: Maybe<_Land>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Opportunity` that was updated by this mutation. */
  opportunity?: Maybe<Opportunity>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Opportunity`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Opportunity` mutation. */
export type UpdateOpportunityPayloadOpportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the `updatePermissionById` mutation. */
export type UpdatePermissionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Permission` being updated. */
  permissionPatch: PermissionPatch;
};

/** All input for the `updatePermission` mutation. */
export type UpdatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Permission` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Permission` being updated. */
  permissionPatch: PermissionPatch;
};

/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayload = {
  __typename?: 'UpdatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Permission` that was updated by this mutation. */
  permission?: Maybe<Permission>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayloadPermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `updatePersoonRolByPersoonRolGuid` mutation. */
export type UpdatePersoonRolByPersoonRolGuidInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  persoonRolGuid: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `PersoonRol` being updated. */
  persoonRolPatch: PersoonRolPatch;
};

/** All input for the `updatePersoonRol` mutation. */
export type UpdatePersoonRolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PersoonRol` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PersoonRol` being updated. */
  persoonRolPatch: PersoonRolPatch;
};

/** The output of our update `PersoonRol` mutation. */
export type UpdatePersoonRolPayload = {
  __typename?: 'UpdatePersoonRolPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PersoonRol` that was updated by this mutation. */
  persoonRol?: Maybe<PersoonRol>;
  /** An edge for our `PersoonRol`. May be used by Relay 1. */
  persoonRolEdge?: Maybe<PersoonRolsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PersoonRol` mutation. */
export type UpdatePersoonRolPayloadPersoonRolEdgeArgs = {
  orderBy?: InputMaybe<Array<PersoonRolsOrderBy>>;
};

/** All input for the `updatePlugById` mutation. */
export type UpdatePlugByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Plug` being updated. */
  plugPatch: PlugPatch;
};

/** All input for the `updatePlugByName` mutation. */
export type UpdatePlugByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Plug` being updated. */
  plugPatch: PlugPatch;
};

/** All input for the `updatePlug` mutation. */
export type UpdatePlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Plug` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Plug` being updated. */
  plugPatch: PlugPatch;
};

/** The output of our update `Plug` mutation. */
export type UpdatePlugPayload = {
  __typename?: 'UpdatePlugPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Plug` that was updated by this mutation. */
  plug?: Maybe<Plug>;
  /** An edge for our `Plug`. May be used by Relay 1. */
  plugEdge?: Maybe<PlugsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Plug`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Plug` mutation. */
export type UpdatePlugPayloadPlugEdgeArgs = {
  orderBy?: InputMaybe<Array<PlugsOrderBy>>;
};

/** All input for the `updatePrincipleById` mutation. */
export type UpdatePrincipleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Principle` being updated. */
  principlePatch: PrinciplePatch;
};

/** All input for the `updatePrincipleByName` mutation. */
export type UpdatePrincipleByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Principle` being updated. */
  principlePatch: PrinciplePatch;
};

/** All input for the `updatePrinciple` mutation. */
export type UpdatePrincipleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Principle` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Principle` being updated. */
  principlePatch: PrinciplePatch;
};

/** The output of our update `Principle` mutation. */
export type UpdatePrinciplePayload = {
  __typename?: 'UpdatePrinciplePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Principle` that was updated by this mutation. */
  principle?: Maybe<Principle>;
  /** An edge for our `Principle`. May be used by Relay 1. */
  principleEdge?: Maybe<PrinciplesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Principle`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Principle` mutation. */
export type UpdatePrinciplePayloadPrincipleEdgeArgs = {
  orderBy?: InputMaybe<Array<PrinciplesOrderBy>>;
};

/** All input for the `updateProductionById` mutation. */
export type UpdateProductionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Production` being updated. */
  productionPatch: ProductionPatch;
};

/** All input for the `updateProduction` mutation. */
export type UpdateProductionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Production` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Production` being updated. */
  productionPatch: ProductionPatch;
};

/** The output of our update `Production` mutation. */
export type UpdateProductionPayload = {
  __typename?: 'UpdateProductionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Production` that was updated by this mutation. */
  production?: Maybe<Production>;
  /** An edge for our `Production`. May be used by Relay 1. */
  productionEdge?: Maybe<ProductionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Production` mutation. */
export type UpdateProductionPayloadProductionEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductionsOrderBy>>;
};

/** All input for the `updatePyrolyserById` mutation. */
export type UpdatePyrolyserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Pyrolyser` being updated. */
  pyrolyserPatch: PyrolyserPatch;
};

/** All input for the `updatePyrolyserByName` mutation. */
export type UpdatePyrolyserByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Pyrolyser` being updated. */
  pyrolyserPatch: PyrolyserPatch;
};

/** All input for the `updatePyrolyser` mutation. */
export type UpdatePyrolyserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Pyrolyser` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Pyrolyser` being updated. */
  pyrolyserPatch: PyrolyserPatch;
};

/** The output of our update `Pyrolyser` mutation. */
export type UpdatePyrolyserPayload = {
  __typename?: 'UpdatePyrolyserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Pyrolyser` that was updated by this mutation. */
  pyrolyser?: Maybe<Pyrolyser>;
  /** An edge for our `Pyrolyser`. May be used by Relay 1. */
  pyrolyserEdge?: Maybe<PyrolysersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Pyrolyser`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Pyrolyser` mutation. */
export type UpdatePyrolyserPayloadPyrolyserEdgeArgs = {
  orderBy?: InputMaybe<Array<PyrolysersOrderBy>>;
};

/** All input for the `updateRangeById` mutation. */
export type UpdateRangeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Range` being updated. */
  rangePatch: RangePatch;
};

/** All input for the `updateRangeByLowEuAndHighEuAndEngineeringUnitsAndGasId` mutation. */
export type UpdateRangeByLowEuAndHighEuAndEngineeringUnitsAndGasIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  engineeringUnits: Scalars['String']['input'];
  gasId: Scalars['Int']['input'];
  highEu: Scalars['Float']['input'];
  lowEu: Scalars['Float']['input'];
  /** An object where the defined keys will be set on the `Range` being updated. */
  rangePatch: RangePatch;
};

/** All input for the `updateRange` mutation. */
export type UpdateRangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Range` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Range` being updated. */
  rangePatch: RangePatch;
};

/** The output of our update `Range` mutation. */
export type UpdateRangePayload = {
  __typename?: 'UpdateRangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Gas` that is related to this `Range`. */
  gasByGasId?: Maybe<Gas>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Range` that was updated by this mutation. */
  range?: Maybe<Range>;
  /** An edge for our `Range`. May be used by Relay 1. */
  rangeEdge?: Maybe<RangesEdge>;
  /** Reads a single `User` that is related to this `Range`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Range` mutation. */
export type UpdateRangePayloadRangeEdgeArgs = {
  orderBy?: InputMaybe<Array<RangesOrderBy>>;
};

/** All input for the `updateRcCardById` mutation. */
export type UpdateRcCardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `RcCard` being updated. */
  rcCardPatch: RcCardPatch;
};

/** All input for the `updateRcCard` mutation. */
export type UpdateRcCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RcCard` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RcCard` being updated. */
  rcCardPatch: RcCardPatch;
};

/** The output of our update `RcCard` mutation. */
export type UpdateRcCardPayload = {
  __typename?: 'UpdateRcCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RcCard` that was updated by this mutation. */
  rcCard?: Maybe<RcCard>;
  /** An edge for our `RcCard`. May be used by Relay 1. */
  rcCardEdge?: Maybe<RcCardsEdge>;
  /** Reads a single `User` that is related to this `RcCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `RcCard` mutation. */
export type UpdateRcCardPayloadRcCardEdgeArgs = {
  orderBy?: InputMaybe<Array<RcCardsOrderBy>>;
};

/** All input for the `updateRefreshTokenById` mutation. */
export type UpdateRefreshTokenByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `RefreshToken` being updated. */
  refreshTokenPatch: RefreshTokenPatch;
};

/** All input for the `updateRefreshToken` mutation. */
export type UpdateRefreshTokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RefreshToken` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RefreshToken` being updated. */
  refreshTokenPatch: RefreshTokenPatch;
};

/** The output of our update `RefreshToken` mutation. */
export type UpdateRefreshTokenPayload = {
  __typename?: 'UpdateRefreshTokenPayload';
  /** Reads a single `AspNetUser` that is related to this `RefreshToken`. */
  aspNetUserByAppUserId?: Maybe<AspNetUser>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RefreshToken` that was updated by this mutation. */
  refreshToken?: Maybe<RefreshToken>;
  /** An edge for our `RefreshToken`. May be used by Relay 1. */
  refreshTokenEdge?: Maybe<RefreshTokensEdge>;
};


/** The output of our update `RefreshToken` mutation. */
export type UpdateRefreshTokenPayloadRefreshTokenEdgeArgs = {
  orderBy?: InputMaybe<Array<RefreshTokensOrderBy>>;
};

/** All input for the `updateReportByFilename` mutation. */
export type UpdateReportByFilenameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  filename: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Report` being updated. */
  reportPatch: ReportPatch;
};

/** All input for the `updateReportById` mutation. */
export type UpdateReportByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Report` being updated. */
  reportPatch: ReportPatch;
};

/** All input for the `updateReportByTsrNumberAndVersion` mutation. */
export type UpdateReportByTsrNumberAndVersionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Report` being updated. */
  reportPatch: ReportPatch;
  tsrNumber: Scalars['String']['input'];
  version: Scalars['String']['input'];
};

/** All input for the `updateReportDetectorById` mutation. */
export type UpdateReportDetectorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReportDetector` being updated. */
  reportDetectorPatch: ReportDetectorPatch;
};

/** All input for the `updateReportDetectorByReportIdAndDetectorId` mutation. */
export type UpdateReportDetectorByReportIdAndDetectorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReportDetector` being updated. */
  reportDetectorPatch: ReportDetectorPatch;
  reportId: Scalars['Int']['input'];
};

/** All input for the `updateReportDetector` mutation. */
export type UpdateReportDetectorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReportDetector` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReportDetector` being updated. */
  reportDetectorPatch: ReportDetectorPatch;
};

/** The output of our update `ReportDetector` mutation. */
export type UpdateReportDetectorPayload = {
  __typename?: 'UpdateReportDetectorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `ReportDetector`. */
  detectorByDetectorId?: Maybe<Detector>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportDetector`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportDetector` that was updated by this mutation. */
  reportDetector?: Maybe<ReportDetector>;
  /** An edge for our `ReportDetector`. May be used by Relay 1. */
  reportDetectorEdge?: Maybe<ReportDetectorsEdge>;
};


/** The output of our update `ReportDetector` mutation. */
export type UpdateReportDetectorPayloadReportDetectorEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportDetectorsOrderBy>>;
};

/** All input for the `updateReport` mutation. */
export type UpdateReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Report` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Report` being updated. */
  reportPatch: ReportPatch;
};

/** All input for the `updateReportItemById` mutation. */
export type UpdateReportItemByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReportItem` being updated. */
  reportItemPatch: ReportItemPatch;
};

/** All input for the `updateReportItem` mutation. */
export type UpdateReportItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReportItem` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReportItem` being updated. */
  reportItemPatch: ReportItemPatch;
};

/** The output of our update `ReportItem` mutation. */
export type UpdateReportItemPayload = {
  __typename?: 'UpdateReportItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Item` that is related to this `ReportItem`. */
  itemByItemId?: Maybe<Item>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportItem`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportItem` that was updated by this mutation. */
  reportItem?: Maybe<ReportItem>;
  /** An edge for our `ReportItem`. May be used by Relay 1. */
  reportItemEdge?: Maybe<ReportItemsEdge>;
};


/** The output of our update `ReportItem` mutation. */
export type UpdateReportItemPayloadReportItemEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportItemsOrderBy>>;
};

/** The output of our update `Report` mutation. */
export type UpdateReportPayload = {
  __typename?: 'UpdateReportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `EndUser` that is related to this `Report`. */
  endUserByEndUserId?: Maybe<EndUser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Report` that was updated by this mutation. */
  report?: Maybe<Report>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
  /** Reads a single `User` that is related to this `Report`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `Report`. */
  userByUserId?: Maybe<User>;
};


/** The output of our update `Report` mutation. */
export type UpdateReportPayloadReportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the `updateReportSensorById` mutation. */
export type UpdateReportSensorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReportSensor` being updated. */
  reportSensorPatch: ReportSensorPatch;
};

/** All input for the `updateReportSensorByReportIdAndSensorId` mutation. */
export type UpdateReportSensorByReportIdAndSensorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  reportId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReportSensor` being updated. */
  reportSensorPatch: ReportSensorPatch;
  sensorId: Scalars['Int']['input'];
};

/** All input for the `updateReportSensor` mutation. */
export type UpdateReportSensorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReportSensor` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReportSensor` being updated. */
  reportSensorPatch: ReportSensorPatch;
};

/** The output of our update `ReportSensor` mutation. */
export type UpdateReportSensorPayload = {
  __typename?: 'UpdateReportSensorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Report` that is related to this `ReportSensor`. */
  reportByReportId?: Maybe<Report>;
  /** The `ReportSensor` that was updated by this mutation. */
  reportSensor?: Maybe<ReportSensor>;
  /** An edge for our `ReportSensor`. May be used by Relay 1. */
  reportSensorEdge?: Maybe<ReportSensorsEdge>;
  /** Reads a single `Sensor` that is related to this `ReportSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
};


/** The output of our update `ReportSensor` mutation. */
export type UpdateReportSensorPayloadReportSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportSensorsOrderBy>>;
};

/** All input for the `updateRequestById` mutation. */
export type UpdateRequestByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Request` being updated. */
  requestPatch: RequestPatch;
};

/** All input for the `updateRequest` mutation. */
export type UpdateRequestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Request` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Request` being updated. */
  requestPatch: RequestPatch;
};

/** The output of our update `Request` mutation. */
export type UpdateRequestPayload = {
  __typename?: 'UpdateRequestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Request` that was updated by this mutation. */
  request?: Maybe<Request>;
  /** An edge for our `Request`. May be used by Relay 1. */
  requestEdge?: Maybe<RequestsEdge>;
  /** Reads a single `User` that is related to this `Request`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Request` mutation. */
export type UpdateRequestPayloadRequestEdgeArgs = {
  orderBy?: InputMaybe<Array<RequestsOrderBy>>;
};

/** All input for the `updateRxCardById` mutation. */
export type UpdateRxCardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `RxCard` being updated. */
  rxCardPatch: RxCardPatch;
};

/** All input for the `updateRxCard` mutation. */
export type UpdateRxCardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `RxCard` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `RxCard` being updated. */
  rxCardPatch: RxCardPatch;
};

/** The output of our update `RxCard` mutation. */
export type UpdateRxCardPayload = {
  __typename?: 'UpdateRxCardPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `RxCard` that was updated by this mutation. */
  rxCard?: Maybe<RxCard>;
  /** An edge for our `RxCard`. May be used by Relay 1. */
  rxCardEdge?: Maybe<RxCardsEdge>;
  /** Reads a single `User` that is related to this `RxCard`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `RxCard` mutation. */
export type UpdateRxCardPayloadRxCardEdgeArgs = {
  orderBy?: InputMaybe<Array<RxCardsOrderBy>>;
};

/** All input for the `updateSamplePointByAreaIdAndName` mutation. */
export type UpdateSamplePointByAreaIdAndNameInput = {
  areaId: Scalars['Int']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `SamplePoint` being updated. */
  samplePointPatch: SamplePointPatch;
};

/** All input for the `updateSamplePointById` mutation. */
export type UpdateSamplePointByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SamplePoint` being updated. */
  samplePointPatch: SamplePointPatch;
};

/** All input for the `updateSamplePoint` mutation. */
export type UpdateSamplePointInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SamplePoint` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SamplePoint` being updated. */
  samplePointPatch: SamplePointPatch;
};

/** The output of our update `SamplePoint` mutation. */
export type UpdateSamplePointPayload = {
  __typename?: 'UpdateSamplePointPayload';
  /** Reads a single `Area` that is related to this `SamplePoint`. */
  areaByAreaId?: Maybe<Area>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SamplePoint` that was updated by this mutation. */
  samplePoint?: Maybe<SamplePoint>;
  /** An edge for our `SamplePoint`. May be used by Relay 1. */
  samplePointEdge?: Maybe<SamplePointsEdge>;
  /** Reads a single `User` that is related to this `SamplePoint`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `SamplePoint` mutation. */
export type UpdateSamplePointPayloadSamplePointEdgeArgs = {
  orderBy?: InputMaybe<Array<SamplePointsOrderBy>>;
};

/** All input for the `updateSensorBaseTypeById` mutation. */
export type UpdateSensorBaseTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorBaseType` being updated. */
  sensorBaseTypePatch: SensorBaseTypePatch;
};

/** All input for the `updateSensorBaseTypeByPrefixAndSuffix` mutation. */
export type UpdateSensorBaseTypeByPrefixAndSuffixInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  prefix: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `SensorBaseType` being updated. */
  sensorBaseTypePatch: SensorBaseTypePatch;
  suffix: Scalars['String']['input'];
};

/** All input for the `updateSensorBaseType` mutation. */
export type UpdateSensorBaseTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorBaseType` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorBaseType` being updated. */
  sensorBaseTypePatch: SensorBaseTypePatch;
};

/** The output of our update `SensorBaseType` mutation. */
export type UpdateSensorBaseTypePayload = {
  __typename?: 'UpdateSensorBaseTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Principle` that is related to this `SensorBaseType`. */
  principleByPrincipleId?: Maybe<Principle>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorBaseType` that was updated by this mutation. */
  sensorBaseType?: Maybe<SensorBaseType>;
  /** An edge for our `SensorBaseType`. May be used by Relay 1. */
  sensorBaseTypeEdge?: Maybe<SensorBaseTypesEdge>;
};


/** The output of our update `SensorBaseType` mutation. */
export type UpdateSensorBaseTypePayloadSensorBaseTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorBaseTypesOrderBy>>;
};

/** All input for the `updateSensorById` mutation. */
export type UpdateSensorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Sensor` being updated. */
  sensorPatch: SensorPatch;
};

/** All input for the `updateSensorBySerialNumberAndSensorTypeId` mutation. */
export type UpdateSensorBySerialNumberAndSensorTypeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Sensor` being updated. */
  sensorPatch: SensorPatch;
  sensorTypeId: Scalars['Int']['input'];
  serialNumber: Scalars['String']['input'];
};

/** All input for the `updateSensorElementById` mutation. */
export type UpdateSensorElementByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorElement` being updated. */
  sensorElementPatch: SensorElementPatch;
};

/** All input for the `updateSensorElement` mutation. */
export type UpdateSensorElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorElement` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorElement` being updated. */
  sensorElementPatch: SensorElementPatch;
};

/** All input for the `updateSensorElementLocationById` mutation. */
export type UpdateSensorElementLocationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorElementLocation` being updated. */
  sensorElementLocationPatch: SensorElementLocationPatch;
};

/** All input for the `updateSensorElementLocationBySensorElementId` mutation. */
export type UpdateSensorElementLocationBySensorElementIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorElementId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorElementLocation` being updated. */
  sensorElementLocationPatch: SensorElementLocationPatch;
};

/** All input for the `updateSensorElementLocation` mutation. */
export type UpdateSensorElementLocationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorElementLocation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorElementLocation` being updated. */
  sensorElementLocationPatch: SensorElementLocationPatch;
};

/** The output of our update `SensorElementLocation` mutation. */
export type UpdateSensorElementLocationPayload = {
  __typename?: 'UpdateSensorElementLocationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DetectorSensorLocation` that is related to this `SensorElementLocation`. */
  detectorSensorLocationByDetectorSensorLocationId?: Maybe<DetectorSensorLocation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SensorElement` that is related to this `SensorElementLocation`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorElementLocation` that was updated by this mutation. */
  sensorElementLocation?: Maybe<SensorElementLocation>;
  /** An edge for our `SensorElementLocation`. May be used by Relay 1. */
  sensorElementLocationEdge?: Maybe<SensorElementLocationsEdge>;
  /** Reads a single `User` that is related to this `SensorElementLocation`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `SensorElementLocation` mutation. */
export type UpdateSensorElementLocationPayloadSensorElementLocationEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementLocationsOrderBy>>;
};

/** All input for the `updateSensorElementLogById` mutation. */
export type UpdateSensorElementLogByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorElementLog` being updated. */
  sensorElementLogPatch: SensorElementLogPatch;
};

/** All input for the `updateSensorElementLog` mutation. */
export type UpdateSensorElementLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorElementLog` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorElementLog` being updated. */
  sensorElementLogPatch: SensorElementLogPatch;
};

/** The output of our update `SensorElementLog` mutation. */
export type UpdateSensorElementLogPayload = {
  __typename?: 'UpdateSensorElementLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorElementLog`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` that is related to this `SensorElementLog`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorElementLog` that was updated by this mutation. */
  sensorElementLog?: Maybe<SensorElementLog>;
  /** An edge for our `SensorElementLog`. May be used by Relay 1. */
  sensorElementLogEdge?: Maybe<SensorElementLogsEdge>;
};


/** The output of our update `SensorElementLog` mutation. */
export type UpdateSensorElementLogPayloadSensorElementLogEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementLogsOrderBy>>;
};

/** The output of our update `SensorElement` mutation. */
export type UpdateSensorElementPayload = {
  __typename?: 'UpdateSensorElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorElement` that was updated by this mutation. */
  sensorElement?: Maybe<SensorElement>;
  /** An edge for our `SensorElement`. May be used by Relay 1. */
  sensorElementEdge?: Maybe<SensorElementsEdge>;
  /** Reads a single `SensorElementType` that is related to this `SensorElement`. */
  sensorElementTypeBySensorElementTypeId?: Maybe<SensorElementType>;
  /** Reads a single `User` that is related to this `SensorElement`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `SensorElement` mutation. */
export type UpdateSensorElementPayloadSensorElementEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementsOrderBy>>;
};

/** All input for the `updateSensorElementTypeById` mutation. */
export type UpdateSensorElementTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorElementType` being updated. */
  sensorElementTypePatch: SensorElementTypePatch;
};

/** All input for the `updateSensorElementType` mutation. */
export type UpdateSensorElementTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorElementType` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorElementType` being updated. */
  sensorElementTypePatch: SensorElementTypePatch;
};

/** The output of our update `SensorElementType` mutation. */
export type UpdateSensorElementTypePayload = {
  __typename?: 'UpdateSensorElementTypePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Range` that is related to this `SensorElementType`. */
  rangeByCalRangeId?: Maybe<Range>;
  /** Reads a single `Range` that is related to this `SensorElementType`. */
  rangeByRangeId?: Maybe<Range>;
  /** Reads a single `SensorBaseType` that is related to this `SensorElementType`. */
  sensorBaseTypeBySensorBaseTypeId?: Maybe<SensorBaseType>;
  /** The `SensorElementType` that was updated by this mutation. */
  sensorElementType?: Maybe<SensorElementType>;
  /** An edge for our `SensorElementType`. May be used by Relay 1. */
  sensorElementTypeEdge?: Maybe<SensorElementTypesEdge>;
  /** Reads a single `User` that is related to this `SensorElementType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `SensorElementType` mutation. */
export type UpdateSensorElementTypePayloadSensorElementTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorElementTypesOrderBy>>;
};

/** All input for the `updateSensor` mutation. */
export type UpdateSensorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Sensor` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Sensor` being updated. */
  sensorPatch: SensorPatch;
};

/** All input for the `updateSensorOrderById` mutation. */
export type UpdateSensorOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorOrder` being updated. */
  sensorOrderPatch: SensorOrderPatch;
};

/** All input for the `updateSensorOrderBySensorIdAndFactuuropdracht` mutation. */
export type UpdateSensorOrderBySensorIdAndFactuuropdrachtInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  sensorId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorOrder` being updated. */
  sensorOrderPatch: SensorOrderPatch;
};

/** All input for the `updateSensorOrder` mutation. */
export type UpdateSensorOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorOrder` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorOrder` being updated. */
  sensorOrderPatch: SensorOrderPatch;
};

/** The output of our update `SensorOrder` mutation. */
export type UpdateSensorOrderPayload = {
  __typename?: 'UpdateSensorOrderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Factureeropdracht` that is related to this `SensorOrder`. */
  factureeropdrachtByFactuuropdracht?: Maybe<Factureeropdracht>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorOrder`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** The `SensorOrder` that was updated by this mutation. */
  sensorOrder?: Maybe<SensorOrder>;
  /** An edge for our `SensorOrder`. May be used by Relay 1. */
  sensorOrderEdge?: Maybe<SensorOrdersEdge>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByCheckedUserId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorOrder`. */
  userByVerifiedUserId?: Maybe<User>;
};


/** The output of our update `SensorOrder` mutation. */
export type UpdateSensorOrderPayloadSensorOrderEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};

/** The output of our update `Sensor` mutation. */
export type UpdateSensorPayload = {
  __typename?: 'UpdateSensorPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Sensor` that was updated by this mutation. */
  sensor?: Maybe<Sensor>;
  /** An edge for our `Sensor`. May be used by Relay 1. */
  sensorEdge?: Maybe<SensorsEdge>;
  /** Reads a single `SensorType` that is related to this `Sensor`. */
  sensorTypeBySensorTypeId?: Maybe<SensorType>;
  /** Reads a single `User` that is related to this `Sensor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Sensor` mutation. */
export type UpdateSensorPayloadSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorsOrderBy>>;
};

/** All input for the `updateSensorSensorElementById` mutation. */
export type UpdateSensorSensorElementByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorSensorElement` being updated. */
  sensorSensorElementPatch: SensorSensorElementPatch;
};

/** All input for the `updateSensorSensorElementBySensorElementId` mutation. */
export type UpdateSensorSensorElementBySensorElementIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorElementId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorSensorElement` being updated. */
  sensorSensorElementPatch: SensorSensorElementPatch;
};

/** All input for the `updateSensorSensorElementBySensorIdAndSensorPosition` mutation. */
export type UpdateSensorSensorElementBySensorIdAndSensorPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorId: Scalars['Int']['input'];
  sensorPosition: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorSensorElement` being updated. */
  sensorSensorElementPatch: SensorSensorElementPatch;
};

/** All input for the `updateSensorSensorElement` mutation. */
export type UpdateSensorSensorElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorSensorElement` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorSensorElement` being updated. */
  sensorSensorElementPatch: SensorSensorElementPatch;
};

/** The output of our update `SensorSensorElement` mutation. */
export type UpdateSensorSensorElementPayload = {
  __typename?: 'UpdateSensorSensorElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorSensorElement`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorElement` that is related to this `SensorSensorElement`. */
  sensorElementBySensorElementId?: Maybe<SensorElement>;
  /** The `SensorSensorElement` that was updated by this mutation. */
  sensorSensorElement?: Maybe<SensorSensorElement>;
  /** An edge for our `SensorSensorElement`. May be used by Relay 1. */
  sensorSensorElementEdge?: Maybe<SensorSensorElementsEdge>;
  /** Reads a single `User` that is related to this `SensorSensorElement`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `SensorSensorElement` mutation. */
export type UpdateSensorSensorElementPayloadSensorSensorElementEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorSensorElementsOrderBy>>;
};

/** All input for the `updateSensorSettingById` mutation. */
export type UpdateSensorSettingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorSetting` being updated. */
  sensorSettingPatch: SensorSettingPatch;
};

/** All input for the `updateSensorSettingByTypeTarget` mutation. */
export type UpdateSensorSettingByTypeTargetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `SensorSetting` being updated. */
  sensorSettingPatch: SensorSettingPatch;
  typeTarget: Scalars['String']['input'];
};

/** All input for the `updateSensorSetting` mutation. */
export type UpdateSensorSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorSetting` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorSetting` being updated. */
  sensorSettingPatch: SensorSettingPatch;
};

/** The output of our update `SensorSetting` mutation. */
export type UpdateSensorSettingPayload = {
  __typename?: 'UpdateSensorSettingPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SensorSetting` that was updated by this mutation. */
  sensorSetting?: Maybe<SensorSetting>;
  /** An edge for our `SensorSetting`. May be used by Relay 1. */
  sensorSettingEdge?: Maybe<SensorSettingsEdge>;
};


/** The output of our update `SensorSetting` mutation. */
export type UpdateSensorSettingPayloadSensorSettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorSettingsOrderBy>>;
};

/** All input for the `updateSensorTestResultById` mutation. */
export type UpdateSensorTestResultByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorTestResult` being updated. */
  sensorTestResultPatch: SensorTestResultPatch;
};

/** All input for the `updateSensorTestResult` mutation. */
export type UpdateSensorTestResultInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorTestResult` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorTestResult` being updated. */
  sensorTestResultPatch: SensorTestResultPatch;
};

/** The output of our update `SensorTestResult` mutation. */
export type UpdateSensorTestResultPayload = {
  __typename?: 'UpdateSensorTestResultPayload';
  /** Reads a single `CalGas` that is related to this `SensorTestResult`. */
  calGasByFsCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `SensorTestResult`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `SensorOrder` that is related to this `SensorTestResult`. */
  sensorOrderBySensorOrderId?: Maybe<SensorOrder>;
  /** The `SensorTestResult` that was updated by this mutation. */
  sensorTestResult?: Maybe<SensorTestResult>;
  /** An edge for our `SensorTestResult`. May be used by Relay 1. */
  sensorTestResultEdge?: Maybe<SensorTestResultsEdge>;
  /** Reads a single `User` that is related to this `SensorTestResult`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `SensorTestResult`. */
  userByUserId?: Maybe<User>;
};


/** The output of our update `SensorTestResult` mutation. */
export type UpdateSensorTestResultPayloadSensorTestResultEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};

/** All input for the `updateSensorTypeById` mutation. */
export type UpdateSensorTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorType` being updated. */
  sensorTypePatch: SensorTypePatch;
};

/** All input for the `updateSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserId` mutation. */
export type UpdateSensorTypeBySensorBaseTypeIdAndRangeIdAndCodeAndModelAndPyrolyserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  model: Scalars['String']['input'];
  pyrolyserId: Scalars['Int']['input'];
  rangeId: Scalars['Int']['input'];
  sensorBaseTypeId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorType` being updated. */
  sensorTypePatch: SensorTypePatch;
};

/** All input for the `updateSensorTypeBySensorTypeId` mutation. */
export type UpdateSensorTypeBySensorTypeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  sensorTypeId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SensorType` being updated. */
  sensorTypePatch: SensorTypePatch;
};

/** All input for the `updateSensorType` mutation. */
export type UpdateSensorTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SensorType` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SensorType` being updated. */
  sensorTypePatch: SensorTypePatch;
};

/** The output of our update `SensorType` mutation. */
export type UpdateSensorTypePayload = {
  __typename?: 'UpdateSensorTypePayload';
  /** Reads a single `CalGas` that is related to this `SensorType`. */
  calGasByCalGasId?: Maybe<CalGas>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Electrolyte` that is related to this `SensorType`. */
  electrolyteByElectrolyteId?: Maybe<Electrolyte>;
  /** Reads a single `Filter` that is related to this `SensorType`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `Membrane` that is related to this `SensorType`. */
  membraneByMembraneId?: Maybe<Membrane>;
  /** Reads a single `ORing` that is related to this `SensorType`. */
  oRingByORingId?: Maybe<ORing>;
  /** Reads a single `Plug` that is related to this `SensorType`. */
  plugByPlugId?: Maybe<Plug>;
  /** Reads a single `Pyrolyser` that is related to this `SensorType`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Range` that is related to this `SensorType`. */
  rangeByRangeId?: Maybe<Range>;
  /** Reads a single `SensorBaseType` that is related to this `SensorType`. */
  sensorBaseTypeBySensorBaseTypeId?: Maybe<SensorBaseType>;
  /** The `SensorType` that was updated by this mutation. */
  sensorType?: Maybe<SensorType>;
  /** An edge for our `SensorType`. May be used by Relay 1. */
  sensorTypeEdge?: Maybe<SensorTypesEdge>;
  /** Reads a single `User` that is related to this `SensorType`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `SensorType` mutation. */
export type UpdateSensorTypePayloadSensorTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};

/** All input for the `updateSoftwareById` mutation. */
export type UpdateSoftwareByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Software` being updated. */
  softwarePatch: SoftwarePatch;
};

/** All input for the `updateSoftware` mutation. */
export type UpdateSoftwareInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Software` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Software` being updated. */
  softwarePatch: SoftwarePatch;
};

/** The output of our update `Software` mutation. */
export type UpdateSoftwarePayload = {
  __typename?: 'UpdateSoftwarePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Hardware` that is related to this `Software`. */
  hardwareByHardwareId?: Maybe<Hardware>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Software` that was updated by this mutation. */
  software?: Maybe<Software>;
  /** An edge for our `Software`. May be used by Relay 1. */
  softwareEdge?: Maybe<SoftwaresEdge>;
  /** Reads a single `User` that is related to this `Software`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Software` mutation. */
export type UpdateSoftwarePayloadSoftwareEdgeArgs = {
  orderBy?: InputMaybe<Array<SoftwaresOrderBy>>;
};

/** All input for the `updateStockGroupById` mutation. */
export type UpdateStockGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `StockGroup` being updated. */
  stockGroupPatch: StockGroupPatch;
};

/** All input for the `updateStockGroup` mutation. */
export type UpdateStockGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `StockGroup` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `StockGroup` being updated. */
  stockGroupPatch: StockGroupPatch;
};

/** The output of our update `StockGroup` mutation. */
export type UpdateStockGroupPayload = {
  __typename?: 'UpdateStockGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `StockGroup` that was updated by this mutation. */
  stockGroup?: Maybe<StockGroup>;
  /** An edge for our `StockGroup`. May be used by Relay 1. */
  stockGroupEdge?: Maybe<StockGroupsEdge>;
  /** Reads a single `User` that is related to this `StockGroup`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `StockGroup` mutation. */
export type UpdateStockGroupPayloadStockGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<StockGroupsOrderBy>>;
};

/** All input for the `updateStockItemById` mutation. */
export type UpdateStockItemByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `StockItem` being updated. */
  stockItemPatch: StockItemPatch;
};

/** All input for the `updateStockItemByStockGroupIdAndCdartikel` mutation. */
export type UpdateStockItemByStockGroupIdAndCdartikelInput = {
  cdartikel: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  stockGroupId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `StockItem` being updated. */
  stockItemPatch: StockItemPatch;
};

/** All input for the `updateStockItem` mutation. */
export type UpdateStockItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `StockItem` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `StockItem` being updated. */
  stockItemPatch: StockItemPatch;
};

/** The output of our update `StockItem` mutation. */
export type UpdateStockItemPayload = {
  __typename?: 'UpdateStockItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `StockGroup` that is related to this `StockItem`. */
  stockGroupByStockGroupId?: Maybe<StockGroup>;
  /** The `StockItem` that was updated by this mutation. */
  stockItem?: Maybe<StockItem>;
  /** An edge for our `StockItem`. May be used by Relay 1. */
  stockItemEdge?: Maybe<StockItemsEdge>;
  /** Reads a single `User` that is related to this `StockItem`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `StockItem` mutation. */
export type UpdateStockItemPayloadStockItemEdgeArgs = {
  orderBy?: InputMaybe<Array<StockItemsOrderBy>>;
};

/** All input for the `updateStockSupplierById` mutation. */
export type UpdateStockSupplierByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `StockSupplier` being updated. */
  stockSupplierPatch: StockSupplierPatch;
};

/** All input for the `updateStockSupplier` mutation. */
export type UpdateStockSupplierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `StockSupplier` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `StockSupplier` being updated. */
  stockSupplierPatch: StockSupplierPatch;
};

/** The output of our update `StockSupplier` mutation. */
export type UpdateStockSupplierPayload = {
  __typename?: 'UpdateStockSupplierPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `StockSupplier` that was updated by this mutation. */
  stockSupplier?: Maybe<StockSupplier>;
  /** An edge for our `StockSupplier`. May be used by Relay 1. */
  stockSupplierEdge?: Maybe<StockSuppliersEdge>;
  /** Reads a single `User` that is related to this `StockSupplier`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `StockSupplier` mutation. */
export type UpdateStockSupplierPayloadStockSupplierEdgeArgs = {
  orderBy?: InputMaybe<Array<StockSuppliersOrderBy>>;
};

/** All input for the `updateTaskById` mutation. */
export type UpdateTaskByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Task` being updated. */
  taskPatch: TaskPatch;
};

/** All input for the `updateTask` mutation. */
export type UpdateTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Task` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Task` being updated. */
  taskPatch: TaskPatch;
};

/** The output of our update `Task` mutation. */
export type UpdateTaskPayload = {
  __typename?: 'UpdateTaskPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Task` that was updated by this mutation. */
  task?: Maybe<Task>;
  /** An edge for our `Task`. May be used by Relay 1. */
  taskEdge?: Maybe<TasksEdge>;
  /** Reads a single `User` that is related to this `Task`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our update `Task` mutation. */
export type UpdateTaskPayloadTaskEdgeArgs = {
  orderBy?: InputMaybe<Array<TasksOrderBy>>;
};

/** All input for the `updateTempFactopdrachtregelByFactuuropdrachtAndFactuurregel` mutation. */
export type UpdateTempFactopdrachtregelByFactuuropdrachtAndFactuurregelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  factuuropdracht: Scalars['String']['input'];
  factuurregel: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TempFactopdrachtregel` being updated. */
  tempFactopdrachtregelPatch: TempFactopdrachtregelPatch;
};

/** All input for the `updateTempFactopdrachtregelById` mutation. */
export type UpdateTempFactopdrachtregelByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `TempFactopdrachtregel` being updated. */
  tempFactopdrachtregelPatch: TempFactopdrachtregelPatch;
};

/** All input for the `updateTempFactopdrachtregel` mutation. */
export type UpdateTempFactopdrachtregelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempFactopdrachtregel` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TempFactopdrachtregel` being updated. */
  tempFactopdrachtregelPatch: TempFactopdrachtregelPatch;
};

/** The output of our update `TempFactopdrachtregel` mutation. */
export type UpdateTempFactopdrachtregelPayload = {
  __typename?: 'UpdateTempFactopdrachtregelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempFactopdrachtregel` that was updated by this mutation. */
  tempFactopdrachtregel?: Maybe<TempFactopdrachtregel>;
  /** An edge for our `TempFactopdrachtregel`. May be used by Relay 1. */
  tempFactopdrachtregelEdge?: Maybe<TempFactopdrachtregelsEdge>;
};


/** The output of our update `TempFactopdrachtregel` mutation. */
export type UpdateTempFactopdrachtregelPayloadTempFactopdrachtregelEdgeArgs = {
  orderBy?: InputMaybe<Array<TempFactopdrachtregelsOrderBy>>;
};

/** All input for the `updateTempLicenseById` mutation. */
export type UpdateTempLicenseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TempLicense` being updated. */
  tempLicensePatch: TempLicensePatch;
};

/** All input for the `updateTempLicense` mutation. */
export type UpdateTempLicenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempLicense` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TempLicense` being updated. */
  tempLicensePatch: TempLicensePatch;
};

/** The output of our update `TempLicense` mutation. */
export type UpdateTempLicensePayload = {
  __typename?: 'UpdateTempLicensePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempLicense` that was updated by this mutation. */
  tempLicense?: Maybe<TempLicense>;
  /** An edge for our `TempLicense`. May be used by Relay 1. */
  tempLicenseEdge?: Maybe<TempLicensesEdge>;
};


/** The output of our update `TempLicense` mutation. */
export type UpdateTempLicensePayloadTempLicenseEdgeArgs = {
  orderBy?: InputMaybe<Array<TempLicensesOrderBy>>;
};

/** All input for the `updateTempRegistrationById` mutation. */
export type UpdateTempRegistrationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TempRegistration` being updated. */
  tempRegistrationPatch: TempRegistrationPatch;
};

/** All input for the `updateTempRegistrationHistoryById` mutation. */
export type UpdateTempRegistrationHistoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TempRegistrationHistory` being updated. */
  tempRegistrationHistoryPatch: TempRegistrationHistoryPatch;
};

/** All input for the `updateTempRegistrationHistory` mutation. */
export type UpdateTempRegistrationHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempRegistrationHistory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TempRegistrationHistory` being updated. */
  tempRegistrationHistoryPatch: TempRegistrationHistoryPatch;
};

/** The output of our update `TempRegistrationHistory` mutation. */
export type UpdateTempRegistrationHistoryPayload = {
  __typename?: 'UpdateTempRegistrationHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistrationHistory` that was updated by this mutation. */
  tempRegistrationHistory?: Maybe<TempRegistrationHistory>;
  /** An edge for our `TempRegistrationHistory`. May be used by Relay 1. */
  tempRegistrationHistoryEdge?: Maybe<TempRegistrationHistoriesEdge>;
};


/** The output of our update `TempRegistrationHistory` mutation. */
export type UpdateTempRegistrationHistoryPayloadTempRegistrationHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrationHistoriesOrderBy>>;
};

/** All input for the `updateTempRegistration` mutation. */
export type UpdateTempRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempRegistration` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TempRegistration` being updated. */
  tempRegistrationPatch: TempRegistrationPatch;
};

/** The output of our update `TempRegistration` mutation. */
export type UpdateTempRegistrationPayload = {
  __typename?: 'UpdateTempRegistrationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistration` that was updated by this mutation. */
  tempRegistration?: Maybe<TempRegistration>;
  /** An edge for our `TempRegistration`. May be used by Relay 1. */
  tempRegistrationEdge?: Maybe<TempRegistrationsEdge>;
};


/** The output of our update `TempRegistration` mutation. */
export type UpdateTempRegistrationPayloadTempRegistrationEdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrationsOrderBy>>;
};

/** All input for the `updateTempRegistrations2ById` mutation. */
export type UpdateTempRegistrations2ByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TempRegistrations2` being updated. */
  tempRegistrations2Patch: TempRegistrations2Patch;
};

/** All input for the `updateTempRegistrations2` mutation. */
export type UpdateTempRegistrations2Input = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TempRegistrations2` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TempRegistrations2` being updated. */
  tempRegistrations2Patch: TempRegistrations2Patch;
};

/** The output of our update `TempRegistrations2` mutation. */
export type UpdateTempRegistrations2Payload = {
  __typename?: 'UpdateTempRegistrations2Payload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TempRegistrations2` that was updated by this mutation. */
  tempRegistrations2?: Maybe<TempRegistrations2>;
  /** An edge for our `TempRegistrations2`. May be used by Relay 1. */
  tempRegistrations2Edge?: Maybe<TempRegistrations2SEdge>;
};


/** The output of our update `TempRegistrations2` mutation. */
export type UpdateTempRegistrations2PayloadTempRegistrations2EdgeArgs = {
  orderBy?: InputMaybe<Array<TempRegistrations2SOrderBy>>;
};

/** All input for the `updateTestById` mutation. */
export type UpdateTestByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Test` being updated. */
  testPatch: TestPatch;
};

/** All input for the `updateTest` mutation. */
export type UpdateTestInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Test` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Test` being updated. */
  testPatch: TestPatch;
};

/** The output of our update `Test` mutation. */
export type UpdateTestPayload = {
  __typename?: 'UpdateTestPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Test` that was updated by this mutation. */
  test?: Maybe<Test>;
  /** An edge for our `Test`. May be used by Relay 1. */
  testEdge?: Maybe<TestsEdge>;
};


/** The output of our update `Test` mutation. */
export type UpdateTestPayloadTestEdgeArgs = {
  orderBy?: InputMaybe<Array<TestsOrderBy>>;
};

/** All input for the `updateUserById` mutation. */
export type UpdateUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch;
};

/** All input for the `updateUserGroups` mutation. */
export type UpdateUserGroupsInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our `updateUserGroups` mutation. */
export type UpdateUserGroupsPayload = {
  __typename?: 'UpdateUserGroupsPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `User`. */
  groupByGroupId?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our `updateUserGroups` mutation. */
export type UpdateUserGroupsPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Group` that is related to this `User`. */
  groupByGroupId?: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUserRightById` mutation. */
export type UpdateUserRightByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserRight` being updated. */
  userRightPatch: UserRightPatch;
};

/** All input for the `updateUserRightByUserIdAndPath` mutation. */
export type UpdateUserRightByUserIdAndPathInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  path: Scalars['String']['input'];
  userId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserRight` being updated. */
  userRightPatch: UserRightPatch;
};

/** All input for the `updateUserRight` mutation. */
export type UpdateUserRightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserRight` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserRight` being updated. */
  userRightPatch: UserRightPatch;
};

/** The output of our update `UserRight` mutation. */
export type UpdateUserRightPayload = {
  __typename?: 'UpdateUserRightPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserRight`. */
  userByUserId?: Maybe<User>;
  /** The `UserRight` that was updated by this mutation. */
  userRight?: Maybe<UserRight>;
  /** An edge for our `UserRight`. May be used by Relay 1. */
  userRightEdge?: Maybe<UserRightsEdge>;
};


/** The output of our update `UserRight` mutation. */
export type UpdateUserRightPayloadUserRightEdgeArgs = {
  orderBy?: InputMaybe<Array<UserRightsOrderBy>>;
};

/** All input for the `updateUserTaskById` mutation. */
export type UpdateUserTaskByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserTask` being updated. */
  userTaskPatch: UserTaskPatch;
};

/** All input for the `updateUserTaskByUserIdAndTaskId` mutation. */
export type UpdateUserTaskByUserIdAndTaskIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  taskId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserTask` being updated. */
  userTaskPatch: UserTaskPatch;
};

/** All input for the `updateUserTask` mutation. */
export type UpdateUserTaskInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserTask` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserTask` being updated. */
  userTaskPatch: UserTaskPatch;
};

/** The output of our update `UserTask` mutation. */
export type UpdateUserTaskPayload = {
  __typename?: 'UpdateUserTaskPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `UserTask`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `UserTask`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `UserTask`. */
  userByUserId?: Maybe<User>;
  /** The `UserTask` that was updated by this mutation. */
  userTask?: Maybe<UserTask>;
  /** An edge for our `UserTask`. May be used by Relay 1. */
  userTaskEdge?: Maybe<UserTasksEdge>;
};


/** The output of our update `UserTask` mutation. */
export type UpdateUserTaskPayloadUserTaskEdgeArgs = {
  orderBy?: InputMaybe<Array<UserTasksOrderBy>>;
};

/** All input for the `updateVoorradenByCdartikelAndCdmagazijn` mutation. */
export type UpdateVoorradenByCdartikelAndCdmagazijnInput = {
  cdartikel: Scalars['String']['input'];
  cdmagazijn: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Voorraden` being updated. */
  voorradenPatch: VoorradenPatch;
};

/** All input for the `updateVoorraden` mutation. */
export type UpdateVoorradenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Voorraden` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Voorraden` being updated. */
  voorradenPatch: VoorradenPatch;
};

/** All input for the `updateVoorradenLogById` mutation. */
export type UpdateVoorradenLogByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `VoorradenLog` being updated. */
  voorradenLogPatch: VoorradenLogPatch;
};

/** All input for the `updateVoorradenLog` mutation. */
export type UpdateVoorradenLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `VoorradenLog` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `VoorradenLog` being updated. */
  voorradenLogPatch: VoorradenLogPatch;
};

/** The output of our update `VoorradenLog` mutation. */
export type UpdateVoorradenLogPayload = {
  __typename?: 'UpdateVoorradenLogPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VoorradenLog` that was updated by this mutation. */
  voorradenLog?: Maybe<VoorradenLog>;
  /** An edge for our `VoorradenLog`. May be used by Relay 1. */
  voorradenLogEdge?: Maybe<VoorradenLogsEdge>;
};


/** The output of our update `VoorradenLog` mutation. */
export type UpdateVoorradenLogPayloadVoorradenLogEdgeArgs = {
  orderBy?: InputMaybe<Array<VoorradenLogsOrderBy>>;
};

/** The output of our update `Voorraden` mutation. */
export type UpdateVoorradenPayload = {
  __typename?: 'UpdateVoorradenPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Voorraden` that was updated by this mutation. */
  voorraden?: Maybe<Voorraden>;
  /** An edge for our `Voorraden`. May be used by Relay 1. */
  voorradenEdge?: Maybe<VoorradensEdge>;
};


/** The output of our update `Voorraden` mutation. */
export type UpdateVoorradenPayloadVoorradenEdgeArgs = {
  orderBy?: InputMaybe<Array<VoorradensOrderBy>>;
};

/** All input for the `updateWeeklyHourById` mutation. */
export type UpdateWeeklyHourByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `WeeklyHour` being updated. */
  weeklyHourPatch: WeeklyHourPatch;
};

/** All input for the `updateWeeklyHour` mutation. */
export type UpdateWeeklyHourInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WeeklyHour` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `WeeklyHour` being updated. */
  weeklyHourPatch: WeeklyHourPatch;
};

/** The output of our update `WeeklyHour` mutation. */
export type UpdateWeeklyHourPayload = {
  __typename?: 'UpdateWeeklyHourPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `WeeklyHour`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `WeeklyHour`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `WeeklyHour`. */
  userByUserId?: Maybe<User>;
  /** The `WeeklyHour` that was updated by this mutation. */
  weeklyHour?: Maybe<WeeklyHour>;
  /** An edge for our `WeeklyHour`. May be used by Relay 1. */
  weeklyHourEdge?: Maybe<WeeklyHoursEdge>;
};


/** The output of our update `WeeklyHour` mutation. */
export type UpdateWeeklyHourPayloadWeeklyHourEdgeArgs = {
  orderBy?: InputMaybe<Array<WeeklyHoursOrderBy>>;
};

/** All input for the `updateWeeklyHourRemarkById` mutation. */
export type UpdateWeeklyHourRemarkByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `WeeklyHourRemark` being updated. */
  weeklyHourRemarkPatch: WeeklyHourRemarkPatch;
};

/** All input for the `updateWeeklyHourRemarkByUserIdAndTaskIdAndDate` mutation. */
export type UpdateWeeklyHourRemarkByUserIdAndTaskIdAndDateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Date']['input'];
  taskId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `WeeklyHourRemark` being updated. */
  weeklyHourRemarkPatch: WeeklyHourRemarkPatch;
};

/** All input for the `updateWeeklyHourRemark` mutation. */
export type UpdateWeeklyHourRemarkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `WeeklyHourRemark` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `WeeklyHourRemark` being updated. */
  weeklyHourRemarkPatch: WeeklyHourRemarkPatch;
};

/** The output of our update `WeeklyHourRemark` mutation. */
export type UpdateWeeklyHourRemarkPayload = {
  __typename?: 'UpdateWeeklyHourRemarkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Task` that is related to this `WeeklyHourRemark`. */
  taskByTaskId?: Maybe<Task>;
  /** Reads a single `User` that is related to this `WeeklyHourRemark`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `WeeklyHourRemark`. */
  userByUserId?: Maybe<User>;
  /** The `WeeklyHourRemark` that was updated by this mutation. */
  weeklyHourRemark?: Maybe<WeeklyHourRemark>;
  /** An edge for our `WeeklyHourRemark`. May be used by Relay 1. */
  weeklyHourRemarkEdge?: Maybe<WeeklyHourRemarksEdge>;
};


/** The output of our update `WeeklyHourRemark` mutation. */
export type UpdateWeeklyHourRemarkPayloadWeeklyHourRemarkEdgeArgs = {
  orderBy?: InputMaybe<Array<WeeklyHourRemarksOrderBy>>;
};

/** All input for the `upsertDetectorSensorBySensorId` mutation. */
export type UpsertDetectorSensorBySensorIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  detectorId?: InputMaybe<Scalars['Int']['input']>;
  detectorPosition?: InputMaybe<Scalars['Int']['input']>;
  filterId?: InputMaybe<Scalars['Int']['input']>;
  pyrolyserId?: InputMaybe<Scalars['Int']['input']>;
  sensorId?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our `upsertDetectorSensorBySensorId` mutation. */
export type UpsertDetectorSensorBySensorIdPayload = {
  __typename?: 'UpsertDetectorSensorBySensorIdPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Detector` that is related to this `DetectorSensor`. */
  detectorByDetectorId?: Maybe<Detector>;
  detectorSensor?: Maybe<DetectorSensor>;
  /** An edge for our `DetectorSensor`. May be used by Relay 1. */
  detectorSensorEdge?: Maybe<DetectorSensorsEdge>;
  /** Reads a single `Filter` that is related to this `DetectorSensor`. */
  filterByFilterId?: Maybe<Filter>;
  /** Reads a single `Pyrolyser` that is related to this `DetectorSensor`. */
  pyrolyserByPyrolyserId?: Maybe<Pyrolyser>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Sensor` that is related to this `DetectorSensor`. */
  sensorBySensorId?: Maybe<Sensor>;
  /** Reads a single `User` that is related to this `DetectorSensor`. */
  userByOwnerId?: Maybe<User>;
};


/** The output of our `upsertDetectorSensorBySensorId` mutation. */
export type UpsertDetectorSensorBySensorIdPayloadDetectorSensorEdgeArgs = {
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};

export type User = Node & {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `Action`. */
  actionsByOwnerId: ActionsConnection;
  /** Reads and enables pagination through a set of `Action`. */
  actionsByUserId: ActionsConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applicationsByOwnerId: ApplicationsConnection;
  /** Reads and enables pagination through a set of `Area`. */
  areasByOwnerId: AreasConnection;
  /** Reads and enables pagination through a set of `Assembly`. */
  assembliesByOwnerId: AssembliesConnection;
  /** Reads and enables pagination through a set of `AssemblyPart`. */
  assemblyPartsByOwnerId: AssemblyPartsConnection;
  /** Reads and enables pagination through a set of `AssemblyTypePart`. */
  assemblyTypePartsByOwnerId: AssemblyTypePartsConnection;
  /** Reads and enables pagination through a set of `AssemblyType`. */
  assemblyTypesByOwnerId: AssemblyTypesConnection;
  /** Reads and enables pagination through a set of `Building`. */
  buildingsByOwnerId: BuildingsConnection;
  /** Reads and enables pagination through a set of `CalGas`. */
  calGasesByOwnerId: CalGasesConnection;
  /** Reads and enables pagination through a set of `CatalogGroup`. */
  catalogGroupsByOwnerId: CatalogGroupsConnection;
  /** Reads and enables pagination through a set of `CatalogItemFile`. */
  catalogItemFilesByOwnerId: CatalogItemFilesConnection;
  /** Reads and enables pagination through a set of `CatalogItem`. */
  catalogItemsByOwnerId: CatalogItemsConnection;
  /** Reads and enables pagination through a set of `CatalogSubGroup`. */
  catalogSubGroupsByOwnerId: CatalogSubGroupsConnection;
  /** Reads and enables pagination through a set of `ChemicalCompound`. */
  chemicalCompoundsByOwnerId: ChemicalCompoundsConnection;
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `DetectorLocation`. */
  detectorLocationsByOwnerId: DetectorLocationsConnection;
  /** Reads and enables pagination through a set of `DetectorOrder`. */
  detectorOrdersByOwnerId: DetectorOrdersConnection;
  /** Reads and enables pagination through a set of `DetectorSensorLocation`. */
  detectorSensorLocationsByOwnerId: DetectorSensorLocationsConnection;
  /** Reads and enables pagination through a set of `DetectorSensorType`. */
  detectorSensorTypesByOwnerId: DetectorSensorTypesConnection;
  /** Reads and enables pagination through a set of `DetectorSensor`. */
  detectorSensorsByOwnerId: DetectorSensorsConnection;
  /** Reads and enables pagination through a set of `DetectorType`. */
  detectorTypesByOwnerId: DetectorTypesConnection;
  /** Reads and enables pagination through a set of `Detector`. */
  detectorsByOwnerId: DetectorsConnection;
  /** Reads and enables pagination through a set of `DpCard`. */
  dpCardsByOwnerId: DpCardsConnection;
  /** Reads and enables pagination through a set of `Electrolyte`. */
  electrolytesByOwnerId: ElectrolytesConnection;
  /** Reads and enables pagination through a set of `EndUser`. */
  endUsersByOwnerId: EndUsersConnection;
  /** Reads and enables pagination through a set of `FactopdrachtregelLineRemark`. */
  factopdrachtregelLineRemarksByUserId: FactopdrachtregelLineRemarksConnection;
  /** Reads and enables pagination through a set of `Factuur`. */
  factuursByCheckedId: FactuursConnection;
  /** Reads and enables pagination through a set of `Factuur`. */
  factuursByOwnerId: FactuursConnection;
  /** Reads and enables pagination through a set of `Factuur`. */
  factuursBySentId: FactuursConnection;
  /** Reads and enables pagination through a set of `Filter`. */
  filtersByOwnerId: FiltersConnection;
  /** Reads and enables pagination through a set of `Floor`. */
  floorsByOwnerId: FloorsConnection;
  fullname?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Gas`. */
  gasesByOwnerId: GasesConnection;
  /** Reads a single `Group` that is related to this `User`. */
  groupByGroupId?: Maybe<Group>;
  groupId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Group`. */
  groupsByOwnerId: GroupsConnection;
  /** Reads and enables pagination through a set of `Hardware`. */
  hardwaresByOwnerId: HardwaresConnection;
  /** Reads and enables pagination through a set of `Hardware`. */
  hardwaresByUserId: HardwaresConnection;
  holidayStartBalance?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `IncomingDocument`. */
  incomingDocumentsByOwnerId: IncomingDocumentsConnection;
  /** Reads and enables pagination through a set of `IncomingDocument`. */
  incomingDocumentsByUserId: IncomingDocumentsConnection;
  initials?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Item`. */
  itemsByOwnerId: ItemsConnection;
  /** Reads and enables pagination through a set of `Job`. */
  jobsByOwnerId: JobsConnection;
  /** Reads and enables pagination through a set of `JunctionBox`. */
  junctionBoxesByOwnerId: JunctionBoxesConnection;
  /** Reads and enables pagination through a set of `Lead`. */
  leadsByOwnerId: LeadsConnection;
  /** Reads and enables pagination through a set of `LicenseCustomer`. */
  licenseCustomersByOwnerId: LicenseCustomersConnection;
  /** Reads and enables pagination through a set of `LicenseModule`. */
  licenseModulesByOwnerId: LicenseModulesConnection;
  /** Reads and enables pagination through a set of `LicenseOrder`. */
  licenseOrdersByOwnerId: LicenseOrdersConnection;
  /** Reads and enables pagination through a set of `LicenseRegistration`. */
  licenseRegistrationsByOwnerId: LicenseRegistrationsConnection;
  /** Reads and enables pagination through a set of `License`. */
  licensesByOwnerId: LicensesConnection;
  /** Reads and enables pagination through a set of `MaintenanceVisit`. */
  maintenanceVisitsByOwnerId: MaintenanceVisitsConnection;
  /** Reads and enables pagination through a set of `MaintenanceVisit`. */
  maintenanceVisitsByUserId: MaintenanceVisitsConnection;
  /** Reads and enables pagination through a set of `Membrane`. */
  membranesByOwnerId: MembranesConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `ORing`. */
  oRingsByOwnerId: ORingsConnection;
  /** Reads and enables pagination through a set of `OfferteRemark`. */
  offerteRemarksByOwnerId: OfferteRemarksConnection;
  /** Reads and enables pagination through a set of `Opportunity`. */
  opportunitiesByOwnerId: OpportunitiesConnection;
  overtimeStartBalance?: Maybe<Scalars['Int']['output']>;
  password?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Plug`. */
  plugsByOwnerId: PlugsConnection;
  /** Reads and enables pagination through a set of `Principle`. */
  principlesByOwnerId: PrinciplesConnection;
  /** Reads and enables pagination through a set of `Pyrolyser`. */
  pyrolysersByOwnerId: PyrolysersConnection;
  /** Reads and enables pagination through a set of `Range`. */
  rangesByOwnerId: RangesConnection;
  /** Reads and enables pagination through a set of `RcCard`. */
  rcCardsByOwnerId: RcCardsConnection;
  /** Reads and enables pagination through a set of `Report`. */
  reportsByOwnerId: ReportsConnection;
  /** Reads and enables pagination through a set of `Report`. */
  reportsByUserId: ReportsConnection;
  /** Reads and enables pagination through a set of `Request`. */
  requestsByOwnerId: RequestsConnection;
  /** Reads and enables pagination through a set of `RxCard`. */
  rxCardsByOwnerId: RxCardsConnection;
  /** Reads and enables pagination through a set of `SamplePoint`. */
  samplePointsByOwnerId: SamplePointsConnection;
  /** Reads and enables pagination through a set of `SensorElementLocation`. */
  sensorElementLocationsByOwnerId: SensorElementLocationsConnection;
  /** Reads and enables pagination through a set of `SensorElementType`. */
  sensorElementTypesByOwnerId: SensorElementTypesConnection;
  /** Reads and enables pagination through a set of `SensorElement`. */
  sensorElementsByOwnerId: SensorElementsConnection;
  /** Reads and enables pagination through a set of `SensorOrder`. */
  sensorOrdersByCheckedUserId: SensorOrdersConnection;
  /** Reads and enables pagination through a set of `SensorOrder`. */
  sensorOrdersByOwnerId: SensorOrdersConnection;
  /** Reads and enables pagination through a set of `SensorOrder`. */
  sensorOrdersByVerifiedUserId: SensorOrdersConnection;
  /** Reads and enables pagination through a set of `SensorSensorElement`. */
  sensorSensorElementsByOwnerId: SensorSensorElementsConnection;
  /** Reads and enables pagination through a set of `SensorTestResult`. */
  sensorTestResultsByOwnerId: SensorTestResultsConnection;
  /** Reads and enables pagination through a set of `SensorTestResult`. */
  sensorTestResultsByUserId: SensorTestResultsConnection;
  /** Reads and enables pagination through a set of `SensorType`. */
  sensorTypesByOwnerId: SensorTypesConnection;
  /** Reads and enables pagination through a set of `Sensor`. */
  sensorsByOwnerId: SensorsConnection;
  /** Reads and enables pagination through a set of `Software`. */
  softwaresByOwnerId: SoftwaresConnection;
  /** Reads and enables pagination through a set of `StockGroup`. */
  stockGroupsByOwnerId: StockGroupsConnection;
  /** Reads and enables pagination through a set of `StockItem`. */
  stockItemsByOwnerId: StockItemsConnection;
  /** Reads and enables pagination through a set of `StockSupplier`. */
  stockSuppliersByOwnerId: StockSuppliersConnection;
  /** Reads and enables pagination through a set of `Task`. */
  tasksByOwnerId: TasksConnection;
  url?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `UserRight`. */
  userRightsByUserId: UserRightsConnection;
  /** Reads and enables pagination through a set of `UserTask`. */
  userTasksByOwnerId: UserTasksConnection;
  /** Reads and enables pagination through a set of `UserTask`. */
  userTasksByUserId: UserTasksConnection;
  username?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `UsersGroup`. */
  usersGroupsByUserId: UsersGroupsConnection;
  /** Reads and enables pagination through a set of `WeeklyHourRemark`. */
  weeklyHourRemarksByOwnerId: WeeklyHourRemarksConnection;
  /** Reads and enables pagination through a set of `WeeklyHourRemark`. */
  weeklyHourRemarksByUserId: WeeklyHourRemarksConnection;
  /** Reads and enables pagination through a set of `WeeklyHour`. */
  weeklyHoursByOwnerId: WeeklyHoursConnection;
  /** Reads and enables pagination through a set of `WeeklyHour`. */
  weeklyHoursByUserId: WeeklyHoursConnection;
  weeklyHoursFullAccess: Scalars['Boolean']['output'];
};


export type UserActionsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionCondition>;
  filter?: InputMaybe<ActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionsOrderBy>>;
};


export type UserActionsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionCondition>;
  filter?: InputMaybe<ActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionsOrderBy>>;
};


export type UserApplicationsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


export type UserAreasByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AreaCondition>;
  filter?: InputMaybe<AreaFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AreasOrderBy>>;
};


export type UserAssembliesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyCondition>;
  filter?: InputMaybe<AssemblyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssembliesOrderBy>>;
};


export type UserAssemblyPartsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyPartCondition>;
  filter?: InputMaybe<AssemblyPartFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyPartsOrderBy>>;
};


export type UserAssemblyTypePartsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyTypePartCondition>;
  filter?: InputMaybe<AssemblyTypePartFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyTypePartsOrderBy>>;
};


export type UserAssemblyTypesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssemblyTypeCondition>;
  filter?: InputMaybe<AssemblyTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssemblyTypesOrderBy>>;
};


export type UserBuildingsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BuildingCondition>;
  filter?: InputMaybe<BuildingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BuildingsOrderBy>>;
};


export type UserCalGasesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CalGasCondition>;
  filter?: InputMaybe<CalGasFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CalGasesOrderBy>>;
};


export type UserCatalogGroupsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogGroupCondition>;
  filter?: InputMaybe<CatalogGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogGroupsOrderBy>>;
};


export type UserCatalogItemFilesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemFileCondition>;
  filter?: InputMaybe<CatalogItemFileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemFilesOrderBy>>;
};


export type UserCatalogItemsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogItemCondition>;
  filter?: InputMaybe<CatalogItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogItemsOrderBy>>;
};


export type UserCatalogSubGroupsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CatalogSubGroupCondition>;
  filter?: InputMaybe<CatalogSubGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CatalogSubGroupsOrderBy>>;
};


export type UserChemicalCompoundsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ChemicalCompoundCondition>;
  filter?: InputMaybe<ChemicalCompoundFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ChemicalCompoundsOrderBy>>;
};


export type UserDetectorLocationsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorLocationCondition>;
  filter?: InputMaybe<DetectorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorLocationsOrderBy>>;
};


export type UserDetectorOrdersByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorOrderCondition>;
  filter?: InputMaybe<DetectorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorOrdersOrderBy>>;
};


export type UserDetectorSensorLocationsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorLocationCondition>;
  filter?: InputMaybe<DetectorSensorLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorLocationsOrderBy>>;
};


export type UserDetectorSensorTypesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorTypeCondition>;
  filter?: InputMaybe<DetectorSensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorTypesOrderBy>>;
};


export type UserDetectorSensorsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorSensorCondition>;
  filter?: InputMaybe<DetectorSensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorSensorsOrderBy>>;
};


export type UserDetectorTypesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorTypeCondition>;
  filter?: InputMaybe<DetectorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorTypesOrderBy>>;
};


export type UserDetectorsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DetectorCondition>;
  filter?: InputMaybe<DetectorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DetectorsOrderBy>>;
};


export type UserDpCardsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DpCardCondition>;
  filter?: InputMaybe<DpCardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DpCardsOrderBy>>;
};


export type UserElectrolytesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ElectrolyteCondition>;
  filter?: InputMaybe<ElectrolyteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ElectrolytesOrderBy>>;
};


export type UserEndUsersByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EndUserCondition>;
  filter?: InputMaybe<EndUserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EndUsersOrderBy>>;
};


export type UserFactopdrachtregelLineRemarksByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactopdrachtregelLineRemarkCondition>;
  filter?: InputMaybe<FactopdrachtregelLineRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactopdrachtregelLineRemarksOrderBy>>;
};


export type UserFactuursByCheckedIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactuurCondition>;
  filter?: InputMaybe<FactuurFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactuursOrderBy>>;
};


export type UserFactuursByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactuurCondition>;
  filter?: InputMaybe<FactuurFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactuursOrderBy>>;
};


export type UserFactuursBySentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FactuurCondition>;
  filter?: InputMaybe<FactuurFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FactuursOrderBy>>;
};


export type UserFiltersByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FilterCondition>;
  filter?: InputMaybe<FilterFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};


export type UserFloorsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FloorCondition>;
  filter?: InputMaybe<FloorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FloorsOrderBy>>;
};


export type UserGasesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GasCondition>;
  filter?: InputMaybe<GasFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GasesOrderBy>>;
};


export type UserGroupsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GroupCondition>;
  filter?: InputMaybe<GroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GroupsOrderBy>>;
};


export type UserHardwaresByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<HardwareCondition>;
  filter?: InputMaybe<HardwareFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<HardwaresOrderBy>>;
};


export type UserHardwaresByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<HardwareCondition>;
  filter?: InputMaybe<HardwareFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<HardwaresOrderBy>>;
};


export type UserIncomingDocumentsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<IncomingDocumentCondition>;
  filter?: InputMaybe<IncomingDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IncomingDocumentsOrderBy>>;
};


export type UserIncomingDocumentsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<IncomingDocumentCondition>;
  filter?: InputMaybe<IncomingDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IncomingDocumentsOrderBy>>;
};


export type UserItemsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ItemCondition>;
  filter?: InputMaybe<ItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
};


export type UserJobsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JobCondition>;
  filter?: InputMaybe<JobFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JobsOrderBy>>;
};


export type UserJunctionBoxesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<JunctionBoxCondition>;
  filter?: InputMaybe<JunctionBoxFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<JunctionBoxesOrderBy>>;
};


export type UserLeadsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LeadCondition>;
  filter?: InputMaybe<LeadFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};


export type UserLicenseCustomersByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseCustomerCondition>;
  filter?: InputMaybe<LicenseCustomerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseCustomersOrderBy>>;
};


export type UserLicenseModulesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseModuleCondition>;
  filter?: InputMaybe<LicenseModuleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseModulesOrderBy>>;
};


export type UserLicenseOrdersByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseOrderCondition>;
  filter?: InputMaybe<LicenseOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseOrdersOrderBy>>;
};


export type UserLicenseRegistrationsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseRegistrationCondition>;
  filter?: InputMaybe<LicenseRegistrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicenseRegistrationsOrderBy>>;
};


export type UserLicensesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LicenseCondition>;
  filter?: InputMaybe<LicenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LicensesOrderBy>>;
};


export type UserMaintenanceVisitsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitCondition>;
  filter?: InputMaybe<MaintenanceVisitFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsOrderBy>>;
};


export type UserMaintenanceVisitsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MaintenanceVisitCondition>;
  filter?: InputMaybe<MaintenanceVisitFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MaintenanceVisitsOrderBy>>;
};


export type UserMembranesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MembraneCondition>;
  filter?: InputMaybe<MembraneFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MembranesOrderBy>>;
};


export type UserORingsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ORingCondition>;
  filter?: InputMaybe<ORingFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ORingsOrderBy>>;
};


export type UserOfferteRemarksByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OfferteRemarkCondition>;
  filter?: InputMaybe<OfferteRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OfferteRemarksOrderBy>>;
};


export type UserOpportunitiesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OpportunityCondition>;
  filter?: InputMaybe<OpportunityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};


export type UserPlugsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PlugCondition>;
  filter?: InputMaybe<PlugFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PlugsOrderBy>>;
};


export type UserPrinciplesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PrincipleCondition>;
  filter?: InputMaybe<PrincipleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PrinciplesOrderBy>>;
};


export type UserPyrolysersByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PyrolyserCondition>;
  filter?: InputMaybe<PyrolyserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PyrolysersOrderBy>>;
};


export type UserRangesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RangeCondition>;
  filter?: InputMaybe<RangeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RangesOrderBy>>;
};


export type UserRcCardsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RcCardCondition>;
  filter?: InputMaybe<RcCardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RcCardsOrderBy>>;
};


export type UserReportsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportCondition>;
  filter?: InputMaybe<ReportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};


export type UserReportsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReportCondition>;
  filter?: InputMaybe<ReportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};


export type UserRequestsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RequestCondition>;
  filter?: InputMaybe<RequestFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RequestsOrderBy>>;
};


export type UserRxCardsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<RxCardCondition>;
  filter?: InputMaybe<RxCardFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RxCardsOrderBy>>;
};


export type UserSamplePointsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SamplePointCondition>;
  filter?: InputMaybe<SamplePointFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SamplePointsOrderBy>>;
};


export type UserSensorElementLocationsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementLocationCondition>;
  filter?: InputMaybe<SensorElementLocationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementLocationsOrderBy>>;
};


export type UserSensorElementTypesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementTypeCondition>;
  filter?: InputMaybe<SensorElementTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementTypesOrderBy>>;
};


export type UserSensorElementsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorElementCondition>;
  filter?: InputMaybe<SensorElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorElementsOrderBy>>;
};


export type UserSensorOrdersByCheckedUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorOrderCondition>;
  filter?: InputMaybe<SensorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};


export type UserSensorOrdersByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorOrderCondition>;
  filter?: InputMaybe<SensorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};


export type UserSensorOrdersByVerifiedUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorOrderCondition>;
  filter?: InputMaybe<SensorOrderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorOrdersOrderBy>>;
};


export type UserSensorSensorElementsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorSensorElementCondition>;
  filter?: InputMaybe<SensorSensorElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorSensorElementsOrderBy>>;
};


export type UserSensorTestResultsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTestResultCondition>;
  filter?: InputMaybe<SensorTestResultFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};


export type UserSensorTestResultsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTestResultCondition>;
  filter?: InputMaybe<SensorTestResultFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTestResultsOrderBy>>;
};


export type UserSensorTypesByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorTypeCondition>;
  filter?: InputMaybe<SensorTypeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorTypesOrderBy>>;
};


export type UserSensorsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SensorCondition>;
  filter?: InputMaybe<SensorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SensorsOrderBy>>;
};


export type UserSoftwaresByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SoftwareCondition>;
  filter?: InputMaybe<SoftwareFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SoftwaresOrderBy>>;
};


export type UserStockGroupsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockGroupCondition>;
  filter?: InputMaybe<StockGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockGroupsOrderBy>>;
};


export type UserStockItemsByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockItemCondition>;
  filter?: InputMaybe<StockItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockItemsOrderBy>>;
};


export type UserStockSuppliersByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<StockSupplierCondition>;
  filter?: InputMaybe<StockSupplierFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StockSuppliersOrderBy>>;
};


export type UserTasksByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TaskCondition>;
  filter?: InputMaybe<TaskFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TasksOrderBy>>;
};


export type UserUserRightsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserRightCondition>;
  filter?: InputMaybe<UserRightFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRightsOrderBy>>;
};


export type UserUserTasksByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserTaskCondition>;
  filter?: InputMaybe<UserTaskFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserTasksOrderBy>>;
};


export type UserUserTasksByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserTaskCondition>;
  filter?: InputMaybe<UserTaskFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserTasksOrderBy>>;
};


export type UserUsersGroupsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UsersGroupCondition>;
  filter?: InputMaybe<UsersGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersGroupsOrderBy>>;
};


export type UserWeeklyHourRemarksByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHourRemarkCondition>;
  filter?: InputMaybe<WeeklyHourRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHourRemarksOrderBy>>;
};


export type UserWeeklyHourRemarksByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHourRemarkCondition>;
  filter?: InputMaybe<WeeklyHourRemarkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHourRemarksOrderBy>>;
};


export type UserWeeklyHoursByOwnerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHourCondition>;
  filter?: InputMaybe<WeeklyHourFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHoursOrderBy>>;
};


export type UserWeeklyHoursByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WeeklyHourCondition>;
  filter?: InputMaybe<WeeklyHourFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WeeklyHoursOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fullname` field. */
  fullname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `holidayStartBalance` field. */
  holidayStartBalance?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initials` field. */
  initials?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `overtimeStartBalance` field. */
  overtimeStartBalance?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `password` field. */
  password?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `weeklyHoursFullAccess` field. */
  weeklyHoursFullAccess?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `actionsByOwnerId` relation. */
  actionsByOwnerId?: InputMaybe<UserToManyActionFilter>;
  /** Some related `actionsByOwnerId` exist. */
  actionsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `actionsByUserId` relation. */
  actionsByUserId?: InputMaybe<UserToManyActionFilter>;
  /** Some related `actionsByUserId` exist. */
  actionsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `applicationsByOwnerId` relation. */
  applicationsByOwnerId?: InputMaybe<UserToManyApplicationFilter>;
  /** Some related `applicationsByOwnerId` exist. */
  applicationsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `areasByOwnerId` relation. */
  areasByOwnerId?: InputMaybe<UserToManyAreaFilter>;
  /** Some related `areasByOwnerId` exist. */
  areasByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assembliesByOwnerId` relation. */
  assembliesByOwnerId?: InputMaybe<UserToManyAssemblyFilter>;
  /** Some related `assembliesByOwnerId` exist. */
  assembliesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assemblyPartsByOwnerId` relation. */
  assemblyPartsByOwnerId?: InputMaybe<UserToManyAssemblyPartFilter>;
  /** Some related `assemblyPartsByOwnerId` exist. */
  assemblyPartsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assemblyTypePartsByOwnerId` relation. */
  assemblyTypePartsByOwnerId?: InputMaybe<UserToManyAssemblyTypePartFilter>;
  /** Some related `assemblyTypePartsByOwnerId` exist. */
  assemblyTypePartsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assemblyTypesByOwnerId` relation. */
  assemblyTypesByOwnerId?: InputMaybe<UserToManyAssemblyTypeFilter>;
  /** Some related `assemblyTypesByOwnerId` exist. */
  assemblyTypesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `buildingsByOwnerId` relation. */
  buildingsByOwnerId?: InputMaybe<UserToManyBuildingFilter>;
  /** Some related `buildingsByOwnerId` exist. */
  buildingsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `calGasesByOwnerId` relation. */
  calGasesByOwnerId?: InputMaybe<UserToManyCalGasFilter>;
  /** Some related `calGasesByOwnerId` exist. */
  calGasesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `catalogGroupsByOwnerId` relation. */
  catalogGroupsByOwnerId?: InputMaybe<UserToManyCatalogGroupFilter>;
  /** Some related `catalogGroupsByOwnerId` exist. */
  catalogGroupsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `catalogItemFilesByOwnerId` relation. */
  catalogItemFilesByOwnerId?: InputMaybe<UserToManyCatalogItemFileFilter>;
  /** Some related `catalogItemFilesByOwnerId` exist. */
  catalogItemFilesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `catalogItemsByOwnerId` relation. */
  catalogItemsByOwnerId?: InputMaybe<UserToManyCatalogItemFilter>;
  /** Some related `catalogItemsByOwnerId` exist. */
  catalogItemsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `catalogSubGroupsByOwnerId` relation. */
  catalogSubGroupsByOwnerId?: InputMaybe<UserToManyCatalogSubGroupFilter>;
  /** Some related `catalogSubGroupsByOwnerId` exist. */
  catalogSubGroupsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `chemicalCompoundsByOwnerId` relation. */
  chemicalCompoundsByOwnerId?: InputMaybe<UserToManyChemicalCompoundFilter>;
  /** Some related `chemicalCompoundsByOwnerId` exist. */
  chemicalCompoundsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `detectorLocationsByOwnerId` relation. */
  detectorLocationsByOwnerId?: InputMaybe<UserToManyDetectorLocationFilter>;
  /** Some related `detectorLocationsByOwnerId` exist. */
  detectorLocationsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorOrdersByOwnerId` relation. */
  detectorOrdersByOwnerId?: InputMaybe<UserToManyDetectorOrderFilter>;
  /** Some related `detectorOrdersByOwnerId` exist. */
  detectorOrdersByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorSensorLocationsByOwnerId` relation. */
  detectorSensorLocationsByOwnerId?: InputMaybe<UserToManyDetectorSensorLocationFilter>;
  /** Some related `detectorSensorLocationsByOwnerId` exist. */
  detectorSensorLocationsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorSensorTypesByOwnerId` relation. */
  detectorSensorTypesByOwnerId?: InputMaybe<UserToManyDetectorSensorTypeFilter>;
  /** Some related `detectorSensorTypesByOwnerId` exist. */
  detectorSensorTypesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorSensorsByOwnerId` relation. */
  detectorSensorsByOwnerId?: InputMaybe<UserToManyDetectorSensorFilter>;
  /** Some related `detectorSensorsByOwnerId` exist. */
  detectorSensorsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorTypesByOwnerId` relation. */
  detectorTypesByOwnerId?: InputMaybe<UserToManyDetectorTypeFilter>;
  /** Some related `detectorTypesByOwnerId` exist. */
  detectorTypesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `detectorsByOwnerId` relation. */
  detectorsByOwnerId?: InputMaybe<UserToManyDetectorFilter>;
  /** Some related `detectorsByOwnerId` exist. */
  detectorsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dpCardsByOwnerId` relation. */
  dpCardsByOwnerId?: InputMaybe<UserToManyDpCardFilter>;
  /** Some related `dpCardsByOwnerId` exist. */
  dpCardsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `electrolytesByOwnerId` relation. */
  electrolytesByOwnerId?: InputMaybe<UserToManyElectrolyteFilter>;
  /** Some related `electrolytesByOwnerId` exist. */
  electrolytesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `endUsersByOwnerId` relation. */
  endUsersByOwnerId?: InputMaybe<UserToManyEndUserFilter>;
  /** Some related `endUsersByOwnerId` exist. */
  endUsersByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `factopdrachtregelLineRemarksByUserId` relation. */
  factopdrachtregelLineRemarksByUserId?: InputMaybe<UserToManyFactopdrachtregelLineRemarkFilter>;
  /** Some related `factopdrachtregelLineRemarksByUserId` exist. */
  factopdrachtregelLineRemarksByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `factuursByCheckedId` relation. */
  factuursByCheckedId?: InputMaybe<UserToManyFactuurFilter>;
  /** Some related `factuursByCheckedId` exist. */
  factuursByCheckedIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `factuursByOwnerId` relation. */
  factuursByOwnerId?: InputMaybe<UserToManyFactuurFilter>;
  /** Some related `factuursByOwnerId` exist. */
  factuursByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `factuursBySentId` relation. */
  factuursBySentId?: InputMaybe<UserToManyFactuurFilter>;
  /** Some related `factuursBySentId` exist. */
  factuursBySentIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `filtersByOwnerId` relation. */
  filtersByOwnerId?: InputMaybe<UserToManyFilterFilter>;
  /** Some related `filtersByOwnerId` exist. */
  filtersByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `floorsByOwnerId` relation. */
  floorsByOwnerId?: InputMaybe<UserToManyFloorFilter>;
  /** Some related `floorsByOwnerId` exist. */
  floorsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `fullname` field. */
  fullname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gasesByOwnerId` relation. */
  gasesByOwnerId?: InputMaybe<UserToManyGasFilter>;
  /** Some related `gasesByOwnerId` exist. */
  gasesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `groupByGroupId` relation. */
  groupByGroupId?: InputMaybe<GroupFilter>;
  /** A related `groupByGroupId` exists. */
  groupByGroupIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `groupsByOwnerId` relation. */
  groupsByOwnerId?: InputMaybe<UserToManyGroupFilter>;
  /** Some related `groupsByOwnerId` exist. */
  groupsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `hardwaresByOwnerId` relation. */
  hardwaresByOwnerId?: InputMaybe<UserToManyHardwareFilter>;
  /** Some related `hardwaresByOwnerId` exist. */
  hardwaresByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `hardwaresByUserId` relation. */
  hardwaresByUserId?: InputMaybe<UserToManyHardwareFilter>;
  /** Some related `hardwaresByUserId` exist. */
  hardwaresByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `holidayStartBalance` field. */
  holidayStartBalance?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `incomingDocumentsByOwnerId` relation. */
  incomingDocumentsByOwnerId?: InputMaybe<UserToManyIncomingDocumentFilter>;
  /** Some related `incomingDocumentsByOwnerId` exist. */
  incomingDocumentsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `incomingDocumentsByUserId` relation. */
  incomingDocumentsByUserId?: InputMaybe<UserToManyIncomingDocumentFilter>;
  /** Some related `incomingDocumentsByUserId` exist. */
  incomingDocumentsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `initials` field. */
  initials?: InputMaybe<StringFilter>;
  /** Filter by the object’s `itemsByOwnerId` relation. */
  itemsByOwnerId?: InputMaybe<UserToManyItemFilter>;
  /** Some related `itemsByOwnerId` exist. */
  itemsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `jobsByOwnerId` relation. */
  jobsByOwnerId?: InputMaybe<UserToManyJobFilter>;
  /** Some related `jobsByOwnerId` exist. */
  jobsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `junctionBoxesByOwnerId` relation. */
  junctionBoxesByOwnerId?: InputMaybe<UserToManyJunctionBoxFilter>;
  /** Some related `junctionBoxesByOwnerId` exist. */
  junctionBoxesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `leadsByOwnerId` relation. */
  leadsByOwnerId?: InputMaybe<UserToManyLeadFilter>;
  /** Some related `leadsByOwnerId` exist. */
  leadsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseCustomersByOwnerId` relation. */
  licenseCustomersByOwnerId?: InputMaybe<UserToManyLicenseCustomerFilter>;
  /** Some related `licenseCustomersByOwnerId` exist. */
  licenseCustomersByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseModulesByOwnerId` relation. */
  licenseModulesByOwnerId?: InputMaybe<UserToManyLicenseModuleFilter>;
  /** Some related `licenseModulesByOwnerId` exist. */
  licenseModulesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseOrdersByOwnerId` relation. */
  licenseOrdersByOwnerId?: InputMaybe<UserToManyLicenseOrderFilter>;
  /** Some related `licenseOrdersByOwnerId` exist. */
  licenseOrdersByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licenseRegistrationsByOwnerId` relation. */
  licenseRegistrationsByOwnerId?: InputMaybe<UserToManyLicenseRegistrationFilter>;
  /** Some related `licenseRegistrationsByOwnerId` exist. */
  licenseRegistrationsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `licensesByOwnerId` relation. */
  licensesByOwnerId?: InputMaybe<UserToManyLicenseFilter>;
  /** Some related `licensesByOwnerId` exist. */
  licensesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `maintenanceVisitsByOwnerId` relation. */
  maintenanceVisitsByOwnerId?: InputMaybe<UserToManyMaintenanceVisitFilter>;
  /** Some related `maintenanceVisitsByOwnerId` exist. */
  maintenanceVisitsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `maintenanceVisitsByUserId` relation. */
  maintenanceVisitsByUserId?: InputMaybe<UserToManyMaintenanceVisitFilter>;
  /** Some related `maintenanceVisitsByUserId` exist. */
  maintenanceVisitsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `membranesByOwnerId` relation. */
  membranesByOwnerId?: InputMaybe<UserToManyMembraneFilter>;
  /** Some related `membranesByOwnerId` exist. */
  membranesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Filter by the object’s `oRingsByOwnerId` relation. */
  oRingsByOwnerId?: InputMaybe<UserToManyORingFilter>;
  /** Some related `oRingsByOwnerId` exist. */
  oRingsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `offerteRemarksByOwnerId` relation. */
  offerteRemarksByOwnerId?: InputMaybe<UserToManyOfferteRemarkFilter>;
  /** Some related `offerteRemarksByOwnerId` exist. */
  offerteRemarksByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `opportunitiesByOwnerId` relation. */
  opportunitiesByOwnerId?: InputMaybe<UserToManyOpportunityFilter>;
  /** Some related `opportunitiesByOwnerId` exist. */
  opportunitiesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `overtimeStartBalance` field. */
  overtimeStartBalance?: InputMaybe<IntFilter>;
  /** Filter by the object’s `password` field. */
  password?: InputMaybe<StringFilter>;
  /** Filter by the object’s `plugsByOwnerId` relation. */
  plugsByOwnerId?: InputMaybe<UserToManyPlugFilter>;
  /** Some related `plugsByOwnerId` exist. */
  plugsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `principlesByOwnerId` relation. */
  principlesByOwnerId?: InputMaybe<UserToManyPrincipleFilter>;
  /** Some related `principlesByOwnerId` exist. */
  principlesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `pyrolysersByOwnerId` relation. */
  pyrolysersByOwnerId?: InputMaybe<UserToManyPyrolyserFilter>;
  /** Some related `pyrolysersByOwnerId` exist. */
  pyrolysersByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `rangesByOwnerId` relation. */
  rangesByOwnerId?: InputMaybe<UserToManyRangeFilter>;
  /** Some related `rangesByOwnerId` exist. */
  rangesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `rcCardsByOwnerId` relation. */
  rcCardsByOwnerId?: InputMaybe<UserToManyRcCardFilter>;
  /** Some related `rcCardsByOwnerId` exist. */
  rcCardsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reportsByOwnerId` relation. */
  reportsByOwnerId?: InputMaybe<UserToManyReportFilter>;
  /** Some related `reportsByOwnerId` exist. */
  reportsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reportsByUserId` relation. */
  reportsByUserId?: InputMaybe<UserToManyReportFilter>;
  /** Some related `reportsByUserId` exist. */
  reportsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `requestsByOwnerId` relation. */
  requestsByOwnerId?: InputMaybe<UserToManyRequestFilter>;
  /** Some related `requestsByOwnerId` exist. */
  requestsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `rxCardsByOwnerId` relation. */
  rxCardsByOwnerId?: InputMaybe<UserToManyRxCardFilter>;
  /** Some related `rxCardsByOwnerId` exist. */
  rxCardsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `samplePointsByOwnerId` relation. */
  samplePointsByOwnerId?: InputMaybe<UserToManySamplePointFilter>;
  /** Some related `samplePointsByOwnerId` exist. */
  samplePointsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementLocationsByOwnerId` relation. */
  sensorElementLocationsByOwnerId?: InputMaybe<UserToManySensorElementLocationFilter>;
  /** Some related `sensorElementLocationsByOwnerId` exist. */
  sensorElementLocationsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementTypesByOwnerId` relation. */
  sensorElementTypesByOwnerId?: InputMaybe<UserToManySensorElementTypeFilter>;
  /** Some related `sensorElementTypesByOwnerId` exist. */
  sensorElementTypesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorElementsByOwnerId` relation. */
  sensorElementsByOwnerId?: InputMaybe<UserToManySensorElementFilter>;
  /** Some related `sensorElementsByOwnerId` exist. */
  sensorElementsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorOrdersByCheckedUserId` relation. */
  sensorOrdersByCheckedUserId?: InputMaybe<UserToManySensorOrderFilter>;
  /** Some related `sensorOrdersByCheckedUserId` exist. */
  sensorOrdersByCheckedUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorOrdersByOwnerId` relation. */
  sensorOrdersByOwnerId?: InputMaybe<UserToManySensorOrderFilter>;
  /** Some related `sensorOrdersByOwnerId` exist. */
  sensorOrdersByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorOrdersByVerifiedUserId` relation. */
  sensorOrdersByVerifiedUserId?: InputMaybe<UserToManySensorOrderFilter>;
  /** Some related `sensorOrdersByVerifiedUserId` exist. */
  sensorOrdersByVerifiedUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorSensorElementsByOwnerId` relation. */
  sensorSensorElementsByOwnerId?: InputMaybe<UserToManySensorSensorElementFilter>;
  /** Some related `sensorSensorElementsByOwnerId` exist. */
  sensorSensorElementsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorTestResultsByOwnerId` relation. */
  sensorTestResultsByOwnerId?: InputMaybe<UserToManySensorTestResultFilter>;
  /** Some related `sensorTestResultsByOwnerId` exist. */
  sensorTestResultsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorTestResultsByUserId` relation. */
  sensorTestResultsByUserId?: InputMaybe<UserToManySensorTestResultFilter>;
  /** Some related `sensorTestResultsByUserId` exist. */
  sensorTestResultsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorTypesByOwnerId` relation. */
  sensorTypesByOwnerId?: InputMaybe<UserToManySensorTypeFilter>;
  /** Some related `sensorTypesByOwnerId` exist. */
  sensorTypesByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sensorsByOwnerId` relation. */
  sensorsByOwnerId?: InputMaybe<UserToManySensorFilter>;
  /** Some related `sensorsByOwnerId` exist. */
  sensorsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `softwaresByOwnerId` relation. */
  softwaresByOwnerId?: InputMaybe<UserToManySoftwareFilter>;
  /** Some related `softwaresByOwnerId` exist. */
  softwaresByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stockGroupsByOwnerId` relation. */
  stockGroupsByOwnerId?: InputMaybe<UserToManyStockGroupFilter>;
  /** Some related `stockGroupsByOwnerId` exist. */
  stockGroupsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stockItemsByOwnerId` relation. */
  stockItemsByOwnerId?: InputMaybe<UserToManyStockItemFilter>;
  /** Some related `stockItemsByOwnerId` exist. */
  stockItemsByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stockSuppliersByOwnerId` relation. */
  stockSuppliersByOwnerId?: InputMaybe<UserToManyStockSupplierFilter>;
  /** Some related `stockSuppliersByOwnerId` exist. */
  stockSuppliersByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tasksByOwnerId` relation. */
  tasksByOwnerId?: InputMaybe<UserToManyTaskFilter>;
  /** Some related `tasksByOwnerId` exist. */
  tasksByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `url` field. */
  url?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userRightsByUserId` relation. */
  userRightsByUserId?: InputMaybe<UserToManyUserRightFilter>;
  /** Some related `userRightsByUserId` exist. */
  userRightsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userTasksByOwnerId` relation. */
  userTasksByOwnerId?: InputMaybe<UserToManyUserTaskFilter>;
  /** Some related `userTasksByOwnerId` exist. */
  userTasksByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userTasksByUserId` relation. */
  userTasksByUserId?: InputMaybe<UserToManyUserTaskFilter>;
  /** Some related `userTasksByUserId` exist. */
  userTasksByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
  /** Filter by the object’s `usersGroupsByUserId` relation. */
  usersGroupsByUserId?: InputMaybe<UserToManyUsersGroupFilter>;
  /** Some related `usersGroupsByUserId` exist. */
  usersGroupsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `weeklyHourRemarksByOwnerId` relation. */
  weeklyHourRemarksByOwnerId?: InputMaybe<UserToManyWeeklyHourRemarkFilter>;
  /** Some related `weeklyHourRemarksByOwnerId` exist. */
  weeklyHourRemarksByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `weeklyHourRemarksByUserId` relation. */
  weeklyHourRemarksByUserId?: InputMaybe<UserToManyWeeklyHourRemarkFilter>;
  /** Some related `weeklyHourRemarksByUserId` exist. */
  weeklyHourRemarksByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `weeklyHoursByOwnerId` relation. */
  weeklyHoursByOwnerId?: InputMaybe<UserToManyWeeklyHourFilter>;
  /** Some related `weeklyHoursByOwnerId` exist. */
  weeklyHoursByOwnerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `weeklyHoursByUserId` relation. */
  weeklyHoursByUserId?: InputMaybe<UserToManyWeeklyHourFilter>;
  /** Some related `weeklyHoursByUserId` exist. */
  weeklyHoursByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `weeklyHoursFullAccess` field. */
  weeklyHoursFullAccess?: InputMaybe<BooleanFilter>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  fullname?: InputMaybe<Scalars['String']['input']>;
  groupId?: InputMaybe<Scalars['Int']['input']>;
  holidayStartBalance?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  initials?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  overtimeStartBalance?: InputMaybe<Scalars['Int']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  weeklyHoursFullAccess?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  fullname?: InputMaybe<Scalars['String']['input']>;
  groupId?: InputMaybe<Scalars['Int']['input']>;
  holidayStartBalance?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  initials?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  overtimeStartBalance?: InputMaybe<Scalars['Int']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  weeklyHoursFullAccess?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserRight = Node & {
  __typename?: 'UserRight';
  authorized: Scalars['Boolean']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  path?: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `UserRight`. */
  userByUserId?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `UserRight` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserRightCondition = {
  /** Checks for equality with the object’s `authorized` field. */
  authorized?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `path` field. */
  path?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `UserRight` object types. All fields are combined with a logical ‘and.’ */
export type UserRightFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserRightFilter>>;
  /** Filter by the object’s `authorized` field. */
  authorized?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserRightFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserRightFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `path` field. */
  path?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** A related `userByUserId` exists. */
  userByUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `UserRight` */
export type UserRightInput = {
  authorized: Scalars['Boolean']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `UserRight`. Fields that are set will be updated. */
export type UserRightPatch = {
  authorized?: InputMaybe<Scalars['Boolean']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `UserRight` values. */
export type UserRightsConnection = {
  __typename?: 'UserRightsConnection';
  /** A list of edges which contains the `UserRight` and cursor to aid in pagination. */
  edges: Array<UserRightsEdge>;
  /** A list of `UserRight` objects. */
  nodes: Array<UserRight>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserRight` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserRight` edge in the connection. */
export type UserRightsEdge = {
  __typename?: 'UserRightsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserRight` at the end of the edge. */
  node: UserRight;
};

/** Methods to use when ordering `UserRight`. */
export enum UserRightsOrderBy {
  AuthorizedAsc = 'AUTHORIZED_ASC',
  AuthorizedDesc = 'AUTHORIZED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type UserTask = Node & {
  __typename?: 'UserTask';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  qualifiesForOvertime?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `Task` that is related to this `UserTask`. */
  taskByTaskId?: Maybe<Task>;
  taskId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `UserTask`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `UserTask`. */
  userByUserId?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `UserTask` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserTaskCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `qualifiesForOvertime` field. */
  qualifiesForOvertime?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `taskId` field. */
  taskId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `UserTask` object types. All fields are combined with a logical ‘and.’ */
export type UserTaskFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserTaskFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserTaskFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserTaskFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `qualifiesForOvertime` field. */
  qualifiesForOvertime?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `taskByTaskId` relation. */
  taskByTaskId?: InputMaybe<TaskFilter>;
  /** A related `taskByTaskId` exists. */
  taskByTaskIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `taskId` field. */
  taskId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** A related `userByUserId` exists. */
  userByUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `UserTask` */
export type UserTaskInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  qualifiesForOvertime?: InputMaybe<Scalars['Boolean']['input']>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `UserTask`. Fields that are set will be updated. */
export type UserTaskPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  qualifiesForOvertime?: InputMaybe<Scalars['Boolean']['input']>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `UserTask` values. */
export type UserTasksConnection = {
  __typename?: 'UserTasksConnection';
  /** A list of edges which contains the `UserTask` and cursor to aid in pagination. */
  edges: Array<UserTasksEdge>;
  /** A list of `UserTask` objects. */
  nodes: Array<UserTask>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserTask` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserTask` edge in the connection. */
export type UserTasksEdge = {
  __typename?: 'UserTasksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserTask` at the end of the edge. */
  node: UserTask;
};

/** Methods to use when ordering `UserTask`. */
export enum UserTasksOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QualifiesForOvertimeAsc = 'QUALIFIES_FOR_OVERTIME_ASC',
  QualifiesForOvertimeDesc = 'QUALIFIES_FOR_OVERTIME_DESC',
  TaskByTaskIdCodeAsc = 'TASK_BY_TASK_ID__CODE_ASC',
  TaskByTaskIdCodeDesc = 'TASK_BY_TASK_ID__CODE_DESC',
  TaskByTaskIdCreatedAsc = 'TASK_BY_TASK_ID__CREATED_ASC',
  TaskByTaskIdCreatedDesc = 'TASK_BY_TASK_ID__CREATED_DESC',
  TaskByTaskIdDescriptionAsc = 'TASK_BY_TASK_ID__DESCRIPTION_ASC',
  TaskByTaskIdDescriptionDesc = 'TASK_BY_TASK_ID__DESCRIPTION_DESC',
  TaskByTaskIdGroupCodeAsc = 'TASK_BY_TASK_ID__GROUP_CODE_ASC',
  TaskByTaskIdGroupCodeDesc = 'TASK_BY_TASK_ID__GROUP_CODE_DESC',
  TaskByTaskIdIdAsc = 'TASK_BY_TASK_ID__ID_ASC',
  TaskByTaskIdIdDesc = 'TASK_BY_TASK_ID__ID_DESC',
  TaskByTaskIdModifiedAsc = 'TASK_BY_TASK_ID__MODIFIED_ASC',
  TaskByTaskIdModifiedDesc = 'TASK_BY_TASK_ID__MODIFIED_DESC',
  TaskByTaskIdNameAsc = 'TASK_BY_TASK_ID__NAME_ASC',
  TaskByTaskIdNameDesc = 'TASK_BY_TASK_ID__NAME_DESC',
  TaskByTaskIdOwnerIdAsc = 'TASK_BY_TASK_ID__OWNER_ID_ASC',
  TaskByTaskIdOwnerIdDesc = 'TASK_BY_TASK_ID__OWNER_ID_DESC',
  TaskByTaskIdSortCodeAsc = 'TASK_BY_TASK_ID__SORT_CODE_ASC',
  TaskByTaskIdSortCodeDesc = 'TASK_BY_TASK_ID__SORT_CODE_DESC',
  TaskByTaskIdWbsoEndDateAsc = 'TASK_BY_TASK_ID__WBSO_END_DATE_ASC',
  TaskByTaskIdWbsoEndDateDesc = 'TASK_BY_TASK_ID__WBSO_END_DATE_DESC',
  TaskByTaskIdWbsoStartDateAsc = 'TASK_BY_TASK_ID__WBSO_START_DATE_ASC',
  TaskByTaskIdWbsoStartDateDesc = 'TASK_BY_TASK_ID__WBSO_START_DATE_DESC',
  TaskIdAsc = 'TASK_ID_ASC',
  TaskIdDesc = 'TASK_ID_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A filter to be used against many `Action` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyActionFilter = {
  /** Every related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionFilter>;
  /** No related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionFilter>;
  /** Some related `Action` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionFilter>;
};

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationFilter>;
};

/** A filter to be used against many `Area` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyAreaFilter = {
  /** Every related `Area` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AreaFilter>;
  /** No related `Area` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AreaFilter>;
  /** Some related `Area` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AreaFilter>;
};

/** A filter to be used against many `Assembly` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyAssemblyFilter = {
  /** Every related `Assembly` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AssemblyFilter>;
  /** No related `Assembly` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AssemblyFilter>;
  /** Some related `Assembly` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AssemblyFilter>;
};

/** A filter to be used against many `AssemblyPart` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyAssemblyPartFilter = {
  /** Every related `AssemblyPart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AssemblyPartFilter>;
  /** No related `AssemblyPart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AssemblyPartFilter>;
  /** Some related `AssemblyPart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AssemblyPartFilter>;
};

/** A filter to be used against many `AssemblyType` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyAssemblyTypeFilter = {
  /** Every related `AssemblyType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AssemblyTypeFilter>;
  /** No related `AssemblyType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AssemblyTypeFilter>;
  /** Some related `AssemblyType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AssemblyTypeFilter>;
};

/** A filter to be used against many `AssemblyTypePart` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyAssemblyTypePartFilter = {
  /** Every related `AssemblyTypePart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AssemblyTypePartFilter>;
  /** No related `AssemblyTypePart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AssemblyTypePartFilter>;
  /** Some related `AssemblyTypePart` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AssemblyTypePartFilter>;
};

/** A filter to be used against many `Building` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyBuildingFilter = {
  /** Every related `Building` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<BuildingFilter>;
  /** No related `Building` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<BuildingFilter>;
  /** Some related `Building` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<BuildingFilter>;
};

/** A filter to be used against many `CalGas` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyCalGasFilter = {
  /** Every related `CalGas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CalGasFilter>;
  /** No related `CalGas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CalGasFilter>;
  /** Some related `CalGas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CalGasFilter>;
};

/** A filter to be used against many `CatalogGroup` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyCatalogGroupFilter = {
  /** Every related `CatalogGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CatalogGroupFilter>;
  /** No related `CatalogGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CatalogGroupFilter>;
  /** Some related `CatalogGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CatalogGroupFilter>;
};

/** A filter to be used against many `CatalogItemFile` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyCatalogItemFileFilter = {
  /** Every related `CatalogItemFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CatalogItemFileFilter>;
  /** No related `CatalogItemFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CatalogItemFileFilter>;
  /** Some related `CatalogItemFile` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CatalogItemFileFilter>;
};

/** A filter to be used against many `CatalogItem` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyCatalogItemFilter = {
  /** Every related `CatalogItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CatalogItemFilter>;
  /** No related `CatalogItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CatalogItemFilter>;
  /** Some related `CatalogItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CatalogItemFilter>;
};

/** A filter to be used against many `CatalogSubGroup` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyCatalogSubGroupFilter = {
  /** Every related `CatalogSubGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CatalogSubGroupFilter>;
  /** No related `CatalogSubGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CatalogSubGroupFilter>;
  /** Some related `CatalogSubGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CatalogSubGroupFilter>;
};

/** A filter to be used against many `ChemicalCompound` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyChemicalCompoundFilter = {
  /** Every related `ChemicalCompound` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ChemicalCompoundFilter>;
  /** No related `ChemicalCompound` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ChemicalCompoundFilter>;
  /** Some related `ChemicalCompound` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ChemicalCompoundFilter>;
};

/** A filter to be used against many `Detector` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyDetectorFilter = {
  /** Every related `Detector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorFilter>;
  /** No related `Detector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorFilter>;
  /** Some related `Detector` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorFilter>;
};

/** A filter to be used against many `DetectorLocation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyDetectorLocationFilter = {
  /** Every related `DetectorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorLocationFilter>;
  /** No related `DetectorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorLocationFilter>;
  /** Some related `DetectorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorLocationFilter>;
};

/** A filter to be used against many `DetectorOrder` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyDetectorOrderFilter = {
  /** Every related `DetectorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorOrderFilter>;
  /** No related `DetectorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorOrderFilter>;
  /** Some related `DetectorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorOrderFilter>;
};

/** A filter to be used against many `DetectorSensor` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyDetectorSensorFilter = {
  /** Every related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorFilter>;
  /** No related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorFilter>;
  /** Some related `DetectorSensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorFilter>;
};

/** A filter to be used against many `DetectorSensorLocation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyDetectorSensorLocationFilter = {
  /** Every related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorLocationFilter>;
  /** No related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorLocationFilter>;
  /** Some related `DetectorSensorLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorLocationFilter>;
};

/** A filter to be used against many `DetectorSensorType` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyDetectorSensorTypeFilter = {
  /** Every related `DetectorSensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorSensorTypeFilter>;
  /** No related `DetectorSensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorSensorTypeFilter>;
  /** Some related `DetectorSensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorSensorTypeFilter>;
};

/** A filter to be used against many `DetectorType` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyDetectorTypeFilter = {
  /** Every related `DetectorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DetectorTypeFilter>;
  /** No related `DetectorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DetectorTypeFilter>;
  /** Some related `DetectorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DetectorTypeFilter>;
};

/** A filter to be used against many `DpCard` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyDpCardFilter = {
  /** Every related `DpCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DpCardFilter>;
  /** No related `DpCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DpCardFilter>;
  /** Some related `DpCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DpCardFilter>;
};

/** A filter to be used against many `Electrolyte` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyElectrolyteFilter = {
  /** Every related `Electrolyte` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ElectrolyteFilter>;
  /** No related `Electrolyte` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ElectrolyteFilter>;
  /** Some related `Electrolyte` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ElectrolyteFilter>;
};

/** A filter to be used against many `EndUser` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyEndUserFilter = {
  /** Every related `EndUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EndUserFilter>;
  /** No related `EndUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EndUserFilter>;
  /** Some related `EndUser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EndUserFilter>;
};

/** A filter to be used against many `FactopdrachtregelLineRemark` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyFactopdrachtregelLineRemarkFilter = {
  /** Every related `FactopdrachtregelLineRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FactopdrachtregelLineRemarkFilter>;
  /** No related `FactopdrachtregelLineRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FactopdrachtregelLineRemarkFilter>;
  /** Some related `FactopdrachtregelLineRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FactopdrachtregelLineRemarkFilter>;
};

/** A filter to be used against many `Factuur` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyFactuurFilter = {
  /** Every related `Factuur` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FactuurFilter>;
  /** No related `Factuur` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FactuurFilter>;
  /** Some related `Factuur` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FactuurFilter>;
};

/** A filter to be used against many `Filter` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyFilterFilter = {
  /** Every related `Filter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FilterFilter>;
  /** No related `Filter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FilterFilter>;
  /** Some related `Filter` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FilterFilter>;
};

/** A filter to be used against many `Floor` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyFloorFilter = {
  /** Every related `Floor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FloorFilter>;
  /** No related `Floor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FloorFilter>;
  /** Some related `Floor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FloorFilter>;
};

/** A filter to be used against many `Gas` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyGasFilter = {
  /** Every related `Gas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<GasFilter>;
  /** No related `Gas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<GasFilter>;
  /** Some related `Gas` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<GasFilter>;
};

/** A filter to be used against many `Group` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyGroupFilter = {
  /** Every related `Group` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<GroupFilter>;
  /** No related `Group` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<GroupFilter>;
  /** Some related `Group` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<GroupFilter>;
};

/** A filter to be used against many `Hardware` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyHardwareFilter = {
  /** Every related `Hardware` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<HardwareFilter>;
  /** No related `Hardware` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<HardwareFilter>;
  /** Some related `Hardware` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<HardwareFilter>;
};

/** A filter to be used against many `IncomingDocument` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyIncomingDocumentFilter = {
  /** Every related `IncomingDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<IncomingDocumentFilter>;
  /** No related `IncomingDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<IncomingDocumentFilter>;
  /** Some related `IncomingDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<IncomingDocumentFilter>;
};

/** A filter to be used against many `Item` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyItemFilter = {
  /** Every related `Item` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ItemFilter>;
  /** No related `Item` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ItemFilter>;
  /** Some related `Item` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ItemFilter>;
};

/** A filter to be used against many `Job` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyJobFilter = {
  /** Every related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JobFilter>;
  /** No related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JobFilter>;
  /** Some related `Job` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JobFilter>;
};

/** A filter to be used against many `JunctionBox` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyJunctionBoxFilter = {
  /** Every related `JunctionBox` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<JunctionBoxFilter>;
  /** No related `JunctionBox` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<JunctionBoxFilter>;
  /** Some related `JunctionBox` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<JunctionBoxFilter>;
};

/** A filter to be used against many `Lead` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyLeadFilter = {
  /** Every related `Lead` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LeadFilter>;
  /** No related `Lead` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LeadFilter>;
  /** Some related `Lead` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LeadFilter>;
};

/** A filter to be used against many `LicenseCustomer` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyLicenseCustomerFilter = {
  /** Every related `LicenseCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseCustomerFilter>;
  /** No related `LicenseCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseCustomerFilter>;
  /** Some related `LicenseCustomer` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseCustomerFilter>;
};

/** A filter to be used against many `License` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyLicenseFilter = {
  /** Every related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseFilter>;
  /** No related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseFilter>;
  /** Some related `License` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseFilter>;
};

/** A filter to be used against many `LicenseModule` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyLicenseModuleFilter = {
  /** Every related `LicenseModule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseModuleFilter>;
  /** No related `LicenseModule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseModuleFilter>;
  /** Some related `LicenseModule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseModuleFilter>;
};

/** A filter to be used against many `LicenseOrder` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyLicenseOrderFilter = {
  /** Every related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseOrderFilter>;
  /** No related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseOrderFilter>;
  /** Some related `LicenseOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseOrderFilter>;
};

/** A filter to be used against many `LicenseRegistration` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyLicenseRegistrationFilter = {
  /** Every related `LicenseRegistration` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LicenseRegistrationFilter>;
  /** No related `LicenseRegistration` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LicenseRegistrationFilter>;
  /** Some related `LicenseRegistration` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LicenseRegistrationFilter>;
};

/** A filter to be used against many `MaintenanceVisit` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyMaintenanceVisitFilter = {
  /** Every related `MaintenanceVisit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MaintenanceVisitFilter>;
  /** No related `MaintenanceVisit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MaintenanceVisitFilter>;
  /** Some related `MaintenanceVisit` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MaintenanceVisitFilter>;
};

/** A filter to be used against many `Membrane` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyMembraneFilter = {
  /** Every related `Membrane` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MembraneFilter>;
  /** No related `Membrane` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MembraneFilter>;
  /** Some related `Membrane` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MembraneFilter>;
};

/** A filter to be used against many `ORing` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyORingFilter = {
  /** Every related `ORing` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ORingFilter>;
  /** No related `ORing` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ORingFilter>;
  /** Some related `ORing` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ORingFilter>;
};

/** A filter to be used against many `OfferteRemark` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyOfferteRemarkFilter = {
  /** Every related `OfferteRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OfferteRemarkFilter>;
  /** No related `OfferteRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OfferteRemarkFilter>;
  /** Some related `OfferteRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OfferteRemarkFilter>;
};

/** A filter to be used against many `Opportunity` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyOpportunityFilter = {
  /** Every related `Opportunity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OpportunityFilter>;
  /** No related `Opportunity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OpportunityFilter>;
  /** Some related `Opportunity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OpportunityFilter>;
};

/** A filter to be used against many `Plug` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyPlugFilter = {
  /** Every related `Plug` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PlugFilter>;
  /** No related `Plug` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PlugFilter>;
  /** Some related `Plug` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PlugFilter>;
};

/** A filter to be used against many `Principle` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyPrincipleFilter = {
  /** Every related `Principle` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PrincipleFilter>;
  /** No related `Principle` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PrincipleFilter>;
  /** Some related `Principle` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PrincipleFilter>;
};

/** A filter to be used against many `Pyrolyser` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyPyrolyserFilter = {
  /** Every related `Pyrolyser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PyrolyserFilter>;
  /** No related `Pyrolyser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PyrolyserFilter>;
  /** Some related `Pyrolyser` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PyrolyserFilter>;
};

/** A filter to be used against many `Range` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyRangeFilter = {
  /** Every related `Range` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RangeFilter>;
  /** No related `Range` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RangeFilter>;
  /** Some related `Range` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RangeFilter>;
};

/** A filter to be used against many `RcCard` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyRcCardFilter = {
  /** Every related `RcCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RcCardFilter>;
  /** No related `RcCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RcCardFilter>;
  /** Some related `RcCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RcCardFilter>;
};

/** A filter to be used against many `Report` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyReportFilter = {
  /** Every related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReportFilter>;
  /** No related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReportFilter>;
  /** Some related `Report` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReportFilter>;
};

/** A filter to be used against many `Request` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyRequestFilter = {
  /** Every related `Request` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RequestFilter>;
  /** No related `Request` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RequestFilter>;
  /** Some related `Request` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RequestFilter>;
};

/** A filter to be used against many `RxCard` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyRxCardFilter = {
  /** Every related `RxCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<RxCardFilter>;
  /** No related `RxCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<RxCardFilter>;
  /** Some related `RxCard` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<RxCardFilter>;
};

/** A filter to be used against many `SamplePoint` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySamplePointFilter = {
  /** Every related `SamplePoint` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SamplePointFilter>;
  /** No related `SamplePoint` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SamplePointFilter>;
  /** Some related `SamplePoint` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SamplePointFilter>;
};

/** A filter to be used against many `SensorElement` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySensorElementFilter = {
  /** Every related `SensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementFilter>;
  /** No related `SensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementFilter>;
  /** Some related `SensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementFilter>;
};

/** A filter to be used against many `SensorElementLocation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySensorElementLocationFilter = {
  /** Every related `SensorElementLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementLocationFilter>;
  /** No related `SensorElementLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementLocationFilter>;
  /** Some related `SensorElementLocation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementLocationFilter>;
};

/** A filter to be used against many `SensorElementType` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySensorElementTypeFilter = {
  /** Every related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorElementTypeFilter>;
  /** No related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorElementTypeFilter>;
  /** Some related `SensorElementType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorElementTypeFilter>;
};

/** A filter to be used against many `Sensor` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySensorFilter = {
  /** Every related `Sensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorFilter>;
  /** No related `Sensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorFilter>;
  /** Some related `Sensor` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorFilter>;
};

/** A filter to be used against many `SensorOrder` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySensorOrderFilter = {
  /** Every related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorOrderFilter>;
  /** No related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorOrderFilter>;
  /** Some related `SensorOrder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorOrderFilter>;
};

/** A filter to be used against many `SensorSensorElement` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySensorSensorElementFilter = {
  /** Every related `SensorSensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorSensorElementFilter>;
  /** No related `SensorSensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorSensorElementFilter>;
  /** Some related `SensorSensorElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorSensorElementFilter>;
};

/** A filter to be used against many `SensorTestResult` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySensorTestResultFilter = {
  /** Every related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTestResultFilter>;
  /** No related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTestResultFilter>;
  /** Some related `SensorTestResult` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTestResultFilter>;
};

/** A filter to be used against many `SensorType` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySensorTypeFilter = {
  /** Every related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SensorTypeFilter>;
  /** No related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SensorTypeFilter>;
  /** Some related `SensorType` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SensorTypeFilter>;
};

/** A filter to be used against many `Software` object types. All fields are combined with a logical ‘and.’ */
export type UserToManySoftwareFilter = {
  /** Every related `Software` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SoftwareFilter>;
  /** No related `Software` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SoftwareFilter>;
  /** Some related `Software` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SoftwareFilter>;
};

/** A filter to be used against many `StockGroup` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyStockGroupFilter = {
  /** Every related `StockGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<StockGroupFilter>;
  /** No related `StockGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<StockGroupFilter>;
  /** Some related `StockGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<StockGroupFilter>;
};

/** A filter to be used against many `StockItem` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyStockItemFilter = {
  /** Every related `StockItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<StockItemFilter>;
  /** No related `StockItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<StockItemFilter>;
  /** Some related `StockItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<StockItemFilter>;
};

/** A filter to be used against many `StockSupplier` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyStockSupplierFilter = {
  /** Every related `StockSupplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<StockSupplierFilter>;
  /** No related `StockSupplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<StockSupplierFilter>;
  /** Some related `StockSupplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<StockSupplierFilter>;
};

/** A filter to be used against many `Task` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyTaskFilter = {
  /** Every related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TaskFilter>;
  /** No related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TaskFilter>;
  /** Some related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TaskFilter>;
};

/** A filter to be used against many `UserRight` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserRightFilter = {
  /** Every related `UserRight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserRightFilter>;
  /** No related `UserRight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserRightFilter>;
  /** Some related `UserRight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserRightFilter>;
};

/** A filter to be used against many `UserTask` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserTaskFilter = {
  /** Every related `UserTask` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserTaskFilter>;
  /** No related `UserTask` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserTaskFilter>;
  /** Some related `UserTask` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserTaskFilter>;
};

/** A filter to be used against many `UsersGroup` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUsersGroupFilter = {
  /** Every related `UsersGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UsersGroupFilter>;
  /** No related `UsersGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UsersGroupFilter>;
  /** Some related `UsersGroup` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UsersGroupFilter>;
};

/** A filter to be used against many `WeeklyHour` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyWeeklyHourFilter = {
  /** Every related `WeeklyHour` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<WeeklyHourFilter>;
  /** No related `WeeklyHour` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<WeeklyHourFilter>;
  /** Some related `WeeklyHour` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<WeeklyHourFilter>;
};

/** A filter to be used against many `WeeklyHourRemark` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyWeeklyHourRemarkFilter = {
  /** Every related `WeeklyHourRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<WeeklyHourRemarkFilter>;
  /** No related `WeeklyHourRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<WeeklyHourRemarkFilter>;
  /** Some related `WeeklyHourRemark` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<WeeklyHourRemarkFilter>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: User;
};

export type UsersGroup = Node & {
  __typename?: 'UsersGroup';
  /** Reads a single `Group` that is related to this `UsersGroup`. */
  groupByGroupId?: Maybe<Group>;
  groupId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `User` that is related to this `UsersGroup`. */
  userByUserId?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/**
 * A condition to be used against `UsersGroup` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UsersGroupCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `UsersGroup` object types. All fields are combined with a logical ‘and.’ */
export type UsersGroupFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UsersGroupFilter>>;
  /** Filter by the object’s `groupByGroupId` relation. */
  groupByGroupId?: InputMaybe<GroupFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UsersGroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UsersGroupFilter>>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `UsersGroup` values. */
export type UsersGroupsConnection = {
  __typename?: 'UsersGroupsConnection';
  /** A list of edges which contains the `UsersGroup` and cursor to aid in pagination. */
  edges: Array<UsersGroupsEdge>;
  /** A list of `UsersGroup` objects. */
  nodes: Array<UsersGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UsersGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UsersGroup` edge in the connection. */
export type UsersGroupsEdge = {
  __typename?: 'UsersGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UsersGroup` at the end of the edge. */
  node: UsersGroup;
};

/** Methods to use when ordering `UsersGroup`. */
export enum UsersGroupsOrderBy {
  GroupByGroupIdCreatedAsc = 'GROUP_BY_GROUP_ID__CREATED_ASC',
  GroupByGroupIdCreatedDesc = 'GROUP_BY_GROUP_ID__CREATED_DESC',
  GroupByGroupIdIdAsc = 'GROUP_BY_GROUP_ID__ID_ASC',
  GroupByGroupIdIdDesc = 'GROUP_BY_GROUP_ID__ID_DESC',
  GroupByGroupIdModifiedAsc = 'GROUP_BY_GROUP_ID__MODIFIED_ASC',
  GroupByGroupIdModifiedDesc = 'GROUP_BY_GROUP_ID__MODIFIED_DESC',
  GroupByGroupIdNameAsc = 'GROUP_BY_GROUP_ID__NAME_ASC',
  GroupByGroupIdNameDesc = 'GROUP_BY_GROUP_ID__NAME_DESC',
  GroupByGroupIdOwnerIdAsc = 'GROUP_BY_GROUP_ID__OWNER_ID_ASC',
  GroupByGroupIdOwnerIdDesc = 'GROUP_BY_GROUP_ID__OWNER_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  ActionsByOwnerIdCountAsc = 'ACTIONS_BY_OWNER_ID__COUNT_ASC',
  ActionsByOwnerIdCountDesc = 'ACTIONS_BY_OWNER_ID__COUNT_DESC',
  ActionsByUserIdCountAsc = 'ACTIONS_BY_USER_ID__COUNT_ASC',
  ActionsByUserIdCountDesc = 'ACTIONS_BY_USER_ID__COUNT_DESC',
  ApplicationsByOwnerIdCountAsc = 'APPLICATIONS_BY_OWNER_ID__COUNT_ASC',
  ApplicationsByOwnerIdCountDesc = 'APPLICATIONS_BY_OWNER_ID__COUNT_DESC',
  AreasByOwnerIdCountAsc = 'AREAS_BY_OWNER_ID__COUNT_ASC',
  AreasByOwnerIdCountDesc = 'AREAS_BY_OWNER_ID__COUNT_DESC',
  AssembliesByOwnerIdCountAsc = 'ASSEMBLIES_BY_OWNER_ID__COUNT_ASC',
  AssembliesByOwnerIdCountDesc = 'ASSEMBLIES_BY_OWNER_ID__COUNT_DESC',
  AssemblyPartsByOwnerIdCountAsc = 'ASSEMBLY_PARTS_BY_OWNER_ID__COUNT_ASC',
  AssemblyPartsByOwnerIdCountDesc = 'ASSEMBLY_PARTS_BY_OWNER_ID__COUNT_DESC',
  AssemblyTypesByOwnerIdCountAsc = 'ASSEMBLY_TYPES_BY_OWNER_ID__COUNT_ASC',
  AssemblyTypesByOwnerIdCountDesc = 'ASSEMBLY_TYPES_BY_OWNER_ID__COUNT_DESC',
  AssemblyTypePartsByOwnerIdCountAsc = 'ASSEMBLY_TYPE_PARTS_BY_OWNER_ID__COUNT_ASC',
  AssemblyTypePartsByOwnerIdCountDesc = 'ASSEMBLY_TYPE_PARTS_BY_OWNER_ID__COUNT_DESC',
  BuildingsByOwnerIdCountAsc = 'BUILDINGS_BY_OWNER_ID__COUNT_ASC',
  BuildingsByOwnerIdCountDesc = 'BUILDINGS_BY_OWNER_ID__COUNT_DESC',
  CalGasesByOwnerIdCountAsc = 'CAL_GASES_BY_OWNER_ID__COUNT_ASC',
  CalGasesByOwnerIdCountDesc = 'CAL_GASES_BY_OWNER_ID__COUNT_DESC',
  CatalogGroupsByOwnerIdCountAsc = 'CATALOG_GROUPS_BY_OWNER_ID__COUNT_ASC',
  CatalogGroupsByOwnerIdCountDesc = 'CATALOG_GROUPS_BY_OWNER_ID__COUNT_DESC',
  CatalogItemsByOwnerIdCountAsc = 'CATALOG_ITEMS_BY_OWNER_ID__COUNT_ASC',
  CatalogItemsByOwnerIdCountDesc = 'CATALOG_ITEMS_BY_OWNER_ID__COUNT_DESC',
  CatalogItemFilesByOwnerIdCountAsc = 'CATALOG_ITEM_FILES_BY_OWNER_ID__COUNT_ASC',
  CatalogItemFilesByOwnerIdCountDesc = 'CATALOG_ITEM_FILES_BY_OWNER_ID__COUNT_DESC',
  CatalogSubGroupsByOwnerIdCountAsc = 'CATALOG_SUB_GROUPS_BY_OWNER_ID__COUNT_ASC',
  CatalogSubGroupsByOwnerIdCountDesc = 'CATALOG_SUB_GROUPS_BY_OWNER_ID__COUNT_DESC',
  ChemicalCompoundsByOwnerIdCountAsc = 'CHEMICAL_COMPOUNDS_BY_OWNER_ID__COUNT_ASC',
  ChemicalCompoundsByOwnerIdCountDesc = 'CHEMICAL_COMPOUNDS_BY_OWNER_ID__COUNT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetectorsByOwnerIdCountAsc = 'DETECTORS_BY_OWNER_ID__COUNT_ASC',
  DetectorsByOwnerIdCountDesc = 'DETECTORS_BY_OWNER_ID__COUNT_DESC',
  DetectorLocationsByOwnerIdCountAsc = 'DETECTOR_LOCATIONS_BY_OWNER_ID__COUNT_ASC',
  DetectorLocationsByOwnerIdCountDesc = 'DETECTOR_LOCATIONS_BY_OWNER_ID__COUNT_DESC',
  DetectorOrdersByOwnerIdCountAsc = 'DETECTOR_ORDERS_BY_OWNER_ID__COUNT_ASC',
  DetectorOrdersByOwnerIdCountDesc = 'DETECTOR_ORDERS_BY_OWNER_ID__COUNT_DESC',
  DetectorSensorsByOwnerIdCountAsc = 'DETECTOR_SENSORS_BY_OWNER_ID__COUNT_ASC',
  DetectorSensorsByOwnerIdCountDesc = 'DETECTOR_SENSORS_BY_OWNER_ID__COUNT_DESC',
  DetectorSensorLocationsByOwnerIdCountAsc = 'DETECTOR_SENSOR_LOCATIONS_BY_OWNER_ID__COUNT_ASC',
  DetectorSensorLocationsByOwnerIdCountDesc = 'DETECTOR_SENSOR_LOCATIONS_BY_OWNER_ID__COUNT_DESC',
  DetectorSensorTypesByOwnerIdCountAsc = 'DETECTOR_SENSOR_TYPES_BY_OWNER_ID__COUNT_ASC',
  DetectorSensorTypesByOwnerIdCountDesc = 'DETECTOR_SENSOR_TYPES_BY_OWNER_ID__COUNT_DESC',
  DetectorTypesByOwnerIdCountAsc = 'DETECTOR_TYPES_BY_OWNER_ID__COUNT_ASC',
  DetectorTypesByOwnerIdCountDesc = 'DETECTOR_TYPES_BY_OWNER_ID__COUNT_DESC',
  DpCardsByOwnerIdCountAsc = 'DP_CARDS_BY_OWNER_ID__COUNT_ASC',
  DpCardsByOwnerIdCountDesc = 'DP_CARDS_BY_OWNER_ID__COUNT_DESC',
  ElectrolytesByOwnerIdCountAsc = 'ELECTROLYTES_BY_OWNER_ID__COUNT_ASC',
  ElectrolytesByOwnerIdCountDesc = 'ELECTROLYTES_BY_OWNER_ID__COUNT_DESC',
  EndUsersByOwnerIdCountAsc = 'END_USERS_BY_OWNER_ID__COUNT_ASC',
  EndUsersByOwnerIdCountDesc = 'END_USERS_BY_OWNER_ID__COUNT_DESC',
  FactopdrachtregelLineRemarksByUserIdCountAsc = 'FACTOPDRACHTREGEL_LINE_REMARKS_BY_USER_ID__COUNT_ASC',
  FactopdrachtregelLineRemarksByUserIdCountDesc = 'FACTOPDRACHTREGEL_LINE_REMARKS_BY_USER_ID__COUNT_DESC',
  FactuursByCheckedIdCountAsc = 'FACTUURS_BY_CHECKED_ID__COUNT_ASC',
  FactuursByCheckedIdCountDesc = 'FACTUURS_BY_CHECKED_ID__COUNT_DESC',
  FactuursByOwnerIdCountAsc = 'FACTUURS_BY_OWNER_ID__COUNT_ASC',
  FactuursByOwnerIdCountDesc = 'FACTUURS_BY_OWNER_ID__COUNT_DESC',
  FactuursBySentIdCountAsc = 'FACTUURS_BY_SENT_ID__COUNT_ASC',
  FactuursBySentIdCountDesc = 'FACTUURS_BY_SENT_ID__COUNT_DESC',
  FiltersByOwnerIdCountAsc = 'FILTERS_BY_OWNER_ID__COUNT_ASC',
  FiltersByOwnerIdCountDesc = 'FILTERS_BY_OWNER_ID__COUNT_DESC',
  FloorsByOwnerIdCountAsc = 'FLOORS_BY_OWNER_ID__COUNT_ASC',
  FloorsByOwnerIdCountDesc = 'FLOORS_BY_OWNER_ID__COUNT_DESC',
  FullnameAsc = 'FULLNAME_ASC',
  FullnameDesc = 'FULLNAME_DESC',
  GasesByOwnerIdCountAsc = 'GASES_BY_OWNER_ID__COUNT_ASC',
  GasesByOwnerIdCountDesc = 'GASES_BY_OWNER_ID__COUNT_DESC',
  GroupsByOwnerIdCountAsc = 'GROUPS_BY_OWNER_ID__COUNT_ASC',
  GroupsByOwnerIdCountDesc = 'GROUPS_BY_OWNER_ID__COUNT_DESC',
  GroupByGroupIdCreatedAsc = 'GROUP_BY_GROUP_ID__CREATED_ASC',
  GroupByGroupIdCreatedDesc = 'GROUP_BY_GROUP_ID__CREATED_DESC',
  GroupByGroupIdIdAsc = 'GROUP_BY_GROUP_ID__ID_ASC',
  GroupByGroupIdIdDesc = 'GROUP_BY_GROUP_ID__ID_DESC',
  GroupByGroupIdModifiedAsc = 'GROUP_BY_GROUP_ID__MODIFIED_ASC',
  GroupByGroupIdModifiedDesc = 'GROUP_BY_GROUP_ID__MODIFIED_DESC',
  GroupByGroupIdNameAsc = 'GROUP_BY_GROUP_ID__NAME_ASC',
  GroupByGroupIdNameDesc = 'GROUP_BY_GROUP_ID__NAME_DESC',
  GroupByGroupIdOwnerIdAsc = 'GROUP_BY_GROUP_ID__OWNER_ID_ASC',
  GroupByGroupIdOwnerIdDesc = 'GROUP_BY_GROUP_ID__OWNER_ID_DESC',
  GroupIdAsc = 'GROUP_ID_ASC',
  GroupIdDesc = 'GROUP_ID_DESC',
  HardwaresByOwnerIdCountAsc = 'HARDWARES_BY_OWNER_ID__COUNT_ASC',
  HardwaresByOwnerIdCountDesc = 'HARDWARES_BY_OWNER_ID__COUNT_DESC',
  HardwaresByUserIdCountAsc = 'HARDWARES_BY_USER_ID__COUNT_ASC',
  HardwaresByUserIdCountDesc = 'HARDWARES_BY_USER_ID__COUNT_DESC',
  HolidayStartBalanceAsc = 'HOLIDAY_START_BALANCE_ASC',
  HolidayStartBalanceDesc = 'HOLIDAY_START_BALANCE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IncomingDocumentsByOwnerIdCountAsc = 'INCOMING_DOCUMENTS_BY_OWNER_ID__COUNT_ASC',
  IncomingDocumentsByOwnerIdCountDesc = 'INCOMING_DOCUMENTS_BY_OWNER_ID__COUNT_DESC',
  IncomingDocumentsByUserIdCountAsc = 'INCOMING_DOCUMENTS_BY_USER_ID__COUNT_ASC',
  IncomingDocumentsByUserIdCountDesc = 'INCOMING_DOCUMENTS_BY_USER_ID__COUNT_DESC',
  InitialsAsc = 'INITIALS_ASC',
  InitialsDesc = 'INITIALS_DESC',
  ItemsByOwnerIdCountAsc = 'ITEMS_BY_OWNER_ID__COUNT_ASC',
  ItemsByOwnerIdCountDesc = 'ITEMS_BY_OWNER_ID__COUNT_DESC',
  JobsByOwnerIdCountAsc = 'JOBS_BY_OWNER_ID__COUNT_ASC',
  JobsByOwnerIdCountDesc = 'JOBS_BY_OWNER_ID__COUNT_DESC',
  JunctionBoxesByOwnerIdCountAsc = 'JUNCTION_BOXES_BY_OWNER_ID__COUNT_ASC',
  JunctionBoxesByOwnerIdCountDesc = 'JUNCTION_BOXES_BY_OWNER_ID__COUNT_DESC',
  LeadsByOwnerIdCountAsc = 'LEADS_BY_OWNER_ID__COUNT_ASC',
  LeadsByOwnerIdCountDesc = 'LEADS_BY_OWNER_ID__COUNT_DESC',
  LicensesByOwnerIdCountAsc = 'LICENSES_BY_OWNER_ID__COUNT_ASC',
  LicensesByOwnerIdCountDesc = 'LICENSES_BY_OWNER_ID__COUNT_DESC',
  LicenseCustomersByOwnerIdCountAsc = 'LICENSE_CUSTOMERS_BY_OWNER_ID__COUNT_ASC',
  LicenseCustomersByOwnerIdCountDesc = 'LICENSE_CUSTOMERS_BY_OWNER_ID__COUNT_DESC',
  LicenseModulesByOwnerIdCountAsc = 'LICENSE_MODULES_BY_OWNER_ID__COUNT_ASC',
  LicenseModulesByOwnerIdCountDesc = 'LICENSE_MODULES_BY_OWNER_ID__COUNT_DESC',
  LicenseOrdersByOwnerIdCountAsc = 'LICENSE_ORDERS_BY_OWNER_ID__COUNT_ASC',
  LicenseOrdersByOwnerIdCountDesc = 'LICENSE_ORDERS_BY_OWNER_ID__COUNT_DESC',
  LicenseRegistrationsByOwnerIdCountAsc = 'LICENSE_REGISTRATIONS_BY_OWNER_ID__COUNT_ASC',
  LicenseRegistrationsByOwnerIdCountDesc = 'LICENSE_REGISTRATIONS_BY_OWNER_ID__COUNT_DESC',
  MaintenanceVisitsByOwnerIdCountAsc = 'MAINTENANCE_VISITS_BY_OWNER_ID__COUNT_ASC',
  MaintenanceVisitsByOwnerIdCountDesc = 'MAINTENANCE_VISITS_BY_OWNER_ID__COUNT_DESC',
  MaintenanceVisitsByUserIdCountAsc = 'MAINTENANCE_VISITS_BY_USER_ID__COUNT_ASC',
  MaintenanceVisitsByUserIdCountDesc = 'MAINTENANCE_VISITS_BY_USER_ID__COUNT_DESC',
  MembranesByOwnerIdCountAsc = 'MEMBRANES_BY_OWNER_ID__COUNT_ASC',
  MembranesByOwnerIdCountDesc = 'MEMBRANES_BY_OWNER_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OfferteRemarksByOwnerIdCountAsc = 'OFFERTE_REMARKS_BY_OWNER_ID__COUNT_ASC',
  OfferteRemarksByOwnerIdCountDesc = 'OFFERTE_REMARKS_BY_OWNER_ID__COUNT_DESC',
  OpportunitiesByOwnerIdCountAsc = 'OPPORTUNITIES_BY_OWNER_ID__COUNT_ASC',
  OpportunitiesByOwnerIdCountDesc = 'OPPORTUNITIES_BY_OWNER_ID__COUNT_DESC',
  OvertimeStartBalanceAsc = 'OVERTIME_START_BALANCE_ASC',
  OvertimeStartBalanceDesc = 'OVERTIME_START_BALANCE_DESC',
  ORingsByOwnerIdCountAsc = 'O_RINGS_BY_OWNER_ID__COUNT_ASC',
  ORingsByOwnerIdCountDesc = 'O_RINGS_BY_OWNER_ID__COUNT_DESC',
  PasswordAsc = 'PASSWORD_ASC',
  PasswordDesc = 'PASSWORD_DESC',
  PlugsByOwnerIdCountAsc = 'PLUGS_BY_OWNER_ID__COUNT_ASC',
  PlugsByOwnerIdCountDesc = 'PLUGS_BY_OWNER_ID__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PrinciplesByOwnerIdCountAsc = 'PRINCIPLES_BY_OWNER_ID__COUNT_ASC',
  PrinciplesByOwnerIdCountDesc = 'PRINCIPLES_BY_OWNER_ID__COUNT_DESC',
  PyrolysersByOwnerIdCountAsc = 'PYROLYSERS_BY_OWNER_ID__COUNT_ASC',
  PyrolysersByOwnerIdCountDesc = 'PYROLYSERS_BY_OWNER_ID__COUNT_DESC',
  RangesByOwnerIdCountAsc = 'RANGES_BY_OWNER_ID__COUNT_ASC',
  RangesByOwnerIdCountDesc = 'RANGES_BY_OWNER_ID__COUNT_DESC',
  RcCardsByOwnerIdCountAsc = 'RC_CARDS_BY_OWNER_ID__COUNT_ASC',
  RcCardsByOwnerIdCountDesc = 'RC_CARDS_BY_OWNER_ID__COUNT_DESC',
  ReportsByOwnerIdCountAsc = 'REPORTS_BY_OWNER_ID__COUNT_ASC',
  ReportsByOwnerIdCountDesc = 'REPORTS_BY_OWNER_ID__COUNT_DESC',
  ReportsByUserIdCountAsc = 'REPORTS_BY_USER_ID__COUNT_ASC',
  ReportsByUserIdCountDesc = 'REPORTS_BY_USER_ID__COUNT_DESC',
  RequestsByOwnerIdCountAsc = 'REQUESTS_BY_OWNER_ID__COUNT_ASC',
  RequestsByOwnerIdCountDesc = 'REQUESTS_BY_OWNER_ID__COUNT_DESC',
  RxCardsByOwnerIdCountAsc = 'RX_CARDS_BY_OWNER_ID__COUNT_ASC',
  RxCardsByOwnerIdCountDesc = 'RX_CARDS_BY_OWNER_ID__COUNT_DESC',
  SamplePointsByOwnerIdCountAsc = 'SAMPLE_POINTS_BY_OWNER_ID__COUNT_ASC',
  SamplePointsByOwnerIdCountDesc = 'SAMPLE_POINTS_BY_OWNER_ID__COUNT_DESC',
  SensorsByOwnerIdCountAsc = 'SENSORS_BY_OWNER_ID__COUNT_ASC',
  SensorsByOwnerIdCountDesc = 'SENSORS_BY_OWNER_ID__COUNT_DESC',
  SensorElementsByOwnerIdCountAsc = 'SENSOR_ELEMENTS_BY_OWNER_ID__COUNT_ASC',
  SensorElementsByOwnerIdCountDesc = 'SENSOR_ELEMENTS_BY_OWNER_ID__COUNT_DESC',
  SensorElementLocationsByOwnerIdCountAsc = 'SENSOR_ELEMENT_LOCATIONS_BY_OWNER_ID__COUNT_ASC',
  SensorElementLocationsByOwnerIdCountDesc = 'SENSOR_ELEMENT_LOCATIONS_BY_OWNER_ID__COUNT_DESC',
  SensorElementTypesByOwnerIdCountAsc = 'SENSOR_ELEMENT_TYPES_BY_OWNER_ID__COUNT_ASC',
  SensorElementTypesByOwnerIdCountDesc = 'SENSOR_ELEMENT_TYPES_BY_OWNER_ID__COUNT_DESC',
  SensorOrdersByCheckedUserIdCountAsc = 'SENSOR_ORDERS_BY_CHECKED_USER_ID__COUNT_ASC',
  SensorOrdersByCheckedUserIdCountDesc = 'SENSOR_ORDERS_BY_CHECKED_USER_ID__COUNT_DESC',
  SensorOrdersByOwnerIdCountAsc = 'SENSOR_ORDERS_BY_OWNER_ID__COUNT_ASC',
  SensorOrdersByOwnerIdCountDesc = 'SENSOR_ORDERS_BY_OWNER_ID__COUNT_DESC',
  SensorOrdersByVerifiedUserIdCountAsc = 'SENSOR_ORDERS_BY_VERIFIED_USER_ID__COUNT_ASC',
  SensorOrdersByVerifiedUserIdCountDesc = 'SENSOR_ORDERS_BY_VERIFIED_USER_ID__COUNT_DESC',
  SensorSensorElementsByOwnerIdCountAsc = 'SENSOR_SENSOR_ELEMENTS_BY_OWNER_ID__COUNT_ASC',
  SensorSensorElementsByOwnerIdCountDesc = 'SENSOR_SENSOR_ELEMENTS_BY_OWNER_ID__COUNT_DESC',
  SensorTestResultsByOwnerIdCountAsc = 'SENSOR_TEST_RESULTS_BY_OWNER_ID__COUNT_ASC',
  SensorTestResultsByOwnerIdCountDesc = 'SENSOR_TEST_RESULTS_BY_OWNER_ID__COUNT_DESC',
  SensorTestResultsByUserIdCountAsc = 'SENSOR_TEST_RESULTS_BY_USER_ID__COUNT_ASC',
  SensorTestResultsByUserIdCountDesc = 'SENSOR_TEST_RESULTS_BY_USER_ID__COUNT_DESC',
  SensorTypesByOwnerIdCountAsc = 'SENSOR_TYPES_BY_OWNER_ID__COUNT_ASC',
  SensorTypesByOwnerIdCountDesc = 'SENSOR_TYPES_BY_OWNER_ID__COUNT_DESC',
  SoftwaresByOwnerIdCountAsc = 'SOFTWARES_BY_OWNER_ID__COUNT_ASC',
  SoftwaresByOwnerIdCountDesc = 'SOFTWARES_BY_OWNER_ID__COUNT_DESC',
  StockGroupsByOwnerIdCountAsc = 'STOCK_GROUPS_BY_OWNER_ID__COUNT_ASC',
  StockGroupsByOwnerIdCountDesc = 'STOCK_GROUPS_BY_OWNER_ID__COUNT_DESC',
  StockItemsByOwnerIdCountAsc = 'STOCK_ITEMS_BY_OWNER_ID__COUNT_ASC',
  StockItemsByOwnerIdCountDesc = 'STOCK_ITEMS_BY_OWNER_ID__COUNT_DESC',
  StockSuppliersByOwnerIdCountAsc = 'STOCK_SUPPLIERS_BY_OWNER_ID__COUNT_ASC',
  StockSuppliersByOwnerIdCountDesc = 'STOCK_SUPPLIERS_BY_OWNER_ID__COUNT_DESC',
  TasksByOwnerIdCountAsc = 'TASKS_BY_OWNER_ID__COUNT_ASC',
  TasksByOwnerIdCountDesc = 'TASKS_BY_OWNER_ID__COUNT_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UsersGroupsByUserIdCountAsc = 'USERS_GROUPS_BY_USER_ID__COUNT_ASC',
  UsersGroupsByUserIdCountDesc = 'USERS_GROUPS_BY_USER_ID__COUNT_DESC',
  UserRightsByUserIdCountAsc = 'USER_RIGHTS_BY_USER_ID__COUNT_ASC',
  UserRightsByUserIdCountDesc = 'USER_RIGHTS_BY_USER_ID__COUNT_DESC',
  UserTasksByOwnerIdCountAsc = 'USER_TASKS_BY_OWNER_ID__COUNT_ASC',
  UserTasksByOwnerIdCountDesc = 'USER_TASKS_BY_OWNER_ID__COUNT_DESC',
  UserTasksByUserIdCountAsc = 'USER_TASKS_BY_USER_ID__COUNT_ASC',
  UserTasksByUserIdCountDesc = 'USER_TASKS_BY_USER_ID__COUNT_DESC',
  WeeklyHoursByOwnerIdCountAsc = 'WEEKLY_HOURS_BY_OWNER_ID__COUNT_ASC',
  WeeklyHoursByOwnerIdCountDesc = 'WEEKLY_HOURS_BY_OWNER_ID__COUNT_DESC',
  WeeklyHoursByUserIdCountAsc = 'WEEKLY_HOURS_BY_USER_ID__COUNT_ASC',
  WeeklyHoursByUserIdCountDesc = 'WEEKLY_HOURS_BY_USER_ID__COUNT_DESC',
  WeeklyHoursFullAccessAsc = 'WEEKLY_HOURS_FULL_ACCESS_ASC',
  WeeklyHoursFullAccessDesc = 'WEEKLY_HOURS_FULL_ACCESS_DESC',
  WeeklyHourRemarksByOwnerIdCountAsc = 'WEEKLY_HOUR_REMARKS_BY_OWNER_ID__COUNT_ASC',
  WeeklyHourRemarksByOwnerIdCountDesc = 'WEEKLY_HOUR_REMARKS_BY_OWNER_ID__COUNT_DESC',
  WeeklyHourRemarksByUserIdCountAsc = 'WEEKLY_HOUR_REMARKS_BY_USER_ID__COUNT_ASC',
  WeeklyHourRemarksByUserIdCountDesc = 'WEEKLY_HOUR_REMARKS_BY_USER_ID__COUNT_DESC'
}

export type Valuta = {
  __typename?: 'Valuta';
  biedkoerseuro?: Maybe<Scalars['BigFloat']['output']>;
  cddecimalen?: Maybe<Scalars['String']['output']>;
  cdemusoort?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  isovaluta?: Maybe<Scalars['String']['output']>;
  laatkoerseuro?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  rekenkoerseuro?: Maybe<Scalars['BigFloat']['output']>;
};

/** A condition to be used against `Valuta` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ValutaCondition = {
  /** Checks for equality with the object’s `biedkoerseuro` field. */
  biedkoerseuro?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cddecimalen` field. */
  cddecimalen?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdemusoort` field. */
  cdemusoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `laatkoerseuro` field. */
  laatkoerseuro?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rekenkoerseuro` field. */
  rekenkoerseuro?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `Valuta` object types. All fields are combined with a logical ‘and.’ */
export type ValutaFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ValutaFilter>>;
  /** Filter by the object’s `biedkoerseuro` field. */
  biedkoerseuro?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cddecimalen` field. */
  cddecimalen?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdemusoort` field. */
  cdemusoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `laatkoerseuro` field. */
  laatkoerseuro?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ValutaFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ValutaFilter>>;
  /** Filter by the object’s `rekenkoerseuro` field. */
  rekenkoerseuro?: InputMaybe<BigFloatFilter>;
};

export type ValutaMv = {
  __typename?: 'ValutaMv';
  biedkoerseuro?: Maybe<Scalars['BigFloat']['output']>;
  cddecimalen?: Maybe<Scalars['String']['output']>;
  cdemusoort?: Maybe<Scalars['String']['output']>;
  cdvaluta?: Maybe<Scalars['String']['output']>;
  isovaluta?: Maybe<Scalars['String']['output']>;
  laatkoerseuro?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  rekenkoerseuro?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `ValutaMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ValutaMvCondition = {
  /** Checks for equality with the object’s `biedkoerseuro` field. */
  biedkoerseuro?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cddecimalen` field. */
  cddecimalen?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdemusoort` field. */
  cdemusoort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `laatkoerseuro` field. */
  laatkoerseuro?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rekenkoerseuro` field. */
  rekenkoerseuro?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `ValutaMv` object types. All fields are combined with a logical ‘and.’ */
export type ValutaMvFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ValutaMvFilter>>;
  /** Filter by the object’s `biedkoerseuro` field. */
  biedkoerseuro?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cddecimalen` field. */
  cddecimalen?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdemusoort` field. */
  cdemusoort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdvaluta` field. */
  cdvaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `laatkoerseuro` field. */
  laatkoerseuro?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ValutaMvFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ValutaMvFilter>>;
  /** Filter by the object’s `rekenkoerseuro` field. */
  rekenkoerseuro?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `ValutaMv` values. */
export type ValutaMvsConnection = {
  __typename?: 'ValutaMvsConnection';
  /** A list of edges which contains the `ValutaMv` and cursor to aid in pagination. */
  edges: Array<ValutaMvsEdge>;
  /** A list of `ValutaMv` objects. */
  nodes: Array<ValutaMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ValutaMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ValutaMv` edge in the connection. */
export type ValutaMvsEdge = {
  __typename?: 'ValutaMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ValutaMv` at the end of the edge. */
  node: ValutaMv;
};

/** Methods to use when ordering `ValutaMv`. */
export enum ValutaMvsOrderBy {
  BiedkoerseuroAsc = 'BIEDKOERSEURO_ASC',
  BiedkoerseuroDesc = 'BIEDKOERSEURO_DESC',
  CddecimalenAsc = 'CDDECIMALEN_ASC',
  CddecimalenDesc = 'CDDECIMALEN_DESC',
  CdemusoortAsc = 'CDEMUSOORT_ASC',
  CdemusoortDesc = 'CDEMUSOORT_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  IsovalutaAsc = 'ISOVALUTA_ASC',
  IsovalutaDesc = 'ISOVALUTA_DESC',
  LaatkoerseuroAsc = 'LAATKOERSEURO_ASC',
  LaatkoerseuroDesc = 'LAATKOERSEURO_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  RekenkoerseuroAsc = 'REKENKOERSEURO_ASC',
  RekenkoerseuroDesc = 'REKENKOERSEURO_DESC'
}

/** A connection to a list of `Valuta` values. */
export type ValutasConnection = {
  __typename?: 'ValutasConnection';
  /** A list of edges which contains the `Valuta` and cursor to aid in pagination. */
  edges: Array<ValutasEdge>;
  /** A list of `Valuta` objects. */
  nodes: Array<Valuta>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Valuta` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Valuta` edge in the connection. */
export type ValutasEdge = {
  __typename?: 'ValutasEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Valuta` at the end of the edge. */
  node: Valuta;
};

/** Methods to use when ordering `Valuta`. */
export enum ValutasOrderBy {
  BiedkoerseuroAsc = 'BIEDKOERSEURO_ASC',
  BiedkoerseuroDesc = 'BIEDKOERSEURO_DESC',
  CddecimalenAsc = 'CDDECIMALEN_ASC',
  CddecimalenDesc = 'CDDECIMALEN_DESC',
  CdemusoortAsc = 'CDEMUSOORT_ASC',
  CdemusoortDesc = 'CDEMUSOORT_DESC',
  CdvalutaAsc = 'CDVALUTA_ASC',
  CdvalutaDesc = 'CDVALUTA_DESC',
  IsovalutaAsc = 'ISOVALUTA_ASC',
  IsovalutaDesc = 'ISOVALUTA_DESC',
  LaatkoerseuroAsc = 'LAATKOERSEURO_ASC',
  LaatkoerseuroDesc = 'LAATKOERSEURO_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  RekenkoerseuroAsc = 'REKENKOERSEURO_ASC',
  RekenkoerseuroDesc = 'REKENKOERSEURO_DESC'
}

export type VerrekenprijsChangesIndex = {
  __typename?: 'VerrekenprijsChangesIndex';
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Datetime']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  marginDiff?: Maybe<Scalars['BigFloat']['output']>;
  marginNew?: Maybe<Scalars['BigFloat']['output']>;
  marginOld?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  uitloop?: Maybe<Scalars['String']['output']>;
  verrekenprijsDiff?: Maybe<Scalars['BigFloat']['output']>;
  verrekenprijsNew?: Maybe<Scalars['BigFloat']['output']>;
  verrekenprijsOld?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  voorraadVerrekenprijsDiff?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `VerrekenprijsChangesIndex` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type VerrekenprijsChangesIndexCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `marginDiff` field. */
  marginDiff?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginNew` field. */
  marginNew?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginOld` field. */
  marginOld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `uitloop` field. */
  uitloop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijsDiff` field. */
  verrekenprijsDiff?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `verrekenprijsNew` field. */
  verrekenprijsNew?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `verrekenprijsOld` field. */
  verrekenprijsOld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraadVerrekenprijsDiff` field. */
  voorraadVerrekenprijsDiff?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `VerrekenprijsChangesIndex` object types. All fields are combined with a logical ‘and.’ */
export type VerrekenprijsChangesIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VerrekenprijsChangesIndexFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `marginDiff` field. */
  marginDiff?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `marginNew` field. */
  marginNew?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `marginOld` field. */
  marginOld?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VerrekenprijsChangesIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VerrekenprijsChangesIndexFilter>>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `uitloop` field. */
  uitloop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verrekenprijsDiff` field. */
  verrekenprijsDiff?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `verrekenprijsNew` field. */
  verrekenprijsNew?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `verrekenprijsOld` field. */
  verrekenprijsOld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `voorraadVerrekenprijsDiff` field. */
  voorraadVerrekenprijsDiff?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `VerrekenprijsChangesIndex` values. */
export type VerrekenprijsChangesIndicesConnection = {
  __typename?: 'VerrekenprijsChangesIndicesConnection';
  /** A list of edges which contains the `VerrekenprijsChangesIndex` and cursor to aid in pagination. */
  edges: Array<VerrekenprijsChangesIndicesEdge>;
  /** A list of `VerrekenprijsChangesIndex` objects. */
  nodes: Array<VerrekenprijsChangesIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VerrekenprijsChangesIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VerrekenprijsChangesIndex` edge in the connection. */
export type VerrekenprijsChangesIndicesEdge = {
  __typename?: 'VerrekenprijsChangesIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VerrekenprijsChangesIndex` at the end of the edge. */
  node: VerrekenprijsChangesIndex;
};

/** Methods to use when ordering `VerrekenprijsChangesIndex`. */
export enum VerrekenprijsChangesIndicesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MarginDiffAsc = 'MARGIN_DIFF_ASC',
  MarginDiffDesc = 'MARGIN_DIFF_DESC',
  MarginNewAsc = 'MARGIN_NEW_ASC',
  MarginNewDesc = 'MARGIN_NEW_DESC',
  MarginOldAsc = 'MARGIN_OLD_ASC',
  MarginOldDesc = 'MARGIN_OLD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  UitloopAsc = 'UITLOOP_ASC',
  UitloopDesc = 'UITLOOP_DESC',
  VerrekenprijsDiffAsc = 'VERREKENPRIJS_DIFF_ASC',
  VerrekenprijsDiffDesc = 'VERREKENPRIJS_DIFF_DESC',
  VerrekenprijsNewAsc = 'VERREKENPRIJS_NEW_ASC',
  VerrekenprijsNewDesc = 'VERREKENPRIJS_NEW_DESC',
  VerrekenprijsOldAsc = 'VERREKENPRIJS_OLD_ASC',
  VerrekenprijsOldDesc = 'VERREKENPRIJS_OLD_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VoorraadVerrekenprijsDiffAsc = 'VOORRAAD_VERREKENPRIJS_DIFF_ASC',
  VoorraadVerrekenprijsDiffDesc = 'VOORRAAD_VERREKENPRIJS_DIFF_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type VerrekenprijsIndex = {
  __typename?: 'VerrekenprijsIndex';
  assemblageArtikel?: Maybe<Scalars['String']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  margin?: Maybe<Scalars['BigFloat']['output']>;
  marginCalc?: Maybe<Scalars['BigFloat']['output']>;
  marginDiff?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  prijsexcl?: Maybe<Scalars['BigFloat']['output']>;
  soort?: Maybe<Scalars['String']['output']>;
  uitloop?: Maybe<Scalars['String']['output']>;
  verrekenprijs?: Maybe<Scalars['BigFloat']['output']>;
  verrekenprijsCalc?: Maybe<Scalars['BigFloat']['output']>;
  verrekenprijsDiff?: Maybe<Scalars['BigFloat']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `VerrekenprijsIndex` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VerrekenprijsIndexCondition = {
  /** Checks for equality with the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginCalc` field. */
  marginCalc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginDiff` field. */
  marginDiff?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `soort` field. */
  soort?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uitloop` field. */
  uitloop?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `verrekenprijsCalc` field. */
  verrekenprijsCalc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `verrekenprijsDiff` field. */
  verrekenprijsDiff?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `VerrekenprijsIndex` object types. All fields are combined with a logical ‘and.’ */
export type VerrekenprijsIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VerrekenprijsIndexFilter>>;
  /** Filter by the object’s `assemblageArtikel` field. */
  assemblageArtikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `marginCalc` field. */
  marginCalc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `marginDiff` field. */
  marginDiff?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VerrekenprijsIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VerrekenprijsIndexFilter>>;
  /** Filter by the object’s `prijsexcl` field. */
  prijsexcl?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `soort` field. */
  soort?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uitloop` field. */
  uitloop?: InputMaybe<StringFilter>;
  /** Filter by the object’s `verrekenprijs` field. */
  verrekenprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `verrekenprijsCalc` field. */
  verrekenprijsCalc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `verrekenprijsDiff` field. */
  verrekenprijsDiff?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `VerrekenprijsIndex` values. */
export type VerrekenprijsIndicesConnection = {
  __typename?: 'VerrekenprijsIndicesConnection';
  /** A list of edges which contains the `VerrekenprijsIndex` and cursor to aid in pagination. */
  edges: Array<VerrekenprijsIndicesEdge>;
  /** A list of `VerrekenprijsIndex` objects. */
  nodes: Array<VerrekenprijsIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VerrekenprijsIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VerrekenprijsIndex` edge in the connection. */
export type VerrekenprijsIndicesEdge = {
  __typename?: 'VerrekenprijsIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VerrekenprijsIndex` at the end of the edge. */
  node: VerrekenprijsIndex;
};

/** Methods to use when ordering `VerrekenprijsIndex`. */
export enum VerrekenprijsIndicesOrderBy {
  AssemblageArtikelAsc = 'ASSEMBLAGE_ARTIKEL_ASC',
  AssemblageArtikelDesc = 'ASSEMBLAGE_ARTIKEL_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginCalcAsc = 'MARGIN_CALC_ASC',
  MarginCalcDesc = 'MARGIN_CALC_DESC',
  MarginDesc = 'MARGIN_DESC',
  MarginDiffAsc = 'MARGIN_DIFF_ASC',
  MarginDiffDesc = 'MARGIN_DIFF_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  PrijsexclAsc = 'PRIJSEXCL_ASC',
  PrijsexclDesc = 'PRIJSEXCL_DESC',
  SoortAsc = 'SOORT_ASC',
  SoortDesc = 'SOORT_DESC',
  UitloopAsc = 'UITLOOP_ASC',
  UitloopDesc = 'UITLOOP_DESC',
  VerrekenprijsAsc = 'VERREKENPRIJS_ASC',
  VerrekenprijsCalcAsc = 'VERREKENPRIJS_CALC_ASC',
  VerrekenprijsCalcDesc = 'VERREKENPRIJS_CALC_DESC',
  VerrekenprijsDesc = 'VERREKENPRIJS_DESC',
  VerrekenprijsDiffAsc = 'VERREKENPRIJS_DIFF_ASC',
  VerrekenprijsDiffDesc = 'VERREKENPRIJS_DIFF_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

export type VooradenIndex = {
  __typename?: 'VooradenIndex';
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  bestcode?: Maybe<Scalars['String']['output']>;
  besthoeveelheid?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkoopprijs?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  isovaluta?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
  vrij?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `VooradenIndex` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VooradenIndexCondition = {
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bestcode` field. */
  bestcode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `vrij` field. */
  vrij?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `VooradenIndex` object types. All fields are combined with a logical ‘and.’ */
export type VooradenIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VooradenIndexFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `bestcode` field. */
  bestcode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `besthoeveelheid` field. */
  besthoeveelheid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkoopprijs` field. */
  inkoopprijs?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `isovaluta` field. */
  isovaluta?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VooradenIndexFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VooradenIndexFilter>>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `vrij` field. */
  vrij?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `VooradenIndex` values. */
export type VooradenIndicesConnection = {
  __typename?: 'VooradenIndicesConnection';
  /** A list of edges which contains the `VooradenIndex` and cursor to aid in pagination. */
  edges: Array<VooradenIndicesEdge>;
  /** A list of `VooradenIndex` objects. */
  nodes: Array<VooradenIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VooradenIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VooradenIndex` edge in the connection. */
export type VooradenIndicesEdge = {
  __typename?: 'VooradenIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VooradenIndex` at the end of the edge. */
  node: VooradenIndex;
};

/** Methods to use when ordering `VooradenIndex`. */
export enum VooradenIndicesOrderBy {
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  BestcodeAsc = 'BESTCODE_ASC',
  BestcodeDesc = 'BESTCODE_DESC',
  BesthoeveelheidAsc = 'BESTHOEVEELHEID_ASC',
  BesthoeveelheidDesc = 'BESTHOEVEELHEID_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkoopprijsAsc = 'INKOOPPRIJS_ASC',
  InkoopprijsDesc = 'INKOOPPRIJS_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  IsovalutaAsc = 'ISOVALUTA_ASC',
  IsovalutaDesc = 'ISOVALUTA_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC',
  VrijAsc = 'VRIJ_ASC',
  VrijDesc = 'VRIJ_DESC'
}

export type Voorraden = Node & {
  __typename?: 'Voorraden';
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  assemblbij?: Maybe<Scalars['BigFloat']['output']>;
  besteld?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel: Scalars['String']['output'];
  cdmagazijn: Scalars['String']['output'];
  geleverd?: Maybe<Scalars['BigFloat']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  leveren?: Maybe<Scalars['BigFloat']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Voorraden` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VoorradenCondition = {
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `besteld` field. */
  besteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geleverd` field. */
  geleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `leveren` field. */
  leveren?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `Voorraden` object types. All fields are combined with a logical ‘and.’ */
export type VoorradenFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VoorradenFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `besteld` field. */
  besteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geleverd` field. */
  geleverd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `leveren` field. */
  leveren?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VoorradenFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VoorradenFilter>>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
};

/** An input for mutations affecting `Voorraden` */
export type VoorradenInput = {
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  assemblbij?: InputMaybe<Scalars['BigFloat']['input']>;
  besteld?: InputMaybe<Scalars['BigFloat']['input']>;
  cdartikel: Scalars['String']['input'];
  cdmagazijn: Scalars['String']['input'];
  geleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  leveren?: InputMaybe<Scalars['BigFloat']['input']>;
  locatie?: InputMaybe<Scalars['String']['input']>;
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type VoorradenLog = Node & {
  __typename?: 'VoorradenLog';
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  new?: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  old?: Maybe<Scalars['JSON']['output']>;
  operation?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `VoorradenLog` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VoorradenLogCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `new` field. */
  new?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `old` field. */
  old?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `operation` field. */
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `VoorradenLog` object types. All fields are combined with a logical ‘and.’ */
export type VoorradenLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VoorradenLogFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `new` field. */
  new?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VoorradenLogFilter>;
  /** Filter by the object’s `old` field. */
  old?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `operation` field. */
  operation?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VoorradenLogFilter>>;
};

/** An input for mutations affecting `VoorradenLog` */
export type VoorradenLogInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  new?: InputMaybe<Scalars['JSON']['input']>;
  old?: InputMaybe<Scalars['JSON']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `VoorradenLog`. Fields that are set will be updated. */
export type VoorradenLogPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  new?: InputMaybe<Scalars['JSON']['input']>;
  old?: InputMaybe<Scalars['JSON']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `VoorradenLog` values. */
export type VoorradenLogsConnection = {
  __typename?: 'VoorradenLogsConnection';
  /** A list of edges which contains the `VoorradenLog` and cursor to aid in pagination. */
  edges: Array<VoorradenLogsEdge>;
  /** A list of `VoorradenLog` objects. */
  nodes: Array<VoorradenLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VoorradenLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VoorradenLog` edge in the connection. */
export type VoorradenLogsEdge = {
  __typename?: 'VoorradenLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VoorradenLog` at the end of the edge. */
  node: VoorradenLog;
};

export type VoorradenLogsIndex = {
  __typename?: 'VoorradenLogsIndex';
  cdartikel?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['Date']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  new?: Maybe<Scalars['String']['output']>;
  old?: Maybe<Scalars['String']['output']>;
  omschr?: Maybe<Scalars['String']['output']>;
  zoeknaam?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `VoorradenLogsIndex` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VoorradenLogsIndexCondition = {
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `new` field. */
  new?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `old` field. */
  old?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `omschr` field. */
  omschr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `VoorradenLogsIndex` object types. All fields are combined with a logical ‘and.’ */
export type VoorradenLogsIndexFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VoorradenLogsIndexFilter>>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DateFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `new` field. */
  new?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VoorradenLogsIndexFilter>;
  /** Filter by the object’s `old` field. */
  old?: InputMaybe<StringFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VoorradenLogsIndexFilter>>;
  /** Filter by the object’s `zoeknaam` field. */
  zoeknaam?: InputMaybe<StringFilter>;
};

/** A connection to a list of `VoorradenLogsIndex` values. */
export type VoorradenLogsIndicesConnection = {
  __typename?: 'VoorradenLogsIndicesConnection';
  /** A list of edges which contains the `VoorradenLogsIndex` and cursor to aid in pagination. */
  edges: Array<VoorradenLogsIndicesEdge>;
  /** A list of `VoorradenLogsIndex` objects. */
  nodes: Array<VoorradenLogsIndex>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VoorradenLogsIndex` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VoorradenLogsIndex` edge in the connection. */
export type VoorradenLogsIndicesEdge = {
  __typename?: 'VoorradenLogsIndicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VoorradenLogsIndex` at the end of the edge. */
  node: VoorradenLogsIndex;
};

/** Methods to use when ordering `VoorradenLogsIndex`. */
export enum VoorradenLogsIndicesOrderBy {
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  Natural = 'NATURAL',
  NewAsc = 'NEW_ASC',
  NewDesc = 'NEW_DESC',
  OldAsc = 'OLD_ASC',
  OldDesc = 'OLD_DESC',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  ZoeknaamAsc = 'ZOEKNAAM_ASC',
  ZoeknaamDesc = 'ZOEKNAAM_DESC'
}

/** Methods to use when ordering `VoorradenLog`. */
export enum VoorradenLogsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NewAsc = 'NEW_ASC',
  NewDesc = 'NEW_DESC',
  OldAsc = 'OLD_ASC',
  OldDesc = 'OLD_DESC',
  OperationAsc = 'OPERATION_ASC',
  OperationDesc = 'OPERATION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type VoorradenMv = {
  __typename?: 'VoorradenMv';
  assemblaf?: Maybe<Scalars['BigFloat']['output']>;
  assemblbij?: Maybe<Scalars['BigFloat']['output']>;
  besteld?: Maybe<Scalars['BigFloat']['output']>;
  cdartikel?: Maybe<Scalars['String']['output']>;
  cdmagazijn?: Maybe<Scalars['String']['output']>;
  geleverd?: Maybe<Scalars['BigFloat']['output']>;
  gereserveerd?: Maybe<Scalars['BigFloat']['output']>;
  inkopen?: Maybe<Scalars['BigFloat']['output']>;
  leveren?: Maybe<Scalars['BigFloat']['output']>;
  locatie?: Maybe<Scalars['String']['output']>;
  maxvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  minvoorraad?: Maybe<Scalars['BigFloat']['output']>;
  voorraad?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `VoorradenMv` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type VoorradenMvCondition = {
  /** Checks for equality with the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `besteld` field. */
  besteld?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `geleverd` field. */
  geleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `inkopen` field. */
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `leveren` field. */
  leveren?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `locatie` field. */
  locatie?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `voorraad` field. */
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `VoorradenMv` object types. All fields are combined with a logical ‘and.’ */
export type VoorradenMvFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VoorradenMvFilter>>;
  /** Filter by the object’s `assemblaf` field. */
  assemblaf?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `assemblbij` field. */
  assemblbij?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `besteld` field. */
  besteld?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `cdartikel` field. */
  cdartikel?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdmagazijn` field. */
  cdmagazijn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `geleverd` field. */
  geleverd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `gereserveerd` field. */
  gereserveerd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `inkopen` field. */
  inkopen?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `leveren` field. */
  leveren?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `locatie` field. */
  locatie?: InputMaybe<StringFilter>;
  /** Filter by the object’s `maxvoorraad` field. */
  maxvoorraad?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minvoorraad` field. */
  minvoorraad?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VoorradenMvFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VoorradenMvFilter>>;
  /** Filter by the object’s `voorraad` field. */
  voorraad?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `VoorradenMv` values. */
export type VoorradenMvsConnection = {
  __typename?: 'VoorradenMvsConnection';
  /** A list of edges which contains the `VoorradenMv` and cursor to aid in pagination. */
  edges: Array<VoorradenMvsEdge>;
  /** A list of `VoorradenMv` objects. */
  nodes: Array<VoorradenMv>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VoorradenMv` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VoorradenMv` edge in the connection. */
export type VoorradenMvsEdge = {
  __typename?: 'VoorradenMvsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VoorradenMv` at the end of the edge. */
  node: VoorradenMv;
};

/** Methods to use when ordering `VoorradenMv`. */
export enum VoorradenMvsOrderBy {
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  AssemblbijAsc = 'ASSEMBLBIJ_ASC',
  AssemblbijDesc = 'ASSEMBLBIJ_DESC',
  BesteldAsc = 'BESTELD_ASC',
  BesteldDesc = 'BESTELD_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  GeleverdAsc = 'GELEVERD_ASC',
  GeleverdDesc = 'GELEVERD_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  LeverenAsc = 'LEVEREN_ASC',
  LeverenDesc = 'LEVEREN_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC'
}

/** Represents an update to a `Voorraden`. Fields that are set will be updated. */
export type VoorradenPatch = {
  assemblaf?: InputMaybe<Scalars['BigFloat']['input']>;
  assemblbij?: InputMaybe<Scalars['BigFloat']['input']>;
  besteld?: InputMaybe<Scalars['BigFloat']['input']>;
  cdartikel?: InputMaybe<Scalars['String']['input']>;
  cdmagazijn?: InputMaybe<Scalars['String']['input']>;
  geleverd?: InputMaybe<Scalars['BigFloat']['input']>;
  gereserveerd?: InputMaybe<Scalars['BigFloat']['input']>;
  inkopen?: InputMaybe<Scalars['BigFloat']['input']>;
  leveren?: InputMaybe<Scalars['BigFloat']['input']>;
  locatie?: InputMaybe<Scalars['String']['input']>;
  maxvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  minvoorraad?: InputMaybe<Scalars['BigFloat']['input']>;
  voorraad?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A connection to a list of `Voorraden` values. */
export type VoorradensConnection = {
  __typename?: 'VoorradensConnection';
  /** A list of edges which contains the `Voorraden` and cursor to aid in pagination. */
  edges: Array<VoorradensEdge>;
  /** A list of `Voorraden` objects. */
  nodes: Array<Voorraden>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Voorraden` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Voorraden` edge in the connection. */
export type VoorradensEdge = {
  __typename?: 'VoorradensEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Voorraden` at the end of the edge. */
  node: Voorraden;
};

/** Methods to use when ordering `Voorraden`. */
export enum VoorradensOrderBy {
  AssemblafAsc = 'ASSEMBLAF_ASC',
  AssemblafDesc = 'ASSEMBLAF_DESC',
  AssemblbijAsc = 'ASSEMBLBIJ_ASC',
  AssemblbijDesc = 'ASSEMBLBIJ_DESC',
  BesteldAsc = 'BESTELD_ASC',
  BesteldDesc = 'BESTELD_DESC',
  CdartikelAsc = 'CDARTIKEL_ASC',
  CdartikelDesc = 'CDARTIKEL_DESC',
  CdmagazijnAsc = 'CDMAGAZIJN_ASC',
  CdmagazijnDesc = 'CDMAGAZIJN_DESC',
  GeleverdAsc = 'GELEVERD_ASC',
  GeleverdDesc = 'GELEVERD_DESC',
  GereserveerdAsc = 'GERESERVEERD_ASC',
  GereserveerdDesc = 'GERESERVEERD_DESC',
  InkopenAsc = 'INKOPEN_ASC',
  InkopenDesc = 'INKOPEN_DESC',
  LeverenAsc = 'LEVEREN_ASC',
  LeverenDesc = 'LEVEREN_DESC',
  LocatieAsc = 'LOCATIE_ASC',
  LocatieDesc = 'LOCATIE_DESC',
  MaxvoorraadAsc = 'MAXVOORRAAD_ASC',
  MaxvoorraadDesc = 'MAXVOORRAAD_DESC',
  MinvoorraadAsc = 'MINVOORRAAD_ASC',
  MinvoorraadDesc = 'MINVOORRAAD_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  VoorraadAsc = 'VOORRAAD_ASC',
  VoorraadDesc = 'VOORRAAD_DESC'
}

export type WeeklyHour = Node & {
  __typename?: 'WeeklyHour';
  created?: Maybe<Scalars['Datetime']['output']>;
  endTime?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  office: Scalars['Boolean']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  startTime?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `Task` that is related to this `WeeklyHour`. */
  taskByTaskId?: Maybe<Task>;
  taskId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `WeeklyHour`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `WeeklyHour`. */
  userByUserId?: Maybe<User>;
  userId: Scalars['Int']['output'];
};

/**
 * A condition to be used against `WeeklyHour` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type WeeklyHourCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `endTime` field. */
  endTime?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `office` field. */
  office?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `startTime` field. */
  startTime?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `taskId` field. */
  taskId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `WeeklyHour` object types. All fields are combined with a logical ‘and.’ */
export type WeeklyHourFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WeeklyHourFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `endTime` field. */
  endTime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WeeklyHourFilter>;
  /** Filter by the object’s `office` field. */
  office?: InputMaybe<BooleanFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WeeklyHourFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `startTime` field. */
  startTime?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `taskByTaskId` relation. */
  taskByTaskId?: InputMaybe<TaskFilter>;
  /** Filter by the object’s `taskId` field. */
  taskId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `WeeklyHour` */
export type WeeklyHourInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  endTime?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  office?: InputMaybe<Scalars['Boolean']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  startTime?: InputMaybe<Scalars['Datetime']['input']>;
  taskId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** Represents an update to a `WeeklyHour`. Fields that are set will be updated. */
export type WeeklyHourPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  endTime?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  office?: InputMaybe<Scalars['Boolean']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  startTime?: InputMaybe<Scalars['Datetime']['input']>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

export type WeeklyHourRemark = Node & {
  __typename?: 'WeeklyHourRemark';
  created?: Maybe<Scalars['Datetime']['output']>;
  date?: Maybe<Scalars['Date']['output']>;
  id: Scalars['Int']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  ownerId?: Maybe<Scalars['Int']['output']>;
  remark?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Task` that is related to this `WeeklyHourRemark`. */
  taskByTaskId?: Maybe<Task>;
  taskId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `User` that is related to this `WeeklyHourRemark`. */
  userByOwnerId?: Maybe<User>;
  /** Reads a single `User` that is related to this `WeeklyHourRemark`. */
  userByUserId?: Maybe<User>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `WeeklyHourRemark` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type WeeklyHourRemarkCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `ownerId` field. */
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `remark` field. */
  remark?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `taskId` field. */
  taskId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `WeeklyHourRemark` object types. All fields are combined with a logical ‘and.’ */
export type WeeklyHourRemarkFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WeeklyHourRemarkFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DateFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WeeklyHourRemarkFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WeeklyHourRemarkFilter>>;
  /** Filter by the object’s `ownerId` field. */
  ownerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `remark` field. */
  remark?: InputMaybe<StringFilter>;
  /** Filter by the object’s `taskByTaskId` relation. */
  taskByTaskId?: InputMaybe<TaskFilter>;
  /** A related `taskByTaskId` exists. */
  taskByTaskIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `taskId` field. */
  taskId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userByOwnerId` relation. */
  userByOwnerId?: InputMaybe<UserFilter>;
  /** A related `userByOwnerId` exists. */
  userByOwnerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userByUserId` relation. */
  userByUserId?: InputMaybe<UserFilter>;
  /** A related `userByUserId` exists. */
  userByUserIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `WeeklyHourRemark` */
export type WeeklyHourRemarkInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remark?: InputMaybe<Scalars['String']['input']>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `WeeklyHourRemark`. Fields that are set will be updated. */
export type WeeklyHourRemarkPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  date?: InputMaybe<Scalars['Date']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  ownerId?: InputMaybe<Scalars['Int']['input']>;
  remark?: InputMaybe<Scalars['String']['input']>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `WeeklyHourRemark` values. */
export type WeeklyHourRemarksConnection = {
  __typename?: 'WeeklyHourRemarksConnection';
  /** A list of edges which contains the `WeeklyHourRemark` and cursor to aid in pagination. */
  edges: Array<WeeklyHourRemarksEdge>;
  /** A list of `WeeklyHourRemark` objects. */
  nodes: Array<WeeklyHourRemark>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WeeklyHourRemark` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `WeeklyHourRemark` edge in the connection. */
export type WeeklyHourRemarksEdge = {
  __typename?: 'WeeklyHourRemarksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `WeeklyHourRemark` at the end of the edge. */
  node: WeeklyHourRemark;
};

/** Methods to use when ordering `WeeklyHourRemark`. */
export enum WeeklyHourRemarksOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RemarkAsc = 'REMARK_ASC',
  RemarkDesc = 'REMARK_DESC',
  TaskByTaskIdCodeAsc = 'TASK_BY_TASK_ID__CODE_ASC',
  TaskByTaskIdCodeDesc = 'TASK_BY_TASK_ID__CODE_DESC',
  TaskByTaskIdCreatedAsc = 'TASK_BY_TASK_ID__CREATED_ASC',
  TaskByTaskIdCreatedDesc = 'TASK_BY_TASK_ID__CREATED_DESC',
  TaskByTaskIdDescriptionAsc = 'TASK_BY_TASK_ID__DESCRIPTION_ASC',
  TaskByTaskIdDescriptionDesc = 'TASK_BY_TASK_ID__DESCRIPTION_DESC',
  TaskByTaskIdGroupCodeAsc = 'TASK_BY_TASK_ID__GROUP_CODE_ASC',
  TaskByTaskIdGroupCodeDesc = 'TASK_BY_TASK_ID__GROUP_CODE_DESC',
  TaskByTaskIdIdAsc = 'TASK_BY_TASK_ID__ID_ASC',
  TaskByTaskIdIdDesc = 'TASK_BY_TASK_ID__ID_DESC',
  TaskByTaskIdModifiedAsc = 'TASK_BY_TASK_ID__MODIFIED_ASC',
  TaskByTaskIdModifiedDesc = 'TASK_BY_TASK_ID__MODIFIED_DESC',
  TaskByTaskIdNameAsc = 'TASK_BY_TASK_ID__NAME_ASC',
  TaskByTaskIdNameDesc = 'TASK_BY_TASK_ID__NAME_DESC',
  TaskByTaskIdOwnerIdAsc = 'TASK_BY_TASK_ID__OWNER_ID_ASC',
  TaskByTaskIdOwnerIdDesc = 'TASK_BY_TASK_ID__OWNER_ID_DESC',
  TaskByTaskIdSortCodeAsc = 'TASK_BY_TASK_ID__SORT_CODE_ASC',
  TaskByTaskIdSortCodeDesc = 'TASK_BY_TASK_ID__SORT_CODE_DESC',
  TaskByTaskIdWbsoEndDateAsc = 'TASK_BY_TASK_ID__WBSO_END_DATE_ASC',
  TaskByTaskIdWbsoEndDateDesc = 'TASK_BY_TASK_ID__WBSO_END_DATE_DESC',
  TaskByTaskIdWbsoStartDateAsc = 'TASK_BY_TASK_ID__WBSO_START_DATE_ASC',
  TaskByTaskIdWbsoStartDateDesc = 'TASK_BY_TASK_ID__WBSO_START_DATE_DESC',
  TaskIdAsc = 'TASK_ID_ASC',
  TaskIdDesc = 'TASK_ID_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `WeeklyHour` values. */
export type WeeklyHoursConnection = {
  __typename?: 'WeeklyHoursConnection';
  /** A list of edges which contains the `WeeklyHour` and cursor to aid in pagination. */
  edges: Array<WeeklyHoursEdge>;
  /** A list of `WeeklyHour` objects. */
  nodes: Array<WeeklyHour>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WeeklyHour` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `WeeklyHour` edge in the connection. */
export type WeeklyHoursEdge = {
  __typename?: 'WeeklyHoursEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `WeeklyHour` at the end of the edge. */
  node: WeeklyHour;
};

/** Methods to use when ordering `WeeklyHour`. */
export enum WeeklyHoursOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EndTimeAsc = 'END_TIME_ASC',
  EndTimeDesc = 'END_TIME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  OfficeAsc = 'OFFICE_ASC',
  OfficeDesc = 'OFFICE_DESC',
  OwnerIdAsc = 'OWNER_ID_ASC',
  OwnerIdDesc = 'OWNER_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StartTimeAsc = 'START_TIME_ASC',
  StartTimeDesc = 'START_TIME_DESC',
  TaskByTaskIdCodeAsc = 'TASK_BY_TASK_ID__CODE_ASC',
  TaskByTaskIdCodeDesc = 'TASK_BY_TASK_ID__CODE_DESC',
  TaskByTaskIdCreatedAsc = 'TASK_BY_TASK_ID__CREATED_ASC',
  TaskByTaskIdCreatedDesc = 'TASK_BY_TASK_ID__CREATED_DESC',
  TaskByTaskIdDescriptionAsc = 'TASK_BY_TASK_ID__DESCRIPTION_ASC',
  TaskByTaskIdDescriptionDesc = 'TASK_BY_TASK_ID__DESCRIPTION_DESC',
  TaskByTaskIdGroupCodeAsc = 'TASK_BY_TASK_ID__GROUP_CODE_ASC',
  TaskByTaskIdGroupCodeDesc = 'TASK_BY_TASK_ID__GROUP_CODE_DESC',
  TaskByTaskIdIdAsc = 'TASK_BY_TASK_ID__ID_ASC',
  TaskByTaskIdIdDesc = 'TASK_BY_TASK_ID__ID_DESC',
  TaskByTaskIdModifiedAsc = 'TASK_BY_TASK_ID__MODIFIED_ASC',
  TaskByTaskIdModifiedDesc = 'TASK_BY_TASK_ID__MODIFIED_DESC',
  TaskByTaskIdNameAsc = 'TASK_BY_TASK_ID__NAME_ASC',
  TaskByTaskIdNameDesc = 'TASK_BY_TASK_ID__NAME_DESC',
  TaskByTaskIdOwnerIdAsc = 'TASK_BY_TASK_ID__OWNER_ID_ASC',
  TaskByTaskIdOwnerIdDesc = 'TASK_BY_TASK_ID__OWNER_ID_DESC',
  TaskByTaskIdSortCodeAsc = 'TASK_BY_TASK_ID__SORT_CODE_ASC',
  TaskByTaskIdSortCodeDesc = 'TASK_BY_TASK_ID__SORT_CODE_DESC',
  TaskByTaskIdWbsoEndDateAsc = 'TASK_BY_TASK_ID__WBSO_END_DATE_ASC',
  TaskByTaskIdWbsoEndDateDesc = 'TASK_BY_TASK_ID__WBSO_END_DATE_DESC',
  TaskByTaskIdWbsoStartDateAsc = 'TASK_BY_TASK_ID__WBSO_START_DATE_ASC',
  TaskByTaskIdWbsoStartDateDesc = 'TASK_BY_TASK_ID__WBSO_START_DATE_DESC',
  TaskIdAsc = 'TASK_ID_ASC',
  TaskIdDesc = 'TASK_ID_DESC',
  UserByOwnerIdCreatedAsc = 'USER_BY_OWNER_ID__CREATED_ASC',
  UserByOwnerIdCreatedDesc = 'USER_BY_OWNER_ID__CREATED_DESC',
  UserByOwnerIdFullnameAsc = 'USER_BY_OWNER_ID__FULLNAME_ASC',
  UserByOwnerIdFullnameDesc = 'USER_BY_OWNER_ID__FULLNAME_DESC',
  UserByOwnerIdGroupIdAsc = 'USER_BY_OWNER_ID__GROUP_ID_ASC',
  UserByOwnerIdGroupIdDesc = 'USER_BY_OWNER_ID__GROUP_ID_DESC',
  UserByOwnerIdHolidayStartBalanceAsc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByOwnerIdHolidayStartBalanceDesc = 'USER_BY_OWNER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByOwnerIdIdAsc = 'USER_BY_OWNER_ID__ID_ASC',
  UserByOwnerIdIdDesc = 'USER_BY_OWNER_ID__ID_DESC',
  UserByOwnerIdInitialsAsc = 'USER_BY_OWNER_ID__INITIALS_ASC',
  UserByOwnerIdInitialsDesc = 'USER_BY_OWNER_ID__INITIALS_DESC',
  UserByOwnerIdModifiedAsc = 'USER_BY_OWNER_ID__MODIFIED_ASC',
  UserByOwnerIdModifiedDesc = 'USER_BY_OWNER_ID__MODIFIED_DESC',
  UserByOwnerIdOvertimeStartBalanceAsc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_ASC',
  UserByOwnerIdOvertimeStartBalanceDesc = 'USER_BY_OWNER_ID__OVERTIME_START_BALANCE_DESC',
  UserByOwnerIdPasswordAsc = 'USER_BY_OWNER_ID__PASSWORD_ASC',
  UserByOwnerIdPasswordDesc = 'USER_BY_OWNER_ID__PASSWORD_DESC',
  UserByOwnerIdUrlAsc = 'USER_BY_OWNER_ID__URL_ASC',
  UserByOwnerIdUrlDesc = 'USER_BY_OWNER_ID__URL_DESC',
  UserByOwnerIdUsernameAsc = 'USER_BY_OWNER_ID__USERNAME_ASC',
  UserByOwnerIdUsernameDesc = 'USER_BY_OWNER_ID__USERNAME_DESC',
  UserByOwnerIdWeeklyHoursFullAccessAsc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByOwnerIdWeeklyHoursFullAccessDesc = 'USER_BY_OWNER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdFullnameAsc = 'USER_BY_USER_ID__FULLNAME_ASC',
  UserByUserIdFullnameDesc = 'USER_BY_USER_ID__FULLNAME_DESC',
  UserByUserIdGroupIdAsc = 'USER_BY_USER_ID__GROUP_ID_ASC',
  UserByUserIdGroupIdDesc = 'USER_BY_USER_ID__GROUP_ID_DESC',
  UserByUserIdHolidayStartBalanceAsc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_ASC',
  UserByUserIdHolidayStartBalanceDesc = 'USER_BY_USER_ID__HOLIDAY_START_BALANCE_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdInitialsAsc = 'USER_BY_USER_ID__INITIALS_ASC',
  UserByUserIdInitialsDesc = 'USER_BY_USER_ID__INITIALS_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdOvertimeStartBalanceAsc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_ASC',
  UserByUserIdOvertimeStartBalanceDesc = 'USER_BY_USER_ID__OVERTIME_START_BALANCE_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdUrlAsc = 'USER_BY_USER_ID__URL_ASC',
  UserByUserIdUrlDesc = 'USER_BY_USER_ID__URL_DESC',
  UserByUserIdUsernameAsc = 'USER_BY_USER_ID__USERNAME_ASC',
  UserByUserIdUsernameDesc = 'USER_BY_USER_ID__USERNAME_DESC',
  UserByUserIdWeeklyHoursFullAccessAsc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_ASC',
  UserByUserIdWeeklyHoursFullAccessDesc = 'USER_BY_USER_ID__WEEKLY_HOURS_FULL_ACCESS_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type WeeklyHoursWeekTotal = {
  __typename?: 'WeeklyHoursWeekTotal';
  absent?: Maybe<Scalars['Int']['output']>;
  compensation?: Maybe<Scalars['Int']['output']>;
  compensationSpent?: Maybe<Scalars['Int']['output']>;
  holidaySpent?: Maybe<Scalars['Int']['output']>;
  office?: Maybe<Scalars['BigInt']['output']>;
  spareHourSpent?: Maybe<Scalars['Int']['output']>;
  target?: Maybe<Scalars['Int']['output']>;
  total?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  week?: Maybe<Scalars['String']['output']>;
  worked?: Maybe<Scalars['Int']['output']>;
  year?: Maybe<Scalars['String']['output']>;
  yearWeek?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `WeeklyHoursWeekTotal` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type WeeklyHoursWeekTotalCondition = {
  /** Checks for equality with the object’s `absent` field. */
  absent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `compensation` field. */
  compensation?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `compensationSpent` field. */
  compensationSpent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `holidaySpent` field. */
  holidaySpent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `office` field. */
  office?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `spareHourSpent` field. */
  spareHourSpent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `target` field. */
  target?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `total` field. */
  total?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `week` field. */
  week?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `worked` field. */
  worked?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `year` field. */
  year?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `yearWeek` field. */
  yearWeek?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `WeeklyHoursWeekTotal` object types. All fields are combined with a logical ‘and.’ */
export type WeeklyHoursWeekTotalFilter = {
  /** Filter by the object’s `absent` field. */
  absent?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WeeklyHoursWeekTotalFilter>>;
  /** Filter by the object’s `compensation` field. */
  compensation?: InputMaybe<IntFilter>;
  /** Filter by the object’s `compensationSpent` field. */
  compensationSpent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `holidaySpent` field. */
  holidaySpent?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WeeklyHoursWeekTotalFilter>;
  /** Filter by the object’s `office` field. */
  office?: InputMaybe<BigIntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WeeklyHoursWeekTotalFilter>>;
  /** Filter by the object’s `spareHourSpent` field. */
  spareHourSpent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `target` field. */
  target?: InputMaybe<IntFilter>;
  /** Filter by the object’s `total` field. */
  total?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `week` field. */
  week?: InputMaybe<StringFilter>;
  /** Filter by the object’s `worked` field. */
  worked?: InputMaybe<IntFilter>;
  /** Filter by the object’s `year` field. */
  year?: InputMaybe<StringFilter>;
  /** Filter by the object’s `yearWeek` field. */
  yearWeek?: InputMaybe<StringFilter>;
};

/** A connection to a list of `WeeklyHoursWeekTotal` values. */
export type WeeklyHoursWeekTotalsConnection = {
  __typename?: 'WeeklyHoursWeekTotalsConnection';
  /** A list of edges which contains the `WeeklyHoursWeekTotal` and cursor to aid in pagination. */
  edges: Array<WeeklyHoursWeekTotalsEdge>;
  /** A list of `WeeklyHoursWeekTotal` objects. */
  nodes: Array<WeeklyHoursWeekTotal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `WeeklyHoursWeekTotal` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `WeeklyHoursWeekTotal` edge in the connection. */
export type WeeklyHoursWeekTotalsEdge = {
  __typename?: 'WeeklyHoursWeekTotalsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `WeeklyHoursWeekTotal` at the end of the edge. */
  node: WeeklyHoursWeekTotal;
};

/** Methods to use when ordering `WeeklyHoursWeekTotal`. */
export enum WeeklyHoursWeekTotalsOrderBy {
  AbsentAsc = 'ABSENT_ASC',
  AbsentDesc = 'ABSENT_DESC',
  CompensationAsc = 'COMPENSATION_ASC',
  CompensationDesc = 'COMPENSATION_DESC',
  CompensationSpentAsc = 'COMPENSATION_SPENT_ASC',
  CompensationSpentDesc = 'COMPENSATION_SPENT_DESC',
  HolidaySpentAsc = 'HOLIDAY_SPENT_ASC',
  HolidaySpentDesc = 'HOLIDAY_SPENT_DESC',
  Natural = 'NATURAL',
  OfficeAsc = 'OFFICE_ASC',
  OfficeDesc = 'OFFICE_DESC',
  SpareHourSpentAsc = 'SPARE_HOUR_SPENT_ASC',
  SpareHourSpentDesc = 'SPARE_HOUR_SPENT_DESC',
  TargetAsc = 'TARGET_ASC',
  TargetDesc = 'TARGET_DESC',
  TotalAsc = 'TOTAL_ASC',
  TotalDesc = 'TOTAL_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  WeekAsc = 'WEEK_ASC',
  WeekDesc = 'WEEK_DESC',
  WorkedAsc = 'WORKED_ASC',
  WorkedDesc = 'WORKED_DESC',
  YearAsc = 'YEAR_ASC',
  YearDesc = 'YEAR_DESC',
  YearWeekAsc = 'YEAR_WEEK_ASC',
  YearWeekDesc = 'YEAR_WEEK_DESC'
}

export type _Adre = Node & {
  __typename?: '_Adre';
  adresGuid: Scalars['String']['output'];
  adrestype: Scalars['String']['output'];
  cdadres?: Maybe<Scalars['Int']['output']>;
  cdland?: Maybe<Scalars['String']['output']>;
  cdpersoon?: Maybe<Scalars['String']['output']>;
  cdrelatie?: Maybe<Scalars['Int']['output']>;
  cdtaal?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  homepage?: Maybe<Scalars['String']['output']>;
  naam?: Maybe<Scalars['String']['output']>;
  naamstraat?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  persoon?: Maybe<Scalars['String']['output']>;
  postcode?: Maybe<Scalars['String']['output']>;
  straat?: Maybe<Scalars['String']['output']>;
  telefax?: Maybe<Scalars['String']['output']>;
  telefoon?: Maybe<Scalars['String']['output']>;
  telefoonmobiel?: Maybe<Scalars['String']['output']>;
  woonplaats?: Maybe<Scalars['String']['output']>;
};

/** An input for mutations affecting `_Adre` */
export type _AdreInput = {
  adresGuid: Scalars['String']['input'];
  adrestype: Scalars['String']['input'];
  cdadres?: InputMaybe<Scalars['Int']['input']>;
  cdland?: InputMaybe<Scalars['String']['input']>;
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  homepage?: InputMaybe<Scalars['String']['input']>;
  naam?: InputMaybe<Scalars['String']['input']>;
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  persoon?: InputMaybe<Scalars['String']['input']>;
  postcode?: InputMaybe<Scalars['String']['input']>;
  straat?: InputMaybe<Scalars['String']['input']>;
  telefax?: InputMaybe<Scalars['String']['input']>;
  telefoon?: InputMaybe<Scalars['String']['input']>;
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  woonplaats?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `_Adre`. Fields that are set will be updated. */
export type _AdrePatch = {
  adresGuid?: InputMaybe<Scalars['String']['input']>;
  adrestype?: InputMaybe<Scalars['String']['input']>;
  cdadres?: InputMaybe<Scalars['Int']['input']>;
  cdland?: InputMaybe<Scalars['String']['input']>;
  cdpersoon?: InputMaybe<Scalars['String']['input']>;
  cdrelatie?: InputMaybe<Scalars['Int']['input']>;
  cdtaal?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  homepage?: InputMaybe<Scalars['String']['input']>;
  naam?: InputMaybe<Scalars['String']['input']>;
  naamstraat?: InputMaybe<Scalars['String']['input']>;
  persoon?: InputMaybe<Scalars['String']['input']>;
  postcode?: InputMaybe<Scalars['String']['input']>;
  straat?: InputMaybe<Scalars['String']['input']>;
  telefax?: InputMaybe<Scalars['String']['input']>;
  telefoon?: InputMaybe<Scalars['String']['input']>;
  telefoonmobiel?: InputMaybe<Scalars['String']['input']>;
  woonplaats?: InputMaybe<Scalars['String']['input']>;
};

/** A `_Adre` edge in the connection. */
export type _AdresEdge = {
  __typename?: '_AdresEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `_Adre` at the end of the edge. */
  node: _Adre;
};

/** Methods to use when ordering `_Adre`. */
export enum _AdresOrderBy {
  AdrestypeAsc = 'ADRESTYPE_ASC',
  AdrestypeDesc = 'ADRESTYPE_DESC',
  AdresGuidAsc = 'ADRES_GUID_ASC',
  AdresGuidDesc = 'ADRES_GUID_DESC',
  CdadresAsc = 'CDADRES_ASC',
  CdadresDesc = 'CDADRES_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  CdpersoonAsc = 'CDPERSOON_ASC',
  CdpersoonDesc = 'CDPERSOON_DESC',
  CdrelatieAsc = 'CDRELATIE_ASC',
  CdrelatieDesc = 'CDRELATIE_DESC',
  CdtaalAsc = 'CDTAAL_ASC',
  CdtaalDesc = 'CDTAAL_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  HomepageAsc = 'HOMEPAGE_ASC',
  HomepageDesc = 'HOMEPAGE_DESC',
  NaamstraatAsc = 'NAAMSTRAAT_ASC',
  NaamstraatDesc = 'NAAMSTRAAT_DESC',
  NaamAsc = 'NAAM_ASC',
  NaamDesc = 'NAAM_DESC',
  Natural = 'NATURAL',
  PersoonAsc = 'PERSOON_ASC',
  PersoonDesc = 'PERSOON_DESC',
  PostcodeAsc = 'POSTCODE_ASC',
  PostcodeDesc = 'POSTCODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StraatAsc = 'STRAAT_ASC',
  StraatDesc = 'STRAAT_DESC',
  TelefaxAsc = 'TELEFAX_ASC',
  TelefaxDesc = 'TELEFAX_DESC',
  TelefoonmobielAsc = 'TELEFOONMOBIEL_ASC',
  TelefoonmobielDesc = 'TELEFOONMOBIEL_DESC',
  TelefoonAsc = 'TELEFOON_ASC',
  TelefoonDesc = 'TELEFOON_DESC',
  WoonplaatsAsc = 'WOONPLAATS_ASC',
  WoonplaatsDesc = 'WOONPLAATS_DESC'
}

export type _Land = Node & {
  __typename?: '_Land';
  cbsland?: Maybe<Scalars['String']['output']>;
  cdeglid?: Maybe<Scalars['String']['output']>;
  cdland: Scalars['String']['output'];
  isoland?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  omschr?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Opportunity`. */
  opportunitiesByCdland: OpportunitiesConnection;
  rszland?: Maybe<Scalars['Int']['output']>;
  sepa?: Maybe<Scalars['String']['output']>;
};


export type _LandOpportunitiesByCdlandArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OpportunityCondition>;
  filter?: InputMaybe<OpportunityFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** A filter to be used against `_Land` object types. All fields are combined with a logical ‘and.’ */
export type _LandFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_LandFilter>>;
  /** Filter by the object’s `cbsland` field. */
  cbsland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdeglid` field. */
  cdeglid?: InputMaybe<StringFilter>;
  /** Filter by the object’s `cdland` field. */
  cdland?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isoland` field. */
  isoland?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<_LandFilter>;
  /** Filter by the object’s `omschr` field. */
  omschr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `opportunitiesByCdland` relation. */
  opportunitiesByCdland?: InputMaybe<_LandToManyOpportunityFilter>;
  /** Some related `opportunitiesByCdland` exist. */
  opportunitiesByCdlandExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_LandFilter>>;
  /** Filter by the object’s `rszland` field. */
  rszland?: InputMaybe<IntFilter>;
  /** Filter by the object’s `sepa` field. */
  sepa?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `_Land` */
export type _LandInput = {
  cbsland?: InputMaybe<Scalars['String']['input']>;
  cdeglid?: InputMaybe<Scalars['String']['input']>;
  cdland: Scalars['String']['input'];
  isoland?: InputMaybe<Scalars['String']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  rszland?: InputMaybe<Scalars['Int']['input']>;
  sepa?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `_Land`. Fields that are set will be updated. */
export type _LandPatch = {
  cbsland?: InputMaybe<Scalars['String']['input']>;
  cdeglid?: InputMaybe<Scalars['String']['input']>;
  cdland?: InputMaybe<Scalars['String']['input']>;
  isoland?: InputMaybe<Scalars['String']['input']>;
  omschr?: InputMaybe<Scalars['String']['input']>;
  rszland?: InputMaybe<Scalars['Int']['input']>;
  sepa?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `Opportunity` object types. All fields are combined with a logical ‘and.’ */
export type _LandToManyOpportunityFilter = {
  /** Every related `Opportunity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OpportunityFilter>;
  /** No related `Opportunity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OpportunityFilter>;
  /** Some related `Opportunity` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OpportunityFilter>;
};

/** A `_Land` edge in the connection. */
export type _LandsEdge = {
  __typename?: '_LandsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `_Land` at the end of the edge. */
  node: _Land;
};

/** Methods to use when ordering `_Land`. */
export enum _LandsOrderBy {
  CbslandAsc = 'CBSLAND_ASC',
  CbslandDesc = 'CBSLAND_DESC',
  CdeglidAsc = 'CDEGLID_ASC',
  CdeglidDesc = 'CDEGLID_DESC',
  CdlandAsc = 'CDLAND_ASC',
  CdlandDesc = 'CDLAND_DESC',
  IsolandAsc = 'ISOLAND_ASC',
  IsolandDesc = 'ISOLAND_DESC',
  Natural = 'NATURAL',
  OmschrAsc = 'OMSCHR_ASC',
  OmschrDesc = 'OMSCHR_DESC',
  OpportunitiesByCdlandCountAsc = 'OPPORTUNITIES_BY_CDLAND__COUNT_ASC',
  OpportunitiesByCdlandCountDesc = 'OPPORTUNITIES_BY_CDLAND__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RszlandAsc = 'RSZLAND_ASC',
  RszlandDesc = 'RSZLAND_DESC',
  SepaAsc = 'SEPA_ASC',
  SepaDesc = 'SEPA_DESC'
}

export type AllApplicationsNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllApplicationsNoPaginationQuery = { __typename?: 'Query', allApplications?: { __typename?: 'ApplicationsConnection', nodes: Array<{ __typename?: 'Application', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type AllApplicationsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: ApplicationFilter;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy> | ApplicationsOrderBy>;
}>;


export type AllApplicationsQuery = { __typename?: 'Query', allApplications?: { __typename?: 'ApplicationsConnection', totalCount: number, nodes: Array<{ __typename?: 'Application', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type CreateApplicationMutationVariables = Exact<{
  body: ApplicationInput;
}>;


export type CreateApplicationMutation = { __typename?: 'Mutation', createApplication?: { __typename?: 'CreateApplicationPayload', application?: { __typename?: 'Application', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdateApplicationMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: ApplicationPatch;
}>;


export type UpdateApplicationMutation = { __typename?: 'Mutation', updateApplicationById?: { __typename?: 'UpdateApplicationPayload', application?: { __typename?: 'Application', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeleteApplicationMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteApplicationMutation = { __typename?: 'Mutation', deleteApplicationById?: { __typename?: 'DeleteApplicationPayload', clientMutationId?: string | null } | null };

export type AllAreasNoPaginationQueryVariables = Exact<{
  floorId?: InputMaybe<Array<Scalars['Int']['input']> | Scalars['Int']['input']>;
}>;


export type AllAreasNoPaginationQuery = { __typename?: 'Query', allAreas?: { __typename?: 'AreasConnection', nodes: Array<{ __typename?: 'Area', id: number, name: string, remarks?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type AllAreaEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: AreaEntityFilter;
  orderBy?: InputMaybe<Array<AreaEntitiesOrderBy> | AreaEntitiesOrderBy>;
}>;


export type AllAreaEntitiesQuery = { __typename?: 'Query', allAreaEntities?: { __typename?: 'AreaEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'AreaEntity', id?: number | null, name?: string | null, created?: any | null, remarks?: string | null, floorName?: string | null, floorId?: number | null, endUserName?: string | null, endUserId?: number | null, buildingName?: string | null, buildingId?: number | null, initials?: string | null, ownerId?: number | null }> } | null };

export type CreateAreaMutationVariables = Exact<{
  body: AreaInput;
}>;


export type CreateAreaMutation = { __typename?: 'Mutation', createArea?: { __typename?: 'CreateAreaPayload', area?: { __typename?: 'Area', id: number, name: string, created?: any | null, floorByFloorId?: { __typename?: 'Floor', name: string, buildingByBuildingId?: { __typename?: 'Building', id: number, name: string, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null } | null } | null } | null } | null };

export type UpdateAreaMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: AreaPatch;
}>;


export type UpdateAreaMutation = { __typename?: 'Mutation', updateAreaById?: { __typename?: 'UpdateAreaPayload', area?: { __typename?: 'Area', id: number, name: string, created?: any | null, floorByFloorId?: { __typename?: 'Floor', name: string, buildingByBuildingId?: { __typename?: 'Building', id: number, name: string, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null } | null } | null } | null } | null };

export type DeleteAreaMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteAreaMutation = { __typename?: 'Mutation', deleteAreaById?: { __typename?: 'DeleteAreaPayload', clientMutationId?: string | null } | null };

export type AllAssemblyMultiversEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: AssemblyMultiversEntityFilter;
  orderBy?: InputMaybe<Array<AssemblyMultiversEntitiesOrderBy> | AssemblyMultiversEntitiesOrderBy>;
}>;


export type AllAssemblyMultiversEntitiesQuery = { __typename?: 'Query', allAssemblyMultiversEntities?: { __typename?: 'AssemblyMultiversEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'AssemblyMultiversEntity', id?: string | null, aantal?: any | null, aantalGeassembleerd?: any | null, aantalgereservbij?: any | null, advice?: number | null, afdrukAssemblageBon?: string | null, assemblageDatum?: any | null, assemblageOrder?: string | null, cdartikel?: string | null, cdmagazijn?: string | null, commentaar?: string | null, omschr?: string | null, guidItem?: string | null, orderDatum?: any | null, status?: string | null, sysCreate?: string | null, sysUpdate?: string | null, waardeGeassembleerd?: any | null }> } | null };

export type AllAssemblyLinesMultiversEntitiesQueryVariables = Exact<{
  assemblage_order?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  search: Scalars['String']['input'];
  orderBy?: InputMaybe<Array<AssemblyLineEntitiesOrderBy> | AssemblyLineEntitiesOrderBy>;
}>;


export type AllAssemblyLinesMultiversEntitiesQuery = { __typename?: 'Query', allAssemblyLineEntities?: { __typename?: 'AssemblyLineEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'AssemblyLineEntity', omschr?: string | null, zoeknaam?: string | null, waardeGebruikt?: any | null, voorraad?: any | null, minvoorraad?: any | null, maxvoorraad?: any | null, locatie?: string | null, inkvolgnr?: number | null, inkopen?: any | null, gereserveerd?: any | null, cdmagazijn?: string | null, cdcrediteur?: string | null, cdartikel?: string | null, bestcode?: string | null, assemblageOrder?: string | null, assemblageDatum?: any | null, advice?: number | null, aantalSamenstelling?: any | null, aantalNorm?: any | null, aantalGebruikt?: any | null }> } | null };

export type AssemblyMultiversByIdQueryVariables = Exact<{
  id?: InputMaybe<Scalars['String']['input']>;
}>;


export type AssemblyMultiversByIdQuery = { __typename?: 'Query', assemblyMultiversById?: { __typename?: 'AssemblyMultiversEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'AssemblyMultiversEntity', id?: string | null, aantal?: any | null, omschr?: string | null, aantalGeassembleerd?: any | null, aantalgereservbij?: any | null, advice?: number | null, afdrukAssemblageBon?: string | null, assemblageDatum?: any | null, assemblageOrder?: string | null, cdartikel?: string | null, cdmagazijn?: string | null, commentaar?: string | null, guidItem?: string | null, orderDatum?: any | null, status?: string | null, sysCreate?: string | null, sysUpdate?: string | null, waardeGeassembleerd?: any | null }> } | null };

export type AssemblyTypeEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: AssemblyTypesEntityFilter;
  orderBy?: InputMaybe<Array<AssemblyTypesEntitiesOrderBy> | AssemblyTypesEntitiesOrderBy>;
}>;


export type AssemblyTypeEntitiesQuery = { __typename?: 'Query', assemblyTypes?: { __typename?: 'AssemblyTypesEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'AssemblyTypesEntity', id?: number | null, name?: string | null, cdartikel?: string | null, created?: any | null, modified?: any | null, minvoorraad?: any | null, maxvoorraad?: any | null, voorraad?: any | null, gereserveerd?: any | null, assemblaf?: any | null, advice?: number | null, initials?: string | null }> } | null };

export type UpdateAssemblyTypeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: AssemblyTypePatch;
}>;


export type UpdateAssemblyTypeMutation = { __typename?: 'Mutation', updateAssemblyTypeById?: { __typename?: 'UpdateAssemblyTypePayload', assemblyType?: { __typename?: 'AssemblyType', name?: string | null, cdartikel?: string | null, modified?: any | null } | null } | null };

export type AssemblyTypeByIdQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type AssemblyTypeByIdQuery = { __typename?: 'Query', assemblyType?: { __typename?: 'AssemblyType', id: number, name?: string | null, cdartikel?: string | null, created: any, modified?: any | null } | null };

export type CreateAssemblyTypeMutationVariables = Exact<{
  name: Scalars['String']['input'];
  cdartikel: Scalars['String']['input'];
  ownerId: Scalars['Int']['input'];
  created: Scalars['Datetime']['input'];
}>;


export type CreateAssemblyTypeMutation = { __typename?: 'Mutation', createAssemblyType?: { __typename?: 'CreateAssemblyTypePayload', assemblyType?: { __typename?: 'AssemblyType', id: number, name?: string | null, cdartikel?: string | null, created: any, modified?: any | null, ownerId: number } | null } | null };

export type DeleteAssemblyTypeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteAssemblyTypeMutation = { __typename?: 'Mutation', deleteAssemblyTypeById?: { __typename?: 'DeleteAssemblyTypePayload', clientMutationId?: string | null } | null };

export type AllBuildingsNoPaginationQueryVariables = Exact<{
  userId?: InputMaybe<Array<Scalars['Int']['input']> | Scalars['Int']['input']>;
}>;


export type AllBuildingsNoPaginationQuery = { __typename?: 'Query', allBuildings?: { __typename?: 'BuildingsConnection', nodes: Array<{ __typename?: 'Building', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null }> } | null };

export type AllBuildingsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: BuildingFilter;
  orderBy?: InputMaybe<Array<BuildingsOrderBy> | BuildingsOrderBy>;
}>;


export type AllBuildingsQuery = { __typename?: 'Query', allBuildings?: { __typename?: 'BuildingsConnection', totalCount: number, nodes: Array<{ __typename?: 'Building', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null }> } | null };

export type CreateBuildingMutationVariables = Exact<{
  body: BuildingInput;
}>;


export type CreateBuildingMutation = { __typename?: 'Mutation', createBuilding?: { __typename?: 'CreateBuildingPayload', building?: { __typename?: 'Building', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null } | null } | null };

export type UpdateBuildingMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: BuildingPatch;
}>;


export type UpdateBuildingMutation = { __typename?: 'Mutation', updateBuildingById?: { __typename?: 'UpdateBuildingPayload', building?: { __typename?: 'Building', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null } | null } | null };

export type DeleteBuildingMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteBuildingMutation = { __typename?: 'Mutation', deleteBuildingById?: { __typename?: 'DeleteBuildingPayload', clientMutationId?: string | null } | null };

export type AllCalibrationGasesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter?: InputMaybe<CalgasEntityFilter>;
  orderBy?: InputMaybe<Array<CalgasEntitiesOrderBy> | CalgasEntitiesOrderBy>;
}>;


export type AllCalibrationGasesQuery = { __typename?: 'Query', calGases?: { __typename?: 'CalgasEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'CalgasEntity', id?: number | null, cdartikel?: string | null, concentration?: number | null, created?: any | null, engineeringUnits?: string | null, gasCreated?: any | null, gasId?: number | null, initials?: string | null, modified?: any | null, name?: string | null, ownerId?: number | null, username?: string | null }> } | null };

export type CreateCalGasMutationVariables = Exact<{
  body: CalGasInput;
}>;


export type CreateCalGasMutation = { __typename?: 'Mutation', createCalGas?: { __typename?: 'CreateCalGasPayload', calGas?: { __typename?: 'CalGas', id: number, cdartikel?: string | null, concentration?: number | null, engineeringUnits?: string | null, created?: any | null, ownerId?: number | null, modified?: any | null } | null } | null };

export type UpdateCalGasMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: CalGasPatch;
}>;


export type UpdateCalGasMutation = { __typename?: 'Mutation', updateCalGasById?: { __typename?: 'UpdateCalGasPayload', calGas?: { __typename?: 'CalGas', id: number, cdartikel?: string | null, concentration?: number | null, engineeringUnits?: string | null, created?: any | null, ownerId?: number | null, modified?: any | null } | null } | null };

export type DeleteCalGasMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteCalGasMutation = { __typename?: 'Mutation', deleteCalGasById?: { __typename?: 'DeleteCalGasPayload', clientMutationId?: string | null } | null };

export type AllChemicalCompoundsNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllChemicalCompoundsNoPaginationQuery = { __typename?: 'Query', allChemicalCompounds?: { __typename?: 'ChemicalCompoundsConnection', nodes: Array<{ __typename?: 'ChemicalCompound', id: number, name?: string | null, otherName?: string | null, formula?: string | null, cas?: string | null, molarMass?: number | null, icsc?: string | null, density?: number | null, url?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type AllChemicalCompoundsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: ChemicalCompoundFilter;
  orderBy?: InputMaybe<Array<ChemicalCompoundsOrderBy> | ChemicalCompoundsOrderBy>;
}>;


export type AllChemicalCompoundsQuery = { __typename?: 'Query', allChemicalCompounds?: { __typename?: 'ChemicalCompoundsConnection', totalCount: number, nodes: Array<{ __typename?: 'ChemicalCompound', id: number, name?: string | null, otherName?: string | null, formula?: string | null, cas?: string | null, icsc?: string | null, molarMass?: number | null, density?: number | null, url?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type CreateChemicalCompoundMutationVariables = Exact<{
  body: ChemicalCompoundInput;
}>;


export type CreateChemicalCompoundMutation = { __typename?: 'Mutation', createChemicalCompound?: { __typename?: 'CreateChemicalCompoundPayload', chemicalCompound?: { __typename?: 'ChemicalCompound', id: number, name?: string | null, otherName?: string | null, formula?: string | null, cas?: string | null, molarMass?: number | null, density?: number | null, url?: string | null, icsc?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdateChemicalCompoundMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: ChemicalCompoundPatch;
}>;


export type UpdateChemicalCompoundMutation = { __typename?: 'Mutation', updateChemicalCompoundById?: { __typename?: 'UpdateChemicalCompoundPayload', chemicalCompound?: { __typename?: 'ChemicalCompound', id: number, name?: string | null, otherName?: string | null, formula?: string | null, cas?: string | null, icsc?: string | null, molarMass?: number | null, density?: number | null, url?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeleteChemicalCompoundMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteChemicalCompoundMutation = { __typename?: 'Mutation', deleteChemicalCompoundById?: { __typename?: 'DeleteChemicalCompoundPayload', clientMutationId?: string | null } | null };

export type DeleteDetectorTypeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteDetectorTypeMutation = { __typename?: 'Mutation', deleteDetectorTypeById?: { __typename?: 'DeleteDetectorTypePayload', clientMutationId?: string | null } | null };

export type AllDetectorTypesNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllDetectorTypesNoPaginationQuery = { __typename?: 'Query', allDetectorTypesEntities?: { __typename?: 'DetectorTypesEntitiesConnection', nodes: Array<{ __typename?: 'DetectorTypesEntity', id?: number | null, name?: string | null }> } | null };

export type AllDetectorTypeEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: DetectorTypesEntityFilter;
  orderBy?: InputMaybe<Array<DetectorTypesEntitiesOrderBy> | DetectorTypesEntitiesOrderBy>;
}>;


export type AllDetectorTypeEntitiesQuery = { __typename?: 'Query', detectorTypes?: { __typename?: 'DetectorTypesEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'DetectorTypesEntity', code?: string | null, created?: any | null, id?: number | null, initials?: string | null, modified?: any | null, name?: string | null, obsolete?: boolean | null, ownerId?: number | null, prefix?: string | null, sensorCount?: number | null, suffix?: string | null }> } | null };

export type UpdateDetectorTypeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: DetectorTypePatch;
}>;


export type UpdateDetectorTypeMutation = { __typename?: 'Mutation', updateDetectorTypeById?: { __typename?: 'UpdateDetectorTypePayload', detectorType?: { __typename?: 'DetectorType', id: number, obsolete?: boolean | null, prefix?: string | null, suffix?: string | null, code?: string | null, sensorCount?: number | null, created?: any | null, modified?: any | null, ownerId?: number | null } | null } | null };

export type CreateDetectorTypeMutationVariables = Exact<{
  body: DetectorTypeInput;
}>;


export type CreateDetectorTypeMutation = { __typename?: 'Mutation', createDetectorType?: { __typename?: 'CreateDetectorTypePayload', detectorType?: { __typename?: 'DetectorType', id: number, obsolete?: boolean | null, prefix?: string | null, suffix?: string | null, code?: string | null, sensorCount?: number | null, created?: any | null, modified?: any | null, ownerId?: number | null } | null } | null };

export type LocalDetectorFieldsFragment = { __typename?: 'Detector', id: number, serialNumber: string, labelDate?: any | null, created: any, detectorTypeId: number };

export type DetectorFieldsFragment = { __typename?: 'Detector', id: number, serialNumber: string, labelDate?: any | null, created: any, detectorTypeId: number, detectorType?: { __typename?: 'DetectorType', id: number, type?: string | null, sensorCount?: number | null } | null, detectorLocation?: { __typename?: 'DetectorLocation', id: number, detectorId?: number | null, areaId: number, address?: number | null, bus?: number | null, area?: { __typename?: 'Area', id: number, name: string, floor?: { __typename?: 'Floor', id: number, name: string, building?: { __typename?: 'Building', id: number, name: string, endUser?: { __typename?: 'EndUser', id: number, name?: string | null, location: string, subLocation: string } | null } | null } | null } | null } | null, detectorSensors: { __typename?: 'DetectorSensorsConnection', nodes: Array<{ __typename?: 'DetectorSensor', id: number, detectorPosition: number, sensor?: { __typename?: 'Sensor', id: number, serialNumber: string, labelDate?: any | null, created: any, sensorTypeId: number, sensorType?: { __typename?: 'SensorType', id: number, type?: string | null, rangeId: number, range?: { __typename?: 'Range', id: number, lowEu?: number | null, highEu?: number | null, engineeringUnits?: string | null, gasId: number, gas?: { __typename?: 'Gas', id: number, name?: string | null } | null } | null } | null } | null, detectorSensorLocation?: { __typename?: 'DetectorSensorLocation', id: number, simsChannel?: number | null, simsTag?: string | null, samplePointId: number, samplePoint?: { __typename?: 'SamplePoint', id: number, areaId: number, name: string, area?: { __typename?: 'Area', id: number, name: string, floor?: { __typename?: 'Floor', id: number, name: string, building?: { __typename?: 'Building', id: number, name: string, endUser?: { __typename?: 'EndUser', id: number, name?: string | null, location: string, subLocation: string } | null } | null } | null } | null } | null } | null, pyrolyser?: { __typename?: 'Pyrolyser', id: number, name: string } | null, filter?: { __typename?: 'Filter', id: number, name: string } | null }> } };

export type AllDetectorsEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: DetectorEntityFilter;
  orderBy?: InputMaybe<Array<DetectorEntitiesOrderBy> | DetectorEntitiesOrderBy>;
}>;


export type AllDetectorsEntitiesQuery = { __typename?: 'Query', detectors?: { __typename?: 'DetectorEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'DetectorEntity', id?: number | null, suffix?: string | null, serialNumber?: string | null, remarks?: string | null, prefix?: string | null, name?: string | null, ownerId?: number | null, labelDate?: any | null, initials?: string | null, detectorTypeId?: number | null, created?: any | null, code?: string | null }> } | null };

export type UpdateDetectorMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: DetectorPatch;
}>;


export type UpdateDetectorMutation = { __typename?: 'Mutation', updateDetectorById?: { __typename?: 'UpdateDetectorPayload', detector?: { __typename?: 'Detector', id: number, serialNumber: string, labelDate?: any | null, created: any, detectorTypeId: number } | null } | null };

export type UpdateDetectorAndSensorsMutationVariables = Exact<{
  input: UpdateDetectorAndSensorsInput;
}>;


export type UpdateDetectorAndSensorsMutation = { __typename?: 'Mutation', updateDetectorAndSensors?: { __typename?: 'UpdateDetectorAndSensorsPayload', detector?: { __typename?: 'Detector', id: number, serialNumber: string, labelDate?: any | null, created: any, detectorTypeId: number, detectorType?: { __typename?: 'DetectorType', id: number, type?: string | null, sensorCount?: number | null } | null, detectorLocation?: { __typename?: 'DetectorLocation', id: number, detectorId?: number | null, areaId: number, address?: number | null, bus?: number | null, area?: { __typename?: 'Area', id: number, name: string, floor?: { __typename?: 'Floor', id: number, name: string, building?: { __typename?: 'Building', id: number, name: string, endUser?: { __typename?: 'EndUser', id: number, name?: string | null, location: string, subLocation: string } | null } | null } | null } | null } | null, detectorSensors: { __typename?: 'DetectorSensorsConnection', nodes: Array<{ __typename?: 'DetectorSensor', id: number, detectorPosition: number, sensor?: { __typename?: 'Sensor', id: number, serialNumber: string, labelDate?: any | null, created: any, sensorTypeId: number, sensorType?: { __typename?: 'SensorType', id: number, type?: string | null, rangeId: number, range?: { __typename?: 'Range', id: number, lowEu?: number | null, highEu?: number | null, engineeringUnits?: string | null, gasId: number, gas?: { __typename?: 'Gas', id: number, name?: string | null } | null } | null } | null } | null, detectorSensorLocation?: { __typename?: 'DetectorSensorLocation', id: number, simsChannel?: number | null, simsTag?: string | null, samplePointId: number, samplePoint?: { __typename?: 'SamplePoint', id: number, areaId: number, name: string, area?: { __typename?: 'Area', id: number, name: string, floor?: { __typename?: 'Floor', id: number, name: string, building?: { __typename?: 'Building', id: number, name: string, endUser?: { __typename?: 'EndUser', id: number, name?: string | null, location: string, subLocation: string } | null } | null } | null } | null } | null } | null, pyrolyser?: { __typename?: 'Pyrolyser', id: number, name: string } | null, filter?: { __typename?: 'Filter', id: number, name: string } | null }> } } | null } | null };

export type CreateDetectorMutationVariables = Exact<{
  detector: DetectorInput;
}>;


export type CreateDetectorMutation = { __typename?: 'Mutation', createDetector?: { __typename?: 'CreateDetectorPayload', detector?: { __typename?: 'Detector', id: number, serialNumber: string, labelDate?: any | null, created: any, detectorTypeId: number, detectorType?: { __typename?: 'DetectorType', id: number, type?: string | null, sensorCount?: number | null } | null, detectorLocation?: { __typename?: 'DetectorLocation', id: number, detectorId?: number | null, areaId: number, address?: number | null, bus?: number | null, area?: { __typename?: 'Area', id: number, name: string, floor?: { __typename?: 'Floor', id: number, name: string, building?: { __typename?: 'Building', id: number, name: string, endUser?: { __typename?: 'EndUser', id: number, name?: string | null, location: string, subLocation: string } | null } | null } | null } | null } | null, detectorSensors: { __typename?: 'DetectorSensorsConnection', nodes: Array<{ __typename?: 'DetectorSensor', id: number, detectorPosition: number, sensor?: { __typename?: 'Sensor', id: number, serialNumber: string, labelDate?: any | null, created: any, sensorTypeId: number, sensorType?: { __typename?: 'SensorType', id: number, type?: string | null, rangeId: number, range?: { __typename?: 'Range', id: number, lowEu?: number | null, highEu?: number | null, engineeringUnits?: string | null, gasId: number, gas?: { __typename?: 'Gas', id: number, name?: string | null } | null } | null } | null } | null, detectorSensorLocation?: { __typename?: 'DetectorSensorLocation', id: number, simsChannel?: number | null, simsTag?: string | null, samplePointId: number, samplePoint?: { __typename?: 'SamplePoint', id: number, areaId: number, name: string, area?: { __typename?: 'Area', id: number, name: string, floor?: { __typename?: 'Floor', id: number, name: string, building?: { __typename?: 'Building', id: number, name: string, endUser?: { __typename?: 'EndUser', id: number, name?: string | null, location: string, subLocation: string } | null } | null } | null } | null } | null } | null, pyrolyser?: { __typename?: 'Pyrolyser', id: number, name: string } | null, filter?: { __typename?: 'Filter', id: number, name: string } | null }> } } | null } | null };

export type DeleteDetectorMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteDetectorMutation = { __typename?: 'Mutation', deleteDetectorById?: { __typename?: 'DeleteDetectorPayload', clientMutationId?: string | null } | null };

export type AllElectrolytesNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllElectrolytesNoPaginationQuery = { __typename?: 'Query', allElectrolytes?: { __typename?: 'ElectrolytesConnection', nodes: Array<{ __typename?: 'Electrolyte', id: number, name: string }> } | null };

export type AllElectrolyteEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: ElectrolyteEntityFilter;
  orderBy?: InputMaybe<Array<ElectrolyteEntitiesOrderBy> | ElectrolyteEntitiesOrderBy>;
}>;


export type AllElectrolyteEntitiesQuery = { __typename?: 'Query', allElectrolyteEntities?: { __typename?: 'ElectrolyteEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'ElectrolyteEntity', id?: number | null, replacementIntervalMonths?: number | null, ownerId?: number | null, volume?: number | null, omschr?: string | null, name?: string | null, initials?: string | null, created?: any | null, cdartikel?: string | null }> } | null };

export type CreateElectrolyteMutationVariables = Exact<{
  body: ElectrolyteInput;
}>;


export type CreateElectrolyteMutation = { __typename?: 'Mutation', createElectrolyte?: { __typename?: 'CreateElectrolytePayload', electrolyte?: { __typename?: 'Electrolyte', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdateElectrolyteMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: ElectrolytePatch;
}>;


export type UpdateElectrolyteMutation = { __typename?: 'Mutation', updateElectrolyteById?: { __typename?: 'UpdateElectrolytePayload', electrolyte?: { __typename?: 'Electrolyte', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeleteElectrolyteMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteElectrolyteMutation = { __typename?: 'Mutation', deleteElectrolyteById?: { __typename?: 'DeleteElectrolytePayload', clientMutationId?: string | null } | null };

export type AllEndUsersNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllEndUsersNoPaginationQuery = { __typename?: 'Query', allEndUsers?: { __typename?: 'EndUsersConnection', nodes: Array<{ __typename?: 'EndUser', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type AllFiltersNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllFiltersNoPaginationQuery = { __typename?: 'Query', allFilters?: { __typename?: 'FiltersConnection', nodes: Array<{ __typename?: 'Filter', id: number, name: string }> } | null };

export type AllFilterEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilterEntitiesOrderBy> | FilterEntitiesOrderBy>;
  filter: FilterEntityFilter;
}>;


export type AllFilterEntitiesQuery = { __typename?: 'Query', allFilterEntities?: { __typename?: 'FilterEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'FilterEntity', id?: number | null, replacementIntervalMonths?: number | null, ownerId?: number | null, consumable?: boolean | null, omschr?: string | null, name?: string | null, initials?: string | null, created?: any | null, cdartikel?: string | null }> } | null };

export type CreateFilterMutationVariables = Exact<{
  body: FilterInput;
}>;


export type CreateFilterMutation = { __typename?: 'Mutation', createFilter?: { __typename?: 'CreateFilterPayload', filter?: { __typename?: 'Filter', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdateFilterMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: FilterPatch;
}>;


export type UpdateFilterMutation = { __typename?: 'Mutation', updateFilterById?: { __typename?: 'UpdateFilterPayload', filter?: { __typename?: 'Filter', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeleteFilterMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteFilterMutation = { __typename?: 'Mutation', deleteFilterById?: { __typename?: 'DeleteFilterPayload', clientMutationId?: string | null } | null };

export type AllFloorsNoPaginationQueryVariables = Exact<{
  buildingId?: InputMaybe<Array<Scalars['Int']['input']> | Scalars['Int']['input']>;
}>;


export type AllFloorsNoPaginationQuery = { __typename?: 'Query', allFloors?: { __typename?: 'FloorsConnection', nodes: Array<{ __typename?: 'Floor', id: number, name: string, created?: any | null, buildingByBuildingId?: { __typename?: 'Building', name: string, id: number } | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type AllFloorEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: FloorEntityFilter;
  orderBy?: InputMaybe<Array<FloorEntitiesOrderBy> | FloorEntitiesOrderBy>;
}>;


export type AllFloorEntitiesQuery = { __typename?: 'Query', allFloorEntities?: { __typename?: 'FloorEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'FloorEntity', name?: string | null, created?: any | null, initials?: string | null, ownerId?: number | null, id?: number | null, endUserName?: string | null, endUserId?: number | null, buildingName?: string | null, buildingId?: number | null }> } | null };

export type CreateFloorMutationVariables = Exact<{
  body: FloorInput;
}>;


export type CreateFloorMutation = { __typename?: 'Mutation', createFloor?: { __typename?: 'CreateFloorPayload', floor?: { __typename?: 'Floor', name: string, created?: any | null, buildingByBuildingId?: { __typename?: 'Building', id: number, name: string, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null } | null, userByOwnerId?: { __typename?: 'User', id: number, initials?: string | null } | null } | null } | null };

export type UpdateFloorMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: FloorPatch;
}>;


export type UpdateFloorMutation = { __typename?: 'Mutation', updateFloorById?: { __typename?: 'UpdateFloorPayload', floor?: { __typename?: 'Floor', name: string, created?: any | null, buildingByBuildingId?: { __typename?: 'Building', id: number, name: string, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null } | null, userByOwnerId?: { __typename?: 'User', id: number, initials?: string | null } | null } | null } | null };

export type DeleteFloorMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteFloorMutation = { __typename?: 'Mutation', deleteFloorById?: { __typename?: 'DeleteFloorPayload', clientMutationId?: string | null } | null };

export type AllGasesNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllGasesNoPaginationQuery = { __typename?: 'Query', allGases?: { __typename?: 'GasesConnection', nodes: Array<{ __typename?: 'Gas', id: number, name?: string | null }> } | null };

export type AllGasesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: GasFilter;
  orderBy?: InputMaybe<Array<GasesOrderBy> | GasesOrderBy>;
}>;


export type AllGasesQuery = { __typename?: 'Query', allGases?: { __typename?: 'GasesConnection', totalCount: number, nodes: Array<{ __typename?: 'Gas', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type CreateGasMutationVariables = Exact<{
  body: GasInput;
}>;


export type CreateGasMutation = { __typename?: 'Mutation', createGas?: { __typename?: 'CreateGasPayload', gas?: { __typename?: 'Gas', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdateGasMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: GasPatch;
}>;


export type UpdateGasMutation = { __typename?: 'Mutation', updateGasById?: { __typename?: 'UpdateGasPayload', gas?: { __typename?: 'Gas', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeleteGasMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteGasMutation = { __typename?: 'Mutation', deleteGasById?: { __typename?: 'DeleteGasPayload', clientMutationId?: string | null } | null };

export type GroupFieldsFragment = { __typename?: 'Group', id: number, name?: string | null };

export type CacheGroupsQueryVariables = Exact<{ [key: string]: never; }>;


export type CacheGroupsQuery = { __typename?: 'Query', groups?: { __typename?: 'GroupsConnection', nodes: Array<{ __typename?: 'Group', id: number, name?: string | null }> } | null };

export type GroupsQueryVariables = Exact<{ [key: string]: never; }>;


export type GroupsQuery = { __typename?: 'Query', groups?: { __typename?: 'GroupsConnection', nodes: Array<{ __typename?: 'Group', id: number, name?: string | null, groupPermission?: { __typename?: 'GroupPermission', id: number, readIds: Array<number | null>, writeIds: Array<number | null> } | null }> } | null };

export type GroupQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type GroupQuery = { __typename?: 'Query', group?: { __typename?: 'Group', id: number, name?: string | null, groupPermission?: { __typename?: 'GroupPermission', id: number, readIds: Array<number | null>, writeIds: Array<number | null> } | null } | null };

export type DeleteGroupMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteGroupMutation = { __typename?: 'Mutation', deleteGroupById?: { __typename?: 'DeleteGroupPayload', clientMutationId?: string | null } | null };

export type PermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type PermissionsQuery = { __typename?: 'Query', permissions?: { __typename?: 'PermissionsConnection', nodes: Array<{ __typename?: 'Permission', id: number, name?: string | null }> } | null };

export type CreateGroupMutationVariables = Exact<{
  name?: InputMaybe<Scalars['String']['input']>;
}>;


export type CreateGroupMutation = { __typename?: 'Mutation', createGroup?: { __typename?: 'CreateGroupPayload', group?: { __typename?: 'Group', id: number, name?: string | null, groupPermission?: { __typename?: 'GroupPermission', id: number, readIds: Array<number | null>, writeIds: Array<number | null> } | null } | null } | null };

export type UpdateGroupMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  groupPermissionId: Scalars['Int']['input'];
  readIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
  writeIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
}>;


export type UpdateGroupMutation = { __typename?: 'Mutation', updateGroupById?: { __typename?: 'UpdateGroupPayload', group?: { __typename?: 'Group', id: number, name?: string | null } | null } | null, updateGroupPermissionById?: { __typename?: 'UpdateGroupPermissionPayload', groupPermission?: { __typename?: 'GroupPermission', id: number, readIds: Array<number | null>, writeIds: Array<number | null> } | null } | null };

export type JwtTokenQueryVariables = Exact<{ [key: string]: never; }>;


export type JwtTokenQuery = { __typename?: 'Query', jwtToken: string };

export type AllMembranesNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllMembranesNoPaginationQuery = { __typename?: 'Query', allMembranes?: { __typename?: 'MembranesConnection', nodes: Array<{ __typename?: 'Membrane', id: number, name: string }> } | null };

export type AllMembraneEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: MembraneEntityFilter;
  orderBy?: InputMaybe<Array<MembraneEntitiesOrderBy> | MembraneEntitiesOrderBy>;
}>;


export type AllMembraneEntitiesQuery = { __typename?: 'Query', allMembraneEntities?: { __typename?: 'MembraneEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'MembraneEntity', id?: number | null, replacementIntervalMonths?: number | null, ownerId?: number | null, omschr?: string | null, name?: string | null, initials?: string | null, quantity?: number | null, created?: any | null, cdartikel?: string | null }> } | null };

export type CreateMembraneMutationVariables = Exact<{
  body: MembraneInput;
}>;


export type CreateMembraneMutation = { __typename?: 'Mutation', createMembrane?: { __typename?: 'CreateMembranePayload', membrane?: { __typename?: 'Membrane', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdateMembraneMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: MembranePatch;
}>;


export type UpdateMembraneMutation = { __typename?: 'Mutation', updateMembraneById?: { __typename?: 'UpdateMembranePayload', membrane?: { __typename?: 'Membrane', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeleteMembraneMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteMembraneMutation = { __typename?: 'Mutation', deleteMembraneById?: { __typename?: 'DeleteMembranePayload', clientMutationId?: string | null } | null };

export type AllORingsNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllORingsNoPaginationQuery = { __typename?: 'Query', allORings?: { __typename?: 'ORingsConnection', nodes: Array<{ __typename?: 'ORing', id: number, name: string }> } | null };

export type AllORingEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: ORingEntityFilter;
  orderBy?: InputMaybe<Array<ORingEntitiesOrderBy> | ORingEntitiesOrderBy>;
}>;


export type AllORingEntitiesQuery = { __typename?: 'Query', allORingEntities?: { __typename?: 'ORingEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'ORingEntity', id?: number | null, replacementIntervalMonths?: number | null, ownerId?: number | null, omschr?: string | null, name?: string | null, initials?: string | null, quantity?: number | null, created?: any | null, cdartikel?: string | null }> } | null };

export type CreateORingMutationVariables = Exact<{
  body: ORingInput;
}>;


export type CreateORingMutation = { __typename?: 'Mutation', createORing?: { __typename?: 'CreateORingPayload', oRing?: { __typename?: 'ORing', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdateORingMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: ORingPatch;
}>;


export type UpdateORingMutation = { __typename?: 'Mutation', updateORingById?: { __typename?: 'UpdateORingPayload', oRing?: { __typename?: 'ORing', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeleteORingMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteORingMutation = { __typename?: 'Mutation', deleteORingById?: { __typename?: 'DeleteORingPayload', clientMutationId?: string | null } | null };

export type AllPrinciplesNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllPrinciplesNoPaginationQuery = { __typename?: 'Query', allPrinciples?: { __typename?: 'PrinciplesConnection', nodes: Array<{ __typename?: 'Principle', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type AllPrinciplesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: PrincipleFilter;
  orderBy?: InputMaybe<Array<PrinciplesOrderBy> | PrinciplesOrderBy>;
}>;


export type AllPrinciplesQuery = { __typename?: 'Query', allPrinciples?: { __typename?: 'PrinciplesConnection', totalCount: number, nodes: Array<{ __typename?: 'Principle', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type CreatePrincipleMutationVariables = Exact<{
  body: PrincipleInput;
}>;


export type CreatePrincipleMutation = { __typename?: 'Mutation', createPrinciple?: { __typename?: 'CreatePrinciplePayload', principle?: { __typename?: 'Principle', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdatePrincipleMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: PrinciplePatch;
}>;


export type UpdatePrincipleMutation = { __typename?: 'Mutation', updatePrincipleById?: { __typename?: 'UpdatePrinciplePayload', principle?: { __typename?: 'Principle', id: number, name?: string | null, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeletePrincipleMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeletePrincipleMutation = { __typename?: 'Mutation', deletePrincipleById?: { __typename?: 'DeletePrinciplePayload', clientMutationId?: string | null } | null };

export type AllPyrolysersNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllPyrolysersNoPaginationQuery = { __typename?: 'Query', allPyrolysers?: { __typename?: 'PyrolysersConnection', nodes: Array<{ __typename?: 'Pyrolyser', id: number, name: string }> } | null };

export type AllPyrolyserEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: PyrolyserEntityFilter;
  orderBy?: InputMaybe<Array<PyrolyserEntitiesOrderBy> | PyrolyserEntitiesOrderBy>;
}>;


export type AllPyrolyserEntitiesQuery = { __typename?: 'Query', allPyrolyserEntities?: { __typename?: 'PyrolyserEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'PyrolyserEntity', id?: number | null, replacementIntervalMonths?: number | null, ownerId?: number | null, omschr?: string | null, name?: string | null, initials?: string | null, created?: any | null, cdartikel?: string | null }> } | null };

export type CreatePyrolyserMutationVariables = Exact<{
  body: PyrolyserInput;
}>;


export type CreatePyrolyserMutation = { __typename?: 'Mutation', createPyrolyser?: { __typename?: 'CreatePyrolyserPayload', pyrolyser?: { __typename?: 'Pyrolyser', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type UpdatePyrolyserMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: PyrolyserPatch;
}>;


export type UpdatePyrolyserMutation = { __typename?: 'Mutation', updatePyrolyserById?: { __typename?: 'UpdatePyrolyserPayload', pyrolyser?: { __typename?: 'Pyrolyser', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null } | null } | null };

export type DeletePyrolyserMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeletePyrolyserMutation = { __typename?: 'Mutation', deletePyrolyserById?: { __typename?: 'DeletePyrolyserPayload', clientMutationId?: string | null } | null };

export type AllRangesNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllRangesNoPaginationQuery = { __typename?: 'Query', allRanges?: { __typename?: 'RangesConnection', nodes: Array<{ __typename?: 'Range', id: number, created?: any | null, alarm1DirectionUp?: boolean | null, alarm1Level?: any | null, alarm2DirectionUp?: boolean | null, alarm2Level?: any | null, alarmUnits?: boolean | null, engineeringUnits?: string | null, highEu?: number | null, highEuBackup?: number | null, highEuNumeric?: any | null, lowEu?: number | null, modified?: any | null, nodeId: string, ownerId?: number | null, precision?: number | null, range?: string | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null, gasByGasId?: { __typename?: 'Gas', name?: string | null, id: number, formula?: string | null, created?: any | null } | null }> } | null };

export type AllRangesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: RangeFilter;
  orderBy?: InputMaybe<Array<RangesOrderBy> | RangesOrderBy>;
}>;


export type AllRangesQuery = { __typename?: 'Query', allRanges?: { __typename?: 'RangesConnection', totalCount: number, nodes: Array<{ __typename?: 'Range', id: number, created?: any | null, alarm1DirectionUp?: boolean | null, alarm1Level?: any | null, alarm2DirectionUp?: boolean | null, alarm2Level?: any | null, alarmUnits?: boolean | null, engineeringUnits?: string | null, highEu?: number | null, highEuBackup?: number | null, highEuNumeric?: any | null, lowEu?: number | null, modified?: any | null, nodeId: string, ownerId?: number | null, precision?: number | null, range?: string | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null, gasByGasId?: { __typename?: 'Gas', name?: string | null, id: number, formula?: string | null, created?: any | null } | null }> } | null };

export type CreateRangeMutationVariables = Exact<{
  body: RangeInput;
}>;


export type CreateRangeMutation = { __typename?: 'Mutation', createRange?: { __typename?: 'CreateRangePayload', range?: { __typename?: 'Range', id: number, created?: any | null, alarm1DirectionUp?: boolean | null, alarm1Level?: any | null, alarm2DirectionUp?: boolean | null, alarm2Level?: any | null, alarmUnits?: boolean | null, engineeringUnits?: string | null, highEu?: number | null, highEuBackup?: number | null, highEuNumeric?: any | null, lowEu?: number | null, modified?: any | null, nodeId: string, ownerId?: number | null, precision?: number | null, range?: string | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null, gasByGasId?: { __typename?: 'Gas', name?: string | null, id: number, formula?: string | null, created?: any | null } | null } | null } | null };

export type UpdateRangeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: RangePatch;
}>;


export type UpdateRangeMutation = { __typename?: 'Mutation', updateRangeById?: { __typename?: 'UpdateRangePayload', range?: { __typename?: 'Range', id: number, created?: any | null, alarm1DirectionUp?: boolean | null, alarm1Level?: any | null, alarm2DirectionUp?: boolean | null, alarm2Level?: any | null, alarmUnits?: boolean | null, engineeringUnits?: string | null, highEu?: number | null, highEuBackup?: number | null, highEuNumeric?: any | null, lowEu?: number | null, modified?: any | null, nodeId: string, ownerId?: number | null, precision?: number | null, range?: string | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null, gasByGasId?: { __typename?: 'Gas', name?: string | null, id: number, formula?: string | null, created?: any | null } | null } | null } | null };

export type DeleteRangeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteRangeMutation = { __typename?: 'Mutation', deleteRangeById?: { __typename?: 'DeleteRangePayload', clientMutationId?: string | null } | null };

export type AllSamplePointsNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllSamplePointsNoPaginationQuery = { __typename?: 'Query', allSamplePoints?: { __typename?: 'SamplePointsConnection', nodes: Array<{ __typename?: 'SamplePoint', id: number, name: string, created?: any | null, userByOwnerId?: { __typename?: 'User', initials?: string | null, id: number } | null }> } | null };

export type AllSamplePointEntitiesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: SamplePointEntityFilter;
  orderBy?: InputMaybe<Array<SamplePointEntitiesOrderBy> | SamplePointEntitiesOrderBy>;
}>;


export type AllSamplePointEntitiesQuery = { __typename?: 'Query', allSamplePointEntities?: { __typename?: 'SamplePointEntitiesConnection', totalCount: number, nodes: Array<{ __typename?: 'SamplePointEntity', name?: string | null, areaId?: number | null, areaName?: string | null, buildingId?: number | null, buildingName?: string | null, created?: any | null, endUserId?: number | null, endUserName?: string | null, floorId?: number | null, floorName?: string | null, id?: number | null, initials?: string | null, ownerId?: number | null }> } | null };

export type CreateSamplePointMutationVariables = Exact<{
  body: SamplePointInput;
}>;


export type CreateSamplePointMutation = { __typename?: 'Mutation', createSamplePoint?: { __typename?: 'CreateSamplePointPayload', samplePoint?: { __typename?: 'SamplePoint', id: number, name: string, created?: any | null, areaByAreaId?: { __typename?: 'Area', id: number, name: string, created?: any | null, floorByFloorId?: { __typename?: 'Floor', name: string, buildingByBuildingId?: { __typename?: 'Building', id: number, name: string, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null } | null } | null } | null, userByOwnerId?: { __typename?: 'User', id: number, initials?: string | null } | null } | null } | null };

export type UpdateSamplePointMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: SamplePointPatch;
}>;


export type UpdateSamplePointMutation = { __typename?: 'Mutation', updateSamplePointById?: { __typename?: 'UpdateSamplePointPayload', samplePoint?: { __typename?: 'SamplePoint', id: number, name: string, created?: any | null, areaByAreaId?: { __typename?: 'Area', id: number, name: string, created?: any | null, floorByFloorId?: { __typename?: 'Floor', name: string, buildingByBuildingId?: { __typename?: 'Building', id: number, name: string, endUserByEndUserId?: { __typename?: 'EndUser', id: number, name?: string | null } | null } | null } | null } | null, userByOwnerId?: { __typename?: 'User', id: number, initials?: string | null } | null } | null } | null };

export type DeleteSamplePointMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteSamplePointMutation = { __typename?: 'Mutation', deleteSamplePointById?: { __typename?: 'DeleteSamplePointPayload', clientMutationId?: string | null } | null };

export type AllSensorBaseTypesNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllSensorBaseTypesNoPaginationQuery = { __typename?: 'Query', allSensorBaseTypes?: { __typename?: 'SensorBaseTypesConnection', nodes: Array<{ __typename?: 'SensorBaseType', id: number, prefix?: string | null, suffix?: string | null, series?: string | null, volume?: number | null, maintenanceIntervalMonths?: number | null, replacementIntervalMonths?: number | null, quotationIntervalMonths?: number | null, principleByPrincipleId?: { __typename?: 'Principle', id: number, name?: string | null } | null }> } | null };

export type AllSensorBaseTypesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: SensorBaseTypeFilter;
  orderBy?: InputMaybe<Array<SensorBaseTypesOrderBy> | SensorBaseTypesOrderBy>;
}>;


export type AllSensorBaseTypesQuery = { __typename?: 'Query', allSensorBaseTypes?: { __typename?: 'SensorBaseTypesConnection', totalCount: number, nodes: Array<{ __typename?: 'SensorBaseType', id: number, prefix?: string | null, suffix?: string | null, series?: string | null, volume?: number | null, maintenanceIntervalMonths?: number | null, replacementIntervalMonths?: number | null, quotationIntervalMonths?: number | null, principleByPrincipleId?: { __typename?: 'Principle', id: number, name?: string | null } | null }> } | null };

export type CreateSensorBaseTypeMutationVariables = Exact<{
  body: SensorBaseTypeInput;
}>;


export type CreateSensorBaseTypeMutation = { __typename?: 'Mutation', createSensorBaseType?: { __typename?: 'CreateSensorBaseTypePayload', sensorBaseType?: { __typename?: 'SensorBaseType', id: number, prefix?: string | null, suffix?: string | null, series?: string | null, volume?: number | null, maintenanceIntervalMonths?: number | null, replacementIntervalMonths?: number | null, quotationIntervalMonths?: number | null, principleByPrincipleId?: { __typename?: 'Principle', id: number, name?: string | null } | null } | null } | null };

export type UpdateSensorBaseTypeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: SensorBaseTypePatch;
}>;


export type UpdateSensorBaseTypeMutation = { __typename?: 'Mutation', updateSensorBaseTypeById?: { __typename?: 'UpdateSensorBaseTypePayload', sensorBaseType?: { __typename?: 'SensorBaseType', id: number, prefix?: string | null, suffix?: string | null, series?: string | null, volume?: number | null, maintenanceIntervalMonths?: number | null, replacementIntervalMonths?: number | null, quotationIntervalMonths?: number | null, principleByPrincipleId?: { __typename?: 'Principle', id: number, name?: string | null } | null } | null } | null };

export type DeleteSensorBaseTypeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteSensorBaseTypeMutation = { __typename?: 'Mutation', deleteSensorBaseTypeById?: { __typename?: 'DeleteSensorBaseTypePayload', clientMutationId?: string | null } | null };

export type AllSensorTypesNoPaginationQueryVariables = Exact<{ [key: string]: never; }>;


export type AllSensorTypesNoPaginationQuery = { __typename?: 'Query', allSensorTypesIndices?: { __typename?: 'SensorTypesIndicesConnection', nodes: Array<{ __typename?: 'SensorTypesIndex', id?: number | null, sensorTypeArtikelOmschr?: string | null }> } | null };

export type AllSensorTypesIndicesQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  filter: SensorTypesIndexFilter;
  orderBy?: InputMaybe<Array<SensorTypesIndicesOrderBy> | SensorTypesIndicesOrderBy>;
}>;


export type AllSensorTypesIndicesQuery = { __typename?: 'Query', sensorTypes?: { __typename?: 'SensorTypesIndicesConnection', totalCount: number, nodes: Array<{ __typename?: 'SensorTypesIndex', battery?: boolean | null, calEngineeringUnits?: string | null, calFlowRate?: number | null, calGasConcentration?: number | null, calGasName?: string | null, calResponse?: number | null, code?: string | null, createdDate?: string | null, electrolyteCdartikel?: string | null, electrolyteName?: string | null, engineeringUnits?: string | null, filterCdartikel?: string | null, filterName?: string | null, flowRate?: number | null, highEu?: number | null, id?: number | null, maintenanceIntervalMonths?: number | null, membraneCdartikel?: string | null, membraneName?: string | null, membraneSeal?: boolean | null, model?: string | null, oRingCdartikel?: string | null, oRingName?: string | null, prefix?: string | null, target?: string | null, suffix?: string | null, siliconeSheet?: boolean | null, sensorTypeCdartikel?: string | null, sensorTypeArtikelOmschr?: string | null, restrictor?: boolean | null, replacementIntervalMonths?: number | null, pyrolyserName?: string | null, pyrolyserCdartikel?: string | null, principleName?: string | null }> } | null };

export type CreateSensorTypeMutationVariables = Exact<{
  body: SensorTypeInput;
}>;


export type CreateSensorTypeMutation = { __typename?: 'Mutation', createSensorType?: { __typename?: 'CreateSensorTypePayload', sensorType?: { __typename?: 'SensorType', id: number, obsolete?: boolean | null, battery?: boolean | null, biasMv?: number | null, calFlowRate?: number | null, calGasId: number, calResponse: number, cdartikel?: string | null, code: string, created?: any | null, direction?: boolean | null, electrodeCount?: number | null, electrolyteId?: number | null, elementCount?: number | null, filterId?: number | null, flowRate?: number | null, fullType?: string | null, lowElectrolyte?: boolean | null, maintenanceIntervalMonths?: number | null, membraneId?: number | null, membraneSeal?: boolean | null, model: string, modified?: any | null, volume?: number | null, transportSwitch?: boolean | null, siliconeSheet?: boolean | null, spanResistor?: any | null, sensorTypeId?: number | null, sensorBaseTypeId: number, restrictor?: boolean | null, rangeId: number, replacementIntervalMonths?: number | null, pyrolyserVoltage?: number | null, pyrolyserId?: number | null, principleId?: number | null, plugId?: number | null, ownerId: number, oRingId?: number | null } | null } | null };

export type UpdateSensorTypeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  patch: SensorTypePatch;
}>;


export type UpdateSensorTypeMutation = { __typename?: 'Mutation', updateSensorTypeById?: { __typename?: 'UpdateSensorTypePayload', sensorType?: { __typename?: 'SensorType', id: number, obsolete?: boolean | null, battery?: boolean | null, biasMv?: number | null, calFlowRate?: number | null, calGasId: number, calResponse: number, cdartikel?: string | null, code: string, created?: any | null, direction?: boolean | null, electrodeCount?: number | null, electrolyteId?: number | null, elementCount?: number | null, filterId?: number | null, flowRate?: number | null, fullType?: string | null, lowElectrolyte?: boolean | null, maintenanceIntervalMonths?: number | null, membraneId?: number | null, membraneSeal?: boolean | null, model: string, modified?: any | null, volume?: number | null, transportSwitch?: boolean | null, siliconeSheet?: boolean | null, spanResistor?: any | null, sensorTypeId?: number | null, sensorBaseTypeId: number, restrictor?: boolean | null, rangeId: number, replacementIntervalMonths?: number | null, pyrolyserVoltage?: number | null, pyrolyserId?: number | null, principleId?: number | null, plugId?: number | null, ownerId: number, oRingId?: number | null } | null } | null };

export type DeleteSensorTypeMutationVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DeleteSensorTypeMutation = { __typename?: 'Mutation', deleteSensorTypeById?: { __typename?: 'DeleteSensorTypePayload', clientMutationId?: string | null } | null };

export type LocalSensorFieldsFragment = { __typename?: 'Sensor', id: number, serialNumber: string, labelDate?: any | null, created: any, sensorTypeId: number };

export type LocalUserFieldsFragment = { __typename?: 'User', id: number, username?: string | null, fullname?: string | null, initials?: string | null, holidayStartBalance?: number | null, overtimeStartBalance?: number | null };

export type UsersQueryVariables = Exact<{ [key: string]: never; }>;


export type UsersQuery = { __typename?: 'Query', users?: { __typename?: 'UsersConnection', nodes: Array<{ __typename?: 'User', id: number, username?: string | null, fullname?: string | null, initials?: string | null, holidayStartBalance?: number | null, overtimeStartBalance?: number | null }> } | null };

export type UserQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type UserQuery = { __typename?: 'Query', user?: { __typename?: 'User', id: number, username?: string | null, fullname?: string | null, initials?: string | null, holidayStartBalance?: number | null, overtimeStartBalance?: number | null, usersGroups: { __typename?: 'UsersGroupsConnection', nodes: Array<{ __typename?: 'UsersGroup', id: number, group?: { __typename?: 'Group', id: number, name?: string | null } | null }> } } | null };

export type UpdateUserMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  userPatch: UserPatch;
  groupIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>> | InputMaybe<Scalars['Int']['input']>>;
}>;


export type UpdateUserMutation = { __typename?: 'Mutation', updateUserById?: { __typename?: 'UpdateUserPayload', user?: { __typename?: 'User', id: number, username?: string | null, fullname?: string | null, initials?: string | null, holidayStartBalance?: number | null, overtimeStartBalance?: number | null, usersGroups: { __typename?: 'UsersGroupsConnection', nodes: Array<{ __typename?: 'UsersGroup', id: number, group?: { __typename?: 'Group', id: number, name?: string | null } | null }> } } | null } | null, updateUserGroups?: { __typename?: 'UpdateUserGroupsPayload', user?: { __typename?: 'User', id: number, username?: string | null, fullname?: string | null, initials?: string | null, holidayStartBalance?: number | null, overtimeStartBalance?: number | null, usersGroups: { __typename?: 'UsersGroupsConnection', nodes: Array<{ __typename?: 'UsersGroup', id: number, group?: { __typename?: 'Group', id: number, name?: string | null } | null }> } } | null } | null };

export type CurrentUserIdQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserIdQuery = { __typename?: 'Query', currentUserId?: number | null };

export type CurrentUsernameQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUsernameQuery = { __typename?: 'Query', currentUsername?: string | null };

export type CurrentReadPermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentReadPermissionsQuery = { __typename?: 'Query', currentReadPermissions?: { __typename?: 'PermissionsConnection', nodes: Array<{ __typename?: 'Permission', id: number, name?: string | null }> } | null };

export type CurrentWritePermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentWritePermissionsQuery = { __typename?: 'Query', currentWritePermissions?: { __typename?: 'PermissionsConnection', nodes: Array<{ __typename?: 'Permission', id: number, name?: string | null }> } | null };

export type AuthenticateMutationVariables = Exact<{
  username: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type AuthenticateMutation = { __typename?: 'Mutation', authenticate?: { __typename?: 'AuthenticatePayload', jwtToken?: any | null } | null };

export const LocalDetectorFieldsFragmentDoc = gql`
    fragment localDetectorFields on Detector {
  id
  serialNumber
  labelDate
  created
  detectorTypeId
}
    `;
export const LocalSensorFieldsFragmentDoc = gql`
    fragment localSensorFields on Sensor {
  id
  serialNumber
  labelDate
  created
  sensorTypeId
}
    `;
export const DetectorFieldsFragmentDoc = gql`
    fragment detectorFields on Detector {
  ...localDetectorFields
  detectorType: detectorTypeByDetectorTypeId {
    id
    type
    sensorCount
  }
  detectorLocation: detectorLocationByDetectorId {
    id
    detectorId
    areaId
    address
    bus
    area: areaByAreaId {
      id
      name
      floor: floorByFloorId {
        id
        name
        building: buildingByBuildingId {
          id
          name
          endUser: endUserByEndUserId {
            id
            name
            location
            subLocation
          }
        }
      }
    }
  }
  detectorSensors: detectorSensorsByDetectorId(orderBy: DETECTOR_POSITION_ASC) {
    nodes {
      id
      detectorPosition
      sensor: sensorBySensorId {
        ...localSensorFields
        sensorType: sensorTypeBySensorTypeId {
          id
          type
          rangeId
          range: rangeByRangeId {
            id
            lowEu
            highEu
            engineeringUnits
            gasId
            gas: gasByGasId {
              id
              name
            }
          }
        }
      }
      detectorSensorLocation: detectorSensorLocationByDetectorSensorId {
        id
        simsChannel
        simsTag
        samplePointId
        samplePoint: samplePointBySamplePointId {
          id
          areaId
          name
          area: areaByAreaId {
            id
            name
            floor: floorByFloorId {
              id
              name
              building: buildingByBuildingId {
                id
                name
                endUser: endUserByEndUserId {
                  id
                  name
                  location
                  subLocation
                }
              }
            }
          }
        }
      }
      pyrolyser: pyrolyserByPyrolyserId {
        id
        name
      }
      filter: filterByFilterId {
        id
        name
      }
    }
  }
}
    ${LocalDetectorFieldsFragmentDoc}
${LocalSensorFieldsFragmentDoc}`;
export const GroupFieldsFragmentDoc = gql`
    fragment groupFields on Group {
  id
  name
}
    `;
export const LocalUserFieldsFragmentDoc = gql`
    fragment localUserFields on User {
  id
  username
  fullname
  initials
  holidayStartBalance
  overtimeStartBalance
}
    `;
export const AllApplicationsNoPaginationDocument = gql`
    query allApplicationsNoPagination {
  allApplications {
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllApplicationsNoPaginationGQL extends Apollo.Query<AllApplicationsNoPaginationQuery, AllApplicationsNoPaginationQueryVariables> {
    override document = AllApplicationsNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllApplicationsDocument = gql`
    query allApplications($first: Int, $offset: Int, $filter: ApplicationFilter!, $orderBy: [ApplicationsOrderBy!]) {
  allApplications(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllApplicationsGQL extends Apollo.Query<AllApplicationsQuery, AllApplicationsQueryVariables> {
    override document = AllApplicationsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateApplicationDocument = gql`
    mutation CreateApplication($body: ApplicationInput!) {
  createApplication(input: {application: $body}) {
    application {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateApplicationGQL extends Apollo.Mutation<CreateApplicationMutation, CreateApplicationMutationVariables> {
    override document = CreateApplicationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateApplicationDocument = gql`
    mutation UpdateApplication($id: Int!, $patch: ApplicationPatch!) {
  updateApplicationById(input: {id: $id, applicationPatch: $patch}) {
    application {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateApplicationGQL extends Apollo.Mutation<UpdateApplicationMutation, UpdateApplicationMutationVariables> {
    override document = UpdateApplicationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteApplicationDocument = gql`
    mutation DeleteApplication($id: Int!) {
  deleteApplicationById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteApplicationGQL extends Apollo.Mutation<DeleteApplicationMutation, DeleteApplicationMutationVariables> {
    override document = DeleteApplicationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllAreasNoPaginationDocument = gql`
    query allAreasNoPagination($floorId: [Int!]) {
  allAreas(filter: {or: [{floorByFloorId: {id: {inExpansive: $floorId}}}]}) {
    nodes {
      id
      name
      remarks
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllAreasNoPaginationGQL extends Apollo.Query<AllAreasNoPaginationQuery, AllAreasNoPaginationQueryVariables> {
    override document = AllAreasNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllAreaEntitiesDocument = gql`
    query allAreaEntities($first: Int, $offset: Int, $filter: AreaEntityFilter!, $orderBy: [AreaEntitiesOrderBy!]) {
  allAreaEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      name
      created
      remarks
      floorName
      floorId
      endUserName
      endUserId
      buildingName
      buildingId
      initials
      ownerId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllAreaEntitiesGQL extends Apollo.Query<AllAreaEntitiesQuery, AllAreaEntitiesQueryVariables> {
    override document = AllAreaEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateAreaDocument = gql`
    mutation CreateArea($body: AreaInput!) {
  createArea(input: {area: $body}) {
    area {
      id
      name
      created
      floorByFloorId {
        buildingByBuildingId {
          id
          name
          endUserByEndUserId {
            id
            name
          }
        }
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateAreaGQL extends Apollo.Mutation<CreateAreaMutation, CreateAreaMutationVariables> {
    override document = CreateAreaDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateAreaDocument = gql`
    mutation UpdateArea($id: Int!, $patch: AreaPatch!) {
  updateAreaById(input: {id: $id, areaPatch: $patch}) {
    area {
      id
      name
      created
      floorByFloorId {
        buildingByBuildingId {
          id
          name
          endUserByEndUserId {
            id
            name
          }
        }
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateAreaGQL extends Apollo.Mutation<UpdateAreaMutation, UpdateAreaMutationVariables> {
    override document = UpdateAreaDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteAreaDocument = gql`
    mutation DeleteArea($id: Int!) {
  deleteAreaById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteAreaGQL extends Apollo.Mutation<DeleteAreaMutation, DeleteAreaMutationVariables> {
    override document = DeleteAreaDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllAssemblyMultiversEntitiesDocument = gql`
    query allAssemblyMultiversEntities($first: Int, $offset: Int, $filter: AssemblyMultiversEntityFilter!, $orderBy: [AssemblyMultiversEntitiesOrderBy!]) {
  allAssemblyMultiversEntities: allAssemblyMultiversEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      aantal
      aantalGeassembleerd
      aantalgereservbij
      advice
      afdrukAssemblageBon
      assemblageDatum
      assemblageOrder
      cdartikel
      cdmagazijn
      commentaar
      omschr
      guidItem
      orderDatum
      status
      sysCreate
      sysUpdate
      waardeGeassembleerd
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllAssemblyMultiversEntitiesGQL extends Apollo.Query<AllAssemblyMultiversEntitiesQuery, AllAssemblyMultiversEntitiesQueryVariables> {
    override document = AllAssemblyMultiversEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllAssemblyLinesMultiversEntitiesDocument = gql`
    query allAssemblyLinesMultiversEntities($assemblage_order: String, $first: Int, $offset: Int, $search: String!, $orderBy: [AssemblyLineEntitiesOrderBy!]) {
  allAssemblyLineEntities: allAssemblyLineEntities(
    filter: {or: [{cdartikel: {includesInsensitive: $search}}], and: [{assemblageOrder: {equalTo: $assemblage_order}}]}
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      omschr
      zoeknaam
      waardeGebruikt
      voorraad
      minvoorraad
      maxvoorraad
      locatie
      inkvolgnr
      inkopen
      gereserveerd
      cdmagazijn
      cdcrediteur
      cdartikel
      bestcode
      assemblageOrder
      assemblageDatum
      advice
      aantalSamenstelling
      aantalNorm
      aantalGebruikt
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllAssemblyLinesMultiversEntitiesGQL extends Apollo.Query<AllAssemblyLinesMultiversEntitiesQuery, AllAssemblyLinesMultiversEntitiesQueryVariables> {
    override document = AllAssemblyLinesMultiversEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssemblyMultiversByIdDocument = gql`
    query assemblyMultiversById($id: String) {
  assemblyMultiversById: allAssemblyMultiversEntities(
    filter: {assemblageOrder: {equalTo: $id}}
  ) {
    totalCount
    nodes {
      id
      aantal
      omschr
      aantalGeassembleerd
      aantalgereservbij
      advice
      afdrukAssemblageBon
      assemblageDatum
      assemblageOrder
      cdartikel
      cdmagazijn
      commentaar
      guidItem
      orderDatum
      status
      sysCreate
      sysUpdate
      waardeGeassembleerd
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AssemblyMultiversByIdGQL extends Apollo.Query<AssemblyMultiversByIdQuery, AssemblyMultiversByIdQueryVariables> {
    override document = AssemblyMultiversByIdDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssemblyTypeEntitiesDocument = gql`
    query AssemblyTypeEntities($first: Int, $offset: Int, $filter: AssemblyTypesEntityFilter!, $orderBy: [AssemblyTypesEntitiesOrderBy!]) {
  assemblyTypes: allAssemblyTypesEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      name
      cdartikel
      created
      modified
      minvoorraad
      maxvoorraad
      voorraad
      gereserveerd
      assemblaf
      advice
      initials
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AssemblyTypeEntitiesGQL extends Apollo.Query<AssemblyTypeEntitiesQuery, AssemblyTypeEntitiesQueryVariables> {
    override document = AssemblyTypeEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateAssemblyTypeDocument = gql`
    mutation UpdateAssemblyType($id: Int!, $patch: AssemblyTypePatch!) {
  updateAssemblyTypeById(input: {id: $id, assemblyTypePatch: $patch}) {
    assemblyType {
      name
      cdartikel
      modified
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateAssemblyTypeGQL extends Apollo.Mutation<UpdateAssemblyTypeMutation, UpdateAssemblyTypeMutationVariables> {
    override document = UpdateAssemblyTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssemblyTypeByIdDocument = gql`
    query AssemblyTypeById($id: Int!) {
  assemblyType: assemblyTypeById(id: $id) {
    id
    name
    cdartikel
    created
    modified
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AssemblyTypeByIdGQL extends Apollo.Query<AssemblyTypeByIdQuery, AssemblyTypeByIdQueryVariables> {
    override document = AssemblyTypeByIdDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateAssemblyTypeDocument = gql`
    mutation CreateAssemblyType($name: String!, $cdartikel: String!, $ownerId: Int!, $created: Datetime!) {
  createAssemblyType(
    input: {assemblyType: {name: $name, cdartikel: $cdartikel, created: $created, ownerId: $ownerId}}
  ) {
    assemblyType {
      id
      name
      cdartikel
      created
      modified
      ownerId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateAssemblyTypeGQL extends Apollo.Mutation<CreateAssemblyTypeMutation, CreateAssemblyTypeMutationVariables> {
    override document = CreateAssemblyTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteAssemblyTypeDocument = gql`
    mutation DeleteAssemblyType($id: Int!) {
  deleteAssemblyTypeById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteAssemblyTypeGQL extends Apollo.Mutation<DeleteAssemblyTypeMutation, DeleteAssemblyTypeMutationVariables> {
    override document = DeleteAssemblyTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllBuildingsNoPaginationDocument = gql`
    query allBuildingsNoPagination($userId: [Int!]) {
  allBuildings(filter: {or: [{endUserByEndUserId: {id: {inExpansive: $userId}}}]}) {
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
      endUserByEndUserId {
        id
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllBuildingsNoPaginationGQL extends Apollo.Query<AllBuildingsNoPaginationQuery, AllBuildingsNoPaginationQueryVariables> {
    override document = AllBuildingsNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllBuildingsDocument = gql`
    query allBuildings($first: Int, $offset: Int, $filter: BuildingFilter!, $orderBy: [BuildingsOrderBy!]) {
  allBuildings(filter: $filter, orderBy: $orderBy, first: $first, offset: $offset) {
    totalCount
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
      endUserByEndUserId {
        id
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllBuildingsGQL extends Apollo.Query<AllBuildingsQuery, AllBuildingsQueryVariables> {
    override document = AllBuildingsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateBuildingDocument = gql`
    mutation CreateBuilding($body: BuildingInput!) {
  createBuilding(input: {building: $body}) {
    building {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
      endUserByEndUserId {
        id
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateBuildingGQL extends Apollo.Mutation<CreateBuildingMutation, CreateBuildingMutationVariables> {
    override document = CreateBuildingDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateBuildingDocument = gql`
    mutation UpdateBuilding($id: Int!, $patch: BuildingPatch!) {
  updateBuildingById(input: {id: $id, buildingPatch: $patch}) {
    building {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
      endUserByEndUserId {
        id
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateBuildingGQL extends Apollo.Mutation<UpdateBuildingMutation, UpdateBuildingMutationVariables> {
    override document = UpdateBuildingDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteBuildingDocument = gql`
    mutation DeleteBuilding($id: Int!) {
  deleteBuildingById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteBuildingGQL extends Apollo.Mutation<DeleteBuildingMutation, DeleteBuildingMutationVariables> {
    override document = DeleteBuildingDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllCalibrationGasesDocument = gql`
    query allCalibrationGases($first: Int, $offset: Int, $filter: CalgasEntityFilter, $orderBy: [CalgasEntitiesOrderBy!]) {
  calGases: allCalgasEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      cdartikel
      concentration
      created
      engineeringUnits
      gasCreated
      gasId
      initials
      modified
      name
      ownerId
      username
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllCalibrationGasesGQL extends Apollo.Query<AllCalibrationGasesQuery, AllCalibrationGasesQueryVariables> {
    override document = AllCalibrationGasesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateCalGasDocument = gql`
    mutation CreateCalGas($body: CalGasInput!) {
  createCalGas(input: {calGas: $body}) {
    calGas {
      id
      cdartikel
      concentration
      engineeringUnits
      created
      ownerId
      modified
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateCalGasGQL extends Apollo.Mutation<CreateCalGasMutation, CreateCalGasMutationVariables> {
    override document = CreateCalGasDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateCalGasDocument = gql`
    mutation UpdateCalGas($id: Int!, $patch: CalGasPatch!) {
  updateCalGasById(input: {id: $id, calGasPatch: $patch}) {
    calGas {
      id
      cdartikel
      concentration
      engineeringUnits
      created
      ownerId
      modified
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateCalGasGQL extends Apollo.Mutation<UpdateCalGasMutation, UpdateCalGasMutationVariables> {
    override document = UpdateCalGasDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteCalGasDocument = gql`
    mutation DeleteCalGas($id: Int!) {
  deleteCalGasById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteCalGasGQL extends Apollo.Mutation<DeleteCalGasMutation, DeleteCalGasMutationVariables> {
    override document = DeleteCalGasDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllChemicalCompoundsNoPaginationDocument = gql`
    query allChemicalCompoundsNoPagination {
  allChemicalCompounds {
    nodes {
      id
      name
      otherName
      formula
      cas
      molarMass
      icsc
      density
      url
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllChemicalCompoundsNoPaginationGQL extends Apollo.Query<AllChemicalCompoundsNoPaginationQuery, AllChemicalCompoundsNoPaginationQueryVariables> {
    override document = AllChemicalCompoundsNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllChemicalCompoundsDocument = gql`
    query allChemicalCompounds($first: Int, $offset: Int, $filter: ChemicalCompoundFilter!, $orderBy: [ChemicalCompoundsOrderBy!]) {
  allChemicalCompounds(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      name
      otherName
      formula
      cas
      icsc
      molarMass
      density
      url
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllChemicalCompoundsGQL extends Apollo.Query<AllChemicalCompoundsQuery, AllChemicalCompoundsQueryVariables> {
    override document = AllChemicalCompoundsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateChemicalCompoundDocument = gql`
    mutation CreateChemicalCompound($body: ChemicalCompoundInput!) {
  createChemicalCompound(input: {chemicalCompound: $body}) {
    chemicalCompound {
      id
      name
      otherName
      formula
      cas
      molarMass
      density
      url
      icsc
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateChemicalCompoundGQL extends Apollo.Mutation<CreateChemicalCompoundMutation, CreateChemicalCompoundMutationVariables> {
    override document = CreateChemicalCompoundDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateChemicalCompoundDocument = gql`
    mutation UpdateChemicalCompound($id: Int!, $patch: ChemicalCompoundPatch!) {
  updateChemicalCompoundById(input: {id: $id, chemicalCompoundPatch: $patch}) {
    chemicalCompound {
      id
      name
      otherName
      formula
      cas
      icsc
      molarMass
      density
      url
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateChemicalCompoundGQL extends Apollo.Mutation<UpdateChemicalCompoundMutation, UpdateChemicalCompoundMutationVariables> {
    override document = UpdateChemicalCompoundDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteChemicalCompoundDocument = gql`
    mutation DeleteChemicalCompound($id: Int!) {
  deleteChemicalCompoundById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteChemicalCompoundGQL extends Apollo.Mutation<DeleteChemicalCompoundMutation, DeleteChemicalCompoundMutationVariables> {
    override document = DeleteChemicalCompoundDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteDetectorTypeDocument = gql`
    mutation DeleteDetectorType($id: Int!) {
  deleteDetectorTypeById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteDetectorTypeGQL extends Apollo.Mutation<DeleteDetectorTypeMutation, DeleteDetectorTypeMutationVariables> {
    override document = DeleteDetectorTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllDetectorTypesNoPaginationDocument = gql`
    query allDetectorTypesNoPagination {
  allDetectorTypesEntities {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllDetectorTypesNoPaginationGQL extends Apollo.Query<AllDetectorTypesNoPaginationQuery, AllDetectorTypesNoPaginationQueryVariables> {
    override document = AllDetectorTypesNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllDetectorTypeEntitiesDocument = gql`
    query allDetectorTypeEntities($first: Int, $offset: Int, $filter: DetectorTypesEntityFilter!, $orderBy: [DetectorTypesEntitiesOrderBy!]) {
  detectorTypes: allDetectorTypesEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      code
      created
      id
      initials
      modified
      name
      obsolete
      ownerId
      prefix
      sensorCount
      suffix
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllDetectorTypeEntitiesGQL extends Apollo.Query<AllDetectorTypeEntitiesQuery, AllDetectorTypeEntitiesQueryVariables> {
    override document = AllDetectorTypeEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateDetectorTypeDocument = gql`
    mutation UpdateDetectorType($id: Int!, $patch: DetectorTypePatch!) {
  updateDetectorTypeById(input: {id: $id, detectorTypePatch: $patch}) {
    detectorType {
      id
      obsolete
      prefix
      suffix
      code
      sensorCount
      created
      modified
      ownerId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateDetectorTypeGQL extends Apollo.Mutation<UpdateDetectorTypeMutation, UpdateDetectorTypeMutationVariables> {
    override document = UpdateDetectorTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateDetectorTypeDocument = gql`
    mutation CreateDetectorType($body: DetectorTypeInput!) {
  createDetectorType(input: {detectorType: $body}) {
    detectorType {
      id
      obsolete
      prefix
      suffix
      code
      sensorCount
      created
      modified
      ownerId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateDetectorTypeGQL extends Apollo.Mutation<CreateDetectorTypeMutation, CreateDetectorTypeMutationVariables> {
    override document = CreateDetectorTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllDetectorsEntitiesDocument = gql`
    query allDetectorsEntities($first: Int, $offset: Int, $filter: DetectorEntityFilter!, $orderBy: [DetectorEntitiesOrderBy!]) {
  detectors: allDetectorEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      suffix
      serialNumber
      remarks
      prefix
      name
      ownerId
      labelDate
      initials
      detectorTypeId
      created
      code
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllDetectorsEntitiesGQL extends Apollo.Query<AllDetectorsEntitiesQuery, AllDetectorsEntitiesQueryVariables> {
    override document = AllDetectorsEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateDetectorDocument = gql`
    mutation UpdateDetector($id: Int!, $patch: DetectorPatch!) {
  updateDetectorById(input: {id: $id, detectorPatch: $patch}) {
    detector {
      ...localDetectorFields
    }
  }
}
    ${LocalDetectorFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateDetectorGQL extends Apollo.Mutation<UpdateDetectorMutation, UpdateDetectorMutationVariables> {
    override document = UpdateDetectorDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateDetectorAndSensorsDocument = gql`
    mutation UpdateDetectorAndSensors($input: UpdateDetectorAndSensorsInput!) {
  updateDetectorAndSensors(input: $input) {
    detector {
      ...detectorFields
    }
  }
}
    ${DetectorFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateDetectorAndSensorsGQL extends Apollo.Mutation<UpdateDetectorAndSensorsMutation, UpdateDetectorAndSensorsMutationVariables> {
    override document = UpdateDetectorAndSensorsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateDetectorDocument = gql`
    mutation CreateDetector($detector: DetectorInput!) {
  createDetector(input: {detector: $detector}) {
    detector {
      ...detectorFields
    }
  }
}
    ${DetectorFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateDetectorGQL extends Apollo.Mutation<CreateDetectorMutation, CreateDetectorMutationVariables> {
    override document = CreateDetectorDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteDetectorDocument = gql`
    mutation DeleteDetector($id: Int!) {
  deleteDetectorById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteDetectorGQL extends Apollo.Mutation<DeleteDetectorMutation, DeleteDetectorMutationVariables> {
    override document = DeleteDetectorDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllElectrolytesNoPaginationDocument = gql`
    query allElectrolytesNoPagination {
  allElectrolytes {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllElectrolytesNoPaginationGQL extends Apollo.Query<AllElectrolytesNoPaginationQuery, AllElectrolytesNoPaginationQueryVariables> {
    override document = AllElectrolytesNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllElectrolyteEntitiesDocument = gql`
    query allElectrolyteEntities($first: Int, $offset: Int, $filter: ElectrolyteEntityFilter!, $orderBy: [ElectrolyteEntitiesOrderBy!]) {
  allElectrolyteEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      replacementIntervalMonths
      ownerId
      volume
      omschr
      name
      initials
      created
      cdartikel
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllElectrolyteEntitiesGQL extends Apollo.Query<AllElectrolyteEntitiesQuery, AllElectrolyteEntitiesQueryVariables> {
    override document = AllElectrolyteEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateElectrolyteDocument = gql`
    mutation CreateElectrolyte($body: ElectrolyteInput!) {
  createElectrolyte(input: {electrolyte: $body}) {
    electrolyte {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateElectrolyteGQL extends Apollo.Mutation<CreateElectrolyteMutation, CreateElectrolyteMutationVariables> {
    override document = CreateElectrolyteDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateElectrolyteDocument = gql`
    mutation UpdateElectrolyte($id: Int!, $patch: ElectrolytePatch!) {
  updateElectrolyteById(input: {id: $id, electrolytePatch: $patch}) {
    electrolyte {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateElectrolyteGQL extends Apollo.Mutation<UpdateElectrolyteMutation, UpdateElectrolyteMutationVariables> {
    override document = UpdateElectrolyteDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteElectrolyteDocument = gql`
    mutation DeleteElectrolyte($id: Int!) {
  deleteElectrolyteById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteElectrolyteGQL extends Apollo.Mutation<DeleteElectrolyteMutation, DeleteElectrolyteMutationVariables> {
    override document = DeleteElectrolyteDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllEndUsersNoPaginationDocument = gql`
    query allEndUsersNoPagination {
  allEndUsers {
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllEndUsersNoPaginationGQL extends Apollo.Query<AllEndUsersNoPaginationQuery, AllEndUsersNoPaginationQueryVariables> {
    override document = AllEndUsersNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllFiltersNoPaginationDocument = gql`
    query allFiltersNoPagination {
  allFilters {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllFiltersNoPaginationGQL extends Apollo.Query<AllFiltersNoPaginationQuery, AllFiltersNoPaginationQueryVariables> {
    override document = AllFiltersNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllFilterEntitiesDocument = gql`
    query allFilterEntities($first: Int, $offset: Int, $orderBy: [FilterEntitiesOrderBy!], $filter: FilterEntityFilter!) {
  allFilterEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      replacementIntervalMonths
      ownerId
      consumable
      omschr
      name
      initials
      created
      cdartikel
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllFilterEntitiesGQL extends Apollo.Query<AllFilterEntitiesQuery, AllFilterEntitiesQueryVariables> {
    override document = AllFilterEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateFilterDocument = gql`
    mutation CreateFilter($body: FilterInput!) {
  createFilter(input: {filter: $body}) {
    filter {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateFilterGQL extends Apollo.Mutation<CreateFilterMutation, CreateFilterMutationVariables> {
    override document = CreateFilterDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateFilterDocument = gql`
    mutation UpdateFilter($id: Int!, $patch: FilterPatch!) {
  updateFilterById(input: {id: $id, filterPatch: $patch}) {
    filter {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateFilterGQL extends Apollo.Mutation<UpdateFilterMutation, UpdateFilterMutationVariables> {
    override document = UpdateFilterDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteFilterDocument = gql`
    mutation DeleteFilter($id: Int!) {
  deleteFilterById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteFilterGQL extends Apollo.Mutation<DeleteFilterMutation, DeleteFilterMutationVariables> {
    override document = DeleteFilterDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllFloorsNoPaginationDocument = gql`
    query allFloorsNoPagination($buildingId: [Int!]) {
  allFloors(
    filter: {or: [{buildingByBuildingId: {id: {inExpansive: $buildingId}}}]}
  ) {
    nodes {
      id
      name
      created
      buildingByBuildingId {
        name
        id
      }
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllFloorsNoPaginationGQL extends Apollo.Query<AllFloorsNoPaginationQuery, AllFloorsNoPaginationQueryVariables> {
    override document = AllFloorsNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllFloorEntitiesDocument = gql`
    query allFloorEntities($first: Int, $offset: Int, $filter: FloorEntityFilter!, $orderBy: [FloorEntitiesOrderBy!]) {
  allFloorEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      name
      created
      initials
      ownerId
      id
      endUserName
      endUserId
      buildingName
      buildingId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllFloorEntitiesGQL extends Apollo.Query<AllFloorEntitiesQuery, AllFloorEntitiesQueryVariables> {
    override document = AllFloorEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateFloorDocument = gql`
    mutation CreateFloor($body: FloorInput!) {
  createFloor(input: {floor: $body}) {
    floor {
      buildingByBuildingId {
        id
        name
        endUserByEndUserId {
          id
          name
        }
      }
      name
      created
      userByOwnerId {
        id
        initials
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateFloorGQL extends Apollo.Mutation<CreateFloorMutation, CreateFloorMutationVariables> {
    override document = CreateFloorDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateFloorDocument = gql`
    mutation UpdateFloor($id: Int!, $patch: FloorPatch!) {
  updateFloorById(input: {id: $id, floorPatch: $patch}) {
    floor {
      buildingByBuildingId {
        id
        name
        endUserByEndUserId {
          id
          name
        }
      }
      name
      created
      userByOwnerId {
        id
        initials
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateFloorGQL extends Apollo.Mutation<UpdateFloorMutation, UpdateFloorMutationVariables> {
    override document = UpdateFloorDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteFloorDocument = gql`
    mutation DeleteFloor($id: Int!) {
  deleteFloorById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteFloorGQL extends Apollo.Mutation<DeleteFloorMutation, DeleteFloorMutationVariables> {
    override document = DeleteFloorDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllGasesNoPaginationDocument = gql`
    query allGasesNoPagination {
  allGases {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllGasesNoPaginationGQL extends Apollo.Query<AllGasesNoPaginationQuery, AllGasesNoPaginationQueryVariables> {
    override document = AllGasesNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllGasesDocument = gql`
    query allGases($first: Int, $offset: Int, $filter: GasFilter!, $orderBy: [GasesOrderBy!]) {
  allGases(filter: $filter, orderBy: $orderBy, first: $first, offset: $offset) {
    totalCount
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllGasesGQL extends Apollo.Query<AllGasesQuery, AllGasesQueryVariables> {
    override document = AllGasesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateGasDocument = gql`
    mutation CreateGas($body: GasInput!) {
  createGas(input: {gas: $body}) {
    gas {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateGasGQL extends Apollo.Mutation<CreateGasMutation, CreateGasMutationVariables> {
    override document = CreateGasDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateGasDocument = gql`
    mutation UpdateGas($id: Int!, $patch: GasPatch!) {
  updateGasById(input: {id: $id, gasPatch: $patch}) {
    gas {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateGasGQL extends Apollo.Mutation<UpdateGasMutation, UpdateGasMutationVariables> {
    override document = UpdateGasDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteGasDocument = gql`
    mutation DeleteGas($id: Int!) {
  deleteGasById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteGasGQL extends Apollo.Mutation<DeleteGasMutation, DeleteGasMutationVariables> {
    override document = DeleteGasDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CacheGroupsDocument = gql`
    query CacheGroups {
  groups: allGroups {
    nodes {
      ...groupFields
    }
  }
}
    ${GroupFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CacheGroupsGQL extends Apollo.Query<CacheGroupsQuery, CacheGroupsQueryVariables> {
    override document = CacheGroupsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GroupsDocument = gql`
    query Groups {
  groups: allGroups(orderBy: NAME_ASC) {
    nodes {
      ...groupFields
      groupPermission: groupPermissionByGroupId {
        id
        readIds
        writeIds
      }
    }
  }
}
    ${GroupFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GroupsGQL extends Apollo.Query<GroupsQuery, GroupsQueryVariables> {
    override document = GroupsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GroupDocument = gql`
    query Group($id: Int!) {
  group: groupById(id: $id) {
    ...groupFields
    groupPermission: groupPermissionByGroupId {
      id
      readIds
      writeIds
    }
  }
}
    ${GroupFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GroupGQL extends Apollo.Query<GroupQuery, GroupQueryVariables> {
    override document = GroupDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteGroupDocument = gql`
    mutation DeleteGroup($id: Int!) {
  deleteGroupById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteGroupGQL extends Apollo.Mutation<DeleteGroupMutation, DeleteGroupMutationVariables> {
    override document = DeleteGroupDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PermissionsDocument = gql`
    query Permissions {
  permissions: allPermissions {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class PermissionsGQL extends Apollo.Query<PermissionsQuery, PermissionsQueryVariables> {
    override document = PermissionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateGroupDocument = gql`
    mutation CreateGroup($name: String) {
  createGroup(input: {name: $name}) {
    group {
      ...groupFields
      groupPermission: groupPermissionByGroupId {
        id
        readIds
        writeIds
      }
    }
  }
}
    ${GroupFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateGroupGQL extends Apollo.Mutation<CreateGroupMutation, CreateGroupMutationVariables> {
    override document = CreateGroupDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateGroupDocument = gql`
    mutation UpdateGroup($id: Int!, $name: String, $groupPermissionId: Int!, $readIds: [Int], $writeIds: [Int]) {
  updateGroupById(input: {id: $id, groupPatch: {name: $name}}) {
    group {
      ...groupFields
    }
  }
  updateGroupPermissionById(
    input: {id: $groupPermissionId, groupPermissionPatch: {readIds: $readIds, writeIds: $writeIds}}
  ) {
    groupPermission {
      id
      readIds
      writeIds
    }
  }
}
    ${GroupFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateGroupGQL extends Apollo.Mutation<UpdateGroupMutation, UpdateGroupMutationVariables> {
    override document = UpdateGroupDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const JwtTokenDocument = gql`
    query JwtToken {
  jwtToken @client
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class JwtTokenGQL extends Apollo.Query<JwtTokenQuery, JwtTokenQueryVariables> {
    override document = JwtTokenDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllMembranesNoPaginationDocument = gql`
    query allMembranesNoPagination {
  allMembranes {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllMembranesNoPaginationGQL extends Apollo.Query<AllMembranesNoPaginationQuery, AllMembranesNoPaginationQueryVariables> {
    override document = AllMembranesNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllMembraneEntitiesDocument = gql`
    query allMembraneEntities($first: Int, $offset: Int, $filter: MembraneEntityFilter!, $orderBy: [MembraneEntitiesOrderBy!]) {
  allMembraneEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      replacementIntervalMonths
      ownerId
      omschr
      name
      initials
      quantity
      created
      cdartikel
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllMembraneEntitiesGQL extends Apollo.Query<AllMembraneEntitiesQuery, AllMembraneEntitiesQueryVariables> {
    override document = AllMembraneEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateMembraneDocument = gql`
    mutation CreateMembrane($body: MembraneInput!) {
  createMembrane(input: {membrane: $body}) {
    membrane {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateMembraneGQL extends Apollo.Mutation<CreateMembraneMutation, CreateMembraneMutationVariables> {
    override document = CreateMembraneDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateMembraneDocument = gql`
    mutation UpdateMembrane($id: Int!, $patch: MembranePatch!) {
  updateMembraneById(input: {id: $id, membranePatch: $patch}) {
    membrane {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateMembraneGQL extends Apollo.Mutation<UpdateMembraneMutation, UpdateMembraneMutationVariables> {
    override document = UpdateMembraneDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteMembraneDocument = gql`
    mutation DeleteMembrane($id: Int!) {
  deleteMembraneById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteMembraneGQL extends Apollo.Mutation<DeleteMembraneMutation, DeleteMembraneMutationVariables> {
    override document = DeleteMembraneDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllORingsNoPaginationDocument = gql`
    query allORingsNoPagination {
  allORings {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllORingsNoPaginationGQL extends Apollo.Query<AllORingsNoPaginationQuery, AllORingsNoPaginationQueryVariables> {
    override document = AllORingsNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllORingEntitiesDocument = gql`
    query allORingEntities($first: Int, $offset: Int, $filter: ORingEntityFilter!, $orderBy: [ORingEntitiesOrderBy!]) {
  allORingEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      replacementIntervalMonths
      ownerId
      omschr
      name
      initials
      quantity
      created
      cdartikel
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllORingEntitiesGQL extends Apollo.Query<AllORingEntitiesQuery, AllORingEntitiesQueryVariables> {
    override document = AllORingEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateORingDocument = gql`
    mutation CreateORing($body: ORingInput!) {
  createORing(input: {oRing: $body}) {
    oRing {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateORingGQL extends Apollo.Mutation<CreateORingMutation, CreateORingMutationVariables> {
    override document = CreateORingDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateORingDocument = gql`
    mutation UpdateORing($id: Int!, $patch: ORingPatch!) {
  updateORingById(input: {id: $id, oRingPatch: $patch}) {
    oRing {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateORingGQL extends Apollo.Mutation<UpdateORingMutation, UpdateORingMutationVariables> {
    override document = UpdateORingDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteORingDocument = gql`
    mutation DeleteORing($id: Int!) {
  deleteORingById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteORingGQL extends Apollo.Mutation<DeleteORingMutation, DeleteORingMutationVariables> {
    override document = DeleteORingDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllPrinciplesNoPaginationDocument = gql`
    query allPrinciplesNoPagination {
  allPrinciples {
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllPrinciplesNoPaginationGQL extends Apollo.Query<AllPrinciplesNoPaginationQuery, AllPrinciplesNoPaginationQueryVariables> {
    override document = AllPrinciplesNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllPrinciplesDocument = gql`
    query allPrinciples($first: Int, $offset: Int, $filter: PrincipleFilter!, $orderBy: [PrinciplesOrderBy!]) {
  allPrinciples(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllPrinciplesGQL extends Apollo.Query<AllPrinciplesQuery, AllPrinciplesQueryVariables> {
    override document = AllPrinciplesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreatePrincipleDocument = gql`
    mutation CreatePrinciple($body: PrincipleInput!) {
  createPrinciple(input: {principle: $body}) {
    principle {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreatePrincipleGQL extends Apollo.Mutation<CreatePrincipleMutation, CreatePrincipleMutationVariables> {
    override document = CreatePrincipleDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdatePrincipleDocument = gql`
    mutation UpdatePrinciple($id: Int!, $patch: PrinciplePatch!) {
  updatePrincipleById(input: {id: $id, principlePatch: $patch}) {
    principle {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdatePrincipleGQL extends Apollo.Mutation<UpdatePrincipleMutation, UpdatePrincipleMutationVariables> {
    override document = UpdatePrincipleDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeletePrincipleDocument = gql`
    mutation DeletePrinciple($id: Int!) {
  deletePrincipleById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeletePrincipleGQL extends Apollo.Mutation<DeletePrincipleMutation, DeletePrincipleMutationVariables> {
    override document = DeletePrincipleDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllPyrolysersNoPaginationDocument = gql`
    query allPyrolysersNoPagination {
  allPyrolysers {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllPyrolysersNoPaginationGQL extends Apollo.Query<AllPyrolysersNoPaginationQuery, AllPyrolysersNoPaginationQueryVariables> {
    override document = AllPyrolysersNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllPyrolyserEntitiesDocument = gql`
    query allPyrolyserEntities($first: Int, $offset: Int, $filter: PyrolyserEntityFilter!, $orderBy: [PyrolyserEntitiesOrderBy!]) {
  allPyrolyserEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      replacementIntervalMonths
      ownerId
      omschr
      name
      initials
      created
      cdartikel
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllPyrolyserEntitiesGQL extends Apollo.Query<AllPyrolyserEntitiesQuery, AllPyrolyserEntitiesQueryVariables> {
    override document = AllPyrolyserEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreatePyrolyserDocument = gql`
    mutation CreatePyrolyser($body: PyrolyserInput!) {
  createPyrolyser(input: {pyrolyser: $body}) {
    pyrolyser {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreatePyrolyserGQL extends Apollo.Mutation<CreatePyrolyserMutation, CreatePyrolyserMutationVariables> {
    override document = CreatePyrolyserDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdatePyrolyserDocument = gql`
    mutation UpdatePyrolyser($id: Int!, $patch: PyrolyserPatch!) {
  updatePyrolyserById(input: {id: $id, pyrolyserPatch: $patch}) {
    pyrolyser {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdatePyrolyserGQL extends Apollo.Mutation<UpdatePyrolyserMutation, UpdatePyrolyserMutationVariables> {
    override document = UpdatePyrolyserDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeletePyrolyserDocument = gql`
    mutation DeletePyrolyser($id: Int!) {
  deletePyrolyserById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeletePyrolyserGQL extends Apollo.Mutation<DeletePyrolyserMutation, DeletePyrolyserMutationVariables> {
    override document = DeletePyrolyserDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllRangesNoPaginationDocument = gql`
    query allRangesNoPagination {
  allRanges {
    nodes {
      id
      created
      userByOwnerId {
        initials
        id
      }
      alarm1DirectionUp
      alarm1Level
      alarm2DirectionUp
      alarm2Level
      alarmUnits
      engineeringUnits
      highEu
      highEuBackup
      highEuNumeric
      lowEu
      modified
      nodeId
      ownerId
      precision
      range
      gasByGasId {
        name
        id
        formula
        created
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllRangesNoPaginationGQL extends Apollo.Query<AllRangesNoPaginationQuery, AllRangesNoPaginationQueryVariables> {
    override document = AllRangesNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllRangesDocument = gql`
    query allRanges($first: Int, $offset: Int, $filter: RangeFilter!, $orderBy: [RangesOrderBy!]) {
  allRanges(filter: $filter, orderBy: $orderBy, first: $first, offset: $offset) {
    totalCount
    nodes {
      id
      created
      userByOwnerId {
        initials
        id
      }
      alarm1DirectionUp
      alarm1Level
      alarm2DirectionUp
      alarm2Level
      alarmUnits
      engineeringUnits
      highEu
      highEuBackup
      highEuNumeric
      lowEu
      modified
      nodeId
      ownerId
      precision
      range
      gasByGasId {
        name
        id
        formula
        created
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllRangesGQL extends Apollo.Query<AllRangesQuery, AllRangesQueryVariables> {
    override document = AllRangesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateRangeDocument = gql`
    mutation CreateRange($body: RangeInput!) {
  createRange(input: {range: $body}) {
    range {
      id
      created
      userByOwnerId {
        initials
        id
      }
      alarm1DirectionUp
      alarm1Level
      alarm2DirectionUp
      alarm2Level
      alarmUnits
      engineeringUnits
      highEu
      highEuBackup
      highEuNumeric
      lowEu
      modified
      nodeId
      ownerId
      precision
      range
      gasByGasId {
        name
        id
        formula
        created
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateRangeGQL extends Apollo.Mutation<CreateRangeMutation, CreateRangeMutationVariables> {
    override document = CreateRangeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateRangeDocument = gql`
    mutation UpdateRange($id: Int!, $patch: RangePatch!) {
  updateRangeById(input: {id: $id, rangePatch: $patch}) {
    range {
      id
      created
      userByOwnerId {
        initials
        id
      }
      alarm1DirectionUp
      alarm1Level
      alarm2DirectionUp
      alarm2Level
      alarmUnits
      engineeringUnits
      highEu
      highEuBackup
      highEuNumeric
      lowEu
      modified
      nodeId
      ownerId
      precision
      range
      gasByGasId {
        name
        id
        formula
        created
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateRangeGQL extends Apollo.Mutation<UpdateRangeMutation, UpdateRangeMutationVariables> {
    override document = UpdateRangeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteRangeDocument = gql`
    mutation DeleteRange($id: Int!) {
  deleteRangeById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteRangeGQL extends Apollo.Mutation<DeleteRangeMutation, DeleteRangeMutationVariables> {
    override document = DeleteRangeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllSamplePointsNoPaginationDocument = gql`
    query allSamplePointsNoPagination {
  allSamplePoints {
    nodes {
      id
      name
      created
      userByOwnerId {
        initials
        id
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllSamplePointsNoPaginationGQL extends Apollo.Query<AllSamplePointsNoPaginationQuery, AllSamplePointsNoPaginationQueryVariables> {
    override document = AllSamplePointsNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllSamplePointEntitiesDocument = gql`
    query allSamplePointEntities($first: Int, $offset: Int, $filter: SamplePointEntityFilter!, $orderBy: [SamplePointEntitiesOrderBy!]) {
  allSamplePointEntities(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      name
      areaId
      areaName
      buildingId
      buildingName
      created
      endUserId
      endUserName
      floorId
      floorName
      id
      initials
      ownerId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllSamplePointEntitiesGQL extends Apollo.Query<AllSamplePointEntitiesQuery, AllSamplePointEntitiesQueryVariables> {
    override document = AllSamplePointEntitiesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateSamplePointDocument = gql`
    mutation CreateSamplePoint($body: SamplePointInput!) {
  createSamplePoint(input: {samplePoint: $body}) {
    samplePoint {
      id
      name
      created
      areaByAreaId {
        id
        name
        created
        floorByFloorId {
          buildingByBuildingId {
            id
            name
            endUserByEndUserId {
              id
              name
            }
          }
          name
        }
      }
      userByOwnerId {
        id
        initials
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateSamplePointGQL extends Apollo.Mutation<CreateSamplePointMutation, CreateSamplePointMutationVariables> {
    override document = CreateSamplePointDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateSamplePointDocument = gql`
    mutation UpdateSamplePoint($id: Int!, $patch: SamplePointPatch!) {
  updateSamplePointById(input: {id: $id, samplePointPatch: $patch}) {
    samplePoint {
      id
      name
      created
      areaByAreaId {
        id
        name
        created
        floorByFloorId {
          buildingByBuildingId {
            id
            name
            endUserByEndUserId {
              id
              name
            }
          }
          name
        }
      }
      userByOwnerId {
        id
        initials
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateSamplePointGQL extends Apollo.Mutation<UpdateSamplePointMutation, UpdateSamplePointMutationVariables> {
    override document = UpdateSamplePointDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteSamplePointDocument = gql`
    mutation DeleteSamplePoint($id: Int!) {
  deleteSamplePointById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteSamplePointGQL extends Apollo.Mutation<DeleteSamplePointMutation, DeleteSamplePointMutationVariables> {
    override document = DeleteSamplePointDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllSensorBaseTypesNoPaginationDocument = gql`
    query allSensorBaseTypesNoPagination {
  allSensorBaseTypes {
    nodes {
      id
      prefix
      suffix
      series
      volume
      maintenanceIntervalMonths
      replacementIntervalMonths
      quotationIntervalMonths
      principleByPrincipleId {
        id
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllSensorBaseTypesNoPaginationGQL extends Apollo.Query<AllSensorBaseTypesNoPaginationQuery, AllSensorBaseTypesNoPaginationQueryVariables> {
    override document = AllSensorBaseTypesNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllSensorBaseTypesDocument = gql`
    query allSensorBaseTypes($first: Int, $offset: Int, $filter: SensorBaseTypeFilter!, $orderBy: [SensorBaseTypesOrderBy!]) {
  allSensorBaseTypes(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      id
      prefix
      suffix
      series
      volume
      maintenanceIntervalMonths
      replacementIntervalMonths
      quotationIntervalMonths
      principleByPrincipleId {
        id
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllSensorBaseTypesGQL extends Apollo.Query<AllSensorBaseTypesQuery, AllSensorBaseTypesQueryVariables> {
    override document = AllSensorBaseTypesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateSensorBaseTypeDocument = gql`
    mutation CreateSensorBaseType($body: SensorBaseTypeInput!) {
  createSensorBaseType(input: {sensorBaseType: $body}) {
    sensorBaseType {
      id
      prefix
      suffix
      series
      volume
      maintenanceIntervalMonths
      replacementIntervalMonths
      quotationIntervalMonths
      principleByPrincipleId {
        id
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateSensorBaseTypeGQL extends Apollo.Mutation<CreateSensorBaseTypeMutation, CreateSensorBaseTypeMutationVariables> {
    override document = CreateSensorBaseTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateSensorBaseTypeDocument = gql`
    mutation UpdateSensorBaseType($id: Int!, $patch: SensorBaseTypePatch!) {
  updateSensorBaseTypeById(input: {id: $id, sensorBaseTypePatch: $patch}) {
    sensorBaseType {
      id
      prefix
      suffix
      series
      volume
      maintenanceIntervalMonths
      replacementIntervalMonths
      quotationIntervalMonths
      principleByPrincipleId {
        id
        name
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateSensorBaseTypeGQL extends Apollo.Mutation<UpdateSensorBaseTypeMutation, UpdateSensorBaseTypeMutationVariables> {
    override document = UpdateSensorBaseTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteSensorBaseTypeDocument = gql`
    mutation DeleteSensorBaseType($id: Int!) {
  deleteSensorBaseTypeById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteSensorBaseTypeGQL extends Apollo.Mutation<DeleteSensorBaseTypeMutation, DeleteSensorBaseTypeMutationVariables> {
    override document = DeleteSensorBaseTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllSensorTypesNoPaginationDocument = gql`
    query allSensorTypesNoPagination {
  allSensorTypesIndices {
    nodes {
      id
      sensorTypeArtikelOmschr
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllSensorTypesNoPaginationGQL extends Apollo.Query<AllSensorTypesNoPaginationQuery, AllSensorTypesNoPaginationQueryVariables> {
    override document = AllSensorTypesNoPaginationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AllSensorTypesIndicesDocument = gql`
    query allSensorTypesIndices($first: Int, $offset: Int, $filter: SensorTypesIndexFilter!, $orderBy: [SensorTypesIndicesOrderBy!]) {
  sensorTypes: allSensorTypesIndices(
    filter: $filter
    orderBy: $orderBy
    first: $first
    offset: $offset
  ) {
    totalCount
    nodes {
      battery
      calEngineeringUnits
      calFlowRate
      calGasConcentration
      calGasName
      calResponse
      code
      createdDate
      electrolyteCdartikel
      electrolyteName
      engineeringUnits
      filterCdartikel
      filterName
      flowRate
      highEu
      id
      maintenanceIntervalMonths
      membraneCdartikel
      membraneName
      membraneSeal
      model
      oRingCdartikel
      oRingName
      prefix
      target
      suffix
      siliconeSheet
      sensorTypeCdartikel
      sensorTypeArtikelOmschr
      restrictor
      replacementIntervalMonths
      pyrolyserName
      pyrolyserCdartikel
      principleName
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AllSensorTypesIndicesGQL extends Apollo.Query<AllSensorTypesIndicesQuery, AllSensorTypesIndicesQueryVariables> {
    override document = AllSensorTypesIndicesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateSensorTypeDocument = gql`
    mutation CreateSensorType($body: SensorTypeInput!) {
  createSensorType(input: {sensorType: $body}) {
    sensorType {
      id
      obsolete
      battery
      biasMv
      calFlowRate
      calGasId
      calResponse
      cdartikel
      code
      created
      direction
      electrodeCount
      electrolyteId
      elementCount
      filterId
      flowRate
      fullType
      lowElectrolyte
      maintenanceIntervalMonths
      membraneId
      membraneSeal
      model
      modified
      volume
      transportSwitch
      siliconeSheet
      spanResistor
      sensorTypeId
      sensorBaseTypeId
      restrictor
      rangeId
      replacementIntervalMonths
      pyrolyserVoltage
      pyrolyserId
      principleId
      plugId
      ownerId
      oRingId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateSensorTypeGQL extends Apollo.Mutation<CreateSensorTypeMutation, CreateSensorTypeMutationVariables> {
    override document = CreateSensorTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateSensorTypeDocument = gql`
    mutation UpdateSensorType($id: Int!, $patch: SensorTypePatch!) {
  updateSensorTypeById(input: {id: $id, sensorTypePatch: $patch}) {
    sensorType {
      id
      obsolete
      battery
      biasMv
      calFlowRate
      calGasId
      calResponse
      cdartikel
      code
      created
      direction
      electrodeCount
      electrolyteId
      elementCount
      filterId
      flowRate
      fullType
      lowElectrolyte
      maintenanceIntervalMonths
      membraneId
      membraneSeal
      model
      modified
      volume
      transportSwitch
      siliconeSheet
      spanResistor
      sensorTypeId
      sensorBaseTypeId
      restrictor
      rangeId
      replacementIntervalMonths
      pyrolyserVoltage
      pyrolyserId
      principleId
      plugId
      ownerId
      oRingId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateSensorTypeGQL extends Apollo.Mutation<UpdateSensorTypeMutation, UpdateSensorTypeMutationVariables> {
    override document = UpdateSensorTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DeleteSensorTypeDocument = gql`
    mutation DeleteSensorType($id: Int!) {
  deleteSensorTypeById(input: {id: $id}) {
    clientMutationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DeleteSensorTypeGQL extends Apollo.Mutation<DeleteSensorTypeMutation, DeleteSensorTypeMutationVariables> {
    override document = DeleteSensorTypeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UsersDocument = gql`
    query Users {
  users: allUsers {
    nodes {
      ...localUserFields
    }
  }
}
    ${LocalUserFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UsersGQL extends Apollo.Query<UsersQuery, UsersQueryVariables> {
    override document = UsersDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UserDocument = gql`
    query User($id: Int!) {
  user: userById(id: $id) {
    ...localUserFields
    usersGroups: usersGroupsByUserId {
      nodes {
        id
        group: groupByGroupId {
          ...groupFields
        }
      }
    }
  }
}
    ${LocalUserFieldsFragmentDoc}
${GroupFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UserGQL extends Apollo.Query<UserQuery, UserQueryVariables> {
    override document = UserDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateUserDocument = gql`
    mutation UpdateUser($id: Int!, $userPatch: UserPatch!, $groupIds: [Int]) {
  updateUserById(input: {id: $id, userPatch: $userPatch}) {
    user {
      ...localUserFields
      usersGroups: usersGroupsByUserId {
        nodes {
          id
          group: groupByGroupId {
            ...groupFields
          }
        }
      }
    }
  }
  updateUserGroups(input: {userId: $id, groupIds: $groupIds}) {
    user {
      ...localUserFields
      usersGroups: usersGroupsByUserId {
        nodes {
          id
          group: groupByGroupId {
            ...groupFields
          }
        }
      }
    }
  }
}
    ${LocalUserFieldsFragmentDoc}
${GroupFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateUserGQL extends Apollo.Mutation<UpdateUserMutation, UpdateUserMutationVariables> {
    override document = UpdateUserDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CurrentUserIdDocument = gql`
    query CurrentUserId {
  currentUserId
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CurrentUserIdGQL extends Apollo.Query<CurrentUserIdQuery, CurrentUserIdQueryVariables> {
    override document = CurrentUserIdDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CurrentUsernameDocument = gql`
    query CurrentUsername {
  currentUsername
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CurrentUsernameGQL extends Apollo.Query<CurrentUsernameQuery, CurrentUsernameQueryVariables> {
    override document = CurrentUsernameDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CurrentReadPermissionsDocument = gql`
    query CurrentReadPermissions {
  currentReadPermissions {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CurrentReadPermissionsGQL extends Apollo.Query<CurrentReadPermissionsQuery, CurrentReadPermissionsQueryVariables> {
    override document = CurrentReadPermissionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CurrentWritePermissionsDocument = gql`
    query CurrentWritePermissions {
  currentWritePermissions {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CurrentWritePermissionsGQL extends Apollo.Query<CurrentWritePermissionsQuery, CurrentWritePermissionsQueryVariables> {
    override document = CurrentWritePermissionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AuthenticateDocument = gql`
    mutation Authenticate($username: String!, $password: String!) {
  authenticate(input: {username: $username, password: $password}) {
    jwtToken
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AuthenticateGQL extends Apollo.Mutation<AuthenticateMutation, AuthenticateMutationVariables> {
    override document = AuthenticateDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }